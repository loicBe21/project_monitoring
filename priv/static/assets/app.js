(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/tom-select/dist/js/tom-select.complete.js
  var require_tom_select_complete = __commonJS({
    "node_modules/tom-select/dist/js/tom-select.complete.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.TomSelect = factory());
      })(exports, function() {
        "use strict";
        function forEvents(events, callback) {
          events.split(/\s+/).forEach((event) => {
            callback(event);
          });
        }
        class MicroEvent {
          constructor() {
            this._events = void 0;
            this._events = {};
          }
          on(events, fct) {
            forEvents(events, (event) => {
              const event_array = this._events[event] || [];
              event_array.push(fct);
              this._events[event] = event_array;
            });
          }
          off(events, fct) {
            var n = arguments.length;
            if (n === 0) {
              this._events = {};
              return;
            }
            forEvents(events, (event) => {
              if (n === 1) {
                delete this._events[event];
                return;
              }
              const event_array = this._events[event];
              if (event_array === void 0)
                return;
              event_array.splice(event_array.indexOf(fct), 1);
              this._events[event] = event_array;
            });
          }
          trigger(events, ...args) {
            var self2 = this;
            forEvents(events, (event) => {
              const event_array = self2._events[event];
              if (event_array === void 0)
                return;
              event_array.forEach((fct) => {
                fct.apply(self2, args);
              });
            });
          }
        }
        function MicroPlugin(Interface) {
          Interface.plugins = {};
          return class extends Interface {
            constructor(...args) {
              super(...args);
              this.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
              };
            }
            static define(name, fn) {
              Interface.plugins[name] = {
                "name": name,
                "fn": fn
              };
            }
            initializePlugins(plugins) {
              var key, name;
              const self2 = this;
              const queue = [];
              if (Array.isArray(plugins)) {
                plugins.forEach((plugin) => {
                  if (typeof plugin === "string") {
                    queue.push(plugin);
                  } else {
                    self2.plugins.settings[plugin.name] = plugin.options;
                    queue.push(plugin.name);
                  }
                });
              } else if (plugins) {
                for (key in plugins) {
                  if (plugins.hasOwnProperty(key)) {
                    self2.plugins.settings[key] = plugins[key];
                    queue.push(key);
                  }
                }
              }
              while (name = queue.shift()) {
                self2.require(name);
              }
            }
            loadPlugin(name) {
              var self2 = this;
              var plugins = self2.plugins;
              var plugin = Interface.plugins[name];
              if (!Interface.plugins.hasOwnProperty(name)) {
                throw new Error('Unable to find "' + name + '" plugin');
              }
              plugins.requested[name] = true;
              plugins.loaded[name] = plugin.fn.apply(self2, [self2.plugins.settings[name] || {}]);
              plugins.names.push(name);
            }
            require(name) {
              var self2 = this;
              var plugins = self2.plugins;
              if (!self2.plugins.loaded.hasOwnProperty(name)) {
                if (plugins.requested[name]) {
                  throw new Error('Plugin has circular dependency ("' + name + '")');
                }
                self2.loadPlugin(name);
              }
              return plugins.loaded[name];
            }
          };
        }
        const arrayToPattern = (chars) => {
          chars = chars.filter(Boolean);
          if (chars.length < 2) {
            return chars[0] || "";
          }
          return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
        };
        const sequencePattern = (array) => {
          if (!hasDuplicates(array)) {
            return array.join("");
          }
          let pattern = "";
          let prev_char_count = 0;
          const prev_pattern = () => {
            if (prev_char_count > 1) {
              pattern += "{" + prev_char_count + "}";
            }
          };
          array.forEach((char, i) => {
            if (char === array[i - 1]) {
              prev_char_count++;
              return;
            }
            prev_pattern();
            pattern += char;
            prev_char_count = 1;
          });
          prev_pattern();
          return pattern;
        };
        const setToPattern = (chars) => {
          let array = toArray(chars);
          return arrayToPattern(array);
        };
        const hasDuplicates = (array) => {
          return new Set(array).size !== array.length;
        };
        const escape_regex = (str) => {
          return (str + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
        };
        const maxValueLength = (array) => {
          return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
        };
        const unicodeLength = (str) => {
          return toArray(str).length;
        };
        const toArray = (p) => Array.from(p);
        const allSubstrings = (input) => {
          if (input.length === 1)
            return [[input]];
          let result = [];
          const start = input.substring(1);
          const suba = allSubstrings(start);
          suba.forEach(function(subresult) {
            let tmp = subresult.slice(0);
            tmp[0] = input.charAt(0) + tmp[0];
            result.push(tmp);
            tmp = subresult.slice(0);
            tmp.unshift(input.charAt(0));
            result.push(tmp);
          });
          return result;
        };
        const code_points = [[0, 65535]];
        const accent_pat = "[\u0300-\u036F\xB7\u02BE\u02BC]";
        let unicode_map;
        let multi_char_reg;
        const max_char_length = 3;
        const latin_convert = {};
        const latin_condensed = {
          "/": "\u2044\u2215",
          "0": "\u07C0",
          "a": "\u2C65\u0250\u0251",
          "aa": "\uA733",
          "ae": "\xE6\u01FD\u01E3",
          "ao": "\uA735",
          "au": "\uA737",
          "av": "\uA739\uA73B",
          "ay": "\uA73D",
          "b": "\u0180\u0253\u0183",
          "c": "\uA73F\u0188\u023C\u2184",
          "d": "\u0111\u0257\u0256\u1D05\u018C\uABB7\u0501\u0266",
          "e": "\u025B\u01DD\u1D07\u0247",
          "f": "\uA77C\u0192",
          "g": "\u01E5\u0260\uA7A1\u1D79\uA77F\u0262",
          "h": "\u0127\u2C68\u2C76\u0265",
          "i": "\u0268\u0131",
          "j": "\u0249\u0237",
          "k": "\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
          "l": "\u0142\u019A\u026B\u2C61\uA749\uA747\uA781\u026D",
          "m": "\u0271\u026F\u03FB",
          "n": "\uA7A5\u019E\u0272\uA791\u1D0E\u043B\u0509",
          "o": "\xF8\u01FF\u0254\u0275\uA74B\uA74D\u1D11",
          "oe": "\u0153",
          "oi": "\u01A3",
          "oo": "\uA74F",
          "ou": "\u0223",
          "p": "\u01A5\u1D7D\uA751\uA753\uA755\u03C1",
          "q": "\uA757\uA759\u024B",
          "r": "\u024D\u027D\uA75B\uA7A7\uA783",
          "s": "\xDF\u023F\uA7A9\uA785\u0282",
          "t": "\u0167\u01AD\u0288\u2C66\uA787",
          "th": "\xFE",
          "tz": "\uA729",
          "u": "\u0289",
          "v": "\u028B\uA75F\u028C",
          "vy": "\uA761",
          "w": "\u2C73",
          "y": "\u01B4\u024F\u1EFF",
          "z": "\u01B6\u0225\u0240\u2C6C\uA763",
          "hv": "\u0195"
        };
        for (let latin in latin_condensed) {
          let unicode = latin_condensed[latin] || "";
          for (let i = 0; i < unicode.length; i++) {
            let char = unicode.substring(i, i + 1);
            latin_convert[char] = latin;
          }
        }
        const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
        const initialize = (_code_points) => {
          if (unicode_map !== void 0)
            return;
          unicode_map = generateMap(_code_points || code_points);
        };
        const normalize = (str, form = "NFKD") => str.normalize(form);
        const asciifold = (str) => {
          return toArray(str).reduce((result, char) => {
            return result + _asciifold(char);
          }, "");
        };
        const _asciifold = (str) => {
          str = normalize(str).toLowerCase().replace(convert_pat, (char) => {
            return latin_convert[char] || "";
          });
          return normalize(str, "NFC");
        };
        function* generator(code_points2) {
          for (const [code_point_min, code_point_max] of code_points2) {
            for (let i = code_point_min; i <= code_point_max; i++) {
              let composed = String.fromCharCode(i);
              let folded = asciifold(composed);
              if (folded == composed.toLowerCase()) {
                continue;
              }
              if (folded.length > max_char_length) {
                continue;
              }
              if (folded.length == 0) {
                continue;
              }
              yield {
                folded,
                composed,
                code_point: i
              };
            }
          }
        }
        const generateSets = (code_points2) => {
          const unicode_sets = {};
          const addMatching = (folded, to_add) => {
            const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
            const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
            if (to_add.match(patt)) {
              return;
            }
            folded_set.add(escape_regex(to_add));
            unicode_sets[folded] = folded_set;
          };
          for (let value of generator(code_points2)) {
            addMatching(value.folded, value.folded);
            addMatching(value.folded, value.composed);
          }
          return unicode_sets;
        };
        const generateMap = (code_points2) => {
          const unicode_sets = generateSets(code_points2);
          const unicode_map2 = {};
          let multi_char = [];
          for (let folded in unicode_sets) {
            let set = unicode_sets[folded];
            if (set) {
              unicode_map2[folded] = setToPattern(set);
            }
            if (folded.length > 1) {
              multi_char.push(escape_regex(folded));
            }
          }
          multi_char.sort((a, b) => b.length - a.length);
          const multi_char_patt = arrayToPattern(multi_char);
          multi_char_reg = new RegExp("^" + multi_char_patt, "u");
          return unicode_map2;
        };
        const mapSequence = (strings, min_replacement = 1) => {
          let chars_replaced = 0;
          strings = strings.map((str) => {
            if (unicode_map[str]) {
              chars_replaced += str.length;
            }
            return unicode_map[str] || str;
          });
          if (chars_replaced >= min_replacement) {
            return sequencePattern(strings);
          }
          return "";
        };
        const substringsToPattern = (str, min_replacement = 1) => {
          min_replacement = Math.max(min_replacement, str.length - 1);
          return arrayToPattern(allSubstrings(str).map((sub_pat) => {
            return mapSequence(sub_pat, min_replacement);
          }));
        };
        const sequencesToPattern = (sequences, all = true) => {
          let min_replacement = sequences.length > 1 ? 1 : 0;
          return arrayToPattern(sequences.map((sequence) => {
            let seq = [];
            const len = all ? sequence.length() : sequence.length() - 1;
            for (let j = 0; j < len; j++) {
              seq.push(substringsToPattern(sequence.substrs[j] || "", min_replacement));
            }
            return sequencePattern(seq);
          }));
        };
        const inSequences = (needle_seq, sequences) => {
          for (const seq of sequences) {
            if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
              continue;
            }
            if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
              continue;
            }
            let needle_parts = needle_seq.parts;
            const filter = (part) => {
              for (const needle_part of needle_parts) {
                if (needle_part.start === part.start && needle_part.substr === part.substr) {
                  return false;
                }
                if (part.length == 1 || needle_part.length == 1) {
                  continue;
                }
                if (part.start < needle_part.start && part.end > needle_part.start) {
                  return true;
                }
                if (needle_part.start < part.start && needle_part.end > part.start) {
                  return true;
                }
              }
              return false;
            };
            let filtered = seq.parts.filter(filter);
            if (filtered.length > 0) {
              continue;
            }
            return true;
          }
          return false;
        };
        class Sequence {
          constructor() {
            this.parts = [];
            this.substrs = [];
            this.start = 0;
            this.end = 0;
          }
          add(part) {
            if (part) {
              this.parts.push(part);
              this.substrs.push(part.substr);
              this.start = Math.min(part.start, this.start);
              this.end = Math.max(part.end, this.end);
            }
          }
          last() {
            return this.parts[this.parts.length - 1];
          }
          length() {
            return this.parts.length;
          }
          clone(position, last_piece) {
            let clone2 = new Sequence();
            let parts = JSON.parse(JSON.stringify(this.parts));
            let last_part = parts.pop();
            for (const part of parts) {
              clone2.add(part);
            }
            let last_substr = last_piece.substr.substring(0, position - last_part.start);
            let clone_last_len = last_substr.length;
            clone2.add({
              start: last_part.start,
              end: last_part.start + clone_last_len,
              length: clone_last_len,
              substr: last_substr
            });
            return clone2;
          }
        }
        const getPattern = (str) => {
          initialize();
          str = asciifold(str);
          let pattern = "";
          let sequences = [new Sequence()];
          for (let i = 0; i < str.length; i++) {
            let substr = str.substring(i);
            let match = substr.match(multi_char_reg);
            const char = str.substring(i, i + 1);
            const match_str = match ? match[0] : null;
            let overlapping = [];
            let added_types = /* @__PURE__ */ new Set();
            for (const sequence of sequences) {
              const last_piece = sequence.last();
              if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
                if (match_str) {
                  const len = match_str.length;
                  sequence.add({
                    start: i,
                    end: i + len,
                    length: len,
                    substr: match_str
                  });
                  added_types.add("1");
                } else {
                  sequence.add({
                    start: i,
                    end: i + 1,
                    length: 1,
                    substr: char
                  });
                  added_types.add("2");
                }
              } else if (match_str) {
                let clone2 = sequence.clone(i, last_piece);
                const len = match_str.length;
                clone2.add({
                  start: i,
                  end: i + len,
                  length: len,
                  substr: match_str
                });
                overlapping.push(clone2);
              } else {
                added_types.add("3");
              }
            }
            if (overlapping.length > 0) {
              overlapping = overlapping.sort((a, b) => {
                return a.length() - b.length();
              });
              for (let clone2 of overlapping) {
                if (inSequences(clone2, sequences)) {
                  continue;
                }
                sequences.push(clone2);
              }
              continue;
            }
            if (i > 0 && added_types.size == 1 && !added_types.has("3")) {
              pattern += sequencesToPattern(sequences, false);
              let new_seq = new Sequence();
              const old_seq = sequences[0];
              if (old_seq) {
                new_seq.add(old_seq.last());
              }
              sequences = [new_seq];
            }
          }
          pattern += sequencesToPattern(sequences, true);
          return pattern;
        };
        const getAttr = (obj, name) => {
          if (!obj)
            return;
          return obj[name];
        };
        const getAttrNesting = (obj, name) => {
          if (!obj)
            return;
          var part, names = name.split(".");
          while ((part = names.shift()) && (obj = obj[part]))
            ;
          return obj;
        };
        const scoreValue = (value, token, weight) => {
          var score, pos;
          if (!value)
            return 0;
          value = value + "";
          if (token.regex == null)
            return 0;
          pos = value.search(token.regex);
          if (pos === -1)
            return 0;
          score = token.string.length / value.length;
          if (pos === 0)
            score += 0.5;
          return score * weight;
        };
        const propToArray = (obj, key) => {
          var value = obj[key];
          if (typeof value == "function")
            return value;
          if (value && !Array.isArray(value)) {
            obj[key] = [value];
          }
        };
        const iterate$1 = (object, callback) => {
          if (Array.isArray(object)) {
            object.forEach(callback);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback(object[key], key);
              }
            }
          }
        };
        const cmp = (a, b) => {
          if (typeof a === "number" && typeof b === "number") {
            return a > b ? 1 : a < b ? -1 : 0;
          }
          a = asciifold(a + "").toLowerCase();
          b = asciifold(b + "").toLowerCase();
          if (a > b)
            return 1;
          if (b > a)
            return -1;
          return 0;
        };
        class Sifter {
          constructor(items, settings) {
            this.items = void 0;
            this.settings = void 0;
            this.items = items;
            this.settings = settings || {
              diacritics: true
            };
          }
          tokenize(query, respect_word_boundaries, weights) {
            if (!query || !query.length)
              return [];
            const tokens = [];
            const words = query.split(/\s+/);
            var field_regex;
            if (weights) {
              field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
            }
            words.forEach((word) => {
              let field_match;
              let field = null;
              let regex = null;
              if (field_regex && (field_match = word.match(field_regex))) {
                field = field_match[1];
                word = field_match[2];
              }
              if (word.length > 0) {
                if (this.settings.diacritics) {
                  regex = getPattern(word) || null;
                } else {
                  regex = escape_regex(word);
                }
                if (regex && respect_word_boundaries)
                  regex = "\\b" + regex;
              }
              tokens.push({
                string: word,
                regex: regex ? new RegExp(regex, "iu") : null,
                field
              });
            });
            return tokens;
          }
          getScoreFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getScoreFunction(search);
          }
          _getScoreFunction(search) {
            const tokens = search.tokens, token_count = tokens.length;
            if (!token_count) {
              return function() {
                return 0;
              };
            }
            const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
            if (!field_count) {
              return function() {
                return 1;
              };
            }
            const scoreObject = function() {
              if (field_count === 1) {
                return function(token, data) {
                  const field = fields[0].field;
                  return scoreValue(getAttrFn(data, field), token, weights[field] || 1);
                };
              }
              return function(token, data) {
                var sum = 0;
                if (token.field) {
                  const value = getAttrFn(data, token.field);
                  if (!token.regex && value) {
                    sum += 1 / field_count;
                  } else {
                    sum += scoreValue(value, token, 1);
                  }
                } else {
                  iterate$1(weights, (weight, field) => {
                    sum += scoreValue(getAttrFn(data, field), token, weight);
                  });
                }
                return sum / field_count;
              };
            }();
            if (token_count === 1) {
              return function(data) {
                return scoreObject(tokens[0], data);
              };
            }
            if (search.options.conjunction === "and") {
              return function(data) {
                var score, sum = 0;
                for (let token of tokens) {
                  score = scoreObject(token, data);
                  if (score <= 0)
                    return 0;
                  sum += score;
                }
                return sum / token_count;
              };
            } else {
              return function(data) {
                var sum = 0;
                iterate$1(tokens, (token) => {
                  sum += scoreObject(token, data);
                });
                return sum / token_count;
              };
            }
          }
          getSortFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getSortFunction(search);
          }
          _getSortFunction(search) {
            var implicit_score, sort_flds = [];
            const self2 = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;
            if (typeof sort == "function") {
              return sort.bind(this);
            }
            const get_field = function get_field2(name, result) {
              if (name === "$score")
                return result.score;
              return search.getAttrFn(self2.items[result.id], name);
            };
            if (sort) {
              for (let s of sort) {
                if (search.query || s.field !== "$score") {
                  sort_flds.push(s);
                }
              }
            }
            if (search.query) {
              implicit_score = true;
              for (let fld of sort_flds) {
                if (fld.field === "$score") {
                  implicit_score = false;
                  break;
                }
              }
              if (implicit_score) {
                sort_flds.unshift({
                  field: "$score",
                  direction: "desc"
                });
              }
            } else {
              sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
            }
            const sort_flds_count = sort_flds.length;
            if (!sort_flds_count) {
              return null;
            }
            return function(a, b) {
              var result, field;
              for (let sort_fld of sort_flds) {
                field = sort_fld.field;
                let multiplier = sort_fld.direction === "desc" ? -1 : 1;
                result = multiplier * cmp(get_field(field, a), get_field(field, b));
                if (result)
                  return result;
              }
              return 0;
            };
          }
          prepareSearch(query, optsUser) {
            const weights = {};
            var options = Object.assign({}, optsUser);
            propToArray(options, "sort");
            propToArray(options, "sort_empty");
            if (options.fields) {
              propToArray(options, "fields");
              const fields = [];
              options.fields.forEach((field) => {
                if (typeof field == "string") {
                  field = {
                    field,
                    weight: 1
                  };
                }
                fields.push(field);
                weights[field.field] = "weight" in field ? field.weight : 1;
              });
              options.fields = fields;
            }
            return {
              options,
              query: query.toLowerCase().trim(),
              tokens: this.tokenize(query, options.respect_word_boundaries, weights),
              total: 0,
              items: [],
              weights,
              getAttrFn: options.nesting ? getAttrNesting : getAttr
            };
          }
          search(query, options) {
            var self2 = this, score, search;
            search = this.prepareSearch(query, options);
            options = search.options;
            query = search.query;
            const fn_score = options.score || self2._getScoreFunction(search);
            if (query.length) {
              iterate$1(self2.items, (item, id) => {
                score = fn_score(item);
                if (options.filter === false || score > 0) {
                  search.items.push({
                    "score": score,
                    "id": id
                  });
                }
              });
            } else {
              iterate$1(self2.items, (_, id) => {
                search.items.push({
                  "score": 1,
                  "id": id
                });
              });
            }
            const fn_sort = self2._getSortFunction(search);
            if (fn_sort)
              search.items.sort(fn_sort);
            search.total = search.items.length;
            if (typeof options.limit === "number") {
              search.items = search.items.slice(0, options.limit);
            }
            return search;
          }
        }
        const iterate = (object, callback) => {
          if (Array.isArray(object)) {
            object.forEach(callback);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback(object[key], key);
              }
            }
          }
        };
        const getDom = (query) => {
          if (query.jquery) {
            return query[0];
          }
          if (query instanceof HTMLElement) {
            return query;
          }
          if (isHtmlString(query)) {
            var tpl = document.createElement("template");
            tpl.innerHTML = query.trim();
            return tpl.content.firstChild;
          }
          return document.querySelector(query);
        };
        const isHtmlString = (arg) => {
          if (typeof arg === "string" && arg.indexOf("<") > -1) {
            return true;
          }
          return false;
        };
        const escapeQuery = (query) => {
          return query.replace(/['"\\]/g, "\\$&");
        };
        const triggerEvent = (dom_el, event_name) => {
          var event = document.createEvent("HTMLEvents");
          event.initEvent(event_name, true, false);
          dom_el.dispatchEvent(event);
        };
        const applyCSS = (dom_el, css) => {
          Object.assign(dom_el.style, css);
        };
        const addClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.add(cls);
            });
          });
        };
        const removeClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.remove(cls);
            });
          });
        };
        const classesArray = (args) => {
          var classes = [];
          iterate(args, (_classes) => {
            if (typeof _classes === "string") {
              _classes = _classes.trim().split(/[\11\12\14\15\40]/);
            }
            if (Array.isArray(_classes)) {
              classes = classes.concat(_classes);
            }
          });
          return classes.filter(Boolean);
        };
        const castAsArray = (arg) => {
          if (!Array.isArray(arg)) {
            arg = [arg];
          }
          return arg;
        };
        const parentMatch = (target, selector, wrapper) => {
          if (wrapper && !wrapper.contains(target)) {
            return;
          }
          while (target && target.matches) {
            if (target.matches(selector)) {
              return target;
            }
            target = target.parentNode;
          }
        };
        const getTail = (list, direction = 0) => {
          if (direction > 0) {
            return list[list.length - 1];
          }
          return list[0];
        };
        const isEmptyObject = (obj) => {
          return Object.keys(obj).length === 0;
        };
        const nodeIndex = (el, amongst) => {
          if (!el)
            return -1;
          amongst = amongst || el.nodeName;
          var i = 0;
          while (el = el.previousElementSibling) {
            if (el.matches(amongst)) {
              i++;
            }
          }
          return i;
        };
        const setAttr = (el, attrs) => {
          iterate(attrs, (val2, attr) => {
            if (val2 == null) {
              el.removeAttribute(attr);
            } else {
              el.setAttribute(attr, "" + val2);
            }
          });
        };
        const replaceNode = (existing, replacement) => {
          if (existing.parentNode)
            existing.parentNode.replaceChild(replacement, existing);
        };
        const highlight = (element, regex) => {
          if (regex === null)
            return;
          if (typeof regex === "string") {
            if (!regex.length)
              return;
            regex = new RegExp(regex, "i");
          }
          const highlightText = (node) => {
            var match = node.data.match(regex);
            if (match && node.data.length > 0) {
              var spannode = document.createElement("span");
              spannode.className = "highlight";
              var middlebit = node.splitText(match.index);
              middlebit.splitText(match[0].length);
              var middleclone = middlebit.cloneNode(true);
              spannode.appendChild(middleclone);
              replaceNode(middlebit, spannode);
              return 1;
            }
            return 0;
          };
          const highlightChildren = (node) => {
            if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
              Array.from(node.childNodes).forEach((element2) => {
                highlightRecursive(element2);
              });
            }
          };
          const highlightRecursive = (node) => {
            if (node.nodeType === 3) {
              return highlightText(node);
            }
            highlightChildren(node);
            return 0;
          };
          highlightRecursive(element);
        };
        const removeHighlight = (el) => {
          var elements = el.querySelectorAll("span.highlight");
          Array.prototype.forEach.call(elements, function(el2) {
            var parent = el2.parentNode;
            parent.replaceChild(el2.firstChild, el2);
            parent.normalize();
          });
        };
        const KEY_A = 65;
        const KEY_RETURN = 13;
        const KEY_ESC = 27;
        const KEY_LEFT = 37;
        const KEY_UP = 38;
        const KEY_RIGHT = 39;
        const KEY_DOWN = 40;
        const KEY_BACKSPACE = 8;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
        const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
        var defaults = {
          options: [],
          optgroups: [],
          plugins: [],
          delimiter: ",",
          splitOn: null,
          persist: true,
          diacritics: true,
          create: null,
          createOnBlur: false,
          createFilter: null,
          highlight: true,
          openOnFocus: true,
          shouldOpen: null,
          maxOptions: 50,
          maxItems: null,
          hideSelected: null,
          duplicates: false,
          addPrecedence: false,
          selectOnTab: false,
          preload: null,
          allowEmptyOption: false,
          refreshThrottle: 300,
          loadThrottle: 300,
          loadingClass: "loading",
          dataAttr: null,
          optgroupField: "optgroup",
          valueField: "value",
          labelField: "text",
          disabledField: "disabled",
          optgroupLabelField: "label",
          optgroupValueField: "value",
          lockOptgroupOrder: false,
          sortField: "$order",
          searchField: ["text"],
          searchConjunction: "and",
          mode: null,
          wrapperClass: "ts-wrapper",
          controlClass: "ts-control",
          dropdownClass: "ts-dropdown",
          dropdownContentClass: "ts-dropdown-content",
          itemClass: "item",
          optionClass: "option",
          dropdownParent: null,
          controlInput: '<input type="text" autocomplete="off" size="1" />',
          copyClassesToDropdown: false,
          placeholder: null,
          hidePlaceholder: null,
          shouldLoad: function(query) {
            return query.length > 0;
          },
          render: {}
        };
        const hash_key = (value) => {
          if (typeof value === "undefined" || value === null)
            return null;
          return get_hash(value);
        };
        const get_hash = (value) => {
          if (typeof value === "boolean")
            return value ? "1" : "0";
          return value + "";
        };
        const escape_html = (str) => {
          return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        };
        const timeout = (fn, timeout2) => {
          if (timeout2 > 0) {
            return setTimeout(fn, timeout2);
          }
          fn.call(null);
          return null;
        };
        const loadDebounce = (fn, delay) => {
          var timeout2;
          return function(value, callback) {
            var self2 = this;
            if (timeout2) {
              self2.loading = Math.max(self2.loading - 1, 0);
              clearTimeout(timeout2);
            }
            timeout2 = setTimeout(function() {
              timeout2 = null;
              self2.loadedSearches[value] = true;
              fn.call(self2, value, callback);
            }, delay);
          };
        };
        const debounce_events = (self2, types, fn) => {
          var type;
          var trigger = self2.trigger;
          var event_args = {};
          self2.trigger = function() {
            var type2 = arguments[0];
            if (types.indexOf(type2) !== -1) {
              event_args[type2] = arguments;
            } else {
              return trigger.apply(self2, arguments);
            }
          };
          fn.apply(self2, []);
          self2.trigger = trigger;
          for (type of types) {
            if (type in event_args) {
              trigger.apply(self2, event_args[type]);
            }
          }
        };
        const getSelection = (input) => {
          return {
            start: input.selectionStart || 0,
            length: (input.selectionEnd || 0) - (input.selectionStart || 0)
          };
        };
        const preventDefault = (evt, stop = false) => {
          if (evt) {
            evt.preventDefault();
            if (stop) {
              evt.stopPropagation();
            }
          }
        };
        const addEvent = (target, type, callback, options) => {
          target.addEventListener(type, callback, options);
        };
        const isKeyDown = (key_name, evt) => {
          if (!evt) {
            return false;
          }
          if (!evt[key_name]) {
            return false;
          }
          var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
          if (count === 1) {
            return true;
          }
          return false;
        };
        const getId = (el, id) => {
          const existing_id = el.getAttribute("id");
          if (existing_id) {
            return existing_id;
          }
          el.setAttribute("id", id);
          return id;
        };
        const addSlashes = (str) => {
          return str.replace(/[\\"']/g, "\\$&");
        };
        const append = (parent, node) => {
          if (node)
            parent.append(node);
        };
        function getSettings(input, settings_user) {
          var settings = Object.assign({}, defaults, settings_user);
          var attr_data = settings.dataAttr;
          var field_label = settings.labelField;
          var field_value = settings.valueField;
          var field_disabled = settings.disabledField;
          var field_optgroup = settings.optgroupField;
          var field_optgroup_label = settings.optgroupLabelField;
          var field_optgroup_value = settings.optgroupValueField;
          var tag_name = input.tagName.toLowerCase();
          var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
          if (!placeholder && !settings.allowEmptyOption) {
            let option = input.querySelector('option[value=""]');
            if (option) {
              placeholder = option.textContent;
            }
          }
          var settings_element = {
            placeholder,
            options: [],
            optgroups: [],
            items: [],
            maxItems: null
          };
          var init_select = () => {
            var tagName;
            var options = settings_element.options;
            var optionsMap = {};
            var group_count = 1;
            let $order = 0;
            var readData = (el) => {
              var data = Object.assign({}, el.dataset);
              var json = attr_data && data[attr_data];
              if (typeof json === "string" && json.length) {
                data = Object.assign(data, JSON.parse(json));
              }
              return data;
            };
            var addOption = (option, group) => {
              var value = hash_key(option.value);
              if (value == null)
                return;
              if (!value && !settings.allowEmptyOption)
                return;
              if (optionsMap.hasOwnProperty(value)) {
                if (group) {
                  var arr = optionsMap[value][field_optgroup];
                  if (!arr) {
                    optionsMap[value][field_optgroup] = group;
                  } else if (!Array.isArray(arr)) {
                    optionsMap[value][field_optgroup] = [arr, group];
                  } else {
                    arr.push(group);
                  }
                }
              } else {
                var option_data = readData(option);
                option_data[field_label] = option_data[field_label] || option.textContent;
                option_data[field_value] = option_data[field_value] || value;
                option_data[field_disabled] = option_data[field_disabled] || option.disabled;
                option_data[field_optgroup] = option_data[field_optgroup] || group;
                option_data.$option = option;
                option_data.$order = option_data.$order || ++$order;
                optionsMap[value] = option_data;
                options.push(option_data);
              }
              if (option.selected) {
                settings_element.items.push(value);
              }
            };
            var addGroup = (optgroup) => {
              var id, optgroup_data;
              optgroup_data = readData(optgroup);
              optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
              optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
              optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
              optgroup_data.$order = optgroup_data.$order || ++$order;
              settings_element.optgroups.push(optgroup_data);
              id = optgroup_data[field_optgroup_value];
              iterate(optgroup.children, (option) => {
                addOption(option, id);
              });
            };
            settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
            iterate(input.children, (child) => {
              tagName = child.tagName.toLowerCase();
              if (tagName === "optgroup") {
                addGroup(child);
              } else if (tagName === "option") {
                addOption(child);
              }
            });
          };
          var init_textbox = () => {
            const data_raw = input.getAttribute(attr_data);
            if (!data_raw) {
              var value = input.value.trim() || "";
              if (!settings.allowEmptyOption && !value.length)
                return;
              const values = value.split(settings.delimiter);
              iterate(values, (value2) => {
                const option = {};
                option[field_label] = value2;
                option[field_value] = value2;
                settings_element.options.push(option);
              });
              settings_element.items = values;
            } else {
              settings_element.options = JSON.parse(data_raw);
              iterate(settings_element.options, (opt) => {
                settings_element.items.push(opt[field_value]);
              });
            }
          };
          if (tag_name === "select") {
            init_select();
          } else {
            init_textbox();
          }
          return Object.assign({}, defaults, settings_element, settings_user);
        }
        var instance_i = 0;
        class TomSelect5 extends MicroPlugin(MicroEvent) {
          constructor(input_arg, user_settings) {
            super();
            this.control_input = void 0;
            this.wrapper = void 0;
            this.dropdown = void 0;
            this.control = void 0;
            this.dropdown_content = void 0;
            this.focus_node = void 0;
            this.order = 0;
            this.settings = void 0;
            this.input = void 0;
            this.tabIndex = void 0;
            this.is_select_tag = void 0;
            this.rtl = void 0;
            this.inputId = void 0;
            this._destroy = void 0;
            this.sifter = void 0;
            this.isOpen = false;
            this.isDisabled = false;
            this.isReadOnly = false;
            this.isRequired = void 0;
            this.isInvalid = false;
            this.isValid = true;
            this.isLocked = false;
            this.isFocused = false;
            this.isInputHidden = false;
            this.isSetup = false;
            this.ignoreFocus = false;
            this.ignoreHover = false;
            this.hasOptions = false;
            this.currentResults = void 0;
            this.lastValue = "";
            this.caretPos = 0;
            this.loading = 0;
            this.loadedSearches = {};
            this.activeOption = null;
            this.activeItems = [];
            this.optgroups = {};
            this.options = {};
            this.userOptions = {};
            this.items = [];
            this.refreshTimeout = null;
            instance_i++;
            var dir;
            var input = getDom(input_arg);
            if (input.tomselect) {
              throw new Error("Tom Select already initialized on this element");
            }
            input.tomselect = this;
            var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
            dir = computedStyle.getPropertyValue("direction");
            const settings = getSettings(input, user_settings);
            this.settings = settings;
            this.input = input;
            this.tabIndex = input.tabIndex || 0;
            this.is_select_tag = input.tagName.toLowerCase() === "select";
            this.rtl = /rtl/i.test(dir);
            this.inputId = getId(input, "tomselect-" + instance_i);
            this.isRequired = input.required;
            this.sifter = new Sifter(this.options, {
              diacritics: settings.diacritics
            });
            settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
            if (typeof settings.hideSelected !== "boolean") {
              settings.hideSelected = settings.mode === "multi";
            }
            if (typeof settings.hidePlaceholder !== "boolean") {
              settings.hidePlaceholder = settings.mode !== "multi";
            }
            var filter = settings.createFilter;
            if (typeof filter !== "function") {
              if (typeof filter === "string") {
                filter = new RegExp(filter);
              }
              if (filter instanceof RegExp) {
                settings.createFilter = (input2) => filter.test(input2);
              } else {
                settings.createFilter = (value) => {
                  return this.settings.duplicates || !this.options[value];
                };
              }
            }
            this.initializePlugins(settings.plugins);
            this.setupCallbacks();
            this.setupTemplates();
            const wrapper = getDom("<div>");
            const control = getDom("<div>");
            const dropdown = this._render("dropdown");
            const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
            const classes = this.input.getAttribute("class") || "";
            const inputMode = settings.mode;
            var control_input;
            addClasses(wrapper, settings.wrapperClass, classes, inputMode);
            addClasses(control, settings.controlClass);
            append(wrapper, control);
            addClasses(dropdown, settings.dropdownClass, inputMode);
            if (settings.copyClassesToDropdown) {
              addClasses(dropdown, classes);
            }
            addClasses(dropdown_content, settings.dropdownContentClass);
            append(dropdown, dropdown_content);
            getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
            if (isHtmlString(settings.controlInput)) {
              control_input = getDom(settings.controlInput);
              var attrs = ["autocorrect", "autocapitalize", "autocomplete", "spellcheck"];
              iterate$1(attrs, (attr) => {
                if (input.getAttribute(attr)) {
                  setAttr(control_input, {
                    [attr]: input.getAttribute(attr)
                  });
                }
              });
              control_input.tabIndex = -1;
              control.appendChild(control_input);
              this.focus_node = control_input;
            } else if (settings.controlInput) {
              control_input = getDom(settings.controlInput);
              this.focus_node = control_input;
            } else {
              control_input = getDom("<input/>");
              this.focus_node = control;
            }
            this.wrapper = wrapper;
            this.dropdown = dropdown;
            this.dropdown_content = dropdown_content;
            this.control = control;
            this.control_input = control_input;
            this.setup();
          }
          setup() {
            const self2 = this;
            const settings = self2.settings;
            const control_input = self2.control_input;
            const dropdown = self2.dropdown;
            const dropdown_content = self2.dropdown_content;
            const wrapper = self2.wrapper;
            const control = self2.control;
            const input = self2.input;
            const focus_node = self2.focus_node;
            const passive_event = {
              passive: true
            };
            const listboxId = self2.inputId + "-ts-dropdown";
            setAttr(dropdown_content, {
              id: listboxId
            });
            setAttr(focus_node, {
              role: "combobox",
              "aria-haspopup": "listbox",
              "aria-expanded": "false",
              "aria-controls": listboxId
            });
            const control_id = getId(focus_node, self2.inputId + "-ts-control");
            const query = "label[for='" + escapeQuery(self2.inputId) + "']";
            const label = document.querySelector(query);
            const label_click = self2.focus.bind(self2);
            if (label) {
              addEvent(label, "click", label_click);
              setAttr(label, {
                for: control_id
              });
              const label_id = getId(label, self2.inputId + "-ts-label");
              setAttr(focus_node, {
                "aria-labelledby": label_id
              });
              setAttr(dropdown_content, {
                "aria-labelledby": label_id
              });
            }
            wrapper.style.width = input.style.width;
            if (self2.plugins.names.length) {
              const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
              addClasses([wrapper, dropdown], classes_plugins);
            }
            if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
              setAttr(input, {
                multiple: "multiple"
              });
            }
            if (settings.placeholder) {
              setAttr(control_input, {
                placeholder: settings.placeholder
              });
            }
            if (!settings.splitOn && settings.delimiter) {
              settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
            }
            if (settings.load && settings.loadThrottle) {
              settings.load = loadDebounce(settings.load, settings.loadThrottle);
            }
            addEvent(dropdown, "mousemove", () => {
              self2.ignoreHover = false;
            });
            addEvent(dropdown, "mouseenter", (e) => {
              var target_match = parentMatch(e.target, "[data-selectable]", dropdown);
              if (target_match)
                self2.onOptionHover(e, target_match);
            }, {
              capture: true
            });
            addEvent(dropdown, "click", (evt) => {
              const option = parentMatch(evt.target, "[data-selectable]");
              if (option) {
                self2.onOptionSelect(evt, option);
                preventDefault(evt, true);
              }
            });
            addEvent(control, "click", (evt) => {
              var target_match = parentMatch(evt.target, "[data-ts-item]", control);
              if (target_match && self2.onItemSelect(evt, target_match)) {
                preventDefault(evt, true);
                return;
              }
              if (control_input.value != "") {
                return;
              }
              self2.onClick();
              preventDefault(evt, true);
            });
            addEvent(focus_node, "keydown", (e) => self2.onKeyDown(e));
            addEvent(control_input, "keypress", (e) => self2.onKeyPress(e));
            addEvent(control_input, "input", (e) => self2.onInput(e));
            addEvent(focus_node, "blur", (e) => self2.onBlur(e));
            addEvent(focus_node, "focus", (e) => self2.onFocus(e));
            addEvent(control_input, "paste", (e) => self2.onPaste(e));
            const doc_mousedown = (evt) => {
              const target = evt.composedPath()[0];
              if (!wrapper.contains(target) && !dropdown.contains(target)) {
                if (self2.isFocused) {
                  self2.blur();
                }
                self2.inputState();
                return;
              }
              if (target == control_input && self2.isOpen) {
                evt.stopPropagation();
              } else {
                preventDefault(evt, true);
              }
            };
            const win_scroll = () => {
              if (self2.isOpen) {
                self2.positionDropdown();
              }
            };
            addEvent(document, "mousedown", doc_mousedown);
            addEvent(window, "scroll", win_scroll, passive_event);
            addEvent(window, "resize", win_scroll, passive_event);
            this._destroy = () => {
              document.removeEventListener("mousedown", doc_mousedown);
              window.removeEventListener("scroll", win_scroll);
              window.removeEventListener("resize", win_scroll);
              if (label)
                label.removeEventListener("click", label_click);
            };
            this.revertSettings = {
              innerHTML: input.innerHTML,
              tabIndex: input.tabIndex
            };
            input.tabIndex = -1;
            input.insertAdjacentElement("afterend", self2.wrapper);
            self2.sync(false);
            settings.items = [];
            delete settings.optgroups;
            delete settings.options;
            addEvent(input, "invalid", () => {
              if (self2.isValid) {
                self2.isValid = false;
                self2.isInvalid = true;
                self2.refreshState();
              }
            });
            self2.updateOriginalInput();
            self2.refreshItems();
            self2.close(false);
            self2.inputState();
            self2.isSetup = true;
            if (input.disabled) {
              self2.disable();
            } else if (input.readOnly) {
              self2.setReadOnly(true);
            } else {
              self2.enable();
            }
            self2.on("change", this.onChange);
            addClasses(input, "tomselected", "ts-hidden-accessible");
            self2.trigger("initialize");
            if (settings.preload === true) {
              self2.preload();
            }
          }
          setupOptions(options = [], optgroups = []) {
            this.addOptions(options);
            iterate$1(optgroups, (optgroup) => {
              this.registerOptionGroup(optgroup);
            });
          }
          setupTemplates() {
            var self2 = this;
            var field_label = self2.settings.labelField;
            var field_optgroup = self2.settings.optgroupLabelField;
            var templates = {
              "optgroup": (data) => {
                let optgroup = document.createElement("div");
                optgroup.className = "optgroup";
                optgroup.appendChild(data.options);
                return optgroup;
              },
              "optgroup_header": (data, escape) => {
                return '<div class="optgroup-header">' + escape(data[field_optgroup]) + "</div>";
              },
              "option": (data, escape) => {
                return "<div>" + escape(data[field_label]) + "</div>";
              },
              "item": (data, escape) => {
                return "<div>" + escape(data[field_label]) + "</div>";
              },
              "option_create": (data, escape) => {
                return '<div class="create">Add <strong>' + escape(data.input) + "</strong>&hellip;</div>";
              },
              "no_results": () => {
                return '<div class="no-results">No results found</div>';
              },
              "loading": () => {
                return '<div class="spinner"></div>';
              },
              "not_loading": () => {
              },
              "dropdown": () => {
                return "<div></div>";
              }
            };
            self2.settings.render = Object.assign({}, templates, self2.settings.render);
          }
          setupCallbacks() {
            var key, fn;
            var callbacks = {
              "initialize": "onInitialize",
              "change": "onChange",
              "item_add": "onItemAdd",
              "item_remove": "onItemRemove",
              "item_select": "onItemSelect",
              "clear": "onClear",
              "option_add": "onOptionAdd",
              "option_remove": "onOptionRemove",
              "option_clear": "onOptionClear",
              "optgroup_add": "onOptionGroupAdd",
              "optgroup_remove": "onOptionGroupRemove",
              "optgroup_clear": "onOptionGroupClear",
              "dropdown_open": "onDropdownOpen",
              "dropdown_close": "onDropdownClose",
              "type": "onType",
              "load": "onLoad",
              "focus": "onFocus",
              "blur": "onBlur"
            };
            for (key in callbacks) {
              fn = this.settings[callbacks[key]];
              if (fn)
                this.on(key, fn);
            }
          }
          sync(get_settings = true) {
            const self2 = this;
            const settings = get_settings ? getSettings(self2.input, {
              delimiter: self2.settings.delimiter
            }) : self2.settings;
            self2.setupOptions(settings.options, settings.optgroups);
            self2.setValue(settings.items || [], true);
            self2.lastQuery = null;
          }
          onClick() {
            var self2 = this;
            if (self2.activeItems.length > 0) {
              self2.clearActiveItems();
              self2.focus();
              return;
            }
            if (self2.isFocused && self2.isOpen) {
              self2.blur();
            } else {
              self2.focus();
            }
          }
          onMouseDown() {
          }
          onChange() {
            triggerEvent(this.input, "input");
            triggerEvent(this.input, "change");
          }
          onPaste(e) {
            var self2 = this;
            if (self2.isInputHidden || self2.isLocked) {
              preventDefault(e);
              return;
            }
            if (!self2.settings.splitOn) {
              return;
            }
            setTimeout(() => {
              var pastedText = self2.inputValue();
              if (!pastedText.match(self2.settings.splitOn)) {
                return;
              }
              var splitInput = pastedText.trim().split(self2.settings.splitOn);
              iterate$1(splitInput, (piece) => {
                const hash = hash_key(piece);
                if (hash) {
                  if (this.options[piece]) {
                    self2.addItem(piece);
                  } else {
                    self2.createItem(piece);
                  }
                }
              });
            }, 0);
          }
          onKeyPress(e) {
            var self2 = this;
            if (self2.isLocked) {
              preventDefault(e);
              return;
            }
            var character = String.fromCharCode(e.keyCode || e.which);
            if (self2.settings.create && self2.settings.mode === "multi" && character === self2.settings.delimiter) {
              self2.createItem();
              preventDefault(e);
              return;
            }
          }
          onKeyDown(e) {
            var self2 = this;
            self2.ignoreHover = true;
            if (self2.isLocked) {
              if (e.keyCode !== KEY_TAB) {
                preventDefault(e);
              }
              return;
            }
            switch (e.keyCode) {
              case KEY_A:
                if (isKeyDown(KEY_SHORTCUT, e)) {
                  if (self2.control_input.value == "") {
                    preventDefault(e);
                    self2.selectAll();
                    return;
                  }
                }
                break;
              case KEY_ESC:
                if (self2.isOpen) {
                  preventDefault(e, true);
                  self2.close();
                }
                self2.clearActiveItems();
                return;
              case KEY_DOWN:
                if (!self2.isOpen && self2.hasOptions) {
                  self2.open();
                } else if (self2.activeOption) {
                  let next = self2.getAdjacent(self2.activeOption, 1);
                  if (next)
                    self2.setActiveOption(next);
                }
                preventDefault(e);
                return;
              case KEY_UP:
                if (self2.activeOption) {
                  let prev = self2.getAdjacent(self2.activeOption, -1);
                  if (prev)
                    self2.setActiveOption(prev);
                }
                preventDefault(e);
                return;
              case KEY_RETURN:
                if (self2.canSelect(self2.activeOption)) {
                  self2.onOptionSelect(e, self2.activeOption);
                  preventDefault(e);
                } else if (self2.settings.create && self2.createItem()) {
                  preventDefault(e);
                } else if (document.activeElement == self2.control_input && self2.isOpen) {
                  preventDefault(e);
                }
                return;
              case KEY_LEFT:
                self2.advanceSelection(-1, e);
                return;
              case KEY_RIGHT:
                self2.advanceSelection(1, e);
                return;
              case KEY_TAB:
                if (self2.settings.selectOnTab) {
                  if (self2.canSelect(self2.activeOption)) {
                    self2.onOptionSelect(e, self2.activeOption);
                    preventDefault(e);
                  }
                  if (self2.settings.create && self2.createItem()) {
                    preventDefault(e);
                  }
                }
                return;
              case KEY_BACKSPACE:
              case KEY_DELETE:
                self2.deleteSelection(e);
                return;
            }
            if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {
              preventDefault(e);
            }
          }
          onInput(e) {
            if (this.isLocked) {
              return;
            }
            const value = this.inputValue();
            if (this.lastValue === value)
              return;
            this.lastValue = value;
            if (value == "") {
              this._onInput();
              return;
            }
            if (this.refreshTimeout) {
              clearTimeout(this.refreshTimeout);
            }
            this.refreshTimeout = timeout(() => {
              this.refreshTimeout = null;
              this._onInput();
            }, this.settings.refreshThrottle);
          }
          _onInput() {
            const value = this.lastValue;
            if (this.settings.shouldLoad.call(this, value)) {
              this.load(value);
            }
            this.refreshOptions();
            this.trigger("type", value);
          }
          onOptionHover(evt, option) {
            if (this.ignoreHover)
              return;
            this.setActiveOption(option, false);
          }
          onFocus(e) {
            var self2 = this;
            var wasFocused = self2.isFocused;
            if (self2.isDisabled || self2.isReadOnly) {
              self2.blur();
              preventDefault(e);
              return;
            }
            if (self2.ignoreFocus)
              return;
            self2.isFocused = true;
            if (self2.settings.preload === "focus")
              self2.preload();
            if (!wasFocused)
              self2.trigger("focus");
            if (!self2.activeItems.length) {
              self2.inputState();
              self2.refreshOptions(!!self2.settings.openOnFocus);
            }
            self2.refreshState();
          }
          onBlur(e) {
            if (document.hasFocus() === false)
              return;
            var self2 = this;
            if (!self2.isFocused)
              return;
            self2.isFocused = false;
            self2.ignoreFocus = false;
            var deactivate = () => {
              self2.close();
              self2.setActiveItem();
              self2.setCaret(self2.items.length);
              self2.trigger("blur");
            };
            if (self2.settings.create && self2.settings.createOnBlur) {
              self2.createItem(null, deactivate);
            } else {
              deactivate();
            }
          }
          onOptionSelect(evt, option) {
            var value, self2 = this;
            if (option.parentElement && option.parentElement.matches("[data-disabled]")) {
              return;
            }
            if (option.classList.contains("create")) {
              self2.createItem(null, () => {
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
              });
            } else {
              value = option.dataset.value;
              if (typeof value !== "undefined") {
                self2.lastQuery = null;
                self2.addItem(value);
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
                if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                  self2.setActiveOption(option);
                }
              }
            }
          }
          canSelect(option) {
            if (this.isOpen && option && this.dropdown_content.contains(option)) {
              return true;
            }
            return false;
          }
          onItemSelect(evt, item) {
            var self2 = this;
            if (!self2.isLocked && self2.settings.mode === "multi") {
              preventDefault(evt);
              self2.setActiveItem(item, evt);
              return true;
            }
            return false;
          }
          canLoad(value) {
            if (!this.settings.load)
              return false;
            if (this.loadedSearches.hasOwnProperty(value))
              return false;
            return true;
          }
          load(value) {
            const self2 = this;
            if (!self2.canLoad(value))
              return;
            addClasses(self2.wrapper, self2.settings.loadingClass);
            self2.loading++;
            const callback = self2.loadCallback.bind(self2);
            self2.settings.load.call(self2, value, callback);
          }
          loadCallback(options, optgroups) {
            const self2 = this;
            self2.loading = Math.max(self2.loading - 1, 0);
            self2.lastQuery = null;
            self2.clearActiveOption();
            self2.setupOptions(options, optgroups);
            self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
            if (!self2.loading) {
              removeClasses(self2.wrapper, self2.settings.loadingClass);
            }
            self2.trigger("load", options, optgroups);
          }
          preload() {
            var classList = this.wrapper.classList;
            if (classList.contains("preloaded"))
              return;
            classList.add("preloaded");
            this.load("");
          }
          setTextboxValue(value = "") {
            var input = this.control_input;
            var changed = input.value !== value;
            if (changed) {
              input.value = value;
              triggerEvent(input, "update");
              this.lastValue = value;
            }
          }
          getValue() {
            if (this.is_select_tag && this.input.hasAttribute("multiple")) {
              return this.items;
            }
            return this.items.join(this.settings.delimiter);
          }
          setValue(value, silent) {
            var events = silent ? [] : ["change"];
            debounce_events(this, events, () => {
              this.clear(silent);
              this.addItems(value, silent);
            });
          }
          setMaxItems(value) {
            if (value === 0)
              value = null;
            this.settings.maxItems = value;
            this.refreshState();
          }
          setActiveItem(item, e) {
            var self2 = this;
            var eventName;
            var i, begin, end, swap;
            var last;
            if (self2.settings.mode === "single")
              return;
            if (!item) {
              self2.clearActiveItems();
              if (self2.isFocused) {
                self2.inputState();
              }
              return;
            }
            eventName = e && e.type.toLowerCase();
            if (eventName === "click" && isKeyDown("shiftKey", e) && self2.activeItems.length) {
              last = self2.getLastActive();
              begin = Array.prototype.indexOf.call(self2.control.children, last);
              end = Array.prototype.indexOf.call(self2.control.children, item);
              if (begin > end) {
                swap = begin;
                begin = end;
                end = swap;
              }
              for (i = begin; i <= end; i++) {
                item = self2.control.children[i];
                if (self2.activeItems.indexOf(item) === -1) {
                  self2.setActiveItemClass(item);
                }
              }
              preventDefault(e);
            } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e) || eventName === "keydown" && isKeyDown("shiftKey", e)) {
              if (item.classList.contains("active")) {
                self2.removeActiveItem(item);
              } else {
                self2.setActiveItemClass(item);
              }
            } else {
              self2.clearActiveItems();
              self2.setActiveItemClass(item);
            }
            self2.inputState();
            if (!self2.isFocused) {
              self2.focus();
            }
          }
          setActiveItemClass(item) {
            const self2 = this;
            const last_active = self2.control.querySelector(".last-active");
            if (last_active)
              removeClasses(last_active, "last-active");
            addClasses(item, "active last-active");
            self2.trigger("item_select", item);
            if (self2.activeItems.indexOf(item) == -1) {
              self2.activeItems.push(item);
            }
          }
          removeActiveItem(item) {
            var idx = this.activeItems.indexOf(item);
            this.activeItems.splice(idx, 1);
            removeClasses(item, "active");
          }
          clearActiveItems() {
            removeClasses(this.activeItems, "active");
            this.activeItems = [];
          }
          setActiveOption(option, scroll2 = true) {
            if (option === this.activeOption) {
              return;
            }
            this.clearActiveOption();
            if (!option)
              return;
            this.activeOption = option;
            setAttr(this.focus_node, {
              "aria-activedescendant": option.getAttribute("id")
            });
            setAttr(option, {
              "aria-selected": "true"
            });
            addClasses(option, "active");
            if (scroll2)
              this.scrollToOption(option);
          }
          scrollToOption(option, behavior) {
            if (!option)
              return;
            const content = this.dropdown_content;
            const height_menu = content.clientHeight;
            const scrollTop = content.scrollTop || 0;
            const height_item = option.offsetHeight;
            const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
            if (y + height_item > height_menu + scrollTop) {
              this.scroll(y - height_menu + height_item, behavior);
            } else if (y < scrollTop) {
              this.scroll(y, behavior);
            }
          }
          scroll(scrollTop, behavior) {
            const content = this.dropdown_content;
            if (behavior) {
              content.style.scrollBehavior = behavior;
            }
            content.scrollTop = scrollTop;
            content.style.scrollBehavior = "";
          }
          clearActiveOption() {
            if (this.activeOption) {
              removeClasses(this.activeOption, "active");
              setAttr(this.activeOption, {
                "aria-selected": null
              });
            }
            this.activeOption = null;
            setAttr(this.focus_node, {
              "aria-activedescendant": null
            });
          }
          selectAll() {
            const self2 = this;
            if (self2.settings.mode === "single")
              return;
            const activeItems = self2.controlChildren();
            if (!activeItems.length)
              return;
            self2.inputState();
            self2.close();
            self2.activeItems = activeItems;
            iterate$1(activeItems, (item) => {
              self2.setActiveItemClass(item);
            });
          }
          inputState() {
            var self2 = this;
            if (!self2.control.contains(self2.control_input))
              return;
            setAttr(self2.control_input, {
              placeholder: self2.settings.placeholder
            });
            if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
              self2.setTextboxValue();
              self2.isInputHidden = true;
            } else {
              if (self2.settings.hidePlaceholder && self2.items.length > 0) {
                setAttr(self2.control_input, {
                  placeholder: ""
                });
              }
              self2.isInputHidden = false;
            }
            self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
          }
          inputValue() {
            return this.control_input.value.trim();
          }
          focus() {
            var self2 = this;
            if (self2.isDisabled || self2.isReadOnly)
              return;
            self2.ignoreFocus = true;
            if (self2.control_input.offsetWidth) {
              self2.control_input.focus();
            } else {
              self2.focus_node.focus();
            }
            setTimeout(() => {
              self2.ignoreFocus = false;
              self2.onFocus();
            }, 0);
          }
          blur() {
            this.focus_node.blur();
            this.onBlur();
          }
          getScoreFunction(query) {
            return this.sifter.getScoreFunction(query, this.getSearchOptions());
          }
          getSearchOptions() {
            var settings = this.settings;
            var sort = settings.sortField;
            if (typeof settings.sortField === "string") {
              sort = [{
                field: settings.sortField
              }];
            }
            return {
              fields: settings.searchField,
              conjunction: settings.searchConjunction,
              sort,
              nesting: settings.nesting
            };
          }
          search(query) {
            var result, calculateScore;
            var self2 = this;
            var options = this.getSearchOptions();
            if (self2.settings.score) {
              calculateScore = self2.settings.score.call(self2, query);
              if (typeof calculateScore !== "function") {
                throw new Error('Tom Select "score" setting must be a function that returns a function');
              }
            }
            if (query !== self2.lastQuery) {
              self2.lastQuery = query;
              result = self2.sifter.search(query, Object.assign(options, {
                score: calculateScore
              }));
              self2.currentResults = result;
            } else {
              result = Object.assign({}, self2.currentResults);
            }
            if (self2.settings.hideSelected) {
              result.items = result.items.filter((item) => {
                let hashed = hash_key(item.id);
                return !(hashed && self2.items.indexOf(hashed) !== -1);
              });
            }
            return result;
          }
          refreshOptions(triggerDropdown = true) {
            var i, j, k, n, optgroup, optgroups, html, has_create_option, active_group;
            var create;
            const groups = {};
            const groups_order = [];
            var self2 = this;
            var query = self2.inputValue();
            const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
            var results = self2.search(query);
            var active_option = null;
            var show_dropdown = self2.settings.shouldOpen || false;
            var dropdown_content = self2.dropdown_content;
            if (same_query) {
              active_option = self2.activeOption;
              if (active_option) {
                active_group = active_option.closest("[data-group]");
              }
            }
            n = results.items.length;
            if (typeof self2.settings.maxOptions === "number") {
              n = Math.min(n, self2.settings.maxOptions);
            }
            if (n > 0) {
              show_dropdown = true;
            }
            const getGroupFragment = (optgroup2, order) => {
              let group_order_i = groups[optgroup2];
              if (group_order_i !== void 0) {
                let order_group = groups_order[group_order_i];
                if (order_group !== void 0) {
                  return [group_order_i, order_group.fragment];
                }
              }
              let group_fragment = document.createDocumentFragment();
              group_order_i = groups_order.length;
              groups_order.push({
                fragment: group_fragment,
                order,
                optgroup: optgroup2
              });
              return [group_order_i, group_fragment];
            };
            for (i = 0; i < n; i++) {
              let item = results.items[i];
              if (!item)
                continue;
              let opt_value = item.id;
              let option = self2.options[opt_value];
              if (option === void 0)
                continue;
              let opt_hash = get_hash(opt_value);
              let option_el = self2.getOption(opt_hash, true);
              if (!self2.settings.hideSelected) {
                option_el.classList.toggle("selected", self2.items.includes(opt_hash));
              }
              optgroup = option[self2.settings.optgroupField] || "";
              optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
              for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
                optgroup = optgroups[j];
                let order = option.$order;
                let self_optgroup = self2.optgroups[optgroup];
                if (self_optgroup === void 0) {
                  optgroup = "";
                } else {
                  order = self_optgroup.$order;
                }
                const [group_order_i, group_fragment] = getGroupFragment(optgroup, order);
                if (j > 0) {
                  option_el = option_el.cloneNode(true);
                  setAttr(option_el, {
                    id: option.$id + "-clone-" + j,
                    "aria-selected": null
                  });
                  option_el.classList.add("ts-cloned");
                  removeClasses(option_el, "active");
                  if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
                    if (active_group && active_group.dataset.group === optgroup.toString()) {
                      active_option = option_el;
                    }
                  }
                }
                group_fragment.appendChild(option_el);
                if (optgroup != "") {
                  groups[optgroup] = group_order_i;
                }
              }
            }
            if (self2.settings.lockOptgroupOrder) {
              groups_order.sort((a, b) => {
                return a.order - b.order;
              });
            }
            html = document.createDocumentFragment();
            iterate$1(groups_order, (group_order) => {
              let group_fragment = group_order.fragment;
              let optgroup2 = group_order.optgroup;
              if (!group_fragment || !group_fragment.children.length)
                return;
              let group_heading = self2.optgroups[optgroup2];
              if (group_heading !== void 0) {
                let group_options = document.createDocumentFragment();
                let header = self2.render("optgroup_header", group_heading);
                append(group_options, header);
                append(group_options, group_fragment);
                let group_html = self2.render("optgroup", {
                  group: group_heading,
                  options: group_options
                });
                append(html, group_html);
              } else {
                append(html, group_fragment);
              }
            });
            dropdown_content.innerHTML = "";
            append(dropdown_content, html);
            if (self2.settings.highlight) {
              removeHighlight(dropdown_content);
              if (results.query.length && results.tokens.length) {
                iterate$1(results.tokens, (tok) => {
                  highlight(dropdown_content, tok.regex);
                });
              }
            }
            var add_template = (template) => {
              let content = self2.render(template, {
                input: query
              });
              if (content) {
                show_dropdown = true;
                dropdown_content.insertBefore(content, dropdown_content.firstChild);
              }
              return content;
            };
            if (self2.loading) {
              add_template("loading");
            } else if (!self2.settings.shouldLoad.call(self2, query)) {
              add_template("not_loading");
            } else if (results.items.length === 0) {
              add_template("no_results");
            }
            has_create_option = self2.canCreate(query);
            if (has_create_option) {
              create = add_template("option_create");
            }
            self2.hasOptions = results.items.length > 0 || has_create_option;
            if (show_dropdown) {
              if (results.items.length > 0) {
                if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
                  active_option = self2.getOption(self2.items[0]);
                }
                if (!dropdown_content.contains(active_option)) {
                  let active_index = 0;
                  if (create && !self2.settings.addPrecedence) {
                    active_index = 1;
                  }
                  active_option = self2.selectable()[active_index];
                }
              } else if (create) {
                active_option = create;
              }
              if (triggerDropdown && !self2.isOpen) {
                self2.open();
                self2.scrollToOption(active_option, "auto");
              }
              self2.setActiveOption(active_option);
            } else {
              self2.clearActiveOption();
              if (triggerDropdown && self2.isOpen) {
                self2.close(false);
              }
            }
          }
          selectable() {
            return this.dropdown_content.querySelectorAll("[data-selectable]");
          }
          addOption(data, user_created = false) {
            const self2 = this;
            if (Array.isArray(data)) {
              self2.addOptions(data, user_created);
              return false;
            }
            const key = hash_key(data[self2.settings.valueField]);
            if (key === null || self2.options.hasOwnProperty(key)) {
              return false;
            }
            data.$order = data.$order || ++self2.order;
            data.$id = self2.inputId + "-opt-" + data.$order;
            self2.options[key] = data;
            self2.lastQuery = null;
            if (user_created) {
              self2.userOptions[key] = user_created;
              self2.trigger("option_add", key, data);
            }
            return key;
          }
          addOptions(data, user_created = false) {
            iterate$1(data, (dat) => {
              this.addOption(dat, user_created);
            });
          }
          registerOption(data) {
            return this.addOption(data);
          }
          registerOptionGroup(data) {
            var key = hash_key(data[this.settings.optgroupValueField]);
            if (key === null)
              return false;
            data.$order = data.$order || ++this.order;
            this.optgroups[key] = data;
            return key;
          }
          addOptionGroup(id, data) {
            var hashed_id;
            data[this.settings.optgroupValueField] = id;
            if (hashed_id = this.registerOptionGroup(data)) {
              this.trigger("optgroup_add", hashed_id, data);
            }
          }
          removeOptionGroup(id) {
            if (this.optgroups.hasOwnProperty(id)) {
              delete this.optgroups[id];
              this.clearCache();
              this.trigger("optgroup_remove", id);
            }
          }
          clearOptionGroups() {
            this.optgroups = {};
            this.clearCache();
            this.trigger("optgroup_clear");
          }
          updateOption(value, data) {
            const self2 = this;
            var item_new;
            var index_item;
            const value_old = hash_key(value);
            const value_new = hash_key(data[self2.settings.valueField]);
            if (value_old === null)
              return;
            const data_old = self2.options[value_old];
            if (data_old == void 0)
              return;
            if (typeof value_new !== "string")
              throw new Error("Value must be set in option data");
            const option = self2.getOption(value_old);
            const item = self2.getItem(value_old);
            data.$order = data.$order || data_old.$order;
            delete self2.options[value_old];
            self2.uncacheValue(value_new);
            self2.options[value_new] = data;
            if (option) {
              if (self2.dropdown_content.contains(option)) {
                const option_new = self2._render("option", data);
                replaceNode(option, option_new);
                if (self2.activeOption === option) {
                  self2.setActiveOption(option_new);
                }
              }
              option.remove();
            }
            if (item) {
              index_item = self2.items.indexOf(value_old);
              if (index_item !== -1) {
                self2.items.splice(index_item, 1, value_new);
              }
              item_new = self2._render("item", data);
              if (item.classList.contains("active"))
                addClasses(item_new, "active");
              replaceNode(item, item_new);
            }
            self2.lastQuery = null;
          }
          removeOption(value, silent) {
            const self2 = this;
            value = get_hash(value);
            self2.uncacheValue(value);
            delete self2.userOptions[value];
            delete self2.options[value];
            self2.lastQuery = null;
            self2.trigger("option_remove", value);
            self2.removeItem(value, silent);
          }
          clearOptions(filter) {
            const boundFilter = (filter || this.clearFilter).bind(this);
            this.loadedSearches = {};
            this.userOptions = {};
            this.clearCache();
            const selected = {};
            iterate$1(this.options, (option, key) => {
              if (boundFilter(option, key)) {
                selected[key] = option;
              }
            });
            this.options = this.sifter.items = selected;
            this.lastQuery = null;
            this.trigger("option_clear");
          }
          clearFilter(option, value) {
            if (this.items.indexOf(value) >= 0) {
              return true;
            }
            return false;
          }
          getOption(value, create = false) {
            const hashed = hash_key(value);
            if (hashed === null)
              return null;
            const option = this.options[hashed];
            if (option != void 0) {
              if (option.$div) {
                return option.$div;
              }
              if (create) {
                return this._render("option", option);
              }
            }
            return null;
          }
          getAdjacent(option, direction, type = "option") {
            var self2 = this, all;
            if (!option) {
              return null;
            }
            if (type == "item") {
              all = self2.controlChildren();
            } else {
              all = self2.dropdown_content.querySelectorAll("[data-selectable]");
            }
            for (let i = 0; i < all.length; i++) {
              if (all[i] != option) {
                continue;
              }
              if (direction > 0) {
                return all[i + 1];
              }
              return all[i - 1];
            }
            return null;
          }
          getItem(item) {
            if (typeof item == "object") {
              return item;
            }
            var value = hash_key(item);
            return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
          }
          addItems(values, silent) {
            var self2 = this;
            var items = Array.isArray(values) ? values : [values];
            items = items.filter((x) => self2.items.indexOf(x) === -1);
            const last_item = items[items.length - 1];
            items.forEach((item) => {
              self2.isPending = item !== last_item;
              self2.addItem(item, silent);
            });
          }
          addItem(value, silent) {
            var events = silent ? [] : ["change", "dropdown_close"];
            debounce_events(this, events, () => {
              var item, wasFull;
              const self2 = this;
              const inputMode = self2.settings.mode;
              const hashed = hash_key(value);
              if (hashed && self2.items.indexOf(hashed) !== -1) {
                if (inputMode === "single") {
                  self2.close();
                }
                if (inputMode === "single" || !self2.settings.duplicates) {
                  return;
                }
              }
              if (hashed === null || !self2.options.hasOwnProperty(hashed))
                return;
              if (inputMode === "single")
                self2.clear(silent);
              if (inputMode === "multi" && self2.isFull())
                return;
              item = self2._render("item", self2.options[hashed]);
              if (self2.control.contains(item)) {
                item = item.cloneNode(true);
              }
              wasFull = self2.isFull();
              self2.items.splice(self2.caretPos, 0, hashed);
              self2.insertAtCaret(item);
              if (self2.isSetup) {
                if (!self2.isPending && self2.settings.hideSelected) {
                  let option = self2.getOption(hashed);
                  let next = self2.getAdjacent(option, 1);
                  if (next) {
                    self2.setActiveOption(next);
                  }
                }
                if (!self2.isPending && !self2.settings.closeAfterSelect) {
                  self2.refreshOptions(self2.isFocused && inputMode !== "single");
                }
                if (self2.settings.closeAfterSelect != false && self2.isFull()) {
                  self2.close();
                } else if (!self2.isPending) {
                  self2.positionDropdown();
                }
                self2.trigger("item_add", hashed, item);
                if (!self2.isPending) {
                  self2.updateOriginalInput({
                    silent
                  });
                }
              }
              if (!self2.isPending || !wasFull && self2.isFull()) {
                self2.inputState();
                self2.refreshState();
              }
            });
          }
          removeItem(item = null, silent) {
            const self2 = this;
            item = self2.getItem(item);
            if (!item)
              return;
            var i, idx;
            const value = item.dataset.value;
            i = nodeIndex(item);
            item.remove();
            if (item.classList.contains("active")) {
              idx = self2.activeItems.indexOf(item);
              self2.activeItems.splice(idx, 1);
              removeClasses(item, "active");
            }
            self2.items.splice(i, 1);
            self2.lastQuery = null;
            if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
              self2.removeOption(value, silent);
            }
            if (i < self2.caretPos) {
              self2.setCaret(self2.caretPos - 1);
            }
            self2.updateOriginalInput({
              silent
            });
            self2.refreshState();
            self2.positionDropdown();
            self2.trigger("item_remove", value, item);
          }
          createItem(input = null, callback = () => {
          }) {
            if (arguments.length === 3) {
              callback = arguments[2];
            }
            if (typeof callback != "function") {
              callback = () => {
              };
            }
            var self2 = this;
            var caret = self2.caretPos;
            var output;
            input = input || self2.inputValue();
            if (!self2.canCreate(input)) {
              callback();
              return false;
            }
            self2.lock();
            var created = false;
            var create = (data) => {
              self2.unlock();
              if (!data || typeof data !== "object")
                return callback();
              var value = hash_key(data[self2.settings.valueField]);
              if (typeof value !== "string") {
                return callback();
              }
              self2.setTextboxValue();
              self2.addOption(data, true);
              self2.setCaret(caret);
              self2.addItem(value);
              callback(data);
              created = true;
            };
            if (typeof self2.settings.create === "function") {
              output = self2.settings.create.call(this, input, create);
            } else {
              output = {
                [self2.settings.labelField]: input,
                [self2.settings.valueField]: input
              };
            }
            if (!created) {
              create(output);
            }
            return true;
          }
          refreshItems() {
            var self2 = this;
            self2.lastQuery = null;
            if (self2.isSetup) {
              self2.addItems(self2.items);
            }
            self2.updateOriginalInput();
            self2.refreshState();
          }
          refreshState() {
            const self2 = this;
            self2.refreshValidityState();
            const isFull = self2.isFull();
            const isLocked = self2.isLocked;
            self2.wrapper.classList.toggle("rtl", self2.rtl);
            const wrap_classList = self2.wrapper.classList;
            wrap_classList.toggle("focus", self2.isFocused);
            wrap_classList.toggle("disabled", self2.isDisabled);
            wrap_classList.toggle("readonly", self2.isReadOnly);
            wrap_classList.toggle("required", self2.isRequired);
            wrap_classList.toggle("invalid", !self2.isValid);
            wrap_classList.toggle("locked", isLocked);
            wrap_classList.toggle("full", isFull);
            wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
            wrap_classList.toggle("dropdown-active", self2.isOpen);
            wrap_classList.toggle("has-options", isEmptyObject(self2.options));
            wrap_classList.toggle("has-items", self2.items.length > 0);
          }
          refreshValidityState() {
            var self2 = this;
            if (!self2.input.validity) {
              return;
            }
            self2.isValid = self2.input.validity.valid;
            self2.isInvalid = !self2.isValid;
          }
          isFull() {
            return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
          }
          updateOriginalInput(opts = {}) {
            const self2 = this;
            var option, label;
            const empty_option = self2.input.querySelector('option[value=""]');
            if (self2.is_select_tag) {
              let AddSelected = function(option_el, value, label2) {
                if (!option_el) {
                  option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label2) + "</option>");
                }
                if (option_el != empty_option) {
                  self2.input.append(option_el);
                }
                selected.push(option_el);
                if (option_el != empty_option || has_selected > 0) {
                  option_el.selected = true;
                }
                return option_el;
              };
              const selected = [];
              const has_selected = self2.input.querySelectorAll("option:checked").length;
              self2.input.querySelectorAll("option:checked").forEach((option_el) => {
                option_el.selected = false;
              });
              if (self2.items.length == 0 && self2.settings.mode == "single") {
                AddSelected(empty_option, "", "");
              } else {
                self2.items.forEach((value) => {
                  option = self2.options[value];
                  label = option[self2.settings.labelField] || "";
                  if (selected.includes(option.$option)) {
                    const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
                    AddSelected(reuse_opt, value, label);
                  } else {
                    option.$option = AddSelected(option.$option, value, label);
                  }
                });
              }
            } else {
              self2.input.value = self2.getValue();
            }
            if (self2.isSetup) {
              if (!opts.silent) {
                self2.trigger("change", self2.getValue());
              }
            }
          }
          open() {
            var self2 = this;
            if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
              return;
            self2.isOpen = true;
            setAttr(self2.focus_node, {
              "aria-expanded": "true"
            });
            self2.refreshState();
            applyCSS(self2.dropdown, {
              visibility: "hidden",
              display: "block"
            });
            self2.positionDropdown();
            applyCSS(self2.dropdown, {
              visibility: "visible",
              display: "block"
            });
            self2.focus();
            self2.trigger("dropdown_open", self2.dropdown);
          }
          close(setTextboxValue = true) {
            var self2 = this;
            var trigger = self2.isOpen;
            if (setTextboxValue) {
              self2.setTextboxValue();
              if (self2.settings.mode === "single" && self2.items.length) {
                self2.inputState();
              }
            }
            self2.isOpen = false;
            setAttr(self2.focus_node, {
              "aria-expanded": "false"
            });
            applyCSS(self2.dropdown, {
              display: "none"
            });
            if (self2.settings.hideSelected) {
              self2.clearActiveOption();
            }
            self2.refreshState();
            if (trigger)
              self2.trigger("dropdown_close", self2.dropdown);
          }
          positionDropdown() {
            if (this.settings.dropdownParent !== "body") {
              return;
            }
            var context = this.control;
            var rect = context.getBoundingClientRect();
            var top = context.offsetHeight + rect.top + window.scrollY;
            var left = rect.left + window.scrollX;
            applyCSS(this.dropdown, {
              width: rect.width + "px",
              top: top + "px",
              left: left + "px"
            });
          }
          clear(silent) {
            var self2 = this;
            if (!self2.items.length)
              return;
            var items = self2.controlChildren();
            iterate$1(items, (item) => {
              self2.removeItem(item, true);
            });
            self2.inputState();
            if (!silent)
              self2.updateOriginalInput();
            self2.trigger("clear");
          }
          insertAtCaret(el) {
            const self2 = this;
            const caret = self2.caretPos;
            const target = self2.control;
            target.insertBefore(el, target.children[caret] || null);
            self2.setCaret(caret + 1);
          }
          deleteSelection(e) {
            var direction, selection, caret, tail;
            var self2 = this;
            direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
            selection = getSelection(self2.control_input);
            const rm_items = [];
            if (self2.activeItems.length) {
              tail = getTail(self2.activeItems, direction);
              caret = nodeIndex(tail);
              if (direction > 0) {
                caret++;
              }
              iterate$1(self2.activeItems, (item) => rm_items.push(item));
            } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
              const items = self2.controlChildren();
              let rm_item;
              if (direction < 0 && selection.start === 0 && selection.length === 0) {
                rm_item = items[self2.caretPos - 1];
              } else if (direction > 0 && selection.start === self2.inputValue().length) {
                rm_item = items[self2.caretPos];
              }
              if (rm_item !== void 0) {
                rm_items.push(rm_item);
              }
            }
            if (!self2.shouldDelete(rm_items, e)) {
              return false;
            }
            preventDefault(e, true);
            if (typeof caret !== "undefined") {
              self2.setCaret(caret);
            }
            while (rm_items.length) {
              self2.removeItem(rm_items.pop());
            }
            self2.inputState();
            self2.positionDropdown();
            self2.refreshOptions(false);
            return true;
          }
          shouldDelete(items, evt) {
            const values = items.map((item) => item.dataset.value);
            if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
              return false;
            }
            return true;
          }
          advanceSelection(direction, e) {
            var last_active, adjacent, self2 = this;
            if (self2.rtl)
              direction *= -1;
            if (self2.inputValue().length)
              return;
            if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown("shiftKey", e)) {
              last_active = self2.getLastActive(direction);
              if (last_active) {
                if (!last_active.classList.contains("active")) {
                  adjacent = last_active;
                } else {
                  adjacent = self2.getAdjacent(last_active, direction, "item");
                }
              } else if (direction > 0) {
                adjacent = self2.control_input.nextElementSibling;
              } else {
                adjacent = self2.control_input.previousElementSibling;
              }
              if (adjacent) {
                if (adjacent.classList.contains("active")) {
                  self2.removeActiveItem(last_active);
                }
                self2.setActiveItemClass(adjacent);
              }
            } else {
              self2.moveCaret(direction);
            }
          }
          moveCaret(direction) {
          }
          getLastActive(direction) {
            let last_active = this.control.querySelector(".last-active");
            if (last_active) {
              return last_active;
            }
            var result = this.control.querySelectorAll(".active");
            if (result) {
              return getTail(result, direction);
            }
          }
          setCaret(new_pos) {
            this.caretPos = this.items.length;
          }
          controlChildren() {
            return Array.from(this.control.querySelectorAll("[data-ts-item]"));
          }
          lock() {
            this.setLocked(true);
          }
          unlock() {
            this.setLocked(false);
          }
          setLocked(lock = this.isReadOnly || this.isDisabled) {
            this.isLocked = lock;
            this.refreshState();
          }
          disable() {
            this.setDisabled(true);
            this.close();
          }
          enable() {
            this.setDisabled(false);
          }
          setDisabled(disabled) {
            this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
            this.isDisabled = disabled;
            this.input.disabled = disabled;
            this.control_input.disabled = disabled;
            this.setLocked();
          }
          setReadOnly(isReadOnly) {
            this.isReadOnly = isReadOnly;
            this.input.readOnly = isReadOnly;
            this.control_input.readOnly = isReadOnly;
            this.setLocked();
          }
          destroy() {
            var self2 = this;
            var revertSettings = self2.revertSettings;
            self2.trigger("destroy");
            self2.off();
            self2.wrapper.remove();
            self2.dropdown.remove();
            self2.input.innerHTML = revertSettings.innerHTML;
            self2.input.tabIndex = revertSettings.tabIndex;
            removeClasses(self2.input, "tomselected", "ts-hidden-accessible");
            self2._destroy();
            delete self2.input.tomselect;
          }
          render(templateName, data) {
            var id, html;
            const self2 = this;
            if (typeof this.settings.render[templateName] !== "function") {
              return null;
            }
            html = self2.settings.render[templateName].call(this, data, escape_html);
            if (!html) {
              return null;
            }
            html = getDom(html);
            if (templateName === "option" || templateName === "option_create") {
              if (data[self2.settings.disabledField]) {
                setAttr(html, {
                  "aria-disabled": "true"
                });
              } else {
                setAttr(html, {
                  "data-selectable": ""
                });
              }
            } else if (templateName === "optgroup") {
              id = data.group[self2.settings.optgroupValueField];
              setAttr(html, {
                "data-group": id
              });
              if (data.group[self2.settings.disabledField]) {
                setAttr(html, {
                  "data-disabled": ""
                });
              }
            }
            if (templateName === "option" || templateName === "item") {
              const value = get_hash(data[self2.settings.valueField]);
              setAttr(html, {
                "data-value": value
              });
              if (templateName === "item") {
                addClasses(html, self2.settings.itemClass);
                setAttr(html, {
                  "data-ts-item": ""
                });
              } else {
                addClasses(html, self2.settings.optionClass);
                setAttr(html, {
                  role: "option",
                  id: data.$id
                });
                data.$div = html;
                self2.options[value] = data;
              }
            }
            return html;
          }
          _render(templateName, data) {
            const html = this.render(templateName, data);
            if (html == null) {
              throw "HTMLElement expected";
            }
            return html;
          }
          clearCache() {
            iterate$1(this.options, (option) => {
              if (option.$div) {
                option.$div.remove();
                delete option.$div;
              }
            });
          }
          uncacheValue(value) {
            const option_el = this.getOption(value);
            if (option_el)
              option_el.remove();
          }
          canCreate(input) {
            return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
          }
          hook(when, method, new_fn) {
            var self2 = this;
            var orig_method = self2[method];
            self2[method] = function() {
              var result, result_new;
              if (when === "after") {
                result = orig_method.apply(self2, arguments);
              }
              result_new = new_fn.apply(self2, arguments);
              if (when === "instead") {
                return result_new;
              }
              if (when === "before") {
                result = orig_method.apply(self2, arguments);
              }
              return result;
            };
          }
        }
        function change_listener() {
          addEvent(this.input, "change", () => {
            this.sync();
          });
        }
        function checkbox_options(userOptions) {
          var self2 = this;
          var orig_onOptionSelect = self2.onOptionSelect;
          self2.settings.hideSelected = false;
          const cbOptions = Object.assign({
            className: "tomselect-checkbox",
            checkedClassNames: void 0,
            uncheckedClassNames: void 0
          }, userOptions);
          var UpdateChecked = function UpdateChecked2(checkbox, toCheck) {
            if (toCheck) {
              checkbox.checked = true;
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.remove(...cbOptions.uncheckedClassNames);
              }
              if (cbOptions.checkedClassNames) {
                checkbox.classList.add(...cbOptions.checkedClassNames);
              }
            } else {
              checkbox.checked = false;
              if (cbOptions.checkedClassNames) {
                checkbox.classList.remove(...cbOptions.checkedClassNames);
              }
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.add(...cbOptions.uncheckedClassNames);
              }
            }
          };
          var UpdateCheckbox = function UpdateCheckbox2(option) {
            setTimeout(() => {
              var checkbox = option.querySelector("input." + cbOptions.className);
              if (checkbox instanceof HTMLInputElement) {
                UpdateChecked(checkbox, option.classList.contains("selected"));
              }
            }, 1);
          };
          self2.hook("after", "setupTemplates", () => {
            var orig_render_option = self2.settings.render.option;
            self2.settings.render.option = (data, escape_html2) => {
              var rendered = getDom(orig_render_option.call(self2, data, escape_html2));
              var checkbox = document.createElement("input");
              if (cbOptions.className) {
                checkbox.classList.add(cbOptions.className);
              }
              checkbox.addEventListener("click", function(evt) {
                preventDefault(evt);
              });
              checkbox.type = "checkbox";
              const hashed = hash_key(data[self2.settings.valueField]);
              UpdateChecked(checkbox, !!(hashed && self2.items.indexOf(hashed) > -1));
              rendered.prepend(checkbox);
              return rendered;
            };
          });
          self2.on("item_remove", (value) => {
            var option = self2.getOption(value);
            if (option) {
              option.classList.remove("selected");
              UpdateCheckbox(option);
            }
          });
          self2.on("item_add", (value) => {
            var option = self2.getOption(value);
            if (option) {
              UpdateCheckbox(option);
            }
          });
          self2.hook("instead", "onOptionSelect", (evt, option) => {
            if (option.classList.contains("selected")) {
              option.classList.remove("selected");
              self2.removeItem(option.dataset.value);
              self2.refreshOptions();
              preventDefault(evt, true);
              return;
            }
            orig_onOptionSelect.call(self2, evt, option);
            UpdateCheckbox(option);
          });
        }
        function clear_button(userOptions) {
          const self2 = this;
          const options = Object.assign({
            className: "clear-button",
            title: "Clear All",
            html: (data) => {
              return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
            }
          }, userOptions);
          self2.on("initialize", () => {
            var button = getDom(options.html(options));
            button.addEventListener("click", (evt) => {
              if (self2.isLocked)
                return;
              self2.clear();
              if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
                self2.addItem("");
              }
              evt.preventDefault();
              evt.stopPropagation();
            });
            self2.control.appendChild(button);
          });
        }
        const insertAfter = (referenceNode, newNode) => {
          var _referenceNode$parent;
          (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
        };
        const insertBefore = (referenceNode, newNode) => {
          var _referenceNode$parent2;
          (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
        };
        const isBefore = (referenceNode, newNode) => {
          do {
            var _newNode;
            newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
            if (referenceNode == newNode) {
              return true;
            }
          } while (newNode && newNode.previousElementSibling);
          return false;
        };
        function drag_drop() {
          var self2 = this;
          if (self2.settings.mode !== "multi")
            return;
          var orig_lock = self2.lock;
          var orig_unlock = self2.unlock;
          let sortable = true;
          let drag_item;
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape) => {
              const item = getDom(orig_render_item.call(self2, data, escape));
              setAttr(item, {
                "draggable": "true"
              });
              const mousedown = (evt) => {
                if (!sortable)
                  preventDefault(evt);
                evt.stopPropagation();
              };
              const dragStart = (evt) => {
                drag_item = item;
                setTimeout(() => {
                  item.classList.add("ts-dragging");
                }, 0);
              };
              const dragOver = (evt) => {
                evt.preventDefault();
                item.classList.add("ts-drag-over");
                moveitem(item, drag_item);
              };
              const dragLeave = () => {
                item.classList.remove("ts-drag-over");
              };
              const moveitem = (targetitem, dragitem) => {
                if (dragitem === void 0)
                  return;
                if (isBefore(dragitem, item)) {
                  insertAfter(targetitem, dragitem);
                } else {
                  insertBefore(targetitem, dragitem);
                }
              };
              const dragend = () => {
                var _drag_item;
                document.querySelectorAll(".ts-drag-over").forEach((el) => el.classList.remove("ts-drag-over"));
                (_drag_item = drag_item) == null || _drag_item.classList.remove("ts-dragging");
                drag_item = void 0;
                var values = [];
                self2.control.querySelectorAll(`[data-value]`).forEach((el) => {
                  if (el.dataset.value) {
                    let value = el.dataset.value;
                    if (value) {
                      values.push(value);
                    }
                  }
                });
                self2.setValue(values);
              };
              addEvent(item, "mousedown", mousedown);
              addEvent(item, "dragstart", dragStart);
              addEvent(item, "dragenter", dragOver);
              addEvent(item, "dragover", dragOver);
              addEvent(item, "dragleave", dragLeave);
              addEvent(item, "dragend", dragend);
              return item;
            };
          });
          self2.hook("instead", "lock", () => {
            sortable = false;
            return orig_lock.call(self2);
          });
          self2.hook("instead", "unlock", () => {
            sortable = true;
            return orig_unlock.call(self2);
          });
        }
        function dropdown_header(userOptions) {
          const self2 = this;
          const options = Object.assign({
            title: "Untitled",
            headerClass: "dropdown-header",
            titleRowClass: "dropdown-header-title",
            labelClass: "dropdown-header-label",
            closeClass: "dropdown-header-close",
            html: (data) => {
              return '<div class="' + data.headerClass + '"><div class="' + data.titleRowClass + '"><span class="' + data.labelClass + '">' + data.title + '</span><a class="' + data.closeClass + '">&times;</a></div></div>';
            }
          }, userOptions);
          self2.on("initialize", () => {
            var header = getDom(options.html(options));
            var close_link = header.querySelector("." + options.closeClass);
            if (close_link) {
              close_link.addEventListener("click", (evt) => {
                preventDefault(evt, true);
                self2.close();
              });
            }
            self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
          });
        }
        function caret_position() {
          var self2 = this;
          self2.hook("instead", "setCaret", (new_pos) => {
            if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
              new_pos = self2.items.length;
            } else {
              new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
              if (new_pos != self2.caretPos && !self2.isPending) {
                self2.controlChildren().forEach((child, j) => {
                  if (j < new_pos) {
                    self2.control_input.insertAdjacentElement("beforebegin", child);
                  } else {
                    self2.control.appendChild(child);
                  }
                });
              }
            }
            self2.caretPos = new_pos;
          });
          self2.hook("instead", "moveCaret", (direction) => {
            if (!self2.isFocused)
              return;
            const last_active = self2.getLastActive(direction);
            if (last_active) {
              const idx = nodeIndex(last_active);
              self2.setCaret(direction > 0 ? idx + 1 : idx);
              self2.setActiveItem();
              removeClasses(last_active, "last-active");
            } else {
              self2.setCaret(self2.caretPos + direction);
            }
          });
        }
        function dropdown_input() {
          const self2 = this;
          self2.settings.shouldOpen = true;
          self2.hook("before", "setup", () => {
            self2.focus_node = self2.control;
            addClasses(self2.control_input, "dropdown-input");
            const div = getDom('<div class="dropdown-input-wrap">');
            div.append(self2.control_input);
            self2.dropdown.insertBefore(div, self2.dropdown.firstChild);
            const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
            placeholder.placeholder = self2.settings.placeholder || "";
            self2.control.append(placeholder);
          });
          self2.on("initialize", () => {
            self2.control_input.addEventListener("keydown", (evt) => {
              switch (evt.keyCode) {
                case KEY_ESC:
                  if (self2.isOpen) {
                    preventDefault(evt, true);
                    self2.close();
                  }
                  self2.clearActiveItems();
                  return;
                case KEY_TAB:
                  self2.focus_node.tabIndex = -1;
                  break;
              }
              return self2.onKeyDown.call(self2, evt);
            });
            self2.on("blur", () => {
              self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
            });
            self2.on("dropdown_open", () => {
              self2.control_input.focus();
            });
            const orig_onBlur = self2.onBlur;
            self2.hook("instead", "onBlur", (evt) => {
              if (evt && evt.relatedTarget == self2.control_input)
                return;
              return orig_onBlur.call(self2);
            });
            addEvent(self2.control_input, "blur", () => self2.onBlur());
            self2.hook("before", "close", () => {
              if (!self2.isOpen)
                return;
              self2.focus_node.focus({
                preventScroll: true
              });
            });
          });
        }
        function input_autogrow() {
          var self2 = this;
          self2.on("initialize", () => {
            var test_input = document.createElement("span");
            var control = self2.control_input;
            test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
            self2.wrapper.appendChild(test_input);
            var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
            for (const style_name of transfer_styles) {
              test_input.style[style_name] = control.style[style_name];
            }
            var resize = () => {
              test_input.textContent = control.value;
              control.style.width = test_input.clientWidth + "px";
            };
            resize();
            self2.on("update item_add item_remove", resize);
            addEvent(control, "input", resize);
            addEvent(control, "keyup", resize);
            addEvent(control, "blur", resize);
            addEvent(control, "update", resize);
          });
        }
        function no_backspace_delete() {
          var self2 = this;
          var orig_deleteSelection = self2.deleteSelection;
          this.hook("instead", "deleteSelection", (evt) => {
            if (self2.activeItems.length) {
              return orig_deleteSelection.call(self2, evt);
            }
            return false;
          });
        }
        function no_active_items() {
          this.hook("instead", "setActiveItem", () => {
          });
          this.hook("instead", "selectAll", () => {
          });
        }
        function optgroup_columns() {
          var self2 = this;
          var orig_keydown = self2.onKeyDown;
          self2.hook("instead", "onKeyDown", (evt) => {
            var index2, option, options, optgroup;
            if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
              return orig_keydown.call(self2, evt);
            }
            self2.ignoreHover = true;
            optgroup = parentMatch(self2.activeOption, "[data-group]");
            index2 = nodeIndex(self2.activeOption, "[data-selectable]");
            if (!optgroup) {
              return;
            }
            if (evt.keyCode === KEY_LEFT) {
              optgroup = optgroup.previousSibling;
            } else {
              optgroup = optgroup.nextSibling;
            }
            if (!optgroup) {
              return;
            }
            options = optgroup.querySelectorAll("[data-selectable]");
            option = options[Math.min(options.length - 1, index2)];
            if (option) {
              self2.setActiveOption(option);
            }
          });
        }
        function remove_button(userOptions) {
          const options = Object.assign({
            label: "&times;",
            title: "Remove",
            className: "remove",
            append: true
          }, userOptions);
          var self2 = this;
          if (!options.append) {
            return;
          }
          var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape) => {
              var item = getDom(orig_render_item.call(self2, data, escape));
              var close_button = getDom(html);
              item.appendChild(close_button);
              addEvent(close_button, "mousedown", (evt) => {
                preventDefault(evt, true);
              });
              addEvent(close_button, "click", (evt) => {
                if (self2.isLocked)
                  return;
                preventDefault(evt, true);
                if (self2.isLocked)
                  return;
                if (!self2.shouldDelete([item], evt))
                  return;
                self2.removeItem(item);
                self2.refreshOptions(false);
                self2.inputState();
              });
              return item;
            };
          });
        }
        function restore_on_backspace(userOptions) {
          const self2 = this;
          const options = Object.assign({
            text: (option) => {
              return option[self2.settings.labelField];
            }
          }, userOptions);
          self2.on("item_remove", function(value) {
            if (!self2.isFocused) {
              return;
            }
            if (self2.control_input.value.trim() === "") {
              var option = self2.options[value];
              if (option) {
                self2.setTextboxValue(options.text.call(self2, option));
              }
            }
          });
        }
        function virtual_scroll() {
          const self2 = this;
          const orig_canLoad = self2.canLoad;
          const orig_clearActiveOption = self2.clearActiveOption;
          const orig_loadCallback = self2.loadCallback;
          var pagination = {};
          var dropdown_content;
          var loading_more = false;
          var load_more_opt;
          var default_values = [];
          if (!self2.settings.shouldLoadMore) {
            self2.settings.shouldLoadMore = () => {
              const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
              if (scroll_percent > 0.9) {
                return true;
              }
              if (self2.activeOption) {
                var selectable = self2.selectable();
                var index2 = Array.from(selectable).indexOf(self2.activeOption);
                if (index2 >= selectable.length - 2) {
                  return true;
                }
              }
              return false;
            };
          }
          if (!self2.settings.firstUrl) {
            throw "virtual_scroll plugin requires a firstUrl() method";
          }
          self2.settings.sortField = [{
            field: "$order"
          }, {
            field: "$score"
          }];
          const canLoadMore = (query) => {
            if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
              return false;
            }
            if (query in pagination && pagination[query]) {
              return true;
            }
            return false;
          };
          const clearFilter = (option, value) => {
            if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
              return true;
            }
            return false;
          };
          self2.setNextUrl = (value, next_url) => {
            pagination[value] = next_url;
          };
          self2.getUrl = (query) => {
            if (query in pagination) {
              const next_url = pagination[query];
              pagination[query] = false;
              return next_url;
            }
            self2.clearPagination();
            return self2.settings.firstUrl.call(self2, query);
          };
          self2.clearPagination = () => {
            pagination = {};
          };
          self2.hook("instead", "clearActiveOption", () => {
            if (loading_more) {
              return;
            }
            return orig_clearActiveOption.call(self2);
          });
          self2.hook("instead", "canLoad", (query) => {
            if (!(query in pagination)) {
              return orig_canLoad.call(self2, query);
            }
            return canLoadMore(query);
          });
          self2.hook("instead", "loadCallback", (options, optgroups) => {
            if (!loading_more) {
              self2.clearOptions(clearFilter);
            } else if (load_more_opt) {
              const first_option = options[0];
              if (first_option !== void 0) {
                load_more_opt.dataset.value = first_option[self2.settings.valueField];
              }
            }
            orig_loadCallback.call(self2, options, optgroups);
            loading_more = false;
          });
          self2.hook("after", "refreshOptions", () => {
            const query = self2.lastValue;
            var option;
            if (canLoadMore(query)) {
              option = self2.render("loading_more", {
                query
              });
              if (option) {
                option.setAttribute("data-selectable", "");
                load_more_opt = option;
              }
            } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
              option = self2.render("no_more_results", {
                query
              });
            }
            if (option) {
              addClasses(option, self2.settings.optionClass);
              dropdown_content.append(option);
            }
          });
          self2.on("initialize", () => {
            default_values = Object.keys(self2.options);
            dropdown_content = self2.dropdown_content;
            self2.settings.render = Object.assign({}, {
              loading_more: () => {
                return `<div class="loading-more-results">Loading more results ... </div>`;
              },
              no_more_results: () => {
                return `<div class="no-more-results">No more results</div>`;
              }
            }, self2.settings.render);
            dropdown_content.addEventListener("scroll", () => {
              if (!self2.settings.shouldLoadMore.call(self2)) {
                return;
              }
              if (!canLoadMore(self2.lastValue)) {
                return;
              }
              if (loading_more)
                return;
              loading_more = true;
              self2.load.call(self2, self2.lastValue);
            });
          });
        }
        TomSelect5.define("change_listener", change_listener);
        TomSelect5.define("checkbox_options", checkbox_options);
        TomSelect5.define("clear_button", clear_button);
        TomSelect5.define("drag_drop", drag_drop);
        TomSelect5.define("dropdown_header", dropdown_header);
        TomSelect5.define("caret_position", caret_position);
        TomSelect5.define("dropdown_input", dropdown_input);
        TomSelect5.define("input_autogrow", input_autogrow);
        TomSelect5.define("no_backspace_delete", no_backspace_delete);
        TomSelect5.define("no_active_items", no_active_items);
        TomSelect5.define("optgroup_columns", optgroup_columns);
        TomSelect5.define("remove_button", remove_button);
        TomSelect5.define("restore_on_backspace", restore_on_backspace);
        TomSelect5.define("virtual_scroll", virtual_scroll);
        return TomSelect5;
      });
    }
  });

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop() {
                progressTimerId = window2.requestAnimationFrame(loop);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // node_modules/chart.js/dist/chart.js
  var require_chart = __commonJS({
    "node_modules/chart.js/dist/chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory());
      })(exports, function() {
        "use strict";
        function noop2() {
        }
        const uid = function() {
          let id = 0;
          return function() {
            return id++;
          };
        }();
        function isNullOrUndef(value) {
          return value === null || typeof value === "undefined";
        }
        function isArray(value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }
          const type = Object.prototype.toString.call(value);
          if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
            return true;
          }
          return false;
        }
        function isObject2(value) {
          return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
        function finiteOrDefault(value, defaultValue) {
          return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
          return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn, args, thisArg) {
          if (fn && typeof fn.call === "function") {
            return fn.apply(thisArg, args);
          }
        }
        function each(loopable, fn, thisArg, reverse) {
          let i, len, keys;
          if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[i], i);
              }
            }
          } else if (isObject2(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        }
        function _elementsEqual(a0, a1) {
          let i, ilen, v0, v1;
          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }
          for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
            }
          }
          return true;
        }
        function clone$1(source) {
          if (isArray(source)) {
            return source.map(clone$1);
          }
          if (isObject2(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
              target[keys[k]] = clone$1(source[keys[k]]);
            }
            return target;
          }
          return source;
        }
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            merge(tval, sval, options);
          } else {
            target[key] = clone$1(sval);
          }
        }
        function merge(target, source, options) {
          const sources = isArray(source) ? source : [source];
          const ilen = sources.length;
          if (!isObject2(target)) {
            return target;
          }
          options = options || {};
          const merger = options.merger || _merger;
          for (let i = 0; i < ilen; ++i) {
            source = sources[i];
            if (!isObject2(source)) {
              continue;
            }
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
              merger(keys[k], target, source, options);
            }
          }
          return target;
        }
        function mergeIf(target, source) {
          return merge(target, source, { merger: _mergerIf });
        }
        function _mergerIf(key, target, source) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            mergeIf(tval, sval);
          } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone$1(sval);
          }
        }
        function _deprecated(scope, value, previous, current) {
          if (value !== void 0) {
            console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
          }
        }
        const keyResolvers = {
          "": (v) => v,
          x: (o) => o.x,
          y: (o) => o.y
        };
        function resolveObjectKey(obj, key) {
          const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
          return resolver(obj);
        }
        function _getKeyResolver(key) {
          const keys = _splitKey(key);
          return (obj) => {
            for (const k of keys) {
              if (k === "") {
                break;
              }
              obj = obj && obj[k];
            }
            return obj;
          };
        }
        function _splitKey(key) {
          const parts = key.split(".");
          const keys = [];
          let tmp = "";
          for (const part of parts) {
            tmp += part;
            if (tmp.endsWith("\\")) {
              tmp = tmp.slice(0, -1) + ".";
            } else {
              keys.push(tmp);
              tmp = "";
            }
          }
          return keys;
        }
        function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = (value) => typeof value !== "undefined";
        const isFunction2 = (value) => typeof value === "function";
        const setsEqual = (a, b) => {
          if (a.size !== b.size) {
            return false;
          }
          for (const item of a) {
            if (!b.has(item)) {
              return false;
            }
          }
          return true;
        };
        function _isClickEvent(e) {
          return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function niceNum(range2) {
          const roundedRange = Math.round(range2);
          range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
          const niceRange = Math.pow(10, Math.floor(log10(range2)));
          const fraction = range2 / niceRange;
          const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
          return niceFraction * niceRange;
        }
        function _factorize(value) {
          const result = [];
          const sqrt = Math.sqrt(value);
          let i;
          for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
              result.push(i);
              result.push(value / i);
            }
          }
          if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
          }
          result.sort((a, b) => a - b).pop();
          return result;
        }
        function isNumber(n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostEquals(x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        }
        function almostWhole(x, epsilon) {
          const rounded = Math.round(x);
          return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
          let i, ilen, value;
          for (i = 0, ilen = array.length; i < ilen; i++) {
            value = array[i][property];
            if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
            }
          }
        }
        function toRadians(degrees) {
          return degrees * (PI / 180);
        }
        function toDegrees(radians) {
          return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
          if (!isNumberFinite(x)) {
            return;
          }
          let e = 1;
          let p = 0;
          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }
          return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
          const distanceFromXCenter = anglePoint.x - centrePoint.x;
          const distanceFromYCenter = anglePoint.y - centrePoint.y;
          const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * PI) {
            angle += TAU;
          }
          return {
            angle,
            distance: radialDistanceFromCenter
          };
        }
        function distanceBetweenPoints(pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
          return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
          return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
          const a = _normalizeAngle(angle);
          const s = _normalizeAngle(start);
          const e = _normalizeAngle(end);
          const angleToStart = _normalizeAngle(s - a);
          const angleToEnd = _normalizeAngle(e - a);
          const startToAngle = _normalizeAngle(a - s);
          const endToAngle = _normalizeAngle(a - e);
          return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
          return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
          return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _lookup(table, value, cmp) {
          cmp = cmp || ((index3) => table[index3] < value);
          let hi = table.length - 1;
          let lo = 0;
          let mid;
          while (hi - lo > 1) {
            mid = lo + hi >> 1;
            if (cmp(mid)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return { lo, hi };
        }
        const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index3) => table[index3][key] <= value : (index3) => table[index3][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index3) => table[index3][key] >= value);
        function _filterBetween(values, min, max) {
          let start = 0;
          let end = values.length;
          while (start < end && values[start] < min) {
            start++;
          }
          while (end > start && values[end - 1] > max) {
            end--;
          }
          return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach((key) => {
            const method = "_onData" + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                  if (typeof object[method] === "function") {
                    object[method](...args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          const stub = array._chartjs;
          if (!stub) {
            return;
          }
          const listeners = stub.listeners;
          const index3 = listeners.indexOf(listener);
          if (index3 !== -1) {
            listeners.splice(index3, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach((key) => {
            delete array[key];
          });
          delete array._chartjs;
        }
        function _arrayUnique(items) {
          const set2 = /* @__PURE__ */ new Set();
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            set2.add(items[i]);
          }
          if (set2.size === ilen) {
            return items;
          }
          return Array.from(set2);
        }
        function fontString(pixelSize, fontStyle, fontFamily) {
          return fontStyle + " " + pixelSize + "px " + fontFamily;
        }
        const requestAnimFrame = function() {
          if (typeof window === "undefined") {
            return function(callback2) {
              return callback2();
            };
          }
          return window.requestAnimationFrame;
        }();
        function throttled(fn, thisArg, updateFn) {
          const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
          let ticking = false;
          let args = [];
          return function(...rest) {
            args = updateArgs(rest);
            if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, () => {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function debounce(fn, delay) {
          let timeout;
          return function(...args) {
            if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn, delay, args);
            } else {
              fn.apply(this, args);
            }
            return delay;
          };
        }
        const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
          const check = rtl ? "left" : "right";
          return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
          const pointCount = points.length;
          let start = 0;
          let count = pointCount;
          if (meta._sorted) {
            const { iScale, _parsed } = meta;
            const axis = iScale.axis;
            const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
            if (minDefined) {
              start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
            }
            if (maxDefined) {
              count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
            } else {
              count = pointCount - start;
            }
          }
          return { start, count };
        }
        function _scaleRangesChanged(meta) {
          const { xScale, yScale, _scaleRanges } = meta;
          const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max
          };
          if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
          }
          const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
          Object.assign(_scaleRanges, newRanges);
          return changed;
        }
        class Animator {
          constructor() {
            this._request = null;
            this._charts = /* @__PURE__ */ new Map();
            this._running = false;
            this._lastDate = void 0;
          }
          _notify(chart2, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn) => fn({
              chart: chart2,
              initial: anims.initial,
              numSteps,
              currentStep: Math.min(date - anims.start, numSteps)
            }));
          }
          _refresh() {
            if (this._request) {
              return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, () => {
              this._update();
              this._request = null;
              if (this._running) {
                this._refresh();
              }
            });
          }
          _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart2) => {
              if (!anims.running || !anims.items.length) {
                return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw2 = false;
              let item;
              for (; i >= 0; --i) {
                item = items[i];
                if (item._active) {
                  if (item._total > anims.duration) {
                    anims.duration = item._total;
                  }
                  item.tick(date);
                  draw2 = true;
                } else {
                  items[i] = items[items.length - 1];
                  items.pop();
                }
              }
              if (draw2) {
                chart2.draw();
                this._notify(chart2, anims, date, "progress");
              }
              if (!items.length) {
                anims.running = false;
                this._notify(chart2, anims, date, "complete");
                anims.initial = false;
              }
              remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
              this._running = false;
            }
          }
          _getAnims(chart2) {
            const charts = this._charts;
            let anims = charts.get(chart2);
            if (!anims) {
              anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                  complete: [],
                  progress: []
                }
              };
              charts.set(chart2, anims);
            }
            return anims;
          }
          listen(chart2, event, cb) {
            this._getAnims(chart2).listeners[event].push(cb);
          }
          add(chart2, items) {
            if (!items || !items.length) {
              return;
            }
            this._getAnims(chart2).items.push(...items);
          }
          has(chart2) {
            return this._getAnims(chart2).items.length > 0;
          }
          start(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims) {
              return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
            this._refresh();
          }
          running(chart2) {
            if (!this._running) {
              return false;
            }
            const anims = this._charts.get(chart2);
            if (!anims || !anims.running || !anims.items.length) {
              return false;
            }
            return true;
          }
          stop(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
              items[i].cancel();
            }
            anims.items = [];
            this._notify(chart2, anims, Date.now(), "complete");
          }
          remove(chart2) {
            return this._charts.delete(chart2);
          }
        }
        var animator = new Animator();
        function round(v) {
          return v + 0.5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }
        const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
        const hex = [..."0123456789ABCDEF"];
        const h1 = (b) => hex[b & 15];
        const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = (b) => (b & 240) >> 4 === (b & 15);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === "#") {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h, s, v) {
          const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h, w, b) {
          const rgb = hsl2rgbn(h, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d, max) {
          if (r === max) {
            return (g - b) / d + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d + 2;
          }
          return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
          const range2 = 255;
          const r = v.r / range2;
          const g = v.g / range2;
          const b = v.b / range2;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h, s, d;
          if (max !== min) {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = hueValue(r, g, b, d, max);
            h = h * 60 + 0.5;
          }
          return [h | 0, s || 0, l];
        }
        function calln(f, a, b, c) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
          return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
          return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
          return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
          return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === "hwb") {
            v = hwb2rgb(h, p1, p2);
          } else if (m[1] === "hsv") {
            v = hsv2rgb(h, p1, p2);
          } else {
            v = hsl2rgb(h, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a
          };
        }
        function rotate(v, deg) {
          var h = rgb2hsl(v);
          h[0] = hue(h[0] + deg);
          h = hsl2rgb(h);
          v.r = h[0];
          v.g = h[1];
          v.b = h[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map$2 = {
          x: "dark",
          Z: "light",
          Y: "re",
          X: "blu",
          W: "gr",
          V: "medium",
          U: "slate",
          A: "ee",
          T: "ol",
          S: "or",
          B: "ra",
          C: "lateg",
          D: "ights",
          R: "in",
          Q: "turquois",
          E: "hi",
          P: "ro",
          O: "al",
          N: "le",
          M: "de",
          L: "yello",
          F: "en",
          K: "ch",
          G: "arks",
          H: "ea",
          I: "ightg",
          J: "wh"
        };
        const names$1 = {
          OiceXe: "f0f8ff",
          antiquewEte: "faebd7",
          aqua: "ffff",
          aquamarRe: "7fffd4",
          azuY: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "0",
          blanKedOmond: "ffebcd",
          Xe: "ff",
          XeviTet: "8a2be2",
          bPwn: "a52a2a",
          burlywood: "deb887",
          caMtXe: "5f9ea0",
          KartYuse: "7fff00",
          KocTate: "d2691e",
          cSO: "ff7f50",
          cSnflowerXe: "6495ed",
          cSnsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "ffff",
          xXe: "8b",
          xcyan: "8b8b",
          xgTMnPd: "b8860b",
          xWay: "a9a9a9",
          xgYF: "6400",
          xgYy: "a9a9a9",
          xkhaki: "bdb76b",
          xmagFta: "8b008b",
          xTivegYF: "556b2f",
          xSange: "ff8c00",
          xScEd: "9932cc",
          xYd: "8b0000",
          xsOmon: "e9967a",
          xsHgYF: "8fbc8f",
          xUXe: "483d8b",
          xUWay: "2f4f4f",
          xUgYy: "2f4f4f",
          xQe: "ced1",
          xviTet: "9400d3",
          dAppRk: "ff1493",
          dApskyXe: "bfff",
          dimWay: "696969",
          dimgYy: "696969",
          dodgerXe: "1e90ff",
          fiYbrick: "b22222",
          flSOwEte: "fffaf0",
          foYstWAn: "228b22",
          fuKsia: "ff00ff",
          gaRsbSo: "dcdcdc",
          ghostwEte: "f8f8ff",
          gTd: "ffd700",
          gTMnPd: "daa520",
          Way: "808080",
          gYF: "8000",
          gYFLw: "adff2f",
          gYy: "808080",
          honeyMw: "f0fff0",
          hotpRk: "ff69b4",
          RdianYd: "cd5c5c",
          Rdigo: "4b0082",
          ivSy: "fffff0",
          khaki: "f0e68c",
          lavFMr: "e6e6fa",
          lavFMrXsh: "fff0f5",
          lawngYF: "7cfc00",
          NmoncEffon: "fffacd",
          ZXe: "add8e6",
          ZcSO: "f08080",
          Zcyan: "e0ffff",
          ZgTMnPdLw: "fafad2",
          ZWay: "d3d3d3",
          ZgYF: "90ee90",
          ZgYy: "d3d3d3",
          ZpRk: "ffb6c1",
          ZsOmon: "ffa07a",
          ZsHgYF: "20b2aa",
          ZskyXe: "87cefa",
          ZUWay: "778899",
          ZUgYy: "778899",
          ZstAlXe: "b0c4de",
          ZLw: "ffffe0",
          lime: "ff00",
          limegYF: "32cd32",
          lRF: "faf0e6",
          magFta: "ff00ff",
          maPon: "800000",
          VaquamarRe: "66cdaa",
          VXe: "cd",
          VScEd: "ba55d3",
          VpurpN: "9370db",
          VsHgYF: "3cb371",
          VUXe: "7b68ee",
          VsprRggYF: "fa9a",
          VQe: "48d1cc",
          VviTetYd: "c71585",
          midnightXe: "191970",
          mRtcYam: "f5fffa",
          mistyPse: "ffe4e1",
          moccasR: "ffe4b5",
          navajowEte: "ffdead",
          navy: "80",
          Tdlace: "fdf5e6",
          Tive: "808000",
          TivedBb: "6b8e23",
          Sange: "ffa500",
          SangeYd: "ff4500",
          ScEd: "da70d6",
          pOegTMnPd: "eee8aa",
          pOegYF: "98fb98",
          pOeQe: "afeeee",
          pOeviTetYd: "db7093",
          papayawEp: "ffefd5",
          pHKpuff: "ffdab9",
          peru: "cd853f",
          pRk: "ffc0cb",
          plum: "dda0dd",
          powMrXe: "b0e0e6",
          purpN: "800080",
          YbeccapurpN: "663399",
          Yd: "ff0000",
          Psybrown: "bc8f8f",
          PyOXe: "4169e1",
          saddNbPwn: "8b4513",
          sOmon: "fa8072",
          sandybPwn: "f4a460",
          sHgYF: "2e8b57",
          sHshell: "fff5ee",
          siFna: "a0522d",
          silver: "c0c0c0",
          skyXe: "87ceeb",
          UXe: "6a5acd",
          UWay: "708090",
          UgYy: "708090",
          snow: "fffafa",
          sprRggYF: "ff7f",
          stAlXe: "4682b4",
          tan: "d2b48c",
          teO: "8080",
          tEstN: "d8bfd8",
          tomato: "ff6347",
          Qe: "40e0d0",
          viTet: "ee82ee",
          JHt: "f5deb3",
          wEte: "ffffff",
          wEtesmoke: "f5f5f5",
          Lw: "ffff00",
          LwgYF: "9acd32"
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map$2);
          let i, j, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
              k = tkeys[j];
              nk = nk.replace(k, map$2[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
          }
          return unpacked;
        }
        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a.length === 4 ? a[3] : 255
          };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r,
            g,
            b,
            a
          };
        }
        function rgbString(v) {
          return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
        const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate$1(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a)
          };
        }
        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone2(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === "r") {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === "object") {
              v = fromObject(input);
            } else if (type === "string") {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone2(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
          }
          mix(color2, weight) {
            if (color2) {
              const c1 = this.rgb;
              const c2 = color2.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color2, t) {
            if (color2) {
              this._rgb = interpolate$1(this._rgb, color2._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val2 = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val2;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }
        function index_esm(input) {
          return new Color(input);
        }
        function isPatternOrGradient(value) {
          if (value && typeof value === "object") {
            const type = value.toString();
            return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
          }
          return false;
        }
        function color(value) {
          return isPatternOrGradient(value) ? value : index_esm(value);
        }
        function getHoverColor(value) {
          return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
          if (!key) {
            return node;
          }
          const keys = key.split(".");
          for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
          }
          return node;
        }
        function set(root, scope, values) {
          if (typeof scope === "string") {
            return merge(getScope$1(root, scope), values);
          }
          return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
          constructor(_descriptors2) {
            this.animation = void 0;
            this.backgroundColor = "rgba(0,0,0,0.1)";
            this.borderColor = "rgba(0,0,0,0.1)";
            this.color = "#666";
            this.datasets = {};
            this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
              "mousemove",
              "mouseout",
              "click",
              "touchstart",
              "touchmove"
            ];
            this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: "normal",
              lineHeight: 1.2,
              weight: null
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = "x";
            this.interaction = {
              mode: "nearest",
              intersect: true,
              includeInvisible: false
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = void 0;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors2);
          }
          set(scope, values) {
            return set(this, scope, values);
          }
          get(scope) {
            return getScope$1(this, scope);
          }
          describe(scope, values) {
            return set(descriptors, scope, values);
          }
          override(scope, values) {
            return set(overrides, scope, values);
          }
          route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = "_" + name;
            Object.defineProperties(scopeObject, {
              [privateName]: {
                value: scopeObject[name],
                writable: true
              },
              [name]: {
                enumerable: true,
                get() {
                  const local = this[privateName];
                  const target = targetScopeObject[targetName];
                  if (isObject2(local)) {
                    return Object.assign({}, target, local);
                  }
                  return valueOrDefault(local, target);
                },
                set(value) {
                  this[privateName] = value;
                }
              }
            });
          }
        }
        var defaults = new Defaults({
          _scriptable: (name) => !name.startsWith("on"),
          _indexable: (name) => name !== "events",
          hover: {
            _fallback: "interaction"
          },
          interaction: {
            _scriptable: false,
            _indexable: false
          }
        });
        function _isDomSupported() {
          return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
          let parent = domNode.parentNode;
          if (parent && parent.toString() === "[object ShadowRoot]") {
            parent = parent.host;
          }
          return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
          let valueInPixels;
          if (typeof styleValue === "string") {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf("%") !== -1) {
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        const getComputedStyle2 = (element) => window.getComputedStyle(element, null);
        function getStyle(el, property) {
          return getComputedStyle2(el).getPropertyValue(property);
        }
        const positions = ["top", "right", "bottom", "left"];
        function getPositionedStyle(styles, style, suffix) {
          const result = {};
          suffix = suffix ? "-" + suffix : "";
          for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
          }
          result.width = result.left + result.right;
          result.height = result.top + result.bottom;
          return result;
        }
        const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
          const touches = e.touches;
          const source = touches && touches.length ? touches[0] : e;
          const { offsetX, offsetY } = source;
          let box = false;
          let x, y;
          if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
          } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
          }
          return { x, y, box };
        }
        function getRelativePosition(evt, chart2) {
          if ("native" in evt) {
            return evt;
          }
          const { canvas, currentDevicePixelRatio } = chart2;
          const style = getComputedStyle2(canvas);
          const borderBox = style.boxSizing === "border-box";
          const paddings = getPositionedStyle(style, "padding");
          const borders = getPositionedStyle(style, "border", "width");
          const { x, y, box } = getCanvasPosition(evt, canvas);
          const xOffset = paddings.left + (box && borders.left);
          const yOffset = paddings.top + (box && borders.top);
          let { width, height } = chart2;
          if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          return {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
          };
        }
        function getContainerSize(canvas, width, height) {
          let maxWidth, maxHeight;
          if (width === void 0 || height === void 0) {
            const container = _getParentNode(canvas);
            if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
            } else {
              const rect = container.getBoundingClientRect();
              const containerStyle = getComputedStyle2(container);
              const containerBorder = getPositionedStyle(containerStyle, "border", "width");
              const containerPadding = getPositionedStyle(containerStyle, "padding");
              width = rect.width - containerPadding.width - containerBorder.width;
              height = rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
              maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
            }
          }
          return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY
          };
        }
        const round1 = (v) => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
          const style = getComputedStyle2(canvas);
          const margins = getPositionedStyle(style, "margin");
          const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
          const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
          const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
          let { width, height } = containerSize;
          if (style.boxSizing === "content-box") {
            const borders = getPositionedStyle(style, "border", "width");
            const paddings = getPositionedStyle(style, "padding");
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          width = Math.max(0, width - margins.width);
          height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
          width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
          height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
          if (width && !height) {
            height = round1(width / 2);
          }
          return {
            width,
            height
          };
        }
        function retinaScale(chart2, forceRatio, forceStyle) {
          const pixelRatio = forceRatio || 1;
          const deviceHeight = Math.floor(chart2.height * pixelRatio);
          const deviceWidth = Math.floor(chart2.width * pixelRatio);
          chart2.height = deviceHeight / pixelRatio;
          chart2.width = deviceWidth / pixelRatio;
          const canvas = chart2.canvas;
          if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
            canvas.style.height = `${chart2.height}px`;
            canvas.style.width = `${chart2.width}px`;
          }
          if (chart2.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
            chart2.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart2.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
          }
          return false;
        }
        const supportsEventListenerOptions = function() {
          let passiveSupported = false;
          try {
            const options = {
              get passive() {
                passiveSupported = true;
                return false;
              }
            };
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
          } catch (e) {
          }
          return passiveSupported;
        }();
        function readUsedSize(element, property) {
          const value = getStyle(element, property);
          const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? +matches[1] : void 0;
        }
        function toFontString(font) {
          if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc, longest, string) {
          let textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          let data = cache.data = cache.data || {};
          let gc = cache.garbageCollect = cache.garbageCollect || [];
          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.save();
          ctx.font = font;
          let longest = 0;
          const ilen = arrayOfThings.length;
          let i, j, jlen, thing, nestedThing;
          for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
              longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray(thing)) {
              for (j = 0, jlen = thing.length; j < jlen; j++) {
                nestedThing = thing[j];
                if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                  longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
              }
            }
          }
          ctx.restore();
          const gcLen = gc.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
              delete data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
          return longest;
        }
        function _alignPixel(chart2, pixel, width) {
          const devicePixelRatio = chart2.currentDevicePixelRatio;
          const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
          return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
          ctx = ctx || canvas.getContext("2d");
          ctx.save();
          ctx.resetTransform();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
          drawPointLegend(ctx, options, x, y, null);
        }
        function drawPointLegend(ctx, options, x, y, w) {
          let type, xOffset, yOffset, size, cornerRadius, width;
          const style = options.pointStyle;
          const rotation = options.rotation;
          const radius = options.radius;
          let rad = (rotation || 0) * RAD_PER_DEG;
          if (style && typeof style === "object") {
            type = style.toString();
            if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rad);
              ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
              ctx.restore();
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          ctx.beginPath();
          switch (style) {
            default:
              if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
              } else {
                ctx.arc(x, y, radius, 0, TAU);
              }
              ctx.closePath();
              break;
            case "triangle":
              ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;
            case "rectRounded":
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;
            case "rect":
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            case "rectRot":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + yOffset, y - xOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              ctx.closePath();
              break;
            case "crossRot":
              rad += QUARTER_PI;
            case "cross":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "star":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              rad += QUARTER_PI;
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "line":
              xOffset = w ? w / 2 : Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;
            case "dash":
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
              break;
          }
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        function _isPointInArea(point, area, margin) {
          margin = margin || 0.5;
          return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
          ctx.clip();
        }
        function unclipArea(ctx) {
          ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          if (mode === "middle") {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
          } else if (mode === "after" !== !!flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function renderText(ctx, text, x, y, font, opts = {}) {
          const lines = isArray(text) ? text : [text];
          const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
          let i, line;
          ctx.save();
          ctx.font = font.string;
          setRenderOpts(ctx, opts);
          for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (stroke) {
              if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += font.lineHeight;
          }
          ctx.restore();
        }
        function setRenderOpts(ctx, opts) {
          if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
          }
          if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
          }
          if (opts.color) {
            ctx.fillStyle = opts.color;
          }
          if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
          }
          if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
          }
        }
        function decorateText(ctx, x, y, line, opts) {
          if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
        }
        function addRoundedRectPath(ctx, rect) {
          const { x, y, w, h, radius } = rect;
          ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
          ctx.lineTo(x, y + h - radius.bottomLeft);
          ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
          ctx.lineTo(x + w - radius.bottomRight, y + h);
          ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
          ctx.lineTo(x + w, y + radius.topRight);
          ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
          ctx.lineTo(x + radius.topLeft, y);
        }
        function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
          if (!defined(fallback)) {
            fallback = _resolve("_fallback", scopes);
          }
          const cache = {
            [Symbol.toStringTag]: "Object",
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete target._keys;
              delete scopes[0][prop];
              return true;
            },
            get(target, prop) {
              return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
            },
            getOwnPropertyDescriptor(target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(scopes[0]);
            },
            has(target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
            },
            ownKeys(target) {
              return getKeysFromAllScopes(target);
            },
            set(target, prop, value) {
              const storage = target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value;
              delete target._keys;
              return true;
            }
          });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
          const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: /* @__PURE__ */ new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete proxy[prop];
              return true;
            },
            get(target, prop, receiver) {
              return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
            },
            getOwnPropertyDescriptor(target, prop) {
              return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(proxy);
            },
            has(target, prop) {
              return Reflect.has(proxy, prop);
            },
            ownKeys() {
              return Reflect.ownKeys(proxy);
            },
            set(target, prop, value) {
              proxy[prop] = value;
              delete target[prop];
              return true;
            }
          });
        }
        function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
          const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
          return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
            isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
          };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve2) {
          if (Object.prototype.hasOwnProperty.call(target, prop)) {
            return target[prop];
          }
          const value = resolve2();
          target[prop] = value;
          return value;
        }
        function _resolveWithContext(target, prop, receiver) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          let value = _proxy[prop];
          if (isFunction2(value) && descriptors2.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
          }
          if (isArray(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors2.isIndexable);
          }
          if (needsSubResolver(prop, value)) {
            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
          }
          return value;
        }
        function _resolveScriptable(prop, value, target, receiver) {
          const { _proxy, _context, _subProxy, _stack } = target;
          if (_stack.has(prop)) {
            throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
          }
          _stack.add(prop);
          value = value(_context, _subProxy || receiver);
          _stack.delete(prop);
          if (needsSubResolver(prop, value)) {
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
          }
          return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          if (defined(_context.index) && isIndexable(prop)) {
            value = value[_context.index % value.length];
          } else if (isObject2(value[0])) {
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
            }
          }
          return value;
        }
        function resolveFallback(fallback, prop, value) {
          return isFunction2(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set2, parentScopes, key, parentFallback, value) {
          for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
              set2.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
                return fallback;
              }
            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
              return null;
            }
          }
          return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
          const rootScopes = resolver._rootScopes;
          const fallback = resolveFallback(resolver._fallback, prop, value);
          const allScopes = [...parentScopes, ...rootScopes];
          const set2 = /* @__PURE__ */ new Set();
          set2.add(value);
          let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
          if (key === null) {
            return false;
          }
          if (defined(fallback) && fallback !== prop) {
            key = addScopesFromKey(set2, allScopes, fallback, key, value);
            if (key === null) {
              return false;
            }
          }
          return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
        }
        function addScopesFromKey(set2, allScopes, key, fallback, item) {
          while (key) {
            key = addScopes(set2, allScopes, key, fallback, item);
          }
          return key;
        }
        function subGetTarget(resolver, prop, value) {
          const parent = resolver._getTarget();
          if (!(prop in parent)) {
            parent[prop] = {};
          }
          const target = parent[prop];
          if (isArray(target) && isObject2(value)) {
            return value;
          }
          return target;
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
          let value;
          for (const prefix of prefixes) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (defined(value)) {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
          }
        }
        function _resolve(key, scopes) {
          for (const scope of scopes) {
            if (!scope) {
              continue;
            }
            const value = scope[key];
            if (defined(value)) {
              return value;
            }
          }
        }
        function getKeysFromAllScopes(target) {
          let keys = target._keys;
          if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
          }
          return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
          const set2 = /* @__PURE__ */ new Set();
          for (const scope of scopes) {
            for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
              set2.add(key);
            }
          }
          return Array.from(set2);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
          const { iScale } = meta;
          const { key = "r" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index3, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index3 = i + start;
            item = data[index3];
            parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index3)
            };
          }
          return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
          const previous = firstPoint.skip ? middlePoint : firstPoint;
          const current = middlePoint;
          const next = afterPoint.skip ? middlePoint : afterPoint;
          const d01 = distanceBetweenPoints(current, previous);
          const d12 = distanceBetweenPoints(next, current);
          let s01 = d01 / (d01 + d12);
          let s12 = d12 / (d01 + d12);
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          const fa = t * s01;
          const fb = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
            }
          };
        }
        function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
              continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
          }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          let delta, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
          }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          const deltaK = Array(pointsLen).fill(0);
          const mK = Array(pointsLen);
          let i, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            if (pointAfter) {
              const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
              deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
            }
            mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
          }
          monotoneAdjust(points, deltaK, mK);
          monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
          let i, ilen, point, inArea, inAreaPrev;
          let inAreaNext = _isPointInArea(points[0], area);
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
              continue;
            }
            point = points[i];
            if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
          }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
          let i, ilen, point, controlPoints;
          if (options.spanGaps) {
            points = points.filter((pt) => !pt.skip);
          }
          if (options.cubicInterpolationMode === "monotone") {
            splineCurveMonotone(points, indexAxis);
          } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
            }
          }
          if (options.capBezierPoints) {
            capBezierPoints(points, area);
          }
        }
        const atEdge = (t) => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
          easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
          easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
          easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
          easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
          easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
              return m * t * t;
            }
            if (t < 2 / d) {
              return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
              return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
          },
          easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
        };
        function _pointInLine(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
          };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
          };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
          const cp1 = { x: p1.cp2x, y: p1.cp2y };
          const cp2 = { x: p2.cp1x, y: p2.cp1y };
          const a = _pointInLine(p1, cp1, t);
          const b = _pointInLine(cp1, cp2, t);
          const c = _pointInLine(cp2, p2, t);
          const d = _pointInLine(a, b, t);
          const e = _pointInLine(b, c, t);
          return _pointInLine(d, e, t);
        }
        const intlCache = /* @__PURE__ */ new Map();
        function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
          }
          return formatter;
        }
        function formatNumber(num, locale, options) {
          return getNumberFormat(locale, options).format(num);
        }
        const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        function toLineHeight(value, size) {
          const matches = ("" + value).match(LINE_HEIGHT);
          if (!matches || matches[1] === "normal") {
            return size * 1.2;
          }
          value = +matches[2];
          switch (matches[3]) {
            case "px":
              return value;
            case "%":
              value /= 100;
              break;
          }
          return size * value;
        }
        const numberOrZero = (v) => +v || 0;
        function _readValueToProps(value, props) {
          const ret = {};
          const objProps = isObject2(props);
          const keys = objProps ? Object.keys(props) : props;
          const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
          for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
          }
          return ret;
        }
        function toTRBL(value) {
          return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
        }
        function toTRBLCorners(value) {
          return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
        }
        function toPadding(value) {
          const obj = toTRBL(value);
          obj.width = obj.left + obj.right;
          obj.height = obj.top + obj.bottom;
          return obj;
        }
        function toFont(options, fallback) {
          options = options || {};
          fallback = fallback || defaults.font;
          let size = valueOrDefault(options.size, fallback.size);
          if (typeof size === "string") {
            size = parseInt(size, 10);
          }
          let style = valueOrDefault(options.style, fallback.style);
          if (style && !("" + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = "";
          }
          const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ""
          };
          font.string = toFontString(font);
          return font;
        }
        function resolve(inputs, context, index3, info) {
          let cacheable = true;
          let i, ilen, value;
          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === void 0) {
              continue;
            }
            if (context !== void 0 && typeof value === "function") {
              value = value(context);
              cacheable = false;
            }
            if (index3 !== void 0 && isArray(value)) {
              value = value[index3 % value.length];
              cacheable = false;
            }
            if (value !== void 0) {
              if (info && !cacheable) {
                info.cacheable = false;
              }
              return value;
            }
          }
        }
        function _addGrace(minmax, grace, beginAtZero) {
          const { min, max } = minmax;
          const change = toDimension(grace, (max - min) / 2);
          const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
          return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change)
          };
        }
        function createContext(parentContext, context) {
          return Object.assign(Object.create(parentContext), context);
        }
        const getRightToLeftAdapter = function(rectX, width) {
          return {
            x(x) {
              return rectX + rectX + width - x;
            },
            setWidth(w) {
              width = w;
            },
            textAlign(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus(x, value) {
              return x - value;
            },
            leftForLtr(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        const getLeftToRightAdapter = function() {
          return {
            x(x) {
              return x;
            },
            setWidth(w) {
            },
            textAlign(align) {
              return align;
            },
            xPlus(x, value) {
              return x + value;
            },
            leftForLtr(x, _itemWidth) {
              return x;
            }
          };
        };
        function getRtlAdapter(rtl, rectX, width) {
          return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
          let style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        }
        function restoreTextDirection(ctx, original) {
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        }
        function propertyFn(property) {
          if (property === "angle") {
            return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle
            };
          }
          return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x
          };
        }
        function normalizeSegment({ start, end, count, loop, style }) {
          return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style
          };
        }
        function getSegment(segment, points, bounds) {
          const { property, start: startBound, end: endBound } = bounds;
          const { between, normalize } = propertyFn(property);
          const count = points.length;
          let { start, end, loop } = segment;
          let i, ilen;
          if (loop) {
            start += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
              if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
              }
              start--;
              end--;
            }
            start %= count;
            end %= count;
          }
          if (end < start) {
            end += count;
          }
          return { start, end, loop, style: segment.style };
        }
        function _boundSegment(segment, points, bounds) {
          if (!bounds) {
            return [segment];
          }
          const { property, start: startBound, end: endBound } = bounds;
          const count = points.length;
          const { compare, between, normalize } = propertyFn(property);
          const { start, end, loop, style } = getSegment(segment, points, bounds);
          const result = [];
          let inside = false;
          let subStart = null;
          let value, point, prevValue;
          const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
          const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
          const shouldStart = () => inside || startIsBefore();
          const shouldStop = () => !inside || endIsBefore();
          for (let i = start, prev = start; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
              continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
              continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
              result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
              subStart = null;
            }
            prev = i;
            prevValue = value;
          }
          if (subStart !== null) {
            result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
          }
          return result;
        }
        function _boundSegments(line, bounds) {
          const result = [];
          const segments = line.segments;
          for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
              result.push(...sub);
            }
          }
          return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
          let start = 0;
          let end = count - 1;
          if (loop && !spanGaps) {
            while (start < count && !points[start].skip) {
              start++;
            }
          }
          while (start < count && points[start].skip) {
            start++;
          }
          start %= count;
          if (loop) {
            end += start;
          }
          while (end > start && points[end % count].skip) {
            end--;
          }
          end %= count;
          return { start, end };
        }
        function solidSegments(points, start, max, loop) {
          const count = points.length;
          const result = [];
          let last = start;
          let prev = points[start];
          let end;
          for (end = start + 1; end <= max; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
              if (!prev.skip) {
                loop = false;
                result.push({ start: start % count, end: (end - 1) % count, loop });
                start = last = cur.stop ? end : null;
              }
            } else {
              last = end;
              if (prev.skip) {
                start = end;
              }
            }
            prev = cur;
          }
          if (last !== null) {
            result.push({ start: start % count, end: last % count, loop });
          }
          return result;
        }
        function _computeSegments(line, segmentOptions) {
          const points = line.points;
          const spanGaps = line.options.spanGaps;
          const count = points.length;
          if (!count) {
            return [];
          }
          const loop = !!line._loop;
          const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
          if (spanGaps === true) {
            return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
          }
          const max = end < start ? end + count : end;
          const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
          return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
          if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
          }
          return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
          const chartContext = line._chart.getContext();
          const baseStyle = readStyle(line.options);
          const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
          const count = points.length;
          const result = [];
          let prevStyle = baseStyle;
          let start = segments[0].start;
          let i = start;
          function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
              return;
            }
            s += count;
            while (points[s % count].skip) {
              s -= dir;
            }
            while (points[e % count].skip) {
              e += dir;
            }
            if (s % count !== e % count) {
              result.push({ start: s % count, end: e % count, loop: l, style: st });
              prevStyle = st;
              start = e % count;
            }
          }
          for (const segment of segments) {
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for (i = start + 1; i <= segment.end; i++) {
              const pt = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
              })));
              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt;
              prevStyle = style;
            }
            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
          return result;
        }
        function readStyle(options) {
          return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
          };
        }
        function styleChanged(style, prevStyle) {
          return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
        }
        var helpers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          easingEffects: effects,
          isPatternOrGradient,
          color,
          getHoverColor,
          noop: noop2,
          uid,
          isNullOrUndef,
          isArray,
          isObject: isObject2,
          isFinite: isNumberFinite,
          finiteOrDefault,
          valueOrDefault,
          toPercentage,
          toDimension,
          callback,
          each,
          _elementsEqual,
          clone: clone$1,
          _merger,
          merge,
          mergeIf,
          _mergerIf,
          _deprecated,
          resolveObjectKey,
          _splitKey,
          _capitalize,
          defined,
          isFunction: isFunction2,
          setsEqual,
          _isClickEvent,
          toFontString,
          _measureText,
          _longestText,
          _alignPixel,
          clearCanvas,
          drawPoint,
          drawPointLegend,
          _isPointInArea,
          clipArea,
          unclipArea,
          _steppedLineTo,
          _bezierCurveTo,
          renderText,
          addRoundedRectPath,
          _lookup,
          _lookupByKey,
          _rlookupByKey,
          _filterBetween,
          listenArrayEvents,
          unlistenArrayEvents,
          _arrayUnique,
          _createResolver,
          _attachContext,
          _descriptors,
          _parseObjectDataRadialScale,
          splineCurve,
          splineCurveMonotone,
          _updateBezierControlPoints,
          _isDomSupported,
          _getParentNode,
          getStyle,
          getRelativePosition,
          getMaximumSize,
          retinaScale,
          supportsEventListenerOptions,
          readUsedSize,
          fontString,
          requestAnimFrame,
          throttled,
          debounce,
          _toLeftRightCenter,
          _alignStartEnd,
          _textX,
          _getStartAndCountOfVisiblePoints,
          _scaleRangesChanged,
          _pointInLine,
          _steppedInterpolation,
          _bezierInterpolation,
          formatNumber,
          toLineHeight,
          _readValueToProps,
          toTRBL,
          toTRBLCorners,
          toPadding,
          toFont,
          resolve,
          _addGrace,
          createContext,
          PI,
          TAU,
          PITAU,
          INFINITY,
          RAD_PER_DEG,
          HALF_PI,
          QUARTER_PI,
          TWO_THIRDS_PI,
          log10,
          sign,
          niceNum,
          _factorize,
          isNumber,
          almostEquals,
          almostWhole,
          _setMinAndMaxByKey,
          toRadians,
          toDegrees,
          _decimalPlaces,
          getAngleFromPoint,
          distanceBetweenPoints,
          _angleDiff,
          _normalizeAngle,
          _angleBetween,
          _limitValue,
          _int16Range,
          _isBetween,
          getRtlAdapter,
          overrideTextDirection,
          restoreTextDirection,
          _boundSegment,
          _boundSegments,
          _computeSegments
        });
        function binarySearch(metaset, axis, value, intersect) {
          const { controller, data, _sorted } = metaset;
          const iScale = controller._cachedMeta.iScale;
          if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) {
              return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
              const el = data[0];
              const range2 = typeof el.getRange === "function" && el.getRange(axis);
              if (range2) {
                const start = lookupMethod(data, axis, value - range2);
                const end = lookupMethod(data, axis, value + range2);
                return { lo: start.lo, hi: end.hi };
              }
            }
          }
          return { lo: 0, hi: data.length - 1 };
        }
        function evaluateInteractionItems(chart2, axis, position, handler, intersect) {
          const metasets = chart2.getSortedVisibleDatasetMetas();
          const value = position[axis];
          for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index: index3, data } = metasets[i];
            const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
            for (let j = lo; j <= hi; ++j) {
              const element = data[j];
              if (!element.skip) {
                handler(element, index3, j);
              }
            }
          }
        }
        function getDistanceMetricForAxis(axis) {
          const useX = axis.indexOf("x") !== -1;
          const useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) {
          const items = [];
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return items;
          }
          const evaluationFunc = function(element, datasetIndex, index3) {
            if (!includeInvisible && !_isPointInArea(element, chart2.chartArea, 0)) {
              return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({ element, datasetIndex, index: index3 });
            }
          };
          evaluateInteractionItems(chart2, axis, position, evaluationFunc, true);
          return items;
        }
        function getNearestRadialItems(chart2, position, axis, useFinalPosition) {
          let items = [];
          function evaluationFunc(element, datasetIndex, index3) {
            const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
            const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
            if (_angleBetween(angle, startAngle, endAngle)) {
              items.push({ element, datasetIndex, index: index3 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          let items = [];
          const distanceMetric = getDistanceMetricForAxis(axis);
          let minDistance = Number.POSITIVE_INFINITY;
          function evaluationFunc(element, datasetIndex, index3) {
            const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
            if (intersect && !inRange2) {
              return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea = !!includeInvisible || chart2.isPointInArea(center);
            if (!pointInArea && !inRange2) {
              return;
            }
            const distance2 = distanceMetric(position, center);
            if (distance2 < minDistance) {
              items = [{ element, datasetIndex, index: index3 }];
              minDistance = distance2;
            } else if (distance2 === minDistance) {
              items.push({ element, datasetIndex, index: index3 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return [];
          }
          return axis === "r" && !intersect ? getNearestRadialItems(chart2, position, axis, useFinalPosition) : getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart2, position, axis, intersect, useFinalPosition) {
          const items = [];
          const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
          let intersectsItem = false;
          evaluateInteractionItems(chart2, axis, position, (element, datasetIndex, index3) => {
            if (element[rangeMethod](position[axis], useFinalPosition)) {
              items.push({ element, datasetIndex, index: index3 });
              intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
            }
          });
          if (intersect && !intersectsItem) {
            return [];
          }
          return items;
        }
        var Interaction = {
          evaluateInteractionItems,
          modes: {
            index(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "x";
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              const elements2 = [];
              if (!items.length) {
                return [];
              }
              chart2.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index3 = items[0].index;
                const element = meta.data[index3];
                if (element && !element.skip) {
                  elements2.push({ element, datasetIndex: meta.index, index: index3 });
                }
              });
              return elements2;
            },
            dataset(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart2.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i = 0; i < data.length; ++i) {
                  items.push({ element: data[i], datasetIndex, index: i });
                }
              }
              return items;
            },
            point(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible);
            },
            nearest(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(chart2, position, axis, options.intersect, useFinalPosition, includeInvisible);
            },
            x(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "x", options.intersect, useFinalPosition);
            },
            y(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "y", options.intersect, useFinalPosition);
            }
          }
        };
        const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
        function filterByPosition(array, position) {
          return array.filter((v) => v.pos === position);
        }
        function filterDynamicPositionByAxis(array, axis) {
          return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
        }
        function sortByWeight(array, reverse) {
          return array.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          const layoutBoxes = [];
          let i, ilen, box, pos, stack, stackWeight;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({ position: pos, options: { stack, stackWeight = 1 } } = box);
            layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight
            });
          }
          return layoutBoxes;
        }
        function buildStacks(layouts2) {
          const stacks = {};
          for (const wrap of layouts2) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
            }
            const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
            _stack.count++;
            _stack.weight += stackWeight;
          }
          return stacks;
        }
        function setLayoutDims(layouts2, params) {
          const stacks = buildStacks(layouts2);
          const { vBoxMaxWidth, hBoxMaxHeight } = params;
          let i, ilen, layout;
          for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
            layout = layouts2[i];
            const { fullSize } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
              layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
            } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
            }
          }
          return stacks;
        }
        function buildLayoutBoxes(boxes) {
          const layoutBoxes = wrapBoxes(boxes);
          const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
          const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
          const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
          return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
          maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
          maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
          maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
          maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
          const { pos, box } = layout;
          const maxPadding = chartArea.maxPadding;
          if (!isObject2(pos)) {
            if (layout.size) {
              chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || { size: 0, count: 1 };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
          }
          if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
          }
          const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
          const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
          const widthChanged = newWidth !== chartArea.w;
          const heightChanged = newHeight !== chartArea.h;
          chartArea.w = newWidth;
          chartArea.h = newHeight;
          return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
        }
        function handleMaxPadding(chartArea) {
          const maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          const maxPadding = chartArea.maxPadding;
          function marginForPositions(positions2) {
            const margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions2.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
          const refitBoxes = [];
          let i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const { same, other } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
              refitBoxes.push(layout);
            }
          }
          return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
          box.top = top;
          box.left = left;
          box.right = left + width;
          box.bottom = top + height;
          box.width = width;
          box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
          const userPadding = params.padding;
          let { x, y } = chartArea;
          for (const layout of boxes) {
            const box = layout.box;
            const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (defined(stack.start)) {
                y = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
              } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
              }
              stack.start = y;
              stack.placed += width;
              y = box.bottom;
            } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (defined(stack.start)) {
                x = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
              } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        defaults.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
        var layouts = {
          addBox(chart2, item) {
            if (!chart2.boxes) {
              chart2.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }];
            };
            chart2.boxes.push(item);
          },
          removeBox(chart2, layoutItem) {
            const index3 = chart2.boxes ? chart2.boxes.indexOf(layoutItem) : -1;
            if (index3 !== -1) {
              chart2.boxes.splice(index3, 1);
            }
          },
          configure(chart2, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
          },
          update(chart2, width, height, minPadding) {
            if (!chart2) {
              return;
            }
            const padding = toPadding(chart2.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart2.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart2.boxes, (box) => {
              if (typeof box.beforeLayout === "function") {
                box.beforeLayout();
              }
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
            const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
              maxPadding,
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart2.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w
            };
            each(boxes.chartArea, (layout) => {
              const box = layout.box;
              Object.assign(box, chart2.chartArea);
              box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
            });
          }
        };
        class BasePlatform {
          acquireContext(canvas, aspectRatio) {
          }
          releaseContext(context) {
            return false;
          }
          addEventListener(chart2, type, listener) {
          }
          removeEventListener(chart2, type, listener) {
          }
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
              width,
              height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            };
          }
          isAttached(canvas) {
            return true;
          }
          updateConfig(config) {
          }
        }
        class BasicPlatform extends BasePlatform {
          acquireContext(item) {
            return item && item.getContext && item.getContext("2d") || null;
          }
          updateConfig(config) {
            config.options.animation = false;
          }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        const isNullOrEmpty = (value) => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
          const style = canvas.style;
          const renderHeight = canvas.getAttribute("height");
          const renderWidth = canvas.getAttribute("width");
          canvas[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          style.boxSizing = style.boxSizing || "border-box";
          if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, "width");
            if (displayWidth !== void 0) {
              canvas.width = displayWidth;
            }
          }
          if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === "") {
              canvas.height = canvas.width / (aspectRatio || 2);
            } else {
              const displayHeight = readUsedSize(canvas, "height");
              if (displayHeight !== void 0) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart2, type, listener) {
          chart2.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event, chart2) {
          const type = EVENT_TYPES[event.type] || event.type;
          const { x, y } = getRelativePosition(event, chart2);
          return {
            type,
            chart: chart2,
            native: event,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function nodeListContains(nodeList, canvas) {
          for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
              return true;
            }
          }
        }
        function createAttachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        function createDetachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        const drpListeningCharts = /* @__PURE__ */ new Map();
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
          const dpr = window.devicePixelRatio;
          if (dpr === oldDevicePixelRatio) {
            return;
          }
          oldDevicePixelRatio = dpr;
          drpListeningCharts.forEach((resize, chart2) => {
            if (chart2.currentDevicePixelRatio !== dpr) {
              resize();
            }
          });
        }
        function listenDevicePixelRatioChanges(chart2, resize) {
          if (!drpListeningCharts.size) {
            window.addEventListener("resize", onWindowResize);
          }
          drpListeningCharts.set(chart2, resize);
        }
        function unlistenDevicePixelRatioChanges(chart2) {
          drpListeningCharts.delete(chart2);
          if (!drpListeningCharts.size) {
            window.removeEventListener("resize", onWindowResize);
          }
        }
        function createResizeObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const container = canvas && _getParentNode(canvas);
          if (!container) {
            return;
          }
          const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
              listener();
            }
          }, window);
          const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
              return;
            }
            resize(width, height);
          });
          observer.observe(container);
          listenDevicePixelRatioChanges(chart2, resize);
          return observer;
        }
        function releaseObserver(chart2, type, observer) {
          if (observer) {
            observer.disconnect();
          }
          if (type === "resize") {
            unlistenDevicePixelRatioChanges(chart2);
          }
        }
        function createProxyAndListen(chart2, type, listener) {
          const canvas = chart2.canvas;
          const proxy = throttled((event) => {
            if (chart2.ctx !== null) {
              listener(fromNativeEvent(event, chart2));
            }
          }, chart2, (args) => {
            const event = args[0];
            return [event, event.offsetX, event.offsetY];
          });
          addListener(canvas, type, proxy);
          return proxy;
        }
        class DomPlatform extends BasePlatform {
          acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext("2d");
            if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
            }
            return null;
          }
          releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
              return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ["height", "width"].forEach((prop) => {
              const value = initial[prop];
              if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
          }
          addEventListener(chart2, type, listener) {
            this.removeEventListener(chart2, type);
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart2, type, listener);
          }
          removeEventListener(chart2, type) {
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
              return;
            }
            const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver
            };
            const handler = handlers[type] || removeListener;
            handler(chart2, type, proxy);
            proxies[type] = void 0;
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
          }
          isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !!(container && container.isConnected);
          }
        }
        function _detectPlatform(canvas) {
          if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
            return BasicPlatform;
          }
          return DomPlatform;
        }
        var platforms = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          _detectPlatform,
          BasePlatform,
          BasicPlatform,
          DomPlatform
        });
        const transparent = "transparent";
        const interpolators = {
          boolean(from2, to2, factor) {
            return factor > 0.5 ? to2 : from2;
          },
          color(from2, to2, factor) {
            const c0 = color(from2 || transparent);
            const c1 = c0.valid && color(to2 || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
          },
          number(from2, to2, factor) {
            return from2 + (to2 - from2) * factor;
          }
        };
        class Animation {
          constructor(cfg, target, prop, to2) {
            const currentValue = target[prop];
            to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
            const from2 = resolve([cfg.from, currentValue, to2]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from2;
            this._to = to2;
            this._promises = void 0;
          }
          active() {
            return this._active;
          }
          update(cfg, to2, date) {
            if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
              this._from = resolve([cfg.from, currentValue, to2]);
            }
          }
          cancel() {
            if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
            }
          }
          tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from2 = this._from;
            const loop = this._loop;
            const to2 = this._to;
            let factor;
            this._active = from2 !== to2 && (loop || elapsed < duration);
            if (!this._active) {
              this._target[prop] = to2;
              this._notify(true);
              return;
            }
            if (elapsed < 0) {
              this._target[prop] = from2;
              return;
            }
            factor = elapsed / duration % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from2, to2, factor);
          }
          wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
              promises.push({ res, rej });
            });
          }
          _notify(resolved) {
            const method = resolved ? "res" : "rej";
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
              promises[i][method]();
            }
          }
        }
        const numbers = ["x", "y", "borderWidth", "radius", "tension"];
        const colors2 = ["color", "borderColor", "backgroundColor"];
        defaults.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        });
        const animationOptions = Object.keys(defaults.animation);
        defaults.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
        });
        defaults.set("animations", {
          colors: {
            type: "color",
            properties: colors2
          },
          numbers: {
            type: "number",
            properties: numbers
          }
        });
        defaults.describe("animations", {
          _fallback: "animation"
        });
        defaults.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (v) => v | 0
              }
            }
          }
        });
        class Animations {
          constructor(chart2, config) {
            this._chart = chart2;
            this._properties = /* @__PURE__ */ new Map();
            this.configure(config);
          }
          configure(config) {
            if (!isObject2(config)) {
              return;
            }
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
              const cfg = config[key];
              if (!isObject2(cfg)) {
                return;
              }
              const resolved = {};
              for (const option of animationOptions) {
                resolved[option] = cfg[option];
              }
              (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                  animatedProps.set(prop, resolved);
                }
              });
            });
          }
          _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
              return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(() => {
                target.options = newOptions;
              }, () => {
              });
            }
            return animations;
          }
          _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
              const prop = props[i];
              if (prop.charAt(0) === "$") {
                continue;
              }
              if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                if (cfg && animation.active()) {
                  animation.update(cfg, value, date);
                  continue;
                } else {
                  animation.cancel();
                }
              }
              if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
              }
              running[prop] = animation = new Animation(cfg, target, prop, value);
              animations.push(animation);
            }
            return animations;
          }
          update(target, values) {
            if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
              animator.add(this._chart, animations);
              return true;
            }
          }
        }
        function awaitAll(animations, properties) {
          const running = [];
          const keys = Object.keys(properties);
          for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
              running.push(anim.wait());
            }
          }
          return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
          if (!newOptions) {
            return;
          }
          let options = target.options;
          if (!options) {
            target.options = newOptions;
            return;
          }
          if (options.$shared) {
            target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
          }
          return options;
        }
        function scaleClip(scale, allowedOverflow) {
          const opts = scale && scale.options || {};
          const reverse = opts.reverse;
          const min = opts.min === void 0 ? allowedOverflow : 0;
          const max = opts.max === void 0 ? allowedOverflow : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
          if (allowedOverflow === false) {
            return false;
          }
          const x = scaleClip(xScale, allowedOverflow);
          const y = scaleClip(yScale, allowedOverflow);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          let t, r, b, l;
          if (isObject2(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false
          };
        }
        function getSortedDatasetIndices(chart2, filterVisible) {
          const keys = [];
          const metasets = chart2._getSortedDatasetMetas(filterVisible);
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
          }
          return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
          const keys = stack.keys;
          const singleMode = options.mode === "single";
          let i, ilen, datasetIndex, otherValue;
          if (value === null) {
            return;
          }
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
              if (options.all) {
                continue;
              }
              break;
            }
            otherValue = stack.values[datasetIndex];
            if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
              value += otherValue;
            }
          }
          return value;
        }
        function convertObjectDataToArray(data) {
          const keys = Object.keys(data);
          const adata = new Array(keys.length);
          let i, ilen, key;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
              x: key,
              y: data[key]
            };
          }
          return adata;
        }
        function isStacked(scale, meta) {
          const stacked = scale && scale.options.stacked;
          return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
          return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
          const { min, max, minDefined, maxDefined } = scale.getUserBounds();
          return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
          };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
          const subStack = stacks[stackKey] || (stacks[stackKey] = {});
          return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
          for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) {
              return meta.index;
            }
          }
          return null;
        }
        function updateStacks(controller, parsed) {
          const { chart: chart2, _cachedMeta: meta } = controller;
          const stacks = chart2._stacks || (chart2._stacks = {});
          const { iScale, vScale, index: datasetIndex } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const key = getStackKey(iScale, vScale, meta);
          const ilen = parsed.length;
          let stack;
          for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index3, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          }
        }
        function getFirstScaleId(chart2, axis) {
          const scales2 = chart2.scales;
          return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
        }
        function createDatasetContext(parent, index3) {
          return createContext(parent, {
            active: false,
            dataset: void 0,
            datasetIndex: index3,
            index: index3,
            mode: "default",
            type: "dataset"
          });
        }
        function createDataContext(parent, index3, element) {
          return createContext(parent, {
            active: false,
            dataIndex: index3,
            parsed: void 0,
            raw: void 0,
            element,
            index: index3,
            mode: "default",
            type: "data"
          });
        }
        function clearStacks(meta, items) {
          const datasetIndex = meta.controller.index;
          const axis = meta.vScale && meta.vScale.axis;
          if (!axis) {
            return;
          }
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
              return;
            }
            delete stacks[axis][datasetIndex];
          }
        }
        const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart2) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart2, true), values: null };
        class DatasetController {
          constructor(chart2, datasetIndex) {
            this.chart = chart2;
            this._ctx = chart2.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = void 0;
            this._parsing = false;
            this._data = void 0;
            this._objectData = void 0;
            this._sharedOptions = void 0;
            this._drawStart = void 0;
            this._drawCount = void 0;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = void 0;
            this._syncList = [];
            this.initialize();
          }
          initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
          }
          updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
          }
          linkScales() {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart2, "x"));
            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart2, "y"));
            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart2, "r"));
            const indexAxis = meta.indexAxis;
            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
          }
          _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
          }
          reset() {
            this._update("reset");
          }
          _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
              clearStacks(meta);
            }
          }
          _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject2(data)) {
              this._data = convertObjectDataToArray(data);
            } else if (_data !== data) {
              if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
              }
              this._syncList = [];
              this._data = data;
            }
          }
          addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
            }
          }
          buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
            }
          }
          configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
          }
          parse(start, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted = start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
            } else {
              if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
              } else if (isObject2(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
              } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
              for (i = 0; i < count; ++i) {
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                  if (isNotInOrderComparedToPrev()) {
                    sorted = false;
                  }
                  prev = cur;
                }
              }
              meta._sorted = sorted;
            }
            if (_stacked) {
              updateStacks(this, parsed);
            }
          }
          parsePrimitiveData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index3;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index3], index3),
                [vAxis]: vScale.parse(data[index3], index3)
              };
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              item = data[index3];
              parsed[i] = {
                x: xScale.parse(item[0], index3),
                y: yScale.parse(item[1], index3)
              };
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              item = data[index3];
              parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index3)
              };
            }
            return parsed;
          }
          getParsed(index3) {
            return this._cachedMeta._parsed[index3];
          }
          getDataElement(index3) {
            return this._cachedMeta.data[index3];
          }
          applyStack(scale, parsed, mode) {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
              keys: getSortedDatasetIndices(chart2, true),
              values: parsed._stacks[scale.axis]
            };
            return applyStack(stack, value, meta.index, { mode });
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range2.min = Math.min(range2.min, value);
            range2.max = Math.max(range2.max, value);
          }
          getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
            }
            for (i = 0; i < ilen; ++i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range2, scale, parsed, stack);
              if (sorted) {
                break;
              }
            }
            if (sorted) {
              for (i = ilen - 1; i >= 0; --i) {
                if (_skip()) {
                  continue;
                }
                this.updateRangeFromParsed(range2, scale, parsed, stack);
                break;
              }
            }
            return range2;
          }
          getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
              value = parsed[i][scale.axis];
              if (isNumberFinite(value)) {
                values.push(value);
              }
            }
            return values;
          }
          getMaxOverflow() {
            return false;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index3);
            return {
              label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
              value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
            };
          }
          _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || "default");
            meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
          }
          update(mode) {
          }
          draw() {
            const ctx = this._ctx;
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const elements2 = meta.data || [];
            const area = chart2.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements2.length - start;
            const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
            }
            for (i = start; i < start + count; ++i) {
              const element = elements2[i];
              if (element.hidden) {
                continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                active.push(element);
              } else {
                element.draw(ctx, area);
              }
            }
            for (i = 0; i < active.length; ++i) {
              active[i].draw(ctx, area);
            }
          }
          getStyle(index3, active) {
            const mode = active ? "active" : "default";
            return index3 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index3 || 0, mode);
          }
          getContext(index3, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index3];
              context = element.$context || (element.$context = createDataContext(this.getContext(), index3, element));
              context.parsed = this.getParsed(index3);
              context.raw = dataset.data[index3];
              context.index = context.dataIndex = index3;
            } else {
              context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
          }
          resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode);
          }
          resolveDataElementOptions(index3, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index3);
          }
          _resolveElementOptions(elementType, mode = "default", index3) {
            const active = mode === "active";
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + "-" + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index3);
            if (cached) {
              return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
            const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names2 = Object.keys(defaults.elements[elementType]);
            const context = () => this.getContext(index3, active);
            const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
            if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
            }
            return values;
          }
          _resolveAnimations(index3, transition, active) {
            const chart2 = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
              return cached;
            }
            let options;
            if (chart2.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
              const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
              options = config.createResolver(scopes, this.getContext(index3, active, transition));
            }
            const animations = new Animations(chart2, options && options.animations);
            if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
          }
          getSharedOptions(options) {
            if (!options.$shared) {
              return;
            }
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
          }
          includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
          }
          _getSharedOptions(start, mode) {
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return { sharedOptions, includeOptions };
          }
          updateElement(element, index3, properties, mode) {
            if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
            } else {
              this._resolveAnimations(index3, mode).update(element, properties);
            }
          }
          updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
          }
          _setStyle(element, index3, mode, active) {
            element.active = active;
            const options = this.getStyle(index3, active);
            this._resolveAnimations(index3, mode, active).update(element, {
              options: !active && this.getSharedOptions(options) || options
            });
          }
          removeHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, "active", false);
          }
          setHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, "active", true);
          }
          _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", false);
            }
          }
          _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", true);
            }
          }
          _resyncElements(resetNewElements) {
            const data = this._data;
            const elements2 = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
              this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements2.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
              this.parse(0, count);
            }
            if (numData > numMeta) {
              this._insertElements(numMeta, numData - numMeta, resetNewElements);
            } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
            }
          }
          _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move2 = (arr) => {
              arr.length += count;
              for (i = arr.length - 1; i >= end; i--) {
                arr[i] = arr[i - count];
              }
            };
            move2(data);
            for (i = start; i < end; ++i) {
              data[i] = new this.dataElementType();
            }
            if (this._parsing) {
              move2(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
              this.updateElements(data, start, count, "reset");
            }
          }
          updateElements(element, start, count, mode) {
          }
          _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                clearStacks(meta, removed);
              }
            }
            meta.data.splice(start, count);
          }
          _sync(args) {
            if (this._parsing) {
              this._syncList.push(args);
            } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
          }
          _onDataPush() {
            const count = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - count, count]);
          }
          _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
          }
          _onDataShift() {
            this._sync(["_removeElements", 0, 1]);
          }
          _onDataSplice(start, count) {
            if (count) {
              this._sync(["_removeElements", start, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
              this._sync(["_insertElements", start, newCount]);
            }
          }
          _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length]);
          }
        }
        DatasetController.defaults = {};
        DatasetController.prototype.datasetElementType = null;
        DatasetController.prototype.dataElementType = null;
        class Element2 {
          constructor() {
            this.x = void 0;
            this.y = void 0;
            this.active = false;
            this.options = void 0;
            this.$animations = void 0;
          }
          tooltipPosition(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          hasValue() {
            return isNumber(this.x) && isNumber(this.y);
          }
          getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
              return this;
            }
            const ret = {};
            props.forEach((prop) => {
              ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
            });
            return ret;
          }
        }
        Element2.defaults = {};
        Element2.defaultRoutes = void 0;
        const formatters = {
          values(value) {
            return isArray(value) ? value : "" + value;
          },
          numeric(tickValue, index3, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
              const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
              if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = "scientific";
              }
              delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
          },
          logarithmic(tickValue, index3, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (remain === 1 || remain === 2 || remain === 5) {
              return formatters.numeric.call(this, tickValue, index3, ticks);
            }
            return "";
          }
        };
        function calculateDelta(tickValue, ticks) {
          let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
          if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
          }
          return delta;
        }
        var Ticks = { formatters };
        defaults.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        });
        defaults.route("scale.ticks", "color", "", "color");
        defaults.route("scale.grid", "color", "", "borderColor");
        defaults.route("scale.grid", "borderColor", "", "borderColor");
        defaults.route("scale.title", "color", "", "color");
        defaults.describe("scale", {
          _fallback: false,
          _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
          _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
        });
        defaults.describe("scales", {
          _fallback: "scale"
        });
        defaults.describe("scale.ticks", {
          _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
          _indexable: (name) => name !== "backdropPadding"
        });
        function autoSkip(scale, ticks) {
          const tickOpts = scale.options.ticks;
          const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
          const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
          const numMajorIndices = majorIndices.length;
          const first = majorIndices[0];
          const last = majorIndices[numMajorIndices - 1];
          const newTicks = [];
          if (numMajorIndices > ticksLimit) {
            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
            return newTicks;
          }
          const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
          if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
              skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            }
            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
            return newTicks;
          }
          skip(ticks, newTicks, spacing);
          return newTicks;
        }
        function determineMaxTicks(scale) {
          const offset = scale.options.offset;
          const tickLength = scale._tickSize();
          const maxScale = scale._length / tickLength + (offset ? 0 : 1);
          const maxChart = scale._maxLength / tickLength;
          return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
          const evenMajorSpacing = getEvenSpacing(majorIndices);
          const spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          const factors = _factorize(evenMajorSpacing);
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          const result = [];
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
          let count = 0;
          let next = majorIndices[0];
          let i;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
            }
          }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
          const start = valueOrDefault(majorStart, 0);
          const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
          let count = 0;
          let length, i, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
            }
          }
        }
        function getEvenSpacing(arr) {
          const len = arr.length;
          let i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        function sample(arr, numItems) {
          const result = [];
          const increment = arr.length / numItems;
          const len = arr.length;
          let i = 0;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale, index3, offsetGridLines) {
          const length = scale.ticks.length;
          const validIndex2 = Math.min(index3, length - 1);
          const start = scale._startPixel;
          const end = scale._endPixel;
          const epsilon = 1e-6;
          let lineValue = scale.getPixelForTick(validIndex2);
          let offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index3 === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
            }
            lineValue += validIndex2 < index3 ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          each(caches, (cache) => {
            const gc = cache.gc;
            const gcLen = gc.length / 2;
            let i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function getTickMarkLength(options) {
          return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
          if (!options.display) {
            return 0;
          }
          const font = toFont(options.font, fallback);
          const padding = toPadding(options.padding);
          const lines = isArray(options.text) ? options.text.length : 1;
          return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
          return createContext(parent, {
            scale,
            type: "scale"
          });
        }
        function createTickContext(parent, index3, tick) {
          return createContext(parent, {
            tick,
            index: index3,
            type: "tick"
          });
        }
        function titleAlign(align, position, reverse) {
          let ret = _toLeftRightCenter(align);
          if (reverse && position !== "right" || !reverse && position === "right") {
            ret = reverseAlign(ret);
          }
          return ret;
        }
        function titleArgs(scale, offset, position, align) {
          const { top, left, bottom, right, chart: chart2 } = scale;
          const { chartArea, scales: scales2 } = chart2;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          const height = bottom - top;
          const width = right - left;
          if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
            } else if (position === "center") {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
              titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
          } else {
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === "center") {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
              titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === "left" ? -HALF_PI : HALF_PI;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        class Scale extends Element2 {
          constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = void 0;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
            this.maxWidth = void 0;
            this.maxHeight = void 0;
            this.paddingTop = void 0;
            this.paddingBottom = void 0;
            this.paddingLeft = void 0;
            this.paddingRight = void 0;
            this.axis = void 0;
            this.labelRotation = void 0;
            this.min = void 0;
            this.max = void 0;
            this._range = void 0;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = void 0;
            this._endPixel = void 0;
            this._reversePixels = false;
            this._userMax = void 0;
            this._userMin = void 0;
            this._suggestedMax = void 0;
            this._suggestedMin = void 0;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = void 0;
          }
          init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
          }
          parse(raw, index3) {
            return raw;
          }
          getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
            return {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax)
            };
          }
          getMinMax(canStack) {
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            let range2;
            if (minDefined && maxDefined) {
              return { min, max };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
              range2 = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                min = Math.min(min, range2.min);
              }
              if (!maxDefined) {
                max = Math.max(max, range2.max);
              }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max))
            };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          }
          beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
          }
          beforeUpdate() {
            callback(this.options.beforeUpdate, [this]);
          }
          update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = _addGrace(this, grace, beginAtZero);
              this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
            }
            if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
          }
          configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
            } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
          }
          afterUpdate() {
            callback(this.options.afterUpdate, [this]);
          }
          beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [this]);
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
          }
          afterSetDimensions() {
            callback(this.options.afterSetDimensions, [this]);
          }
          _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [this]);
          }
          beforeDataLimits() {
            this._callHooks("beforeDataLimits");
          }
          determineDataLimits() {
          }
          afterDataLimits() {
            this._callHooks("afterDataLimits");
          }
          beforeBuildTicks() {
            this._callHooks("beforeBuildTicks");
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks("afterBuildTicks");
          }
          beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [this]);
          }
          generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              tick = ticks[i];
              tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
            }
          }
          afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [this]);
          }
          beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [this]);
          }
          calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = this.ticks.length;
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
              this.labelRotation = minRotation;
              return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            this.labelRotation = labelRotation;
          }
          afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [this]);
          }
          afterAutoSkip() {
          }
          beforeFit() {
            callback(this.options.beforeFit, [this]);
          }
          fit() {
            const minSize = {
              width: 0,
              height: 0
            };
            const { chart: chart2, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart2.options.font);
              if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                  const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                  minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                  const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                  minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
              }
            }
            this._handleMargins();
            if (isHorizontal) {
              this.width = this._length = chart2.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
            } else {
              this.width = minSize.width;
              this.height = this._length = chart2.height - this._margins.top - this._margins.bottom;
            }
          }
          _calculatePadding(first, last, sin, cos) {
            const { ticks: { align, padding }, position } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== "top" && this.axis === "x";
            if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                if (labelsBelowTicks) {
                  paddingLeft = cos * first.width;
                  paddingRight = sin * last.height;
                } else {
                  paddingLeft = sin * first.height;
                  paddingRight = cos * last.width;
                }
              } else if (align === "start") {
                paddingRight = last.width;
              } else if (align === "end") {
                paddingLeft = first.width;
              } else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
              this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
            } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
              } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
            }
          }
          _handleMargins() {
            if (this._margins) {
              this._margins.left = Math.max(this.paddingLeft, this._margins.left);
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(this.paddingRight, this._margins.right);
              this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
            }
          }
          afterFit() {
            callback(this.options.afterFit, [this]);
          }
          isHorizontal() {
            const { axis, position } = this.options;
            return position === "top" || position === "bottom" || axis === "x";
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              if (isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
              }
            }
            this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
            }
            return labelSizes;
          }
          _computeLabelSizes(ticks, length) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
            for (i = 0; i < length; ++i) {
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString2 = tickFont.string;
              cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
              } else if (isArray(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  nestedLabel = label[j];
                  if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                    width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                  }
                }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
            return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights
            };
          }
          getLabelForValue(value) {
            return value;
          }
          getPixelForValue(value, index3) {
            return NaN;
          }
          getValueForPixel(pixel) {
          }
          getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index3].value);
          }
          getPixelForDecimal(decimal) {
            if (this._reversePixels) {
              decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
          }
          getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min, max } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          }
          getContext(index3) {
            const ticks = this.ticks || [];
            if (index3 >= 0 && index3 < ticks.length) {
              const tick = ticks[index3];
              return tick.$context || (tick.$context = createTickContext(this.getContext(), index3, tick));
            }
            return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
          }
          _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          }
          _isVisible() {
            const display = this.options.display;
            if (display !== "auto") {
              return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart2 = this.chart;
            const options = this.options;
            const { grid, position } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function(pixel) {
              return _alignPixel(chart2, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === "top") {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else if (position === "right") {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl;
            } else if (axis === "x") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl;
            } else if (axis === "y") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl;
              x1 = chartArea.left;
              x2 = chartArea.right;
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
              const optsAtIndex = grid.setContext(this.getContext(i));
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = optsAtIndex.borderDash || [];
              const borderDashOffset = optsAtIndex.borderDashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = _alignPixel(chart2, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
              });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
          }
          _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            let textBaseline = "middle";
            if (position === "top") {
              y = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "bottom") {
              y = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "left") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (position === "right") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (axis === "x") {
              if (position === "center") {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
            } else if (axis === "y") {
              if (position === "center") {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === "y") {
              if (align === "start") {
                textBaseline = "top";
              } else if (align === "end") {
                textBaseline = "bottom";
              }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = isArray(label) ? label.length : 1;
              const halfCount = lineCount / 2;
              const color2 = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                x = pixel;
                if (textAlign === "inner") {
                  if (i === ilen - 1) {
                    tickTextAlign = !this.options.reverse ? "right" : "left";
                  } else if (i === 0) {
                    tickTextAlign = !this.options.reverse ? "left" : "right";
                  } else {
                    tickTextAlign = "center";
                  }
                }
                if (position === "top") {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = -lineCount * lineHeight + lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                  } else {
                    textOffset = -labelSizes.highest.height + lineHeight / 2;
                  }
                } else {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                  } else {
                    textOffset = labelSizes.highest.height - lineCount * lineHeight;
                  }
                }
                if (mirror) {
                  textOffset *= -1;
                }
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = y + textOffset - labelPadding.top;
                let left = x - labelPadding.left;
                switch (textBaseline) {
                  case "middle":
                    top -= height / 2;
                    break;
                  case "bottom":
                    top -= height;
                    break;
                }
                switch (textAlign) {
                  case "center":
                    left -= width / 2;
                    break;
                  case "right":
                    left -= width;
                    break;
                }
                backdrop = {
                  left,
                  top,
                  width: width + labelPadding.width,
                  height: height + labelPadding.height,
                  color: optsAtIndex.backdropColor
                };
              }
              items.push({
                rotation,
                label,
                font,
                color: color2,
                strokeColor,
                strokeWidth,
                textOffset,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [x, y],
                backdrop
              });
            }
            return items;
          }
          _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
              return position === "top" ? "left" : "right";
            }
            let align = "center";
            if (ticks.align === "start") {
              align = "left";
            } else if (ticks.align === "end") {
              align = "right";
            } else if (ticks.align === "inner") {
              align = "inner";
            }
            return align;
          }
          _getYAxisLabelAlignment(tl) {
            const { position, ticks: { crossAlign, mirror, padding } } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === "left") {
              if (mirror) {
                x = this.right + padding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x += widest;
                }
              } else {
                x = this.right - tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x = this.left;
                }
              }
            } else if (position === "right") {
              if (mirror) {
                x = this.left + padding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x -= widest;
                }
              } else {
                x = this.left + tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x = this.right;
                }
              }
            } else {
              textAlign = "right";
            }
            return { textAlign, x };
          }
          _computeLabelArea() {
            if (this.options.ticks.mirror) {
              return;
            }
            const chart2 = this.chart;
            const position = this.options.position;
            if (position === "left" || position === "right") {
              return { top: 0, left: this.left, bottom: chart2.height, right: this.right };
            }
            if (position === "top" || position === "bottom") {
              return { top: this.top, left: 0, bottom: this.bottom, right: chart2.width };
            }
          }
          drawBackground() {
            const { ctx, options: { backgroundColor }, left, top, width, height } = this;
            if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
            }
          }
          getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
              return 0;
            }
            const ticks = this.ticks;
            const index3 = ticks.findIndex((t) => t.value === value);
            if (index3 >= 0) {
              const opts = grid.setContext(this.getContext(index3));
              return opts.lineWidth;
            }
            return 0;
          }
          drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
              if (!style.width || !style.color) {
                return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
            };
            if (grid.display) {
              for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                if (grid.drawOnChartArea) {
                  drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
                }
                if (grid.drawTicks) {
                  drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
                    color: item.tickColor,
                    width: item.tickWidth,
                    borderDash: item.tickBorderDash,
                    borderDashOffset: item.tickBorderDashOffset
                  });
                }
              }
            }
          }
          drawBorder() {
            const { chart: chart2, ctx, options: { grid } } = this;
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) {
              return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
              x1 = _alignPixel(chart2, this.left, axisWidth) - axisWidth / 2;
              x2 = _alignPixel(chart2, this.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 = _alignPixel(chart2, this.top, axisWidth) - axisWidth / 2;
              y2 = _alignPixel(chart2, this.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.borderWidth;
            ctx.strokeStyle = borderOpts.borderColor;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
          }
          drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
              clipArea(ctx, area);
            }
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              const tickFont = item.font;
              const label = item.label;
              if (item.backdrop) {
                ctx.fillStyle = item.backdrop.color;
                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
              }
              let y = item.textOffset;
              renderText(ctx, label, 0, y, tickFont, item);
            }
            if (area) {
              unclipArea(ctx);
            }
          }
          drawTitle() {
            const { ctx, options: { position, title, reverse } } = this;
            if (!title.display) {
              return;
            }
            const font = toFont(title.font);
            const padding = toPadding(title.padding);
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (position === "bottom" || position === "center" || isObject2(position)) {
              offset += padding.bottom;
              if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
              }
            } else {
              offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
              color: title.color,
              maxWidth,
              rotation,
              textAlign: titleAlign(align, position, reverse),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
          draw(chartArea) {
            if (!this._isVisible()) {
              return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
          }
          _layers() {
            const opts = this.options;
            const tz = opts.ticks && opts.ticks.z || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [{
                z: tz,
                draw: (chartArea) => {
                  this.draw(chartArea);
                }
              }];
            }
            return [{
              z: gz,
              draw: (chartArea) => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            }, {
              z: gz + 1,
              draw: () => {
                this.drawBorder();
              }
            }, {
              z: tz,
              draw: (chartArea) => {
                this.drawLabels(chartArea);
              }
            }];
          }
          getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + "AxisID";
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
              }
            }
            return result;
          }
          _resolveTickFontOptions(index3) {
            const opts = this.options.ticks.setContext(this.getContext(index3));
            return toFont(opts.font);
          }
          _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
          }
        }
        class TypedRegistry {
          constructor(type, scope, override) {
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
          }
          isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
          }
          register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + "." + id;
            if (!id) {
              throw new Error("class does not have id: " + item);
            }
            if (id in items) {
              return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
              defaults.override(item.id, item.overrides);
            }
            return scope;
          }
          get(id) {
            return this.items[id];
          }
          unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
              delete items[id];
            }
            if (scope && id in defaults[scope]) {
              delete defaults[scope][id];
              if (this.override) {
                delete overrides[id];
              }
            }
          }
        }
        function registerDefaults(item, scope, parentScope) {
          const itemDefaults = merge(Object.create(null), [
            parentScope ? defaults.get(parentScope) : {},
            defaults.get(scope),
            item.defaults
          ]);
          defaults.set(scope, itemDefaults);
          if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
          }
          if (item.descriptors) {
            defaults.describe(scope, item.descriptors);
          }
        }
        function routeDefaults(scope, routes) {
          Object.keys(routes).forEach((property) => {
            const propertyParts = property.split(".");
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join(".");
            const parts = routes[property].split(".");
            const targetName = parts.pop();
            const targetScope = parts.join(".");
            defaults.route(sourceScope, sourceName, targetScope, targetName);
          });
        }
        function isIChartComponent(proto) {
          return "id" in proto && "defaults" in proto;
        }
        class Registry {
          constructor() {
            this.controllers = new TypedRegistry(DatasetController, "datasets", true);
            this.elements = new TypedRegistry(Element2, "elements");
            this.plugins = new TypedRegistry(Object, "plugins");
            this.scales = new TypedRegistry(Scale, "scales");
            this._typedRegistries = [this.controllers, this.scales, this.elements];
          }
          add(...args) {
            this._each("register", args);
          }
          remove(...args) {
            this._each("unregister", args);
          }
          addControllers(...args) {
            this._each("register", args, this.controllers);
          }
          addElements(...args) {
            this._each("register", args, this.elements);
          }
          addPlugins(...args) {
            this._each("register", args, this.plugins);
          }
          addScales(...args) {
            this._each("register", args, this.scales);
          }
          getController(id) {
            return this._get(id, this.controllers, "controller");
          }
          getElement(id) {
            return this._get(id, this.elements, "element");
          }
          getPlugin(id) {
            return this._get(id, this.plugins, "plugin");
          }
          getScale(id) {
            return this._get(id, this.scales, "scale");
          }
          removeControllers(...args) {
            this._each("unregister", args, this.controllers);
          }
          removeElements(...args) {
            this._each("unregister", args, this.elements);
          }
          removePlugins(...args) {
            this._each("unregister", args, this.plugins);
          }
          removeScales(...args) {
            this._each("unregister", args, this.scales);
          }
          _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
              } else {
                each(arg, (item) => {
                  const itemReg = typedRegistry || this._getRegistryForType(item);
                  this._exec(method, itemReg, item);
                });
              }
            });
          }
          _exec(method, registry2, component) {
            const camelMethod = _capitalize(method);
            callback(component["before" + camelMethod], [], component);
            registry2[method](component);
            callback(component["after" + camelMethod], [], component);
          }
          _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                return reg;
              }
            }
            return this.plugins;
          }
          _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === void 0) {
              throw new Error('"' + id + '" is not a registered ' + type + ".");
            }
            return item;
          }
        }
        var registry = new Registry();
        class PluginService {
          constructor() {
            this._init = [];
          }
          notify(chart2, hook, args, filter) {
            if (hook === "beforeInit") {
              this._init = this._createDescriptors(chart2, true);
              this._notify(this._init, chart2, "install");
            }
            const descriptors2 = filter ? this._descriptors(chart2).filter(filter) : this._descriptors(chart2);
            const result = this._notify(descriptors2, chart2, hook, args);
            if (hook === "afterDestroy") {
              this._notify(descriptors2, chart2, "stop");
              this._notify(this._init, chart2, "uninstall");
            }
            return result;
          }
          _notify(descriptors2, chart2, hook, args) {
            args = args || {};
            for (const descriptor of descriptors2) {
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [chart2, args, descriptor.options];
              if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
              }
            }
            return true;
          }
          invalidate() {
            if (!isNullOrUndef(this._cache)) {
              this._oldCache = this._cache;
              this._cache = void 0;
            }
          }
          _descriptors(chart2) {
            if (this._cache) {
              return this._cache;
            }
            const descriptors2 = this._cache = this._createDescriptors(chart2);
            this._notifyStateChanges(chart2);
            return descriptors2;
          }
          _createDescriptors(chart2, all) {
            const config = chart2 && chart2.config;
            const options = valueOrDefault(config.options && config.options.plugins, {});
            const plugins2 = allPlugins(config);
            return options === false && !all ? [] : createDescriptors(chart2, plugins2, options, all);
          }
          _notifyStateChanges(chart2) {
            const previousDescriptors = this._oldCache || [];
            const descriptors2 = this._cache;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors2), chart2, "stop");
            this._notify(diff(descriptors2, previousDescriptors), chart2, "start");
          }
        }
        function allPlugins(config) {
          const localIds = {};
          const plugins2 = [];
          const keys = Object.keys(registry.plugins.items);
          for (let i = 0; i < keys.length; i++) {
            plugins2.push(registry.getPlugin(keys[i]));
          }
          const local = config.plugins || [];
          for (let i = 0; i < local.length; i++) {
            const plugin = local[i];
            if (plugins2.indexOf(plugin) === -1) {
              plugins2.push(plugin);
              localIds[plugin.id] = true;
            }
          }
          return { plugins: plugins2, localIds };
        }
        function getOpts(options, all) {
          if (!all && options === false) {
            return null;
          }
          if (options === true) {
            return {};
          }
          return options;
        }
        function createDescriptors(chart2, { plugins: plugins2, localIds }, options, all) {
          const result = [];
          const context = chart2.getContext();
          for (const plugin of plugins2) {
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
              continue;
            }
            result.push({
              plugin,
              options: pluginOpts(chart2.config, { plugin, local: localIds[id] }, opts, context)
            });
          }
          return result;
        }
        function pluginOpts(config, { plugin, local }, opts, context) {
          const keys = config.pluginScopeKeys(plugin);
          const scopes = config.getOptionScopes(opts, keys);
          if (local && plugin.defaults) {
            scopes.push(plugin.defaults);
          }
          return config.createResolver(scopes, context, [""], {
            scriptable: false,
            indexable: false,
            allKeys: true
          });
        }
        function getIndexAxis(type, options) {
          const datasetDefaults = defaults.datasets[type] || {};
          const datasetOptions = (options.datasets || {})[type] || {};
          return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
          let axis = id;
          if (id === "_index_") {
            axis = indexAxis;
          } else if (id === "_value_") {
            axis = indexAxis === "x" ? "y" : "x";
          }
          return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
          return axis === indexAxis ? "_index_" : "_value_";
        }
        function axisFromPosition(position) {
          if (position === "top" || position === "bottom") {
            return "x";
          }
          if (position === "left" || position === "right") {
            return "y";
          }
        }
        function determineAxis(id, scaleOptions) {
          if (id === "x" || id === "y") {
            return id;
          }
          return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
        }
        function mergeScaleConfig(config, options) {
          const chartDefaults = overrides[config.type] || { scales: {} };
          const configScales = options.scales || {};
          const chartIndexAxis = getIndexAxis(config.type, options);
          const firstIDs = Object.create(null);
          const scales2 = Object.create(null);
          Object.keys(configScales).forEach((id) => {
            const scaleConf = configScales[id];
            if (!isObject2(scaleConf)) {
              return console.error(`Invalid scale configuration for scale: ${id}`);
            }
            if (scaleConf._proxy) {
              return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
            }
            const axis = determineAxis(id, scaleConf);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            firstIDs[axis] = firstIDs[axis] || id;
            scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
          });
          config.data.datasets.forEach((dataset) => {
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults = overrides[type] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
              scales2[id] = scales2[id] || Object.create(null);
              mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
            });
          });
          Object.keys(scales2).forEach((key) => {
            const scale = scales2[key];
            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
          });
          return scales2;
        }
        function initOptions(config) {
          const options = config.options || (config.options = {});
          options.plugins = valueOrDefault(options.plugins, {});
          options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
          data = data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          return data;
        }
        function initConfig(config) {
          config = config || {};
          config.data = initData(config.data);
          initOptions(config);
          return config;
        }
        const keyCache = /* @__PURE__ */ new Map();
        const keysCached = /* @__PURE__ */ new Set();
        function cachedKeys(cacheKey, generate) {
          let keys = keyCache.get(cacheKey);
          if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
          }
          return keys;
        }
        const addIfFound = (set2, obj, key) => {
          const opts = resolveObjectKey(obj, key);
          if (opts !== void 0) {
            set2.add(opts);
          }
        };
        class Config {
          constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = /* @__PURE__ */ new Map();
            this._resolverCache = /* @__PURE__ */ new Map();
          }
          get platform() {
            return this._config.platform;
          }
          get type() {
            return this._config.type;
          }
          set type(type) {
            this._config.type = type;
          }
          get data() {
            return this._config.data;
          }
          set data(data) {
            this._config.data = initData(data);
          }
          get options() {
            return this._config.options;
          }
          set options(options) {
            this._config.options = options;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
          }
          clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
          }
          datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [[
              `datasets.${datasetType}`,
              ""
            ]]);
          }
          datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`
              ],
              [
                `datasets.${datasetType}`,
                ""
              ]
            ]);
          }
          datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [[
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]]);
          }
          pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, () => [[
              `plugins.${id}`,
              ...plugin.additionalOptionScopes || []
            ]]);
          }
          _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
              cache = /* @__PURE__ */ new Map();
              _scopeCache.set(mainScope, cache);
            }
            return cache;
          }
          getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
              return cached;
            }
            const scopes = /* @__PURE__ */ new Set();
            keyLists.forEach((keys) => {
              if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key) => addIfFound(scopes, options, key));
              keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
              keys.forEach((key) => addIfFound(scopes, defaults, key));
              keys.forEach((key) => addIfFound(scopes, descriptors, key));
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
              array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
            }
            return array;
          }
          chartOptionScopes() {
            const { options, type } = this;
            return [
              options,
              overrides[type] || {},
              defaults.datasets[type] || {},
              { type },
              defaults,
              descriptors
            ];
          }
          resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
            const result = { $shared: true };
            const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (needContext(resolver, names2)) {
              result.$shared = false;
              context = isFunction2(context) ? context() : context;
              const subResolver = this.createResolver(scopes, context, subPrefixes);
              options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names2) {
              result[prop] = options[prop];
            }
            return result;
          }
          createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
            const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
          }
        }
        function getResolver(resolverCache, scopes, prefixes) {
          let cache = resolverCache.get(scopes);
          if (!cache) {
            cache = /* @__PURE__ */ new Map();
            resolverCache.set(scopes, cache);
          }
          const cacheKey = prefixes.join();
          let cached = cache.get(cacheKey);
          if (!cached) {
            const resolver = _createResolver(scopes, prefixes);
            cached = {
              resolver,
              subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
            };
            cache.set(cacheKey, cached);
          }
          return cached;
        }
        const hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
        function needContext(proxy, names2) {
          const { isScriptable, isIndexable } = _descriptors(proxy);
          for (const prop of names2) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray(value)) {
              return true;
            }
          }
          return false;
        }
        var version = "3.9.1";
        const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
        function positionIsHorizontal(position, axis) {
          return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        function onAnimationsComplete(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          chart2.notifyPlugins("afterRender");
          callback(animationOptions2 && animationOptions2.onComplete, [context], chart2);
        }
        function onAnimationProgress(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          callback(animationOptions2 && animationOptions2.onProgress, [context], chart2);
        }
        function getCanvas(item) {
          if (_isDomSupported() && typeof item === "string") {
            item = document.getElementById(item);
          } else if (item && item.length) {
            item = item[0];
          }
          if (item && item.canvas) {
            item = item.canvas;
          }
          return item;
        }
        const instances = {};
        const getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances).filter((c) => c.canvas === canvas).pop();
        };
        function moveNumericKeys(obj, start, move2) {
          const keys = Object.keys(obj);
          for (const key of keys) {
            const intKey = +key;
            if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move2 > 0 || intKey > start) {
                obj[intKey + move2] = value;
              }
            }
          }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
          if (!inChartArea || e.type === "mouseout") {
            return null;
          }
          if (isClick) {
            return lastEvent;
          }
          return e;
        }
        class Chart3 {
          constructor(item, userConfig) {
            const config = this.config = new Config(userConfig);
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
              throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
            }
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = void 0;
            this.boxes = [];
            this.currentDevicePixelRatio = void 0;
            this.chartArea = void 0;
            this._active = [];
            this._lastEvent = void 0;
            this._listeners = {};
            this._responsiveListeners = void 0;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = void 0;
            this.$context = void 0;
            this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            animator.listen(this, "complete", onAnimationsComplete);
            animator.listen(this, "progress", onAnimationProgress);
            this._initialize();
            if (this.attached) {
              this.update();
            }
          }
          get aspectRatio() {
            const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
            if (!isNullOrUndef(aspectRatio)) {
              return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
            }
            return height ? width / height : null;
          }
          get data() {
            return this.config.data;
          }
          set data(data) {
            this.config.data = data;
          }
          get options() {
            return this._options;
          }
          set options(options) {
            this.config.options = options;
          }
          _initialize() {
            this.notifyPlugins("beforeInit");
            if (this.options.responsive) {
              this.resize();
            } else {
              retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins("afterInit");
            return this;
          }
          clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
          }
          stop() {
            animator.stop(this);
            return this;
          }
          resize(width, height) {
            if (!animator.running(this)) {
              this._resize(width, height);
            } else {
              this._resizeBeforeDraw = { width, height };
            }
          }
          _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
            const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? "resize" : "attach";
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
              return;
            }
            this.notifyPlugins("resize", { size: newSize });
            callback(options.onResize, [this, newSize], this);
            if (this.attached) {
              if (this._doResize(mode)) {
                this.render();
              }
            }
          }
          ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID) => {
              axisOptions.id = axisID;
            });
          }
          buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales2 = this.scales;
            const updated = Object.keys(scales2).reduce((obj, id) => {
              obj[id] = false;
              return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
              items = items.concat(Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === "r";
                const isHorizontal = axis === "x";
                return {
                  options: scaleOptions,
                  dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                  dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                };
              }));
            }
            each(items, (item) => {
              const scaleOptions = item.options;
              const id = scaleOptions.id;
              const axis = determineAxis(id, scaleOptions);
              const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              let scale = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale = scales2[id];
              } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                  id,
                  type: scaleType,
                  ctx: this.ctx,
                  chart: this
                });
                scales2[scale.id] = scale;
              }
              scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id) => {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            each(scales2, (scale) => {
              layouts.configure(this, scale, scale.options);
              layouts.addBox(this, scale);
            });
          }
          _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
              for (let i = numData; i < numMeta; ++i) {
                this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
          }
          _removeUnreferencedMetasets() {
            const { _metasets: metasets, data: { datasets } } = this;
            if (metasets.length > datasets.length) {
              delete this._stacks;
            }
            metasets.forEach((meta, index3) => {
              if (datasets.filter((x) => x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index3);
              }
            });
          }
          buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = "" + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = defaults.datasets[type];
                Object.assign(ControllerClass.prototype, {
                  dataElementType: registry.getElement(dataElementType),
                  datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
              }
            }
            this._updateMetasets();
            return newControllers;
          }
          _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex) => {
              this.getDatasetMeta(datasetIndex).controller.reset();
            }, this);
          }
          reset() {
            this._resetElements();
            this.notifyPlugins("reset");
          }
          update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            const animsDisabled = this._animationsDisabled = !options.animation;
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
              const { controller } = this.getDatasetMeta(i);
              const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset2);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
              each(newControllers, (controller) => {
                controller.reset();
              });
            }
            this._updateDatasets(mode);
            this.notifyPlugins("afterUpdate", { mode });
            this._layers.sort(compare2Level("z", "_idx"));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
            }
            this.render();
          }
          _updateScales() {
            each(this.scales, (scale) => {
              layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
          }
          _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
              this.unbindEvents();
              this.bindEvents();
            }
          }
          _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start, count } of changes) {
              const move2 = method === "_removeElements" ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move2);
            }
          }
          _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
              return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
              if (!setsEqual(changeSet, makeSet(i))) {
                return;
              }
            }
            return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
          }
          _updateLayout(minPadding) {
            if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
              return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(this.boxes, (box) => {
              if (noArea && box.position === "chartArea") {
                return;
              }
              if (box.configure) {
                box.configure();
              }
              this._layers.push(...box._layers());
            }, this);
            this._layers.forEach((item, index3) => {
              item._idx = index3;
            });
            this.notifyPlugins("afterLayout");
          }
          _updateDatasets(mode) {
            if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._updateDataset(i, isFunction2(mode) ? mode({ datasetIndex: i }) : mode);
            }
            this.notifyPlugins("afterDatasetsUpdate", { mode });
          }
          _updateDataset(index3, mode) {
            const meta = this.getDatasetMeta(index3);
            const args = { meta, index: index3, mode, cancelable: true };
            if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
              return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins("afterDatasetUpdate", args);
          }
          render() {
            if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
              return;
            }
            if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                animator.start(this);
              }
            } else {
              this.draw();
              onAnimationsComplete({ chart: this });
            }
          }
          draw() {
            let i;
            if (this._resizeBeforeDraw) {
              const { width, height } = this._resizeBeforeDraw;
              this._resize(width, height);
              this._resizeBeforeDraw = null;
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
              return;
            }
            if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
              return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
              layers[i].draw(this.chartArea);
            }
            this.notifyPlugins("afterDraw");
          }
          _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                result.push(meta);
              }
            }
            return result;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
          }
          _drawDatasets() {
            if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
              return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              this._drawDataset(metasets[i]);
            }
            this.notifyPlugins("afterDatasetsDraw");
          }
          _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = this.chartArea;
            const args = {
              meta,
              index: meta.index,
              cancelable: true
            };
            if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
              return;
            }
            if (useClip) {
              clipArea(ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? this.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
              });
            }
            meta.controller.draw();
            if (useClip) {
              unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins("afterDatasetDraw", args);
          }
          isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
          }
          getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options, useFinalPosition);
            }
            return [];
          }
          getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
            if (!meta) {
              meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
              };
              metasets.push(meta);
            }
            return meta;
          }
          getContext() {
            return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
              return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
          }
          setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
          }
          toggleDataVisibility(index3) {
            this._hiddenIndices[index3] = !this._hiddenIndices[index3];
          }
          getDataVisibility(index3) {
            return !this._hiddenIndices[index3];
          }
          _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? "show" : "hide";
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(void 0, mode);
            if (defined(dataIndex)) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
            } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, { visible });
              this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
            }
          }
          hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
          }
          show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
          }
          _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
              meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
          }
          _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._destroyDatasetMeta(i);
            }
          }
          destroy() {
            this.notifyPlugins("beforeDestroy");
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
              this.unbindEvents();
              clearCanvas(canvas, ctx);
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
            }
            this.notifyPlugins("destroy");
            delete instances[this.id];
            this.notifyPlugins("afterDestroy");
          }
          toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
          }
          bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
              this.bindResponsiveEvents();
            } else {
              this.attached = true;
            }
          }
          bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const listener = (e, x, y) => {
              e.offsetX = x;
              e.offsetY = y;
              this._eventHandler(e);
            };
            each(this.options.events, (type) => _add(type, listener));
          }
          bindResponsiveEvents() {
            if (!this._responsiveListeners) {
              this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const _remove = (type, listener2) => {
              if (listeners[type]) {
                platform.removeEventListener(this, type, listener2);
                delete listeners[type];
              }
            };
            const listener = (width, height) => {
              if (this.canvas) {
                this.resize(width, height);
              }
            };
            let detached;
            const attached = () => {
              _remove("attach", attached);
              this.attached = true;
              this.resize();
              _add("resize", listener);
              _add("detach", detached);
            };
            detached = () => {
              this.attached = false;
              _remove("resize", listener);
              this._stop();
              this._resize(0, 0);
              _add("attach", attached);
            };
            if (platform.isAttached(this.canvas)) {
              attached();
            } else {
              detached();
            }
          }
          unbindEvents() {
            each(this._listeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._responsiveListeners = void 0;
          }
          updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? "set" : "remove";
            let meta, item, i, ilen;
            if (mode === "dataset") {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller["_" + prefix + "DatasetHoverStyle"]();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
              }
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex, index: index3 }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("No dataset found at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index3],
                index: index3
              };
            });
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
            }
          }
          notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
          }
          _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
          }
          _eventHandler(e, replay) {
            const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e)
            };
            const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
            if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
              return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins("afterEvent", args, eventFilter);
            if (changed || args.changed) {
              this.render();
            }
            return this;
          }
          _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
            if (inChartArea) {
              this._lastEvent = null;
              callback(options.onHover, [e, active, this], this);
              if (isClick) {
                callback(options.onClick, [e, active, this], this);
              }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
          }
          _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
          }
        }
        const invalidatePlugins = () => each(Chart3.instances, (chart2) => chart2._plugins.invalidate());
        const enumerable = true;
        Object.defineProperties(Chart3, {
          defaults: {
            enumerable,
            value: defaults
          },
          instances: {
            enumerable,
            value: instances
          },
          overrides: {
            enumerable,
            value: overrides
          },
          registry: {
            enumerable,
            value: registry
          },
          version: {
            enumerable,
            value: version
          },
          getChart: {
            enumerable,
            value: getChart
          },
          register: {
            enumerable,
            value: (...items) => {
              registry.add(...items);
              invalidatePlugins();
            }
          },
          unregister: {
            enumerable,
            value: (...items) => {
              registry.remove(...items);
              invalidatePlugins();
            }
          }
        });
        function abstract() {
          throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapter {
          constructor(options) {
            this.options = options || {};
          }
          init(chartOptions) {
          }
          formats() {
            return abstract();
          }
          parse(value, format) {
            return abstract();
          }
          format(timestamp, format) {
            return abstract();
          }
          add(timestamp, amount, unit) {
            return abstract();
          }
          diff(a, b, unit) {
            return abstract();
          }
          startOf(timestamp, unit, weekday) {
            return abstract();
          }
          endOf(timestamp, unit) {
            return abstract();
          }
        }
        DateAdapter.override = function(members) {
          Object.assign(DateAdapter.prototype, members);
        };
        var _adapters = {
          _date: DateAdapter
        };
        function getAllScaleValues(scale, type) {
          if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
              values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
          }
          return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
          const scale = meta.iScale;
          const values = getAllScaleValues(scale, meta.type);
          let min = scale._length;
          let i, ilen, curr, prev;
          const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
              return;
            }
            if (defined(prev)) {
              min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
          };
          for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
          }
          prev = void 0;
          for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
          }
          return min;
        }
        function computeFitCategoryTraits(index3, ruler, options, stackCount) {
          const thickness = options.barThickness;
          let size, ratio;
          if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
          } else {
            size = thickness * stackCount;
            ratio = 1;
          }
          return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index3] - size / 2
          };
        }
        function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
          const pixels = ruler.pixels;
          const curr = pixels[index3];
          let prev = index3 > 0 ? pixels[index3 - 1] : null;
          let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
          const percent = options.categoryPercentage;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          const size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start
          };
        }
        function parseFloatBar(entry, item, vScale, i) {
          const startValue = vScale.parse(entry[0], i);
          const endValue = vScale.parse(entry[1], i);
          const min = Math.min(startValue, endValue);
          const max = Math.max(startValue, endValue);
          let barStart = min;
          let barEnd = max;
          if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
          }
          item[vScale.axis] = barEnd;
          item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max
          };
        }
        function parseValue(entry, item, vScale, i) {
          if (isArray(entry)) {
            parseFloatBar(entry, item, vScale, i);
          } else {
            item[vScale.axis] = vScale.parse(entry, i);
          }
          return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = [];
          let i, ilen, item, entry;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
          }
          return parsed;
        }
        function isFloatBar(custom) {
          return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
          if (size !== 0) {
            return sign(size);
          }
          return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
          let reverse, start, end, top, bottom;
          if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = "left";
            end = "right";
          } else {
            reverse = properties.base < properties.y;
            start = "bottom";
            end = "top";
          }
          if (reverse) {
            top = "end";
            bottom = "start";
          } else {
            top = "start";
            bottom = "end";
          }
          return { start, end, reverse, top, bottom };
        }
        function setBorderSkipped(properties, options, stack, index3) {
          let edge = options.borderSkipped;
          const res = {};
          if (!edge) {
            properties.borderSkipped = res;
            return;
          }
          if (edge === true) {
            properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
            return;
          }
          const { start, end, reverse, top, bottom } = borderProps(properties);
          if (edge === "middle" && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index3) {
              edge = top;
            } else if ((stack._bottom || 0) === index3) {
              edge = bottom;
            } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
            }
          }
          res[parseEdge(edge, start, end, reverse)] = true;
          properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
          if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
          } else {
            edge = startEnd(edge, a, b);
          }
          return edge;
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
          return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, { inflateAmount }, ratio) {
          properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
          parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseObjectData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
              parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            }
            return parsed;
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            super.updateRangeFromParsed(range2, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
              range2.min = Math.min(range2.min, custom.min);
              range2.max = Math.max(range2.max, custom.max);
            }
          }
          getMaxOverflow() {
            return 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
              label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
              value
            };
          }
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
          }
          update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
          }
          updateElements(bars, start, count, mode) {
            const reset2 = mode === "reset";
            const { index: index3, _cachedMeta: { vScale } } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            for (let i = start; i < start + count; i++) {
              const parsed = this.getParsed(i);
              const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index3 === stack._top || index3 === stack._bottom),
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index3);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
            }
          }
          _getStacks(last, dataIndex) {
            const { iScale } = this._cachedMeta;
            const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const skipNull = (meta) => {
              const parsed = meta.controller.getParsed(dataIndex);
              const val2 = parsed && parsed[meta.vScale.axis];
              if (isNullOrUndef(val2) || isNaN(val2)) {
                return true;
              }
            };
            for (const meta of metasets) {
              if (dataIndex !== void 0 && skipNull(meta)) {
                continue;
              }
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            if (!stacks.length) {
              stacks.push(void 0);
            }
            return stacks;
          }
          _getStackCount(index3) {
            return this._getStacks(void 0, index3).length;
          }
          _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index3 = name !== void 0 ? stacks.indexOf(name) : -1;
            return index3 === -1 ? stacks.length - 1 : index3;
          }
          _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
              pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            };
          }
          _calculateBarValuePixels(index3) {
            const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            let head, size;
            if (length !== value) {
              start = length - value;
              length = value;
            }
            if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
              }
              start += value;
            }
            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index3)) {
              head = vScale.getPixelForValue(start + length);
            } else {
              head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
            }
            if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
              base += halfGrid;
              size -= halfGrid;
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          }
          _calculateBarIndexPixels(index3, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
            let center, size;
            if (ruler.grouped) {
              const stackCount = skipNull ? this._getStackCount(index3) : ruler.stackCount;
              const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index3, ruler, options, stackCount) : computeFitCategoryTraits(index3, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index3 : void 0);
              center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
              size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
            } else {
              center = scale.getPixelForValue(this.getParsed(index3)[scale.axis], index3);
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          }
          draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
              if (this.getParsed(i)[vScale.axis] !== null) {
                rects[i].draw(this._ctx);
              }
            }
          }
        }
        BarController.id = "bar";
        BarController.defaults = {
          datasetElementType: false,
          dataElementType: "bar",
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          grouped: true,
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "base", "width", "height"]
            }
          }
        };
        BarController.overrides = {
          scales: {
            _index_: {
              type: "category",
              offset: true,
              grid: {
                offset: true
              }
            },
            _value_: {
              type: "linear",
              beginAtZero: true
            }
          }
        };
        class BubbleController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
          }
          parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index3);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
              label: meta.label,
              value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
            };
          }
          update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const parsed = !reset2 && this.getParsed(i);
              const properties = {};
              const iPixel = properties[iAxis] = reset2 ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
              const vPixel = properties[vAxis] = reset2 ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                if (reset2) {
                  properties.options.radius = 0;
                }
              }
              this.updateElement(point, i, properties, mode);
            }
          }
          resolveDataElementOptions(index3, mode) {
            const parsed = this.getParsed(index3);
            let values = super.resolveDataElementOptions(index3, mode);
            if (values.$shared) {
              values = Object.assign({}, values, { $shared: false });
            }
            const radius = values.radius;
            if (mode !== "active") {
              values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius);
            return values;
          }
        }
        BubbleController.id = "bubble";
        BubbleController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "borderWidth", "radius"]
            }
          }
        };
        BubbleController.overrides = {
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                }
              }
            }
          }
        };
        function getRatioAndOffset(rotation, circumference, cutout) {
          let ratioX = 1;
          let ratioY = 1;
          let offsetX = 0;
          let offsetY = 0;
          if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
          }
          return { ratioX, ratioY, offsetX, offsetY };
        }
        class DoughnutController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.offsetX = void 0;
            this.offsetY = void 0;
          }
          linkScales() {
          }
          parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
              meta._parsed = data;
            } else {
              let getter = (i2) => +data[i2];
              if (isObject2(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i2) => +resolveObjectKey(data[i2], key);
              }
              let i, ilen;
              for (i = start, ilen = start + count; i < ilen; ++i) {
                meta._parsed[i] = getter(i);
              }
            }
          }
          _getRotation() {
            return toRadians(this.options.rotation - 90);
          }
          _getCircumference() {
            return toRadians(this.options.circumference);
          }
          _getRotationExtents() {
            let min = TAU;
            let max = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
              }
            }
            return {
              rotation: min,
              circumference: max - min
            };
          }
          update(mode) {
            const chart2 = this.chart;
            const { chartArea } = chart2;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
            const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          _circumference(i, reset2) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
              return 0;
            }
            return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
          }
          updateElements(arcs, start, count, mode) {
            const reset2 = mode === "reset";
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset2 && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start; ++i) {
              startAngle += this._circumference(i, reset2);
            }
            for (i = start; i < start + count; ++i) {
              const circumference = this._circumference(i, reset2);
              const arc = arcs[i];
              const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
            }
          }
          calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
              const value = meta._parsed[i];
              if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
              }
            }
            return total;
          }
          calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
              return TAU * (Math.abs(value) / total);
            }
            return 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index3], chart2.options.locale);
            return {
              label: labels[index3] || "",
              value
            };
          }
          getMaxBorderWidth(arcs) {
            let max = 0;
            const chart2 = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
              for (i = 0, ilen = chart2.data.datasets.length; i < ilen; ++i) {
                if (chart2.isDatasetVisible(i)) {
                  meta = chart2.getDatasetMeta(i);
                  arcs = meta.data;
                  controller = meta.controller;
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== "inner") {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
              }
            }
            return max;
          }
          getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
              const options = this.resolveDataElementOptions(i);
              max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
            }
            return max;
          }
          _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          }
          _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
          }
          _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
          }
        }
        DoughnutController.id = "doughnut";
        DoughnutController.defaults = {
          datasetElementType: false,
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: false
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
          },
          cutout: "50%",
          rotation: 0,
          circumference: 360,
          radius: "100%",
          spacing: 0,
          indexAxis: "r"
        };
        DoughnutController.descriptors = {
          _scriptable: (name) => name !== "spacing",
          _indexable: (name) => name !== "spacing"
        };
        DoughnutController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(tooltipItem) {
                  let dataLabel = tooltipItem.label;
                  const value = ": " + tooltipItem.formattedValue;
                  if (isArray(dataLabel)) {
                    dataLabel = dataLabel.slice();
                    dataLabel[0] += value;
                  } else {
                    dataLabel += value;
                  }
                  return dataLabel;
                }
              }
            }
          }
        };
        class LineController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
            this.updateElements(points, start, count, mode);
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            const data = meta.data || [];
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
          draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
            super.draw();
          }
        }
        LineController.id = "line";
        LineController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          showLine: true,
          spanGaps: false
        };
        LineController.overrides = {
          scales: {
            _index_: {
              type: "category"
            },
            _value_: {
              type: "linear"
            }
          }
        };
        class PolarAreaController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.innerRadius = void 0;
            this.outerRadius = void 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index3].r, chart2.options.locale);
            return {
              label: labels[index3] || "",
              value
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          getMinMax() {
            const meta = this._cachedMeta;
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            meta.data.forEach((element, index3) => {
              const parsed = this.getParsed(index3).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
                if (parsed < range2.min) {
                  range2.min = parsed;
                }
                if (parsed > range2.max) {
                  range2.max = parsed;
                }
              }
            });
            return range2;
          }
          _updateRadius() {
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            const radiusLength = (outerRadius - innerRadius) / chart2.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
          }
          updateElements(arcs, start, count, mode) {
            const reset2 = mode === "reset";
            const chart2 = this.chart;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) {
              angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start; i < start + count; i++) {
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart2.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
              angle = endAngle;
              if (reset2) {
                if (animationOpts.animateScale) {
                  outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                  startAngle = endAngle = datasetStartAngle;
                }
              }
              const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
              };
              this.updateElement(arc, i, properties, mode);
            }
          }
          countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index3) => {
              if (!isNaN(this.getParsed(index3).r) && this.chart.getDataVisibility(index3)) {
                count++;
              }
            });
            return count;
          }
          _computeAngle(index3, mode, defaultAngle) {
            return this.chart.getDataVisibility(index3) ? toRadians(this.resolveDataElementOptions(index3, mode).angle || defaultAngle) : 0;
          }
        }
        PolarAreaController.id = "polarArea";
        PolarAreaController.defaults = {
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: true
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
          },
          indexAxis: "r",
          startAngle: 0
        };
        PolarAreaController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(context) {
                  return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
                }
              }
            }
          },
          scales: {
            r: {
              type: "radialLinear",
              angleLines: {
                display: false
              },
              beginAtZero: true,
              grid: {
                circular: true
              },
              pointLabels: {
                display: false
              },
              startAngle: 0
            }
          }
        };
        class PieController extends DoughnutController {
        }
        PieController.id = "pie";
        PieController.defaults = {
          cutout: 0,
          rotation: 0,
          circumference: 360,
          radius: "100%"
        };
        class RadarController extends DatasetController {
          getLabelAndValue(index3) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index3);
            return {
              label: vScale.getLabels()[index3],
              value: "" + vScale.getLabelForValue(parsed[vScale.axis])
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== "resize") {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                options.borderWidth = 0;
              }
              const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
              };
              this.updateElement(line, void 0, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset2 = mode === "reset";
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
              const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
              const x = reset2 ? scale.xCenter : pointPosition.x;
              const y = reset2 ? scale.yCenter : pointPosition.y;
              const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
              };
              this.updateElement(point, i, properties, mode);
            }
          }
        }
        RadarController.id = "radar";
        RadarController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          indexAxis: "r",
          showLine: true,
          elements: {
            line: {
              fill: "start"
            }
          }
        };
        RadarController.overrides = {
          aspectRatio: 1,
          scales: {
            r: {
              type: "radialLinear"
            }
          }
        };
        class ScatterController extends DatasetController {
          update(mode) {
            const meta = this._cachedMeta;
            const { data: points = [] } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            if (this.options.showLine) {
              const { dataset: line, _dataset } = meta;
              line._chart = this.chart;
              line._datasetIndex = this.index;
              line._decimated = !!_dataset._decimated;
              line.points = points;
              const options = this.resolveDatasetElementOptions(mode);
              options.segment = this.options.segment;
              this.updateElement(line, void 0, {
                animated: !animationsDisabled,
                options
              }, mode);
            }
            this.updateElements(points, start, count, mode);
          }
          addElements() {
            const { showLine } = this.options;
            if (!this.datasetElementType && showLine) {
              this.datasetElementType = registry.getElement("line");
            }
            super.addElements();
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
              let max = 0;
              for (let i = data.length - 1; i >= 0; --i) {
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
              }
              return max > 0 && max;
            }
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
        }
        ScatterController.id = "scatter";
        ScatterController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          showLine: false,
          fill: false
        };
        ScatterController.overrides = {
          interaction: {
            mode: "point"
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(item) {
                  return "(" + item.label + ", " + item.formattedValue + ")";
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          }
        };
        var controllers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          BarController,
          BubbleController,
          DoughnutController,
          LineController,
          PolarAreaController,
          PieController,
          RadarController,
          ScatterController
        });
        function clipArc(ctx, element, endAngle) {
          const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
          let angleMargin = pixelMargin / outerRadius;
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
          }
          ctx.closePath();
          ctx.clip();
        }
        function toRadiusCorners(value) {
          return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
          const o = toRadiusCorners(arc.options.borderRadius);
          const halfThickness = (outerRadius - innerRadius) / 2;
          const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
          const computeOuterLimit = (val2) => {
            const outerArcLimit = (outerRadius - Math.min(halfThickness, val2)) * angleDelta / 2;
            return _limitValue(val2, 0, Math.min(halfThickness, outerArcLimit));
          };
          return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
          };
        }
        function rThetaToXY(r, theta, x, y) {
          return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta)
          };
        }
        function pathArc(ctx, element, offset, spacing, end, circular) {
          const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
          const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
          const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
          let spacingOffset = 0;
          const alpha2 = end - start;
          if (spacing) {
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
            spacingOffset = (alpha2 - adjustedAngle) / 2;
          }
          const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
          const angleOffset = (alpha2 - beta) / 2;
          const startAngle = start + angleOffset + spacingOffset;
          const endAngle = end - angleOffset - spacingOffset;
          const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
          const outerStartAdjustedRadius = outerRadius - outerStart;
          const outerEndAdjustedRadius = outerRadius - outerEnd;
          const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
          const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
          const innerStartAdjustedRadius = innerRadius + innerStart;
          const innerEndAdjustedRadius = innerRadius + innerEnd;
          const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
          const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
          ctx.beginPath();
          if (circular) {
            ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
            if (outerEnd > 0) {
              const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
            }
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
            ctx.lineTo(p4.x, p4.y);
            if (innerEnd > 0) {
              const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
            }
            ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
            if (innerStart > 0) {
              const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
            }
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
            ctx.lineTo(p8.x, p8.y);
            if (outerStart > 0) {
              const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
            }
          } else {
            ctx.moveTo(x, y);
            const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerEndX, outerEndY);
          }
          ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
          const { fullCircles, startAngle, circumference } = element;
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.fill();
            }
            if (!isNaN(circumference)) {
              endAngle = startAngle + circumference % TAU;
              if (circumference % TAU === 0) {
                endAngle += TAU;
              }
            }
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.fill();
          return endAngle;
        }
        function drawFullCircleBorders(ctx, element, inner) {
          const { x, y, startAngle, pixelMargin, fullCircles } = element;
          const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
          const innerRadius = element.innerRadius + pixelMargin;
          let i;
          if (inner) {
            clipArc(ctx, element, startAngle + TAU);
          }
          ctx.beginPath();
          ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
          const { options } = element;
          const { borderWidth, borderJoinStyle } = options;
          const inner = options.borderAlign === "inner";
          if (!borderWidth) {
            return;
          }
          if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || "round";
          } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || "bevel";
          }
          if (element.fullCircles) {
            drawFullCircleBorders(ctx, element, inner);
          }
          if (inner) {
            clipArc(ctx, element, endAngle);
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.stroke();
        }
        class ArcElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.circumference = void 0;
            this.startAngle = void 0;
            this.endAngle = void 0;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(["x", "y"], useFinalPosition);
            const { angle, distance: distance2 } = getAngleFromPoint(point, { x: chartX, y: chartY });
            const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const rAdjust = this.options.spacing / 2;
            const _circumference = valueOrDefault(circumference, endAngle - startAngle);
            const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
            const withinRadius = _isBetween(distance2, innerRadius + rAdjust, outerRadius + rAdjust);
            return betweenAngles && withinRadius;
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y + Math.sin(halfAngle) * halfRadius
            };
          }
          tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
          }
          draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 2;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
            this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
              return;
            }
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
              radiusOffset = offset / 2;
              const halfAngle = (this.startAngle + this.endAngle) / 2;
              ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
              if (this.circumference >= PI) {
                radiusOffset = offset;
              }
            }
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
            drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
            ctx.restore();
          }
        }
        ArcElement.id = "arc";
        ArcElement.defaults = {
          borderAlign: "center",
          borderColor: "#fff",
          borderJoinStyle: void 0,
          borderRadius: 0,
          borderWidth: 2,
          offset: 0,
          spacing: 0,
          angle: void 0,
          circular: true
        };
        ArcElement.defaultRoutes = {
          backgroundColor: "backgroundColor"
        };
        function setStyle(ctx, options, style = options) {
          ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
          ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
          ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
          ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
          ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
          ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
          ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
          if (options.stepped) {
            return _steppedLineTo;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierCurveTo;
          }
          return lineTo;
        }
        function pathVars(points, segment, params = {}) {
          const count = points.length;
          const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
          const { start: segmentStart, end: segmentEnd } = segment;
          const start = Math.max(paramsStart, segmentStart);
          const end = Math.min(paramsEnd, segmentEnd);
          const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
          return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
          };
        }
        function pathSegment(ctx, line, segment, params) {
          const { points, options } = line;
          const { count, start, loop, ilen } = pathVars(points, segment, params);
          const lineMethod = getLineMethod(options);
          let { move: move2 = true, reverse } = params || {};
          let i, point, prev;
          for (i = 0; i <= ilen; ++i) {
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
              continue;
            } else if (move2) {
              ctx.moveTo(point.x, point.y);
              move2 = false;
            } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
          }
          if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
          const points = line.points;
          const { count, start, ilen } = pathVars(points, segment, params);
          const { move: move2 = true, reverse } = params || {};
          let avgX = 0;
          let countX = 0;
          let i, point, prevX, minY, maxY, lastY;
          const pointIndex = (index3) => (start + (reverse ? ilen - index3 : index3)) % count;
          const drawX = () => {
            if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
            }
          };
          if (move2) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
          }
          for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
              continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
              } else if (y > maxY) {
                maxY = y;
              }
              avgX = (countX * avgX + x) / ++countX;
            } else {
              drawX();
              ctx.lineTo(x, y);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
            }
            lastY = y;
          }
          drawX();
        }
        function _getSegmentMethod(line) {
          const opts = line.options;
          const borderDash = opts.borderDash && opts.borderDash.length;
          const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
          return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
          if (options.stepped) {
            return _steppedInterpolation;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierInterpolation;
          }
          return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
          let path = line._path;
          if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
              path.closePath();
            }
          }
          setStyle(ctx, line.options);
          ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
          const { segments, options } = line;
          const segmentMethod = _getSegmentMethod(line);
          for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
              ctx.closePath();
            }
            ctx.stroke();
          }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
          if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
          } else {
            strokePathDirect(ctx, line, start, count);
          }
        }
        class LineElement extends Element2 {
          constructor(cfg) {
            super();
            this.animated = true;
            this.options = void 0;
            this._chart = void 0;
            this._loop = void 0;
            this._fullLoop = void 0;
            this._path = void 0;
            this._points = void 0;
            this._segments = void 0;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
              this._pointsUpdated = true;
            }
          }
          set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
          }
          get points() {
            return this._points;
          }
          get segments() {
            return this._segments || (this._segments = _computeSegments(this, this.options.segment));
          }
          first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
          }
          last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
          }
          interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, { property, start: value, end: value });
            if (!segments.length) {
              return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
              const { start, end } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                result.push(p1);
                continue;
              }
              const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
          }
          pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
          }
          path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments) {
              loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
            }
            return !!loop;
          }
          draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
            }
            if (this.animated) {
              this._pointsUpdated = false;
              this._path = void 0;
            }
          }
        }
        LineElement.id = "line";
        LineElement.defaults = {
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 3,
          capBezierPoints: true,
          cubicInterpolationMode: "default",
          fill: false,
          spanGaps: false,
          stepped: false,
          tension: 0
        };
        LineElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        LineElement.descriptors = {
          _scriptable: true,
          _indexable: (name) => name !== "borderDash" && name !== "fill"
        };
        function inRange$1(el, pos, axis, useFinalPosition) {
          const options = el.options;
          const { [axis]: value } = el.getProps([axis], useFinalPosition);
          return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.parsed = void 0;
            this.skip = void 0;
            this.stop = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, "x", useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, "y", useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            const borderWidth = radius && options.borderWidth || 0;
            return (radius + borderWidth) * 2;
          }
          draw(ctx, area) {
            const options = this.options;
            if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
              return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
          }
          getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius;
          }
        }
        PointElement.id = "point";
        PointElement.defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: "circle",
          radius: 3,
          rotation: 0
        };
        PointElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        function getBarBounds(bar, useFinalPosition) {
          const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
          let left, right, top, bottom, half;
          if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
          } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
          }
          return { left, top, right, bottom };
        }
        function skipOrLimit(skip2, value, min, max) {
          return skip2 ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
          const value = bar.options.borderWidth;
          const skip2 = bar.borderSkipped;
          const o = toTRBL(value);
          return {
            t: skipOrLimit(skip2.top, o.top, 0, maxH),
            r: skipOrLimit(skip2.right, o.right, 0, maxW),
            b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip2.left, o.left, 0, maxW)
          };
        }
        function parseBorderRadius(bar, maxW, maxH) {
          const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
          const value = bar.options.borderRadius;
          const o = toTRBLCorners(value);
          const maxR = Math.min(maxW, maxH);
          const skip2 = bar.borderSkipped;
          const enableBorder = enableBorderRadius || isObject2(value);
          return {
            topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
            topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
            bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
            bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
          };
        }
        function boundingRects(bar) {
          const bounds = getBarBounds(bar);
          const width = bounds.right - bounds.left;
          const height = bounds.bottom - bounds.top;
          const border = parseBorderWidth(bar, width / 2, height / 2);
          const radius = parseBorderRadius(bar, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
              }
            }
          };
        }
        function inRange(bar, x, y, useFinalPosition) {
          const skipX = x === null;
          const skipY = y === null;
          const skipBoth = skipX && skipY;
          const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
          return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
          return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
          const x = rect.x !== refRect.x ? -amount : 0;
          const y = rect.y !== refRect.y ? -amount : 0;
          const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
          const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
          return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius
          };
        }
        class BarElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.horizontal = void 0;
            this.base = void 0;
            this.width = void 0;
            this.height = void 0;
            this.inflateAmount = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          draw(ctx) {
            const { inflateAmount, options: { borderColor, backgroundColor } } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill("evenodd");
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
            return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y : (y + base) / 2
            };
          }
          getRange(axis) {
            return axis === "x" ? this.width / 2 : this.height / 2;
          }
        }
        BarElement.id = "bar";
        BarElement.defaults = {
          borderSkipped: "start",
          borderWidth: 0,
          borderRadius: 0,
          inflateAmount: "auto",
          pointStyle: void 0
        };
        BarElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        var elements = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          ArcElement,
          LineElement,
          PointElement,
          BarElement
        });
        function lttbDecimation(data, start, count, availableWidth, options) {
          const samples = options.samples || availableWidth;
          if (samples >= count) {
            return data.slice(start, start + count);
          }
          const decimated = [];
          const bucketWidth = (count - 2) / (samples - 2);
          let sampledIndex = 0;
          const endIndex = start + count - 1;
          let a = start;
          let i, maxAreaPoint, maxArea, area, nextA;
          decimated[sampledIndex++] = data[a];
          for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j = avgRangeStart; j < avgRangeEnd; j++) {
              avgX += data[j].x;
              avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j = rangeOffs; j < rangeTo; j++) {
              area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
              if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
              }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
          }
          decimated[sampledIndex++] = data[endIndex];
          return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
          let avgX = 0;
          let countX = 0;
          let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
          const decimated = [];
          const endIndex = start + count - 1;
          const xMin = data[start].x;
          const xMax = data[endIndex].x;
          const dx = xMax - xMin;
          for (i = start; i < start + count; ++i) {
            point = data[i];
            x = (point.x - xMin) / dx * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
                minIndex = i;
              } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
            } else {
              const lastIndex = i - 1;
              if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
                    x: avgX
                  }));
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
                    x: avgX
                  }));
                }
              }
              if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
              minIndex = maxIndex = startIndex = i;
            }
          }
          return decimated;
        }
        function cleanDecimatedDataset(dataset) {
          if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, "data", { value: data });
          }
        }
        function cleanDecimatedData(chart2) {
          chart2.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
          });
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
          const pointCount = points.length;
          let start = 0;
          let count;
          const { iScale } = meta;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
          return { start, count };
        }
        var plugin_decimation = {
          id: "decimation",
          defaults: {
            algorithm: "min-max",
            enabled: false
          },
          beforeElementsUpdate: (chart2, args, options) => {
            if (!options.enabled) {
              cleanDecimatedData(chart2);
              return;
            }
            const availableWidth = chart2.width;
            chart2.data.datasets.forEach((dataset, datasetIndex) => {
              const { _data, indexAxis } = dataset;
              const meta = chart2.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (resolve([indexAxis, chart2.options.indexAxis]) === "y") {
                return;
              }
              if (!meta.controller.supportsDecimation) {
                return;
              }
              const xAxis = chart2.scales[meta.xAxisID];
              if (xAxis.type !== "linear" && xAxis.type !== "time") {
                return;
              }
              if (chart2.options.parsing) {
                return;
              }
              let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
              }
              if (isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                  configurable: true,
                  enumerable: true,
                  get: function() {
                    return this._decimated;
                  },
                  set: function(d) {
                    this._data = d;
                  }
                });
              }
              let decimated;
              switch (options.algorithm) {
                case "lttb":
                  decimated = lttbDecimation(data, start, count, availableWidth, options);
                  break;
                case "min-max":
                  decimated = minMaxDecimation(data, start, count, availableWidth);
                  break;
                default:
                  throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
              }
              dataset._decimated = decimated;
            });
          },
          destroy(chart2) {
            cleanDecimatedData(chart2);
          }
        };
        function _segments(line, target, property) {
          const segments = line.segments;
          const points = line.points;
          const tpoints = target.points;
          const parts = [];
          for (const segment of segments) {
            let { start, end } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
              parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
              });
              continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments) {
              const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
              const fillSources = _boundSegment(segment, points, subBounds);
              for (const fillSource of fillSources) {
                parts.push({
                  source: fillSource,
                  target: tgt,
                  start: {
                    [property]: _getEdge(bounds, subBounds, "start", Math.max)
                  },
                  end: {
                    [property]: _getEdge(bounds, subBounds, "end", Math.min)
                  }
                });
              }
            }
          }
          return parts;
        }
        function _getBounds(property, first, last, loop) {
          if (loop) {
            return;
          }
          let start = first[property];
          let end = last[property];
          if (property === "angle") {
            start = _normalizeAngle(start);
            end = _normalizeAngle(end);
          }
          return { property, start, end };
        }
        function _pointsFromSegments(boundary, line) {
          const { x = null, y = null } = boundary || {};
          const linePoints = line.points;
          const points = [];
          line.segments.forEach(({ start, end }) => {
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y !== null) {
              points.push({ x: first.x, y });
              points.push({ x: last.x, y });
            } else if (x !== null) {
              points.push({ x, y: first.y });
              points.push({ x, y: last.y });
            }
          });
          return points;
        }
        function _findSegmentEnd(start, end, points) {
          for (; end > start; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
            }
          }
          return end;
        }
        function _getEdge(a, b, prop, fn) {
          if (a && b) {
            return fn(a[prop], b[prop]);
          }
          return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
          let points = [];
          let _loop = false;
          if (isArray(boundary)) {
            _loop = true;
            points = boundary;
          } else {
            points = _pointsFromSegments(boundary, line);
          }
          return points.length ? new LineElement({
            points,
            options: { tension: 0 },
            _loop,
            _fullLoop: _loop
          }) : null;
        }
        function _shouldApplyFill(source) {
          return source && source.fill !== false;
        }
        function _resolveTarget(sources, index3, propagate) {
          const source = sources[index3];
          let fill2 = source.fill;
          const visited = [index3];
          let target;
          if (!propagate) {
            return fill2;
          }
          while (fill2 !== false && visited.indexOf(fill2) === -1) {
            if (!isNumberFinite(fill2)) {
              return fill2;
            }
            target = sources[fill2];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill2;
            }
            visited.push(fill2);
            fill2 = target.fill;
          }
          return false;
        }
        function _decodeFill(line, index3, count) {
          const fill2 = parseFillOption(line);
          if (isObject2(fill2)) {
            return isNaN(fill2.value) ? false : fill2;
          }
          let target = parseFloat(fill2);
          if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill2[0], index3, target, count);
          }
          return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
        }
        function decodeTargetIndex(firstCh, index3, target, count) {
          if (firstCh === "-" || firstCh === "+") {
            target = index3 + target;
          }
          if (target === index3 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        function _getTargetPixel(fill2, scale) {
          let pixel = null;
          if (fill2 === "start") {
            pixel = scale.bottom;
          } else if (fill2 === "end") {
            pixel = scale.top;
          } else if (isObject2(fill2)) {
            pixel = scale.getPixelForValue(fill2.value);
          } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
          }
          return pixel;
        }
        function _getTargetValue(fill2, scale, startValue) {
          let value;
          if (fill2 === "start") {
            value = startValue;
          } else if (fill2 === "end") {
            value = scale.options.reverse ? scale.min : scale.max;
          } else if (isObject2(fill2)) {
            value = fill2.value;
          } else {
            value = scale.getBaseValue();
          }
          return value;
        }
        function parseFillOption(line) {
          const options = line.options;
          const fillOption = options.fill;
          let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
          if (fill2 === void 0) {
            fill2 = !!options.backgroundColor;
          }
          if (fill2 === false || fill2 === null) {
            return false;
          }
          if (fill2 === true) {
            return "origin";
          }
          return fill2;
        }
        function _buildStackLine(source) {
          const { scale, index: index3, line } = source;
          const points = [];
          const segments = line.segments;
          const sourcePoints = line.points;
          const linesBelow = getLinesBelow(scale, index3);
          linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j = segment.start; j <= segment.end; j++) {
              addPointsBelow(points, sourcePoints[j], linesBelow);
            }
          }
          return new LineElement({ points, options: {} });
        }
        function getLinesBelow(scale, index3) {
          const below = [];
          const metas = scale.getMatchingVisibleMetas("line");
          for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index3) {
              break;
            }
            if (!meta.hidden) {
              below.unshift(meta.dataset);
            }
          }
          return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
          const postponed = [];
          for (let j = 0; j < linesBelow.length; j++) {
            const line = linesBelow[j];
            const { first, last, point } = findPoint(line, sourcePoint, "x");
            if (!point || first && last) {
              continue;
            }
            if (first) {
              postponed.unshift(point);
            } else {
              points.push(point);
              if (!last) {
                break;
              }
            }
          }
          points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
          const point = line.interpolate(sourcePoint, property);
          if (!point) {
            return {};
          }
          const pointValue = point[property];
          const segments = line.segments;
          const linePoints = line.points;
          let first = false;
          let last = false;
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
            }
          }
          return { first, last, point };
        }
        class simpleArc {
          constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
          }
          pathSegment(ctx, bounds, opts) {
            const { x, y, radius } = this;
            bounds = bounds || { start: 0, end: TAU };
            ctx.arc(x, y, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
          }
          interpolate(point) {
            const { x, y, radius } = this;
            const angle = point.angle;
            return {
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              angle
            };
          }
        }
        function _getTarget(source) {
          const { chart: chart2, fill: fill2, line } = source;
          if (isNumberFinite(fill2)) {
            return getLineByIndex(chart2, fill2);
          }
          if (fill2 === "stack") {
            return _buildStackLine(source);
          }
          if (fill2 === "shape") {
            return true;
          }
          const boundary = computeBoundary(source);
          if (boundary instanceof simpleArc) {
            return boundary;
          }
          return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart2, index3) {
          const meta = chart2.getDatasetMeta(index3);
          const visible = meta && chart2.isDatasetVisible(index3);
          return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
          const scale = source.scale || {};
          if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
          const { scale = {}, fill: fill2 } = source;
          const pixel = _getTargetPixel(fill2, scale);
          if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel
            };
          }
          return null;
        }
        function computeCircularBoundary(source) {
          const { scale, fill: fill2 } = source;
          const options = scale.options;
          const length = scale.getLabels().length;
          const start = options.reverse ? scale.max : scale.min;
          const value = _getTargetValue(fill2, scale, start);
          const target = [];
          if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value)
            });
          }
          for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
          }
          return target;
        }
        function _drawfill(ctx, source, area) {
          const target = _getTarget(source);
          const { line, scale, axis } = source;
          const lineOpts = line.options;
          const fillOption = lineOpts.fill;
          const color2 = lineOpts.backgroundColor;
          const { above = color2, below = color2 } = fillOption || {};
          if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, { line, target, above, below, area, scale, axis });
            unclipArea(ctx);
          }
        }
        function doFill(ctx, cfg) {
          const { line, target, above, below, area, scale } = cfg;
          const property = line._loop ? "angle" : cfg.axis;
          ctx.save();
          if (property === "x" && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, { line, target, color: above, scale, property });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
          }
          fill(ctx, { line, target, color: below, scale, property });
          ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
          const { segments, points } = target;
          let first = true;
          let lineLoop = false;
          ctx.beginPath();
          for (const segment of segments) {
            const { start, end } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
            } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
            if (lineLoop) {
              ctx.closePath();
            } else {
              ctx.lineTo(lastPoint.x, clipY);
            }
          }
          ctx.lineTo(target.first().x, clipY);
          ctx.closePath();
          ctx.clip();
        }
        function fill(ctx, cfg) {
          const { line, target, property, color: color2, scale } = cfg;
          const segments = _segments(line, target, property);
          for (const { source: src, target: tgt, start, end } of segments) {
            const { style: { backgroundColor = color2 } = {} } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
              if (lineLoop) {
                ctx.closePath();
              } else {
                interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
              loop = lineLoop && targetLoop;
              if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
              }
            }
            ctx.closePath();
            ctx.fill(loop ? "evenodd" : "nonzero");
            ctx.restore();
          }
        }
        function clipBounds(ctx, scale, bounds) {
          const { top, bottom } = scale.chart.chartArea;
          const { property, start, end } = bounds || {};
          if (property === "x") {
            ctx.beginPath();
            ctx.rect(start, top, end - start, bottom - top);
            ctx.clip();
          }
        }
        function interpolatedLineTo(ctx, target, point, property) {
          const interpolatedPoint = target.interpolate(point, property);
          if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
          }
        }
        var index2 = {
          id: "filler",
          afterDatasetsUpdate(chart2, _args, options) {
            const count = (chart2.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
              meta = chart2.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                source = {
                  visible: chart2.isDatasetVisible(i),
                  index: i,
                  fill: _decodeFill(line, i, count),
                  chart: chart2,
                  axis: meta.controller.options.indexAxis,
                  scale: meta.vScale,
                  line
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source || source.fill === false) {
                continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
            }
          },
          beforeDraw(chart2, _args, options) {
            const draw2 = options.drawTime === "beforeDraw";
            const metasets = chart2.getSortedVisibleDatasetMetas();
            const area = chart2.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (!source) {
                continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw2 && source.fill) {
                _drawfill(chart2.ctx, source, area);
              }
            }
          },
          beforeDatasetsDraw(chart2, _args, options) {
            if (options.drawTime !== "beforeDatasetsDraw") {
              return;
            }
            const metasets = chart2.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (_shouldApplyFill(source)) {
                _drawfill(chart2.ctx, source, chart2.chartArea);
              }
            }
          },
          beforeDatasetDraw(chart2, args, options) {
            const source = args.meta.$filler;
            if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
              return;
            }
            _drawfill(chart2.ctx, source, chart2.chartArea);
          },
          defaults: {
            propagate: true,
            drawTime: "beforeDatasetDraw"
          }
        };
        const getBoxSize = (labelOpts, fontSize) => {
          let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
          if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
          }
          return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight)
          };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends Element2 {
          constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = void 0;
            this.columnSizes = void 0;
            this.lineWidths = void 0;
            this.maxHeight = void 0;
            this.maxWidth = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.height = void 0;
            this.width = void 0;
            this._margins = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
            }
          }
          buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
            }
            if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
            }
            if (this.options.reverse) {
              legendItems.reverse();
            }
            this.legendItems = legendItems;
          }
          fit() {
            const { options, ctx } = this;
            if (!options.display) {
              this.width = this.height = 0;
              return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
              width = this.maxWidth;
              height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
              height = this.maxHeight;
              width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
          }
          _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxWidth, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const lineWidths = this.lineWidths = [0];
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
              }
              hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
          }
          _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxHeight, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const columnSizes = this.columnSizes = [];
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({ width: currentColWidth, height: currentColHeight });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({ width: currentColWidth, height: currentColHeight });
            return totalWidth;
          }
          adjustHitBoxes() {
            if (!this.options.display) {
              return;
            }
            const titleHeight = this._computeTitleHeight();
            const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
              let row = 0;
              let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                  row = hitbox.row;
                  left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
              }
            } else {
              let col = 0;
              let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                  col = hitbox.col;
                  top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
              }
            }
          }
          isHorizontal() {
            return this.options.position === "top" || this.options.position === "bottom";
          }
          draw() {
            if (this.options.display) {
              const ctx = this.ctx;
              clipArea(ctx, this);
              this._draw();
              unclipArea(ctx);
            }
          }
          _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor = defaults.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { color: fontColor, padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
            const drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
              }
              ctx.save();
              const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
              ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
              if (labelOpts.usePointStyle) {
                const drawOptions = {
                  radius: boxHeight * Math.SQRT2 / 2,
                  pointStyle: legendItem.pointStyle,
                  rotation: legendItem.rotation,
                  borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
              } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                  addRoundedRectPath(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                  });
                } else {
                  ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                  ctx.stroke();
                }
              }
              ctx.restore();
            };
            const fillText = function(x, y, legendItem) {
              renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
              });
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
              cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
              };
            } else {
              cursor = {
                x: this.left + padding,
                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
              };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
              ctx.strokeStyle = legendItem.fontColor || fontColor;
              ctx.fillStyle = legendItem.fontColor || fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                  y = cursor.y += lineHeight;
                  cursor.line++;
                  x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
              fillText(rtlHelper.x(x), y, legendItem);
              if (isHorizontal) {
                cursor.x += width + padding;
              } else {
                cursor.y += lineHeight;
              }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
          }
          drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
              return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y = this.top + topPaddingPlusHalfFontSize;
              left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
              const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
              y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = "middle";
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y, titleFont);
          }
          _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
          }
          _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
              lh = this.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                  return this.legendItems[i];
                }
              }
            }
            return null;
          }
          handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
              return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === "mousemove" || e.type === "mouseout") {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                callback(opts.onLeave, [e, previous, this], this);
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                callback(opts.onHover, [e, hoveredItem, this], this);
              }
            } else if (hoveredItem) {
              callback(opts.onClick, [e, hoveredItem, this], this);
            }
          }
        }
        function isListened(type, opts) {
          if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
            return true;
          }
          if (opts.onClick && (type === "click" || type === "mouseup")) {
            return true;
          }
          return false;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          start(chart2, _args, options) {
            const legend = chart2.legend = new Legend({ ctx: chart2.ctx, options, chart: chart2 });
            layouts.configure(chart2, legend, options);
            layouts.addBox(chart2, legend);
          },
          stop(chart2) {
            layouts.removeBox(chart2, chart2.legend);
            delete chart2.legend;
          },
          beforeUpdate(chart2, _args, options) {
            const legend = chart2.legend;
            layouts.configure(chart2, legend, options);
            legend.options = options;
          },
          afterUpdate(chart2) {
            const legend = chart2.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
          },
          afterEvent(chart2, args) {
            if (!args.replay) {
              chart2.legend.handleEvent(args.event);
            }
          },
          defaults: {
            display: true,
            position: "top",
            align: "center",
            fullSize: true,
            reverse: false,
            weight: 1e3,
            onClick(e, legendItem, legend) {
              const index3 = legendItem.datasetIndex;
              const ci = legend.chart;
              if (ci.isDatasetVisible(index3)) {
                ci.hide(index3);
                legendItem.hidden = true;
              } else {
                ci.show(index3);
                legendItem.hidden = false;
              }
            },
            onHover: null,
            onLeave: null,
            labels: {
              color: (ctx) => ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels(chart2) {
                const datasets = chart2.data.datasets;
                const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart2.legend.options;
                return chart2._getSortedDatasetMetas().map((meta) => {
                  const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  const borderWidth = toPadding(style.borderWidth);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    fontColor: color2,
                    hidden: !meta.visible,
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: (borderWidth.width + borderWidth.height) / 4,
                    strokeStyle: style.borderColor,
                    pointStyle: pointStyle || style.pointStyle,
                    rotation: style.rotation,
                    textAlign: textAlign || style.textAlign,
                    borderRadius: 0,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            },
            title: {
              color: (ctx) => ctx.chart.options.color,
              display: false,
              position: "center",
              text: ""
            }
          },
          descriptors: {
            _scriptable: (name) => !name.startsWith("on"),
            labels: {
              _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
            }
          }
        };
        class Title extends Element2 {
          constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
              this.height = textSize;
            } else {
              this.width = textSize;
            }
          }
          isHorizontal() {
            const pos = this.options.position;
            return pos === "top" || pos === "bottom";
          }
          _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
              titleX = _alignStartEnd(align, left, right);
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              if (options.position === "left") {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
              } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
              }
              maxWidth = bottom - top;
            }
            return { titleX, titleY, maxWidth, rotation };
          }
          draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
              return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
              color: opts.color,
              maxWidth,
              rotation,
              textAlign: _toLeftRightCenter(opts.align),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
        }
        function createTitle(chart2, titleOpts) {
          const title = new Title({
            ctx: chart2.ctx,
            options: titleOpts,
            chart: chart2
          });
          layouts.configure(chart2, title, titleOpts);
          layouts.addBox(chart2, title);
          chart2.titleBlock = title;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          start(chart2, _args, options) {
            createTitle(chart2, options);
          },
          stop(chart2) {
            const titleBlock = chart2.titleBlock;
            layouts.removeBox(chart2, titleBlock);
            delete chart2.titleBlock;
          },
          beforeUpdate(chart2, _args, options) {
            const title = chart2.titleBlock;
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "bold"
            },
            fullSize: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const map = new WeakMap();
        var plugin_subtitle = {
          id: "subtitle",
          start(chart2, _args, options) {
            const title = new Title({
              ctx: chart2.ctx,
              options,
              chart: chart2
            });
            layouts.configure(chart2, title, options);
            layouts.addBox(chart2, title);
            map.set(chart2, title);
          },
          stop(chart2) {
            layouts.removeBox(chart2, map.get(chart2));
            map.delete(chart2);
          },
          beforeUpdate(chart2, _args, options) {
            const title = map.get(chart2);
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "normal"
            },
            fullSize: true,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const positioners = {
          average(items) {
            if (!items.length) {
              return false;
            }
            let i, len;
            let x = 0;
            let y = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          nearest(items, eventPosition) {
            if (!items.length) {
              return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(chart2, item) {
          const { element, datasetIndex, index: index3 } = item;
          const controller = chart2.getDatasetMeta(datasetIndex).controller;
          const { label, value } = controller.getLabelAndValue(index3);
          return {
            chart: chart2,
            label,
            parsed: controller.getParsed(index3),
            raw: chart2.data.datasets[datasetIndex].data[index3],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index3,
            datasetIndex,
            element
          };
        }
        function getTooltipSize(tooltip, options) {
          const ctx = tooltip.chart.ctx;
          const { body, footer, title } = tooltip;
          const { boxWidth, boxHeight } = options;
          const bodyFont = toFont(options.bodyFont);
          const titleFont = toFont(options.titleFont);
          const footerFont = toFont(options.footerFont);
          const titleLineCount = title.length;
          const footerLineCount = footer.length;
          const bodyLineItemCount = body.length;
          const padding = toPadding(options.padding);
          let height = padding.height;
          let width = 0;
          let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
          combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
          if (titleLineCount) {
            height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
          }
          if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
            height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
          }
          if (footerLineCount) {
            height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
          }
          let widthPadding = 0;
          const maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.save();
          ctx.font = titleFont.string;
          each(tooltip.title, maxLineWidth);
          ctx.font = bodyFont.string;
          each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
          widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
          each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = footerFont.string;
          each(tooltip.footer, maxLineWidth);
          ctx.restore();
          width += padding.width;
          return { width, height };
        }
        function determineYAlign(chart2, size) {
          const { y, height } = size;
          if (y < height / 2) {
            return "top";
          } else if (y > chart2.height - height / 2) {
            return "bottom";
          }
          return "center";
        }
        function doesNotFitWithAlign(xAlign, chart2, options, size) {
          const { x, width } = size;
          const caret = options.caretSize + options.caretPadding;
          if (xAlign === "left" && x + width + caret > chart2.width) {
            return true;
          }
          if (xAlign === "right" && x - width - caret < 0) {
            return true;
          }
        }
        function determineXAlign(chart2, options, size, yAlign) {
          const { x, width } = size;
          const { width: chartWidth, chartArea: { left, right } } = chart2;
          let xAlign = "center";
          if (yAlign === "center") {
            xAlign = x <= (left + right) / 2 ? "left" : "right";
          } else if (x <= width / 2) {
            xAlign = "left";
          } else if (x >= chartWidth - width / 2) {
            xAlign = "right";
          }
          if (doesNotFitWithAlign(xAlign, chart2, options, size)) {
            xAlign = "center";
          }
          return xAlign;
        }
        function determineAlignment(chart2, options, size) {
          const yAlign = size.yAlign || options.yAlign || determineYAlign(chart2, size);
          return {
            xAlign: size.xAlign || options.xAlign || determineXAlign(chart2, options, size, yAlign),
            yAlign
          };
        }
        function alignX(size, xAlign) {
          let { x, width } = size;
          if (xAlign === "right") {
            x -= width;
          } else if (xAlign === "center") {
            x -= width / 2;
          }
          return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
          let { y, height } = size;
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= height + paddingAndSize;
          } else {
            y -= height / 2;
          }
          return y;
        }
        function getBackgroundPoint(options, size, alignment, chart2) {
          const { caretSize, caretPadding, cornerRadius } = options;
          const { xAlign, yAlign } = alignment;
          const paddingAndSize = caretSize + caretPadding;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
          let x = alignX(size, xAlign);
          const y = alignY(size, yAlign, paddingAndSize);
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x += Math.max(topRight, bottomRight) + caretSize;
          }
          return {
            x: _limitValue(x, 0, chart2.width - size.width),
            y: _limitValue(y, 0, chart2.height - size.height)
          };
        }
        function getAlignedX(tooltip, align, options) {
          const padding = toPadding(options.padding);
          return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback2) {
          return pushOrConcat([], splitNewlines(callback2));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
          return createContext(parent, {
            tooltip,
            tooltipItems,
            type: "tooltip"
          });
        }
        function overrideCallbacks(callbacks, context) {
          const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
          return override ? callbacks.override(override) : callbacks;
        }
        class Tooltip extends Element2 {
          constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = void 0;
            this._size = void 0;
            this._cachedAnimations = void 0;
            this._tooltipItems = [];
            this.$animations = void 0;
            this.$context = void 0;
            this.chart = config.chart || config._chart;
            this._chart = this.chart;
            this.options = config.options;
            this.dataPoints = void 0;
            this.title = void 0;
            this.beforeBody = void 0;
            this.body = void 0;
            this.afterBody = void 0;
            this.footer = void 0;
            this.xAlign = void 0;
            this.yAlign = void 0;
            this.x = void 0;
            this.y = void 0;
            this.height = void 0;
            this.width = void 0;
            this.caretX = void 0;
            this.caretY = void 0;
            this.labelColors = void 0;
            this.labelPointStyles = void 0;
            this.labelTextColors = void 0;
          }
          initialize(options) {
            this.options = options;
            this._cachedAnimations = void 0;
            this.$context = void 0;
          }
          _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
              return cached;
            }
            const chart2 = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts = options.enabled && chart2.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
          }
          getContext() {
            return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
          }
          getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
            const title = callbacks.title.apply(this, [context]);
            const afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          }
          getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
          }
          getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            each(tooltipItems, (context) => {
              const bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              const scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
              pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
              pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          }
          getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
          }
          getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
            const footer = callbacks.footer.apply(this, [tooltipItems]);
            const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          }
          _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index3, array) => options.filter(element, index3, array, data));
            }
            if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
            }
            each(tooltipItems, (context) => {
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(scoped.labelColor.call(this, context));
              labelPointStyles.push(scoped.labelPointStyle.call(this, context));
              labelTextColors.push(scoped.labelTextColor.call(this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
          }
          update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
              if (this.opacity !== 0) {
                properties = {
                  opacity: 0
                };
              }
            } else {
              const position = positioners[options.position].call(this, active, this._eventPosition);
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(this.chart, options, positionAndSize);
              const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
              };
            }
            this._tooltipItems = tooltipItems;
            this.$context = void 0;
            if (properties) {
              this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
              options.external.call(this, { chart: this.chart, tooltip: this, replay });
            }
          }
          drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          }
          getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
              x3 = x1;
            } else {
              if (xAlign === "left") {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                x2 = this.caretX;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
              }
              y3 = y1;
            }
            return { x1, x2, x3, y1, y2, y3 };
          }
          drawTitle(pt, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = "middle";
              titleFont = toFont(options.titleFont);
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                  pt.y += options.titleMarginBottom - titleSpacing;
                }
              }
            }
          }
          _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColors = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, "left", options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
              const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
              };
              const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              drawPoint(ctx, drawOptions, centerX, centerY);
              ctx.strokeStyle = labelColors.borderColor;
              ctx.fillStyle = labelColors.backgroundColor;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              ctx.lineWidth = isObject2(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
              ctx.strokeStyle = labelColors.borderColor;
              ctx.setLineDash(labelColors.borderDash || []);
              ctx.lineDashOffset = labelColors.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
              const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
              const borderRadius = toTRBLCorners(labelColors.borderRadius);
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                  x: outerX,
                  y: colorY,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: innerX,
                  y: colorY + 1,
                  w: boxWidth - 2,
                  h: boxHeight - 2,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
            }
            ctx.fillStyle = this.labelTextColors[i];
          }
          drawBody(pt, ctx, options) {
            const { body } = this;
            const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
              pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
              }
              each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          }
          drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.footerAlign, options);
              pt.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = "middle";
              footerFont = toFont(options.footerFont);
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
              }
            }
          }
          drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y } = pt;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === "top") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
              ctx.stroke();
            }
          }
          _updateAnimationTarget(options) {
            const chart2 = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
              const position = positioners[options.position].call(this, this._active, this._eventPosition);
              if (!position) {
                return;
              }
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(chart2, options, positionAndSize);
              const point = getBackgroundPoint(options, positionAndSize, alignment, chart2);
              if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
              }
            }
          }
          _willRender() {
            return !!this.opacity;
          }
          draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
              return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
              width: this.width,
              height: this.height
            };
            const pt = {
              x: this.x,
              y: this.y
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, ctx, tooltipSize, options);
              overrideTextDirection(ctx, options.textDirection);
              pt.y += padding.top;
              this.drawTitle(pt, ctx, options);
              this.drawBody(pt, ctx, options);
              this.drawFooter(pt, ctx, options);
              restoreTextDirection(ctx, options.textDirection);
              ctx.restore();
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex, index: index3 }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("Cannot find a dataset at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index3],
                index: index3
              };
            });
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(active, eventPosition);
            if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
            }
          }
          handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
              return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(e, lastActive, replay, inChartArea);
            const positionChanged = this._positionChanged(active, e);
            const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
            if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                this._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                this.update(true, replay);
              }
            }
            return changed;
          }
          _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
            if (options.reverse) {
              active.reverse();
            }
            return active;
          }
          _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(this, active, e);
            return position !== false && (caretX !== position.x || caretY !== position.y);
          }
        }
        Tooltip.positioners = positioners;
        var plugin_tooltip = {
          id: "tooltip",
          _element: Tooltip,
          positioners,
          afterInit(chart2, _args, options) {
            if (options) {
              chart2.tooltip = new Tooltip({ chart: chart2, options });
            }
          },
          beforeUpdate(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          reset(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          afterDraw(chart2) {
            const tooltip = chart2.tooltip;
            if (tooltip && tooltip._willRender()) {
              const args = {
                tooltip
              };
              if (chart2.notifyPlugins("beforeTooltipDraw", args) === false) {
                return;
              }
              tooltip.draw(chart2.ctx);
              chart2.notifyPlugins("afterTooltipDraw", args);
            }
          },
          afterEvent(chart2, args) {
            if (chart2.tooltip) {
              const useFinalPosition = args.replay;
              if (chart2.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
              }
            }
          },
          defaults: {
            enabled: true,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
              weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
              weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: true,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
              duration: 400,
              easing: "easeOutQuart"
            },
            animations: {
              numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
              },
              opacity: {
                easing: "linear",
                duration: 200
              }
            },
            callbacks: {
              beforeTitle: noop2,
              title(tooltipItems) {
                if (tooltipItems.length > 0) {
                  const item = tooltipItems[0];
                  const labels = item.chart.data.labels;
                  const labelCount = labels ? labels.length : 0;
                  if (this && this.options && this.options.mode === "dataset") {
                    return item.dataset.label || "";
                  } else if (item.label) {
                    return item.label;
                  } else if (labelCount > 0 && item.dataIndex < labelCount) {
                    return labels[item.dataIndex];
                  }
                }
                return "";
              },
              afterTitle: noop2,
              beforeBody: noop2,
              beforeLabel: noop2,
              label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") {
                  return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                }
                let label = tooltipItem.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) {
                  label += value;
                }
                return label;
              },
              labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  borderColor: options.borderColor,
                  backgroundColor: options.backgroundColor,
                  borderWidth: options.borderWidth,
                  borderDash: options.borderDash,
                  borderDashOffset: options.borderDashOffset,
                  borderRadius: 0
                };
              },
              labelTextColor() {
                return this.options.bodyColor;
              },
              labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  pointStyle: options.pointStyle,
                  rotation: options.rotation
                };
              },
              afterLabel: noop2,
              afterBody: noop2,
              beforeFooter: noop2,
              footer: noop2,
              afterFooter: noop2
            }
          },
          defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
          },
          descriptors: {
            _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
            _indexable: false,
            callbacks: {
              _scriptable: false,
              _indexable: false
            },
            animation: {
              _fallback: false
            },
            animations: {
              _fallback: "animation"
            }
          },
          additionalOptionScopes: ["interaction"]
        };
        var plugins = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Decimation: plugin_decimation,
          Filler: index2,
          Legend: plugin_legend,
          SubTitle: plugin_subtitle,
          Title: plugin_title,
          Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index3, addedLabels) => {
          if (typeof raw === "string") {
            index3 = labels.push(raw) - 1;
            addedLabels.unshift({ index: index3, label: raw });
          } else if (isNaN(raw)) {
            index3 = null;
          }
          return index3;
        };
        function findOrAddLabel(labels, raw, index3, addedLabels) {
          const first = labels.indexOf(raw);
          if (first === -1) {
            return addIfString(labels, raw, index3, addedLabels);
          }
          const last = labels.lastIndexOf(raw);
          return first !== last ? index3 : first;
        }
        const validIndex = (index3, max) => index3 === null ? null : _limitValue(Math.round(index3), 0, max);
        class CategoryScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this._startValue = void 0;
            this._valueRange = 0;
            this._addedLabels = [];
          }
          init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
              const labels = this.getLabels();
              for (const { index: index3, label } of added) {
                if (labels[index3] === label) {
                  labels.splice(index3, 1);
                }
              }
              this._addedLabels = [];
            }
            super.init(scaleOptions);
          }
          parse(raw, index3) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            const labels = this.getLabels();
            index3 = isFinite(index3) && labels[index3] === raw ? index3 : findOrAddLabel(labels, raw, valueOrDefault(index3, raw), this._addedLabels);
            return validIndex(index3, labels.length - 1);
          }
          determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this.getMinMax(true);
            if (this.options.bounds === "ticks") {
              if (!minDefined) {
                min = 0;
              }
              if (!maxDefined) {
                max = this.getLabels().length - 1;
              }
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min; value <= max; value++) {
              ticks.push({ value });
            }
            return ticks;
          }
          getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) {
              return labels[value];
            }
            return value;
          }
          configure() {
            super.configure();
            if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
            }
          }
          getPixelForValue(value) {
            if (typeof value !== "number") {
              value = this.parse(value);
            }
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index3].value);
          }
          getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
          }
          getBasePixel() {
            return this.bottom;
          }
        }
        CategoryScale.id = "category";
        CategoryScale.defaults = {
          ticks: {
            callback: CategoryScale.prototype.getLabelForValue
          }
        };
        function generateTicks$1(generationOptions, dataRange) {
          const ticks = [];
          const MIN_SPACING = 1e-14;
          const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
          const unit = step || 1;
          const maxSpaces = maxTicks - 1;
          const { min: rmin, max: rmax } = dataRange;
          const minDefined = !isNullOrUndef(min);
          const maxDefined = !isNullOrUndef(max);
          const countDefined = !isNullOrUndef(count);
          const minSpacing = (rmax - rmin) / (maxDigits + 1);
          let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
          let factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [{ value: rmin }, { value: rmax }];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxSpaces) {
            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
          }
          if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          if (bounds === "ticks") {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
          } else {
            niceMin = rmin;
            niceMax = rmax;
          }
          if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
          } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
          } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
              numSpaces = Math.round(numSpaces);
            } else {
              numSpaces = Math.ceil(numSpaces);
            }
          }
          const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
          factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          let j = 0;
          if (minDefined) {
            if (includeBounds && niceMin !== min) {
              ticks.push({ value: min });
              if (niceMin < min) {
                j++;
              }
              if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
              }
            } else if (niceMin < min) {
              j++;
            }
          }
          for (; j < numSpaces; ++j) {
            ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
          }
          if (maxDefined && includeBounds && niceMax !== max) {
            if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
              ticks[ticks.length - 1].value = max;
            } else {
              ticks.push({ value: max });
            }
          } else if (!maxDefined || niceMax === max) {
            ticks.push({ value: niceMax });
          }
          return ticks;
        }
        function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
          const rad = toRadians(minRotation);
          const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
          const length = 0.75 * minSpacing * ("" + value).length;
          return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._endValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index3) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
              return null;
            }
            return +raw;
          }
          handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            if (beginAtZero) {
              const minSign = sign(min);
              const maxSign = sign(max);
              if (minSign < 0 && maxSign < 0) {
                setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
              }
            }
            if (min === max) {
              let offset = 1;
              if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
                offset = Math.abs(max * 0.05);
              }
              setMax(max + offset);
              if (!beginAtZero) {
                setMin(min - offset);
              }
            }
            this.min = min;
            this.max = max;
          }
          getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
              if (maxTicks > 1e3) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1e3;
              }
            } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
          }
          getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
        }
        class LinearScale extends LinearScaleBase {
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? min : 0;
            this.max = isNumberFinite(max) ? max : 1;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
          }
          getPixelForValue(value) {
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          }
        }
        LinearScale.id = "linear";
        LinearScale.defaults = {
          ticks: {
            callback: Ticks.formatters.numeric
          }
        };
        function isMajor(tickVal) {
          const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
          return remain === 1;
        }
        function generateTicks(generationOptions, dataRange) {
          const endExp = Math.floor(log10(dataRange.max));
          const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          const ticks = [];
          let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          let exp = Math.floor(log10(tickVal));
          let significand = Math.floor(tickVal / Math.pow(10, exp));
          let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push({ value: tickVal, major: isMajor(tickVal) });
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          const lastTick = finiteOrDefault(generationOptions.max, tickVal);
          ticks.push({ value: lastTick, major: isMajor(tickVal) });
          return ticks;
        }
        class LogarithmicScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index3) {
            const value = LinearScaleBase.prototype.parse.apply(this, [raw, index3]);
            if (value === 0) {
              this._zero = true;
              return void 0;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null;
            this.max = isNumberFinite(max) ? Math.max(0, max) : null;
            if (this.options.beginAtZero) {
              this._zero = true;
            }
            this.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            if (min === max) {
              if (min <= 0) {
                setMin(1);
                setMax(10);
              } else {
                setMin(exp(min, -1));
                setMax(exp(max, 1));
              }
            }
            if (min <= 0) {
              setMin(exp(max, -1));
            }
            if (max <= 0) {
              setMax(exp(min, 1));
            }
            if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
              setMin(exp(min, -1));
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const opts = this.options;
            const generationOptions = {
              min: this._userMin,
              max: this._userMax
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          getLabelForValue(value) {
            return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
          configure() {
            const start = this.min;
            super.configure();
            this._startValue = log10(start);
            this._valueRange = log10(this.max) - log10(start);
          }
          getPixelForValue(value) {
            if (value === void 0 || value === 0) {
              value = this.min;
            }
            if (value === null || isNaN(value)) {
              return NaN;
            }
            return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
          }
        }
        LogarithmicScale.id = "logarithmic";
        LogarithmicScale.defaults = {
          ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
              enabled: true
            }
          }
        };
        function getTickBackdropHeight(opts) {
          const tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
          }
          return 0;
        }
        function measureLabelSize(ctx, font, label) {
          label = isArray(label) ? label : [label];
          return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale) {
          const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom
          };
          const limits = Object.assign({}, orig);
          const labelSizes = [];
          const padding = [];
          const valueCount = scale._pointLabels.length;
          const pointLabelOpts = scale.options.pointLabels;
          const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
          }
          scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
          scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
          const sin = Math.abs(Math.sin(angle));
          const cos = Math.abs(Math.cos(angle));
          let x = 0;
          let y = 0;
          if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
          } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
          }
          if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
          } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
          }
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
          const items = [];
          const valueCount = scale._pointLabels.length;
          const opts = scale.options;
          const extra = getTickBackdropHeight(opts) / 2;
          const outerDistance = scale.drawingArea;
          const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const size = labelSizes[i];
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            items.push({
              x: pointLabelPosition.x,
              y,
              textAlign,
              left,
              top: y,
              right: left + size.w,
              bottom: y + size.h
            });
          }
          return items;
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function leftForTextAlign(x, w, align) {
          if (align === "right") {
            x -= w;
          } else if (align === "center") {
            x -= w / 2;
          }
          return x;
        }
        function yForAngle(y, h, angle) {
          if (angle === 90 || angle === 270) {
            y -= h / 2;
          } else if (angle > 270 || angle < 90) {
            y -= h;
          }
          return y;
        }
        function drawPointLabels(scale, labelCount) {
          const { ctx, options: { pointLabels } } = scale;
          for (let i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
            const plFont = toFont(optsAtIndex.font);
            const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
            const { backdropColor } = optsAtIndex;
            if (!isNullOrUndef(backdropColor)) {
              const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillStyle = backdropColor;
              const backdropLeft = left - padding.left;
              const backdropTop = top - padding.top;
              const backdropWidth = right - left + padding.width;
              const backdropHeight = bottom - top + padding.height;
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
              }
            }
            renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
              color: optsAtIndex.color,
              textAlign,
              textBaseline: "middle"
            });
          }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
          const { ctx } = scale;
          if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
          } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
          const ctx = scale.ctx;
          const circular = gridLineOpts.circular;
          const { color: color2, lineWidth } = gridLineOpts;
          if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = color2;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(gridLineOpts.borderDash);
          ctx.lineDashOffset = gridLineOpts.borderDashOffset;
          ctx.beginPath();
          pathRadiusLine(scale, radius, circular, labelCount);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function createPointLabelContext(parent, index3, label) {
          return createContext(parent, {
            label,
            index: index3,
            type: "pointLabel"
          });
        }
        class RadialLinearScale extends LinearScaleBase {
          constructor(cfg) {
            super(cfg);
            this.xCenter = void 0;
            this.yCenter = void 0;
            this.drawingArea = void 0;
            this._pointLabels = [];
            this._pointLabelItems = [];
          }
          setDimensions() {
            const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
            const w = this.width = this.maxWidth - padding.width;
            const h = this.height = this.maxHeight - padding.height;
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(false);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
            this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          }
          generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels().map((value, index3) => {
              const label = callback(this.options.pointLabels.callback, [value, index3], this);
              return label || label === 0 ? label : "";
            }).filter((v, i) => this.chart.getDataVisibility(i));
          }
          fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              this.setCenterPoint(0, 0, 0, 0);
            }
          }
          setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
          }
          getIndexAngle(index3) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(index3 * angleMultiplier + toRadians(startAngle));
          }
          getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
              return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
          }
          getValueForDistanceFromCenter(distance2) {
            if (isNullOrUndef(distance2)) {
              return NaN;
            }
            const scaledDistance = distance2 / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
          }
          getPointLabelContext(index3) {
            const pointLabels = this._pointLabels || [];
            if (index3 >= 0 && index3 < pointLabels.length) {
              const pointLabel = pointLabels[index3];
              return createPointLabelContext(this.getContext(), index3, pointLabel);
            }
          }
          getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
            const angle = this.getIndexAngle(index3) - HALF_PI + additionalAngle;
            return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle
            };
          }
          getPointPositionForValue(index3, value) {
            return this.getPointPosition(index3, this.getDistanceFromCenterForValue(value));
          }
          getBasePosition(index3) {
            return this.getPointPositionForValue(index3 || 0, this.getBaseValue());
          }
          getPointLabelPosition(index3) {
            const { left, top, right, bottom } = this._pointLabelItems[index3];
            return {
              left,
              top,
              right,
              bottom
            };
          }
          drawBackground() {
            const { backgroundColor, grid: { circular } } = this.options;
            if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
            }
          }
          drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
            }
            if (grid.display) {
              this.ticks.forEach((tick, index3) => {
                if (index3 !== 0) {
                  offset = this.getDistanceFromCenterForValue(tick.value);
                  const optsAtIndex = grid.setContext(this.getContext(index3 - 1));
                  drawRadiusLine(this, optsAtIndex, offset, labelCount);
                }
              });
            }
            if (angleLines.display) {
              ctx.save();
              for (i = labelCount - 1; i >= 0; i--) {
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color: color2, lineWidth } = optsAtIndex;
                if (!lineWidth || !color2) {
                  continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color2;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          drawBorder() {
          }
          drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.ticks.forEach((tick, index3) => {
              if (index3 === 0 && !opts.reverse) {
                return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index3));
              const tickFont = toFont(optsAtIndex.font);
              offset = this.getDistanceFromCenterForValue(this.ticks[index3].value);
              if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color
              });
            });
            ctx.restore();
          }
          drawTitle() {
          }
        }
        RadialLinearScale.id = "radialLinear";
        RadialLinearScale.defaults = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          grid: {
            circular: false
          },
          startAngle: 0,
          ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric
          },
          pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: true,
            font: {
              size: 10
            },
            callback(label) {
              return label;
            },
            padding: 5,
            centerPointLabels: false
          }
        };
        RadialLinearScale.defaultRoutes = {
          "angleLines.color": "borderColor",
          "pointLabels.color": "color",
          "ticks.color": "color"
        };
        RadialLinearScale.descriptors = {
          angleLines: {
            _fallback: "grid"
          }
        };
        const INTERVALS = {
          millisecond: { common: true, size: 1, steps: 1e3 },
          second: { common: true, size: 1e3, steps: 60 },
          minute: { common: true, size: 6e4, steps: 60 },
          hour: { common: true, size: 36e5, steps: 24 },
          day: { common: true, size: 864e5, steps: 30 },
          week: { common: false, size: 6048e5, steps: 4 },
          month: { common: true, size: 2628e6, steps: 12 },
          quarter: { common: false, size: 7884e6, steps: 4 },
          year: { common: true, size: 3154e7 }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function parse(scale, input) {
          if (isNullOrUndef(input)) {
            return null;
          }
          const adapter = scale._adapter;
          const { parser, round: round2, isoWeekday } = scale._parseOpts;
          let value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!isNumberFinite(value)) {
            value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
          }
          if (value === null) {
            return null;
          }
          if (round2) {
            value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
          }
          return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          const ilen = UNITS.length;
          for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
          for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function addTick(ticks, time, timestamps) {
          if (!timestamps) {
            ticks[time] = true;
          } else if (timestamps.length) {
            const { lo, hi } = _lookup(timestamps, time);
            const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
          }
        }
        function setMajorTicks(scale, ticks, map2, majorUnit) {
          const adapter = scale._adapter;
          const first = +adapter.startOf(ticks[0].value, majorUnit);
          const last = ticks[ticks.length - 1].value;
          let major, index3;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index3 = map2[major];
            if (index3 >= 0) {
              ticks[index3].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
          const ticks = [];
          const map2 = {};
          const ilen = values.length;
          let i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map2[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
        }
        class TimeScale extends Scale {
          constructor(props) {
            super(props);
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
            this._unit = "day";
            this._majorUnit = void 0;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = void 0;
          }
          init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
            adapter.init(opts);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
          }
          parse(raw, index3) {
            if (raw === void 0) {
              return null;
            }
            return parse(this, raw);
          }
          beforeLayout() {
            super.beforeLayout();
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
          }
          determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || "day";
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
              }
            }
            if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
                _applyBounds(this.getMinMax(false));
              }
            }
            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
          }
          _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
            }
            return { min, max };
          }
          buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
            if (options.bounds === "ticks" && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = _filterBetween(timestamps, min, max);
            this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
            this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
          }
          afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
          }
          initOffsets(timestamps) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                start = 1 - first;
              } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                end = last;
              } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
              }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = _limitValue(start, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = { start, end, factor: 1 / (start + 1 + end) };
          }
          _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
            const stepSize = valueOrDefault(timeOpts.stepSize, 1);
            const weekday = minor === "week" ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
              first = +adapter.startOf(first, "isoWeek", weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? "day" : minor);
            if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
              throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
            }
            const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
              addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === "ticks" || count === 1) {
              addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
          }
          getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
          }
          _tickFormatFunction(time, index3, ticks, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index3];
            const major = majorUnit && majorFormat && tick && tick.major;
            const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            const formatter = options.ticks.callback;
            return formatter ? callback(formatter, [label, index3, ticks], this) : label;
          }
          generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
          }
          getDecimalForValue(value) {
            return value === null ? NaN : (value - this.min) / (this.max - this.min);
          }
          getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
          }
          _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          }
          _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
            const size = this._getLabelSize(exampleLabel);
            const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1;
          }
          getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
              return this._cache.data = metas[0].controller.getAllParsedValues(this);
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            }
            return this._cache.data = this.normalize(timestamps);
          }
          getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              timestamps.push(parse(this, labels[i]));
            }
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
          }
          normalize(values) {
            return _arrayUnique(values.sort(sorter));
          }
        }
        TimeScale.id = "time";
        TimeScale.defaults = {
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        function interpolate(table, val2, reverse) {
          let lo = 0;
          let hi = table.length - 1;
          let prevSource, nextSource, prevTarget, nextTarget;
          if (reverse) {
            if (val2 >= table[lo].pos && val2 <= table[hi].pos) {
              ({ lo, hi } = _lookupByKey(table, "pos", val2));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo]);
            ({ pos: nextSource, time: nextTarget } = table[hi]);
          } else {
            if (val2 >= table[lo].time && val2 <= table[hi].time) {
              ({ lo, hi } = _lookupByKey(table, "time", val2));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo]);
            ({ time: nextSource, pos: nextTarget } = table[hi]);
          }
          const span = nextSource - prevSource;
          return span ? prevTarget + (nextTarget - prevTarget) * (val2 - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
          constructor(props) {
            super(props);
            this._table = [];
            this._minPos = void 0;
            this._tableRange = void 0;
          }
          initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
          }
          buildLookupTable(timestamps) {
            const { min, max } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                items.push(curr);
              }
            }
            if (items.length < 2) {
              return [
                { time: min, pos: 0 },
                { time: max, pos: 1 }
              ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                table.push({ time: curr, pos: i / (ilen - 1) });
              }
            }
            return table;
          }
          _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
              return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
            } else {
              timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
          }
          getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange;
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
          }
        }
        TimeSeriesScale.id = "timeseries";
        TimeSeriesScale.defaults = TimeScale.defaults;
        var scales = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          CategoryScale,
          LinearScale,
          LogarithmicScale,
          RadialLinearScale,
          TimeScale,
          TimeSeriesScale
        });
        Chart3.register(controllers, scales, elements, plugins);
        Chart3.helpers = __spreadValues({}, helpers);
        Chart3._adapters = _adapters;
        Chart3.Animation = Animation;
        Chart3.Animations = Animations;
        Chart3.animator = animator;
        Chart3.controllers = registry.controllers.items;
        Chart3.DatasetController = DatasetController;
        Chart3.Element = Element2;
        Chart3.elements = elements;
        Chart3.Interaction = Interaction;
        Chart3.layouts = layouts;
        Chart3.platforms = platforms;
        Chart3.Scale = Scale;
        Chart3.Ticks = Ticks;
        Object.assign(Chart3, controllers, scales, elements, plugins, platforms);
        Chart3.Chart = Chart3;
        if (typeof window !== "undefined") {
          window.Chart = Chart3;
        }
        return Chart3;
      });
    }
  });

  // node_modules/chart.js/helpers/helpers.js
  var require_helpers = __commonJS({
    "node_modules/chart.js/helpers/helpers.js"(exports, module) {
      module.exports = require_chart().helpers;
    }
  });

  // node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js
  var require_chartjs_plugin_datalabels = __commonJS({
    "node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_helpers(), require_chart()) : typeof define === "function" && define.amd ? define(["chart.js/helpers", "chart.js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.ChartDataLabels = factory(global2.Chart.helpers, global2.Chart));
      })(exports, function(helpers, chart_js) {
        "use strict";
        var devicePixelRatio = function() {
          if (typeof window !== "undefined") {
            if (window.devicePixelRatio) {
              return window.devicePixelRatio;
            }
            var screen = window.screen;
            if (screen) {
              return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
          }
          return 1;
        }();
        var utils = {
          toTextLines: function(inputs) {
            var lines = [];
            var input;
            inputs = [].concat(inputs);
            while (inputs.length) {
              input = inputs.pop();
              if (typeof input === "string") {
                lines.unshift.apply(lines, input.split("\n"));
              } else if (Array.isArray(input)) {
                inputs.push.apply(inputs, input);
              } else if (!helpers.isNullOrUndef(inputs)) {
                lines.unshift("" + input);
              }
            }
            return lines;
          },
          textSize: function(ctx, lines, font) {
            var items = [].concat(lines);
            var ilen = items.length;
            var prev = ctx.font;
            var width = 0;
            var i;
            ctx.font = font.string;
            for (i = 0; i < ilen; ++i) {
              width = Math.max(ctx.measureText(items[i]).width, width);
            }
            ctx.font = prev;
            return {
              height: ilen * font.lineHeight,
              width
            };
          },
          bound: function(min, value, max) {
            return Math.max(min, Math.min(value, max));
          },
          arrayDiff: function(a0, a1) {
            var prev = a0.slice();
            var updates = [];
            var i, j, ilen, v;
            for (i = 0, ilen = a1.length; i < ilen; ++i) {
              v = a1[i];
              j = prev.indexOf(v);
              if (j === -1) {
                updates.push([v, 1]);
              } else {
                prev.splice(j, 1);
              }
            }
            for (i = 0, ilen = prev.length; i < ilen; ++i) {
              updates.push([prev[i], -1]);
            }
            return updates;
          },
          rasterize: function(v) {
            return Math.round(v * devicePixelRatio) / devicePixelRatio;
          }
        };
        function orient(point, origin) {
          var x0 = origin.x;
          var y0 = origin.y;
          if (x0 === null) {
            return { x: 0, y: -1 };
          }
          if (y0 === null) {
            return { x: 1, y: 0 };
          }
          var dx = point.x - x0;
          var dy = point.y - y0;
          var ln = Math.sqrt(dx * dx + dy * dy);
          return {
            x: ln ? dx / ln : 0,
            y: ln ? dy / ln : -1
          };
        }
        function aligned(x, y, vx, vy, align) {
          switch (align) {
            case "center":
              vx = vy = 0;
              break;
            case "bottom":
              vx = 0;
              vy = 1;
              break;
            case "right":
              vx = 1;
              vy = 0;
              break;
            case "left":
              vx = -1;
              vy = 0;
              break;
            case "top":
              vx = 0;
              vy = -1;
              break;
            case "start":
              vx = -vx;
              vy = -vy;
              break;
            case "end":
              break;
            default:
              align *= Math.PI / 180;
              vx = Math.cos(align);
              vy = Math.sin(align);
              break;
          }
          return {
            x,
            y,
            vx,
            vy
          };
        }
        var R_INSIDE = 0;
        var R_LEFT = 1;
        var R_RIGHT = 2;
        var R_BOTTOM = 4;
        var R_TOP = 8;
        function region(x, y, rect) {
          var res = R_INSIDE;
          if (x < rect.left) {
            res |= R_LEFT;
          } else if (x > rect.right) {
            res |= R_RIGHT;
          }
          if (y < rect.top) {
            res |= R_TOP;
          } else if (y > rect.bottom) {
            res |= R_BOTTOM;
          }
          return res;
        }
        function clipped(segment, area) {
          var x0 = segment.x0;
          var y0 = segment.y0;
          var x1 = segment.x1;
          var y1 = segment.y1;
          var r0 = region(x0, y0, area);
          var r1 = region(x1, y1, area);
          var r, x, y;
          while (true) {
            if (!(r0 | r1) || r0 & r1) {
              break;
            }
            r = r0 || r1;
            if (r & R_TOP) {
              x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
              y = area.top;
            } else if (r & R_BOTTOM) {
              x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
              y = area.bottom;
            } else if (r & R_RIGHT) {
              y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
              x = area.right;
            } else if (r & R_LEFT) {
              y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
              x = area.left;
            }
            if (r === r0) {
              x0 = x;
              y0 = y;
              r0 = region(x0, y0, area);
            } else {
              x1 = x;
              y1 = y;
              r1 = region(x1, y1, area);
            }
          }
          return {
            x0,
            x1,
            y0,
            y1
          };
        }
        function compute$1(range2, config) {
          var anchor = config.anchor;
          var segment = range2;
          var x, y;
          if (config.clamp) {
            segment = clipped(segment, config.area);
          }
          if (anchor === "start") {
            x = segment.x0;
            y = segment.y0;
          } else if (anchor === "end") {
            x = segment.x1;
            y = segment.y1;
          } else {
            x = (segment.x0 + segment.x1) / 2;
            y = (segment.y0 + segment.y1) / 2;
          }
          return aligned(x, y, range2.vx, range2.vy, config.align);
        }
        var positioners = {
          arc: function(el, config) {
            var angle = (el.startAngle + el.endAngle) / 2;
            var vx = Math.cos(angle);
            var vy = Math.sin(angle);
            var r0 = el.innerRadius;
            var r1 = el.outerRadius;
            return compute$1({
              x0: el.x + vx * r0,
              y0: el.y + vy * r0,
              x1: el.x + vx * r1,
              y1: el.y + vy * r1,
              vx,
              vy
            }, config);
          },
          point: function(el, config) {
            var v = orient(el, config.origin);
            var rx = v.x * el.options.radius;
            var ry = v.y * el.options.radius;
            return compute$1({
              x0: el.x - rx,
              y0: el.y - ry,
              x1: el.x + rx,
              y1: el.y + ry,
              vx: v.x,
              vy: v.y
            }, config);
          },
          bar: function(el, config) {
            var v = orient(el, config.origin);
            var x = el.x;
            var y = el.y;
            var sx = 0;
            var sy = 0;
            if (el.horizontal) {
              x = Math.min(el.x, el.base);
              sx = Math.abs(el.base - el.x);
            } else {
              y = Math.min(el.y, el.base);
              sy = Math.abs(el.base - el.y);
            }
            return compute$1({
              x0: x,
              y0: y + sy,
              x1: x + sx,
              y1: y,
              vx: v.x,
              vy: v.y
            }, config);
          },
          fallback: function(el, config) {
            var v = orient(el, config.origin);
            return compute$1({
              x0: el.x,
              y0: el.y,
              x1: el.x + (el.width || 0),
              y1: el.y + (el.height || 0),
              vx: v.x,
              vy: v.y
            }, config);
          }
        };
        var rasterize = utils.rasterize;
        function boundingRects(model) {
          var borderWidth = model.borderWidth || 0;
          var padding = model.padding;
          var th = model.size.height;
          var tw = model.size.width;
          var tx = -tw / 2;
          var ty = -th / 2;
          return {
            frame: {
              x: tx - padding.left - borderWidth,
              y: ty - padding.top - borderWidth,
              w: tw + padding.width + borderWidth * 2,
              h: th + padding.height + borderWidth * 2
            },
            text: {
              x: tx,
              y: ty,
              w: tw,
              h: th
            }
          };
        }
        function getScaleOrigin(el, context) {
          var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;
          if (!scale) {
            return null;
          }
          if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
            return { x: scale.xCenter, y: scale.yCenter };
          }
          var pixel = scale.getBasePixel();
          return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
        }
        function getPositioner(el) {
          if (el instanceof chart_js.ArcElement) {
            return positioners.arc;
          }
          if (el instanceof chart_js.PointElement) {
            return positioners.point;
          }
          if (el instanceof chart_js.BarElement) {
            return positioners.bar;
          }
          return positioners.fallback;
        }
        function drawRoundedRect(ctx, x, y, w, h, radius) {
          var HALF_PI = Math.PI / 2;
          if (radius) {
            var r = Math.min(radius, h / 2, w / 2);
            var left = x + r;
            var top = y + r;
            var right = x + w - r;
            var bottom = y + h - r;
            ctx.moveTo(x, top);
            if (left < right && top < bottom) {
              ctx.arc(left, top, r, -Math.PI, -HALF_PI);
              ctx.arc(right, top, r, -HALF_PI, 0);
              ctx.arc(right, bottom, r, 0, HALF_PI);
              ctx.arc(left, bottom, r, HALF_PI, Math.PI);
            } else if (left < right) {
              ctx.moveTo(left, y);
              ctx.arc(right, top, r, -HALF_PI, HALF_PI);
              ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
            } else if (top < bottom) {
              ctx.arc(left, top, r, -Math.PI, 0);
              ctx.arc(left, bottom, r, 0, Math.PI);
            } else {
              ctx.arc(left, top, r, -Math.PI, Math.PI);
            }
            ctx.closePath();
            ctx.moveTo(x, y);
          } else {
            ctx.rect(x, y, w, h);
          }
        }
        function drawFrame(ctx, rect, model) {
          var bgColor = model.backgroundColor;
          var borderColor = model.borderColor;
          var borderWidth = model.borderWidth;
          if (!bgColor && (!borderColor || !borderWidth)) {
            return;
          }
          ctx.beginPath();
          drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);
          ctx.closePath();
          if (bgColor) {
            ctx.fillStyle = bgColor;
            ctx.fill();
          }
          if (borderColor && borderWidth) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = "miter";
            ctx.stroke();
          }
        }
        function textGeometry(rect, align, font) {
          var h = font.lineHeight;
          var w = rect.w;
          var x = rect.x;
          var y = rect.y + h / 2;
          if (align === "center") {
            x += w / 2;
          } else if (align === "end" || align === "right") {
            x += w;
          }
          return {
            h,
            w,
            x,
            y
          };
        }
        function drawTextLine(ctx, text, cfg) {
          var shadow = ctx.shadowBlur;
          var stroked = cfg.stroked;
          var x = rasterize(cfg.x);
          var y = rasterize(cfg.y);
          var w = rasterize(cfg.w);
          if (stroked) {
            ctx.strokeText(text, x, y, w);
          }
          if (cfg.filled) {
            if (shadow && stroked) {
              ctx.shadowBlur = 0;
            }
            ctx.fillText(text, x, y, w);
            if (shadow && stroked) {
              ctx.shadowBlur = shadow;
            }
          }
        }
        function drawText(ctx, lines, rect, model) {
          var align = model.textAlign;
          var color = model.color;
          var filled = !!color;
          var font = model.font;
          var ilen = lines.length;
          var strokeColor = model.textStrokeColor;
          var strokeWidth = model.textStrokeWidth;
          var stroked = strokeColor && strokeWidth;
          var i;
          if (!ilen || !filled && !stroked) {
            return;
          }
          rect = textGeometry(rect, align, font);
          ctx.font = font.string;
          ctx.textAlign = align;
          ctx.textBaseline = "middle";
          ctx.shadowBlur = model.textShadowBlur;
          ctx.shadowColor = model.textShadowColor;
          if (filled) {
            ctx.fillStyle = color;
          }
          if (stroked) {
            ctx.lineJoin = "round";
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
          }
          for (i = 0, ilen = lines.length; i < ilen; ++i) {
            drawTextLine(ctx, lines[i], {
              stroked,
              filled,
              w: rect.w,
              x: rect.x,
              y: rect.y + rect.h * i
            });
          }
        }
        var Label = function(config, ctx, el, index2) {
          var me = this;
          me._config = config;
          me._index = index2;
          me._model = null;
          me._rects = null;
          me._ctx = ctx;
          me._el = el;
        };
        helpers.merge(Label.prototype, {
          _modelize: function(display, lines, config, context) {
            var me = this;
            var index2 = me._index;
            var font = helpers.toFont(helpers.resolve([config.font, {}], context, index2));
            var color = helpers.resolve([config.color, chart_js.defaults.color], context, index2);
            return {
              align: helpers.resolve([config.align, "center"], context, index2),
              anchor: helpers.resolve([config.anchor, "center"], context, index2),
              area: context.chart.chartArea,
              backgroundColor: helpers.resolve([config.backgroundColor, null], context, index2),
              borderColor: helpers.resolve([config.borderColor, null], context, index2),
              borderRadius: helpers.resolve([config.borderRadius, 0], context, index2),
              borderWidth: helpers.resolve([config.borderWidth, 0], context, index2),
              clamp: helpers.resolve([config.clamp, false], context, index2),
              clip: helpers.resolve([config.clip, false], context, index2),
              color,
              display,
              font,
              lines,
              offset: helpers.resolve([config.offset, 4], context, index2),
              opacity: helpers.resolve([config.opacity, 1], context, index2),
              origin: getScaleOrigin(me._el, context),
              padding: helpers.toPadding(helpers.resolve([config.padding, 4], context, index2)),
              positioner: getPositioner(me._el),
              rotation: helpers.resolve([config.rotation, 0], context, index2) * (Math.PI / 180),
              size: utils.textSize(me._ctx, lines, font),
              textAlign: helpers.resolve([config.textAlign, "start"], context, index2),
              textShadowBlur: helpers.resolve([config.textShadowBlur, 0], context, index2),
              textShadowColor: helpers.resolve([config.textShadowColor, color], context, index2),
              textStrokeColor: helpers.resolve([config.textStrokeColor, color], context, index2),
              textStrokeWidth: helpers.resolve([config.textStrokeWidth, 0], context, index2)
            };
          },
          update: function(context) {
            var me = this;
            var model = null;
            var rects = null;
            var index2 = me._index;
            var config = me._config;
            var value, label, lines;
            var display = helpers.resolve([config.display, true], context, index2);
            if (display) {
              value = context.dataset.data[index2];
              label = helpers.valueOrDefault(helpers.callback(config.formatter, [value, context]), value);
              lines = helpers.isNullOrUndef(label) ? [] : utils.toTextLines(label);
              if (lines.length) {
                model = me._modelize(display, lines, config, context);
                rects = boundingRects(model);
              }
            }
            me._model = model;
            me._rects = rects;
          },
          geometry: function() {
            return this._rects ? this._rects.frame : {};
          },
          rotation: function() {
            return this._model ? this._model.rotation : 0;
          },
          visible: function() {
            return this._model && this._model.opacity;
          },
          model: function() {
            return this._model;
          },
          draw: function(chart2, center) {
            var me = this;
            var ctx = chart2.ctx;
            var model = me._model;
            var rects = me._rects;
            var area;
            if (!this.visible()) {
              return;
            }
            ctx.save();
            if (model.clip) {
              area = model.area;
              ctx.beginPath();
              ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
              ctx.clip();
            }
            ctx.globalAlpha = utils.bound(0, model.opacity, 1);
            ctx.translate(rasterize(center.x), rasterize(center.y));
            ctx.rotate(model.rotation);
            drawFrame(ctx, rects.frame, model);
            drawText(ctx, model.lines, rects.text, model);
            ctx.restore();
          }
        });
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        function rotated(point, center, angle) {
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          var cx = center.x;
          var cy = center.y;
          return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy)
          };
        }
        function projected(points, axis) {
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var origin = axis.origin;
          var i, pt, vx, vy, dp;
          for (i = 0; i < points.length; ++i) {
            pt = points[i];
            vx = pt.x - origin.x;
            vy = pt.y - origin.y;
            dp = axis.vx * vx + axis.vy * vy;
            min = Math.min(min, dp);
            max = Math.max(max, dp);
          }
          return {
            min,
            max
          };
        }
        function toAxis(p0, p1) {
          var vx = p1.x - p0.x;
          var vy = p1.y - p0.y;
          var ln = Math.sqrt(vx * vx + vy * vy);
          return {
            vx: (p1.x - p0.x) / ln,
            vy: (p1.y - p0.y) / ln,
            origin: p0,
            ln
          };
        }
        var HitBox = function() {
          this._rotation = 0;
          this._rect = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
          };
        };
        helpers.merge(HitBox.prototype, {
          center: function() {
            var r = this._rect;
            return {
              x: r.x + r.w / 2,
              y: r.y + r.h / 2
            };
          },
          update: function(center, rect, rotation) {
            this._rotation = rotation;
            this._rect = {
              x: rect.x + center.x,
              y: rect.y + center.y,
              w: rect.w,
              h: rect.h
            };
          },
          contains: function(point) {
            var me = this;
            var margin = 1;
            var rect = me._rect;
            point = rotated(point, me.center(), -me._rotation);
            return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
          },
          intersects: function(other) {
            var r0 = this._points();
            var r1 = other._points();
            var axes = [
              toAxis(r0[0], r0[1]),
              toAxis(r0[0], r0[3])
            ];
            var i, pr0, pr1;
            if (this._rotation !== other._rotation) {
              axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
            }
            for (i = 0; i < axes.length; ++i) {
              pr0 = projected(r0, axes[i]);
              pr1 = projected(r1, axes[i]);
              if (pr0.max < pr1.min || pr1.max < pr0.min) {
                return false;
              }
            }
            return true;
          },
          _points: function() {
            var me = this;
            var rect = me._rect;
            var angle = me._rotation;
            var center = me.center();
            return [
              rotated({ x: rect.x, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y + rect.h }, center, angle),
              rotated({ x: rect.x, y: rect.y + rect.h }, center, angle)
            ];
          }
        });
        function coordinates(el, model, geometry) {
          var point = model.positioner(el, model);
          var vx = point.vx;
          var vy = point.vy;
          if (!vx && !vy) {
            return { x: point.x, y: point.y };
          }
          var w = geometry.w;
          var h = geometry.h;
          var rotation = model.rotation;
          var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
          var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
          var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
          dx *= vx * vs;
          dy *= vy * vs;
          dx += model.offset * vx;
          dy += model.offset * vy;
          return {
            x: point.x + dx,
            y: point.y + dy
          };
        }
        function collide(labels, collider) {
          var i, j, s0, s1;
          for (i = labels.length - 1; i >= 0; --i) {
            s0 = labels[i].$layout;
            for (j = i - 1; j >= 0 && s0._visible; --j) {
              s1 = labels[j].$layout;
              if (s1._visible && s0._box.intersects(s1._box)) {
                collider(s0, s1);
              }
            }
          }
          return labels;
        }
        function compute(labels) {
          var i, ilen, label, state, geometry, center, proxy;
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;
            if (state._visible) {
              proxy = new Proxy(label._el, { get: (el, p) => el.getProps([p], true)[p] });
              geometry = label.geometry();
              center = coordinates(proxy, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
            }
          }
          return collide(labels, function(s0, s1) {
            var h0 = s0._hidable;
            var h1 = s1._hidable;
            if (h0 && h1 || h1) {
              s1._visible = false;
            } else if (h0) {
              s0._visible = false;
            }
          });
        }
        var layout = {
          prepare: function(datasets) {
            var labels = [];
            var i, j, ilen, jlen, label;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                label = datasets[i][j];
                labels.push(label);
                label.$layout = {
                  _box: new HitBox(),
                  _hidable: false,
                  _visible: true,
                  _set: i,
                  _idx: label._index
                };
              }
            }
            labels.sort(function(a, b) {
              var sa = a.$layout;
              var sb = b.$layout;
              return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
            });
            this.update(labels);
            return labels;
          },
          update: function(labels) {
            var dirty = false;
            var i, ilen, label, model, state;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              model = label.model();
              state = label.$layout;
              state._hidable = model && model.display === "auto";
              state._visible = label.visible();
              dirty |= state._hidable;
            }
            if (dirty) {
              compute(labels);
            }
          },
          lookup: function(labels, point) {
            var i, state;
            for (i = labels.length - 1; i >= 0; --i) {
              state = labels[i].$layout;
              if (state && state._visible && state._box.contains(point)) {
                return labels[i];
              }
            }
            return null;
          },
          draw: function(chart2, labels) {
            var i, ilen, label, state, geometry, center;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              state = label.$layout;
              if (state._visible) {
                geometry = label.geometry();
                center = coordinates(label._el, label.model(), geometry);
                state._box.update(center, geometry, label.rotation());
                label.draw(chart2, center);
              }
            }
          }
        };
        var formatter = function(value) {
          if (helpers.isNullOrUndef(value)) {
            return null;
          }
          var label = value;
          var keys, klen, k;
          if (helpers.isObject(value)) {
            if (!helpers.isNullOrUndef(value.label)) {
              label = value.label;
            } else if (!helpers.isNullOrUndef(value.r)) {
              label = value.r;
            } else {
              label = "";
              keys = Object.keys(value);
              for (k = 0, klen = keys.length; k < klen; ++k) {
                label += (k !== 0 ? ", " : "") + keys[k] + ": " + value[keys[k]];
              }
            }
          }
          return "" + label;
        };
        var defaults = {
          align: "center",
          anchor: "center",
          backgroundColor: null,
          borderColor: null,
          borderRadius: 0,
          borderWidth: 0,
          clamp: false,
          clip: false,
          color: void 0,
          display: true,
          font: {
            family: void 0,
            lineHeight: 1.2,
            size: void 0,
            style: void 0,
            weight: null
          },
          formatter,
          labels: void 0,
          listeners: {},
          offset: 4,
          opacity: 1,
          padding: {
            top: 4,
            right: 4,
            bottom: 4,
            left: 4
          },
          rotation: 0,
          textAlign: "start",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          textShadowBlur: 0,
          textShadowColor: void 0
        };
        var EXPANDO_KEY = "$datalabels";
        var DEFAULT_KEY = "$default";
        function configure(dataset, options) {
          var override = dataset.datalabels;
          var listeners = {};
          var configs = [];
          var labels, keys;
          if (override === false) {
            return null;
          }
          if (override === true) {
            override = {};
          }
          options = helpers.merge({}, [options, override]);
          labels = options.labels || {};
          keys = Object.keys(labels);
          delete options.labels;
          if (keys.length) {
            keys.forEach(function(key) {
              if (labels[key]) {
                configs.push(helpers.merge({}, [
                  options,
                  labels[key],
                  { _key: key }
                ]));
              }
            });
          } else {
            configs.push(options);
          }
          listeners = configs.reduce(function(target, config) {
            helpers.each(config.listeners || {}, function(fn, event) {
              target[event] = target[event] || {};
              target[event][config._key || DEFAULT_KEY] = fn;
            });
            delete config.listeners;
            return target;
          }, {});
          return {
            labels: configs,
            listeners
          };
        }
        function dispatchEvent(chart2, listeners, label, event) {
          if (!listeners) {
            return;
          }
          var context = label.$context;
          var groups = label.$groups;
          var callback;
          if (!listeners[groups._set]) {
            return;
          }
          callback = listeners[groups._set][groups._key];
          if (!callback) {
            return;
          }
          if (helpers.callback(callback, [context, event]) === true) {
            chart2[EXPANDO_KEY]._dirty = true;
            label.update(context);
          }
        }
        function dispatchMoveEvents(chart2, listeners, previous, label, event) {
          var enter, leave;
          if (!previous && !label) {
            return;
          }
          if (!previous) {
            enter = true;
          } else if (!label) {
            leave = true;
          } else if (previous !== label) {
            leave = enter = true;
          }
          if (leave) {
            dispatchEvent(chart2, listeners.leave, previous, event);
          }
          if (enter) {
            dispatchEvent(chart2, listeners.enter, label, event);
          }
        }
        function handleMoveEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var listeners = expando._listeners;
          var previous, label;
          if (!listeners.enter && !listeners.leave) {
            return;
          }
          if (event.type === "mousemove") {
            label = layout.lookup(expando._labels, event);
          } else if (event.type !== "mouseout") {
            return;
          }
          previous = expando._hovered;
          expando._hovered = label;
          dispatchMoveEvents(chart2, listeners, previous, label, event);
        }
        function handleClickEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var handlers = expando._listeners.click;
          var label = handlers && layout.lookup(expando._labels, event);
          if (label) {
            dispatchEvent(chart2, handlers, label, event);
          }
        }
        var plugin = {
          id: "datalabels",
          defaults,
          beforeInit: function(chart2) {
            chart2[EXPANDO_KEY] = {
              _actives: []
            };
          },
          beforeUpdate: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            expando._listened = false;
            expando._listeners = {};
            expando._datasets = [];
            expando._labels = [];
          },
          afterDatasetUpdate: function(chart2, args, options) {
            var datasetIndex = args.index;
            var expando = chart2[EXPANDO_KEY];
            var labels = expando._datasets[datasetIndex] = [];
            var visible = chart2.isDatasetVisible(datasetIndex);
            var dataset = chart2.data.datasets[datasetIndex];
            var config = configure(dataset, options);
            var elements = args.meta.data || [];
            var ctx = chart2.ctx;
            var i, j, ilen, jlen, cfg, key, el, label;
            ctx.save();
            for (i = 0, ilen = elements.length; i < ilen; ++i) {
              el = elements[i];
              el[EXPANDO_KEY] = [];
              if (visible && el && chart2.getDataVisibility(i) && !el.skip) {
                for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                  cfg = config.labels[j];
                  key = cfg._key;
                  label = new Label(cfg, ctx, el, i);
                  label.$groups = {
                    _set: datasetIndex,
                    _key: key || DEFAULT_KEY
                  };
                  label.$context = {
                    active: false,
                    chart: chart2,
                    dataIndex: i,
                    dataset,
                    datasetIndex
                  };
                  label.update(label.$context);
                  el[EXPANDO_KEY].push(label);
                  labels.push(label);
                }
              }
            }
            ctx.restore();
            helpers.merge(expando._listeners, config.listeners, {
              merger: function(event, target, source) {
                target[event] = target[event] || {};
                target[event][args.index] = source[event];
                expando._listened = true;
              }
            });
          },
          afterUpdate: function(chart2) {
            chart2[EXPANDO_KEY]._labels = layout.prepare(chart2[EXPANDO_KEY]._datasets);
          },
          afterDatasetsDraw: function(chart2) {
            layout.draw(chart2, chart2[EXPANDO_KEY]._labels);
          },
          beforeEvent: function(chart2, args) {
            if (chart2[EXPANDO_KEY]._listened) {
              var event = args.event;
              switch (event.type) {
                case "mousemove":
                case "mouseout":
                  handleMoveEvents(chart2, event);
                  break;
                case "click":
                  handleClickEvents(chart2, event);
                  break;
              }
            }
          },
          afterEvent: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            var previous = expando._actives;
            var actives = expando._actives = chart2.getActiveElements();
            var updates = utils.arrayDiff(previous, actives);
            var i, ilen, j, jlen, update, label, labels;
            for (i = 0, ilen = updates.length; i < ilen; ++i) {
              update = updates[i];
              if (update[1]) {
                labels = update[0].element[EXPANDO_KEY] || [];
                for (j = 0, jlen = labels.length; j < jlen; ++j) {
                  label = labels[j];
                  label.$context.active = update[1] === 1;
                  label.update(label.$context);
                }
              }
            }
            if (expando._dirty || updates.length) {
              layout.update(expando._labels);
              chart2.render();
            }
            delete expando._dirty;
          }
        };
        return plugin;
      });
    }
  });

  // node_modules/bootstrap-icons/font/bootstrap-icons.css
  var require_ = __commonJS({
    "node_modules/bootstrap-icons/font/bootstrap-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/material-icons/iconfont/material-icons.css
  var require_2 = __commonJS({
    "node_modules/material-icons/iconfont/material-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // js/app.js
  var import_tom_select4 = __toModule(require_tom_select_complete());

  // js/tom_select_saisie_page.js
  var import_tom_select = __toModule(require_tom_select_complete());
  function saveRow(icon) {
    const row = icon.closest("tr");
    const inputs = row.querySelectorAll("input, select");
    const rowData = {};
    inputs.forEach((input) => {
      rowData[input.name] = input.value;
    });
    console.log("Donn\xE9es \xE0 sauvegarder:", rowData);
    const csrfToken2 = document.querySelector('meta[name="csrf-token"]').getAttribute("content");
    fetch("/save_saisie", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": csrfToken2
      },
      body: JSON.stringify(rowData)
    }).then((response) => {
      console.log(" response : ", response);
      if (!response.ok) {
        throw new Error("Erreur lors de la sauvegarde des donn\xE9es");
      }
      return response.json();
    }).then((data) => {
      console.log("Succ\xE8s:", data.message);
      window.location.reload();
    }).catch((error) => {
      console.error("Erreur :", error);
      alert("Une erreur est survenue lors de la sauvegarde. Veuillez v\xE9rifier que tous les champs sont bien remplis et au bon format");
    });
  }
  function removeRow(icon) {
    icon.closest("tr").remove();
  }
  function isDecimalValid(inputValue) {
    const numericValue = parseFloat(inputValue);
    return !isNaN(numericValue) && numericValue >= 0 && numericValue <= 20;
  }
  function isLabelValid(inputValue) {
    return inputValue.trim() !== "" && inputValue.length <= 255;
  }
  function isProjectIdValid(value) {
    return value.trim() !== "";
  }
  function isTaskValid(selectedTask) {
    return selectedTask !== "";
  }
  function handleDecimalInput(event) {
    if (this.value.includes("+") || this.value.includes("-")) {
      const formattedValue = this.value.replace(/[+-]/g, "");
      this.value = formattedValue;
    }
    if (!isDecimalValid(this.value)) {
      this.style.borderColor = "red";
    } else {
      const decimalLength = (this.value.split(".")[1] || "").length;
      console.log(decimalLength);
      if (decimalLength > 2) {
        valeur = parseFloat(this.value).toFixed(2);
        this.value = valeur;
      }
      this.style.borderColor = "green";
    }
  }
  function handleLabelInput(event) {
    if (!isLabelValid(this.value)) {
      this.style.borderColor = "red";
    } else {
      this.style.borderColor = "green";
    }
  }
  function handleProjectSelectChange(event, task_tom_select2) {
    const projectElement = document.querySelector(".project_id");
    const tsControlElement = projectElement.querySelector(".ts-control");
    const selectedProjectId = event.target.value;
    if (!isProjectIdValid(selectedProjectId)) {
      console.log("makato amin red");
      tsControlElement.style.borderColor = "red";
    } else {
      console.log("makato amin green");
      tsControlElement.style.borderColor = "green";
    }
    updateTaskOptions(selectedProjectId, task_tom_select2);
  }
  function handleTaskSelectChange(event) {
    const taskElement = document.querySelector(".task");
    const tsControlElement = taskElement.querySelector(".ts-control");
    const selectedTask = event.target.value;
    if (!isTaskValid(selectedTask)) {
      console.log("La t\xE2che s\xE9lectionn\xE9e est invalide");
      tsControlElement.style.borderColor = "red";
    } else {
      console.log("La t\xE2che s\xE9lectionn\xE9e est valide");
      tsControlElement.style.borderColor = "green";
    }
  }
  function applyFieldValidations(tableBody) {
    const taskElement = tableBody.querySelector(".task");
    const tsControlElement1 = taskElement.querySelector(".ts-control");
    tsControlElement1.style.borderColor = "red";
    const projectElement = tableBody.querySelector(".project_id");
    const tsControlElement = projectElement.querySelector(".ts-control");
    tsControlElement.style.borderColor = "red";
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    labelInput.style.borderColor = "red";
  }
  function lineValidation(tableBody) {
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    const taskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    const projectSelect = tableBody.querySelector('tr:last-child select[name="project_id"]');
    const decimalInput = tableBody.querySelector('tr:last-child input[name="hours"]');
    const isLabelValidResult = isLabelValid(labelInput.value);
    const isTaskValidResult = isTaskValid(taskSelect.value);
    const isProjectIdValidResult = isProjectIdValid(projectSelect.value);
    const isDecimalValidResult = isDecimalValid(decimalInput.value);
    return isLabelValidResult && isTaskValidResult && isProjectIdValidResult && isDecimalValidResult;
  }
  function haveLineNotSaved(tableBody) {
    const newTaskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    if (newTaskSelect != null)
      return true;
    else
      return false;
  }
  function addRow(tableBody, TomSelect5, userId, date, username, projects) {
    const newRow = `
        <tr>
            <input type="hidden" name="user_id" value="${userId}">
            <td class="date"><input type="date" name="date" value="${date}"></td>
            <td class="user"><input type="text" name="user" value="${username}" readonly></td>
            <td class="project_id">
                <select name="project_id" id="tom_select">
                    <option value="">S\xE9lectionner un projet</option>
                    ${projects.map((project) => `<option value="${project.id}">${project.title}</option>`).join("")}
                </select>
            </td>
            <td class="client">
                <input type="text" name="client_name" value="" readonly>
            </td>
            <td class="task">
                <select name="task" id="tasks_select" placeholder="S\xE9lectioner une t\xE2che"></select>
            </td>
            <td class="labels"><input type="text" name="labels" placeholder="Libell\xE9"></td>
            <td class="temps">
                <input type="number" id="decimal_input" name="hours" step="0.1" value="0.0">
            </td>
            <td class="actions">
                <i title="Sauvegarder" class="bi bi-save" style="cursor: pointer;"></i>
                <i title="Supprimer" id="suppr" class="bi bi-trash" style="cursor: pointer;" ></i>
            </td>
        </tr>
    `;
    tableBody.insertAdjacentHTML("beforeend", newRow);
    const newProjectSelect = tableBody.querySelector('tr:last-child select[name="project_id"]');
    new TomSelect5(newProjectSelect, {
      searchable: true,
      sortField: {
        field: "text",
        direction: "asc"
      },
      render: {
        no_results: function(data, escape) {
          return '<div class="no-results">R\xE9sultat non trouver pour  "' + escape(data.input) + '"</div>';
        }
      }
    });
    const newTaskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    newTaskSelect.addEventListener("change", handleTaskSelectChange);
    task_tom_select = new TomSelect5(newTaskSelect, {
      searchable: true,
      sortField: {
        field: "text",
        direction: "asc"
      },
      render: {
        no_results: function(data, escape) {
          return '<div class="no-results">R\xE9sultat non trouver pour  "' + escape(data.input) + '"</div>';
        }
      }
    });
    applyFieldValidations(tableBody);
    const projectSelect = document.querySelector('select[name="project_id"]');
    projectSelect.addEventListener("change", function(event) {
      handleProjectSelectChange(event, task_tom_select);
    });
    const decimalInput = tableBody.querySelector('tr:last-child input[name="hours"]');
    decimalInput.addEventListener("input", handleDecimalInput);
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    labelInput.addEventListener("input", handleLabelInput);
    const newSaveIcon = tableBody.querySelector(".bi-save");
    newSaveIcon.addEventListener("click", function() {
      const isValid = lineValidation(tableBody);
      if (isValid) {
        saveRow(newSaveIcon);
      } else {
        console.log("Les champs ne sont pas valides. Veuillez v\xE9rifier vos saisies.");
      }
    });
    const newRemoveIcon = tableBody.querySelector("#suppr");
    console.log(newRemoveIcon);
    newRemoveIcon.addEventListener("click", function() {
      removeRow(newRemoveIcon);
      resetAddRowIcon();
    });
  }
  function updateTaskOptions(selectedProjectId, taskTomSelect) {
    fetch(`/tasks/${selectedProjectId}`).then((response) => {
      console.log(response);
      if (!response.ok) {
        throw new Error("Erreur lors de la r\xE9cup\xE9ration des t\xE2ches");
      }
      return response.json();
    }).then((data) => {
      console.log(data);
      const tasks = data.tasks;
      taskTomSelect.clear();
      taskTomSelect.clearOptions();
      tasks.forEach((task) => {
        taskTomSelect.addOption({ value: task.id, text: task.title });
      });
      const clientDetails = data.client_details;
      const clientNameInput = document.querySelector('input[name="client_name"]');
      clientNameInput.value = clientDetails.clients_name;
    }).catch((error) => {
      const clientNameInput = document.querySelector('input[name="client_name"]');
      clientNameInput.value = "";
      taskTomSelect.clear();
      taskTomSelect.clearOptions();
      console.log(taskTomSelect);
      console.error("Erreur :", error);
    });
  }
  function resetAddRowIcon() {
    var addRowLink = document.getElementById("addRowIcon");
    var addRowIcon = document.querySelector("#addRowIcon i");
    addRowLink.classList.remove("non-cliquable");
    addRowIcon.style.cursor = "pointer";
  }

  // js/app.js
  var import_tom_select5 = __toModule(require_tom_select_complete());

  // js/showing_task.js
  var authorizedInputs = {
    Admin: [
      "task_title",
      "task_description",
      "parent_task",
      "assigned_person",
      "due_date",
      "start_date",
      "original_estimate",
      "progress",
      "save",
      "curr_user",
      "pro_id",
      "status_id",
      "priority_id",
      "task_deadline"
    ],
    Attributeur: [
      "task_title",
      "task_description",
      "parent_task",
      "assigned_person",
      "due_date",
      "start_date",
      "original_estimate",
      "progress",
      "save",
      "curr_user",
      "pro_id",
      "status_id",
      "priority_id",
      "task_deadline"
    ],
    Contributeur: [
      "task_title",
      "task_description",
      "progress",
      "save",
      "curr_user",
      "pro_id",
      "status_id",
      "priority_id",
      "task_deadline"
    ]
  };
  function toggleInputs(profile) {
    const inputs = document.querySelectorAll("input, textarea, select");
    const profileInputs = authorizedInputs[profile];
    inputs.forEach(function(input) {
      if (profileInputs && profileInputs.includes(input.name)) {
        input.removeAttribute("disabled");
      } else {
        input.disabled = true;
      }
    });
  }
  function isFirstDateBeforeSecondDate(date1, date2) {
    var firstDate = new Date(date1);
    var secondDate = new Date(date2);
    return firstDate < secondDate;
  }
  function desactivateAllinputs() {
    var mainDiv = document.getElementById("showing_task");
    var inputs = mainDiv.querySelectorAll("input, textarea, select");
    inputs.forEach(function(input) {
      input.disabled = true;
    });
  }
  function handleClickOnModifBtn(profile) {
    var saveBtn = document.getElementById("save");
    var cancelBtn = document.getElementById("cancel");
    var modifBtn = document.getElementById("modify");
    saveBtn.style.display = "inline-block";
    saveBtn.style.cursor = "pointer";
    cancelBtn.style.display = "inline-block";
    cancelBtn.style.cursor = "pointer";
    modifBtn.style.display = "contents";
    modifBtn.style.cursor = "default";
    toggleInputs(profile);
  }
  function handleClickOnCancelBtn() {
    var saveBtn = document.getElementById("save");
    var cancelBtn = document.getElementById("cancel");
    var modifBtn = document.getElementById("modify");
    saveBtn.style.display = "contents";
    saveBtn.style.cursor = "default";
    cancelBtn.style.display = "contents";
    cancelBtn.style.cursor = "default";
    modifBtn.style.display = "inline-block";
    modifBtn.style.cursor = "pointer";
    desactivateAllinputs();
  }
  function validateProgressInput(value) {
    if (!isNaN(value)) {
      if (value >= 0 && value <= 100) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  function validateDateInputs() {
    var startDateInput = document.getElementById("start_date");
    var dueDateInput = document.getElementById("due_date");
    var startDateValue = startDateInput.value;
    var dueDateValue = dueDateInput.value;
    document.getElementById("start_date_error").textContent = "La date d'\xE9ch\xE9ance ne peut pas \xEAtre ant\xE9rieure \xE0 la date de d\xE9but";
    document.getElementById("start_date_error").style.visibility = "hidden";
    document.getElementById("due_date_error").textContent = "La date d'\xE9ch\xE9ance ne peut pas \xEAtre ant\xE9rieure \xE0 la date de d\xE9but";
    document.getElementById("due_date_error").style.visibility = "hidden";
    if (!startDateValue) {
      document.getElementById("start_date_error").textContent = "Veuillez entrer une date de d\xE9but";
      document.getElementById("start_date_error").style.visibility = "";
      return false;
    }
    if (!dueDateValue) {
      document.getElementById("due_date_error").textContent = "Veuillez entrer une date d'\xE9ch\xE9ance";
      document.getElementById("due_date_error").style.visibility = "";
      return false;
    }
    if (isNaN(Date.parse(startDateValue))) {
      document.getElementById("start_date_error").textContent = "Format de date invalide";
      document.getElementById("start_date_error").style.visibility = "";
      return false;
    }
    if (isNaN(Date.parse(dueDateValue))) {
      document.getElementById("due_date_error").textContent = "Format de date invalide";
      document.getElementById("due_date_error").style.visibility = "";
      return false;
    }
    if (isFirstDateBeforeSecondDate(dueDateValue, startDateValue)) {
      document.getElementById("due_date_error").textContent = "La date d'\xE9ch\xE9ance ne peut pas \xEAtre ant\xE9rieure \xE0 la date de d\xE9but";
      document.getElementById("due_date_error").style.visibility = "";
      return false;
    }
    return true;
  }
  function formatNumberInput(value) {
    return value.replace(/\D/g, "");
  }
  function handleProgressInput(event) {
    formated_value = formatNumberInput(this.value);
    is_valid = validateProgressInput(this.value);
    if (is_valid) {
      this.value = formated_value;
    } else
      this.value = "";
  }
  function handleDateInputChange(event) {
    var input = event.target;
    console.log("makato");
    console.log(validateDateInputs());
  }
  function handleEstimationInput(event) {
    let filtredval = this.value.replace(/[^0-9.]/g, "");
    console.log(filtredval);
    val = parseFloat(filtredval);
    console.log(isNaN(val), val, filtredval);
    if (!isNaN(val) || val > 0) {
      console.log(filtredval);
      let decimalLength = (filtredval.split(".")[1] || "").length;
      if (decimalLength > 2) {
        valeur = parseFloat(filtredval).toFixed(2);
        this.value = valeur;
      }
    } else
      this.value = "";
  }
  function loadButtonAction(profile) {
    var modifBtn = document.getElementById("modify");
    modifBtn.addEventListener("click", function() {
      handleClickOnModifBtn(profile);
    });
    var cancelBtn = document.getElementById("cancel");
    cancelBtn.addEventListener("click", function() {
      handleClickOnCancelBtn();
    });
  }
  function loadAllInputsEvent() {
    var progressInput = document.getElementById("progress");
    progressInput.addEventListener("input", handleProgressInput);
    var startDateInput = document.getElementById("start_date");
    var dueDateInput = document.getElementById("due_date");
    var estimationInput = document.getElementById("estimation_val");
    console.log(estimationInput);
    estimationInput.addEventListener("input", handleEstimationInput);
    startDateInput.addEventListener("change", handleDateInputChange);
    dueDateInput.addEventListener("change", handleDateInputChange);
  }
  function showTask(profile) {
    var saveBtn = document.getElementById("save");
    saveBtn.style.display = "contents";
    loadButtonAction(profile);
    loadAllInputsEvent();
  }

  // js/new_task.js
  var import_tom_select2 = __toModule(require_tom_select_complete());
  var import_tom_select3 = __toModule(require_tom_select_complete());
  function loadForm() {
    let contributorSelect = document.getElementById("contributorSelect");
    console.log(contributorSelect);
    let tom = new import_tom_select3.default(contributorSelect, {
      persist: false,
      createOnBlur: true,
      plugins: ["remove_button"]
    });
    console.log(tom);
    var startDateInput = document.getElementById("start_date");
    var dueDateInput = document.getElementById("due_date");
    var estimationInput = document.getElementById("estimation_val");
    var titleInput = document.getElementById("title_i");
    var descriInput = document.getElementById("description");
    estimationInput.addEventListener("input", handleEstimationInput);
    startDateInput.addEventListener("change", handleDateInputChange);
    dueDateInput.addEventListener("change", handleDateInputChange);
    titleInput.addEventListener("input", validateTitle);
    descriInput.addEventListener("input", validateDescription);
  }
  function validateTitle() {
    let titleInput = document.getElementById("title_i");
    let errorLabel = document.getElementById("title_error");
    let titleVal = titleInput.value;
    if (isFieldEmpty(titleVal)) {
      errorLabel.textContent = "Cette champs ne peut pas etre vide!";
      errorLabel.style.visibility = "";
      return false;
    }
    if (!isLengthValid(titleVal, 255)) {
      errorLabel.textContent = "valeur trop long";
      errorLabel.style.visibility = "";
      return false;
    } else {
      errorLabel.textContent = "";
      errorLabel.style.visibility = "hidden";
      return true;
    }
  }
  function validateDescription() {
    let descriInput = document.getElementById("description");
    let errorLabel = document.getElementById("description_error");
    let descriVal = descriInput.value;
    if (isFieldEmpty(descriVal)) {
      errorLabel.textContent = "Cette champs ne peut pas etre vide!";
      errorLabel.style.visibility = "";
      return false;
    }
    if (!isLengthValid(descriVal, 300)) {
      errorLabel.textContent = "valeur trop long";
      errorLabel.style.visibility = "";
      return false;
    }
    return true;
  }
  function isFieldEmpty(value) {
    return value.trim() === "";
  }
  function isLengthValid(value, maxLength) {
    return value.length <= maxLength;
  }

  // js/favicon.js
  function changeFaviconByTheme() {
    const isDarkMode = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isLightMode = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
    const favicon = document.querySelector("link[rel='icon']");
    if (isDarkMode) {
      favicon.href = "https://test.monitoring.phidia.fr/images/profiles/Mgbi-profile-light.png";
      console.log("The theme is Dark and it's", isDarkMode);
    } else {
      favicon.href = "https://test.monitoring.phidia.fr/images/profiles/Mgbi-profile.png";
      console.log("The theme is Light and it's", isLightMode);
    }
  }
  window.onload = function() {
    changeFaviconByTheme();
  };
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
    changeFaviconByTheme();
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  "use strict";
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "hidden";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      form.submit();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.esm.js
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || void 0;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global.XMLHttpRequest();
        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => {
        callback && callback(null);
      };
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry() {
      this.close();
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry();
    }
    poll() {
      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {
        return;
      }
      Ajax.request("GET", this.endpointURL(), "application/json", null, this.timeout, this.ontimeout.bind(this), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => {
                this.onmessage({ data: msg });
              }, 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen();
            this.poll();
            break;
          case 403:
            this.onerror();
            this.close();
            break;
          case 0:
          case 500:
            this.onerror();
            this.closeAndRetry();
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      Ajax.request("POST", this.endpointURL(), "application/json", body, this.timeout, this.onerror.bind(this, "timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry();
        }
      });
    }
    close(_code, _reason) {
      this.readyState = SOCKET_STATES.closed;
      this.onclose();
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    replaceTransport(newTransport) {
      this.disconnect();
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      this.connectClock++;
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.abnormalClose("heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      clearTimeout(this.heartbeatTimer);
      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      clearTimeout(this.heartbeatTimer);
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    abnormalClose(reason) {
      this.closeWasClean = false;
      if (this.isConnected()) {
        this.conn.close(WS_CLOSE_NORMAL, reason);
      }
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          clearTimeout(this.heartbeatTimer);
          this.pendingHeartbeatRef = null;
          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 1e3;
  var RELOAD_JITTER_MAX = 3e3;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val2) => typeof val2 === "function" ? val2 : function() {
    return val2;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix, suffix } = titleEl.dataset;
      document.title = `${prefix || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {
      let debounce = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce === "") {
        debounce = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce || throttle;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER), timeout);
            }
          } else {
            setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle), timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, eventString, detail = {}) {
      let event = new CustomEvent(eventString, { bubbles: true, cancelable: true, detail });
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { except: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val2 = source[key];
        let targetVal = target[key];
        if (isObject(val2) && val2[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val2);
        } else {
          target[key] = val2;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val2 = source[key];
        let targetVal = target[key];
        if (isObject(val2) && val2[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val2);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.__liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail }) {
      dom_default.dispatchEvent(el, event, detail);
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      let { event, data, target, page_loading, loading, value } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" ? sourceEl.form : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, names, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, [], names, transition, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      let [transition_start, running, transition_end] = transition;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val2] }) {
      this.setOrRemoveAttrs(el, [[attr, val2]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      let [transition_run, transition_start, transition_end] = transition || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let keepSets = sets.filter(([attr, _val]) => !this.hasSet(prevSets, attr) && !el.attributes.getNamedItem(attr));
      let keepRemoves = removes.filter((attr) => prevRemoves.indexOf(attr) < 0 && el.attributes.getNamedItem(attr));
      let newSets = prevSets.filter(([attr, _val]) => removes.indexOf(attr) < 0).concat(keepSets);
      let newRemoves = prevRemoves.filter((attr) => !this.hasSet(sets, attr)).concat(keepRemoves);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val2]) => currentEl.setAttribute(attr, val2));
        return [newSets, newRemoves];
      });
    },
    hasSet(sets, nameSearch) {
      return sets.find(([name, val2]) => name === nameSearch);
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta = {}) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val2, key, _index) => {
      if (val2 instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val2] of formData.entries()) {
      params.append(key, val2);
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.getAttribute(PHX_MAIN) !== null;
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val2 = this.el.getAttribute(PHX_STATIC);
      return val2 === "" ? null : val2;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
          let hook = this.getHook(el);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      return this.liveSocket.reloadWithJitter(this);
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.isJoinPending() && document.visibilityState !== "hidden" || this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      this.log("error", () => ["view crashed", reason]);
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { to: this.href, kind: "error" });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData = serializeForm(inputEl.form, { _target: opts._target });
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl);
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { files: filesOrBlobs });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.linkRef = 1;
      this.clickRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.removeItem(PHX_LV_DEBUG);
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      this.socket.disconnect(callback);
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      view.destroy();
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
      if (tries > this.maxReloads) {
        this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        afterMs = this.failsafeJitter;
      }
      setTimeout(() => {
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.getAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      let oldMainEl = this.main.el;
      let newMainEl = dom_default.cloneNode(oldMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            oldMainEl.replaceWith(newMainEl);
            callback && callback();
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        if (!this.isConnected()) {
          return;
        }
        this.clickRef++;
        let clickRefWas = this.clickRef;
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          target = closestPhxBinding(e.target, click);
          this.dispatchClickAway(e, clickRefWas);
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickRefWas) {
      let phxClickAway = this.binding("click-away");
      let phxClick = this.binding("click");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(e.target) || el.contains(e.target))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              let target = e.target.closest(`[${phxClick}]`) || e.target;
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll: scroll2 } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll2 === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll2);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, payload);
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", info);
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", info);
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll2 = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll: scroll2 }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let input = e.target;
          let phxEvent = input.form && input.form.getAttribute(this.binding("change"));
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, () => {
            this.withinOwners(input.form, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, callback) {
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // node_modules/@shopify/draggable/build/esm/shared/AbstractEvent/AbstractEvent.mjs
  var AbstractEvent = class {
    constructor(data) {
      this._canceled = false;
      this.data = data;
    }
    get type() {
      return this.constructor.type;
    }
    get cancelable() {
      return this.constructor.cancelable;
    }
    cancel() {
      this._canceled = true;
    }
    canceled() {
      return this._canceled;
    }
    clone(data) {
      return new this.constructor(__spreadValues(__spreadValues({}, this.data), data));
    }
  };
  AbstractEvent.type = "event";
  AbstractEvent.cancelable = false;

  // node_modules/@shopify/draggable/build/esm/shared/AbstractPlugin/AbstractPlugin.mjs
  var AbstractPlugin = class {
    constructor(draggable) {
      this.draggable = draggable;
    }
    attach() {
      throw new Error("Not Implemented");
    }
    detach() {
      throw new Error("Not Implemented");
    }
  };

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/Sensor/Sensor.mjs
  var defaultDelay = {
    mouse: 0,
    drag: 0,
    touch: 100
  };
  var Sensor = class {
    constructor(containers = [], options = {}) {
      this.containers = [...containers];
      this.options = __spreadValues({}, options);
      this.dragging = false;
      this.currentContainer = null;
      this.originalSource = null;
      this.startEvent = null;
      this.delay = calcDelay(options.delay);
    }
    attach() {
      return this;
    }
    detach() {
      return this;
    }
    addContainer(...containers) {
      this.containers = [...this.containers, ...containers];
    }
    removeContainer(...containers) {
      this.containers = this.containers.filter((container) => !containers.includes(container));
    }
    trigger(element, sensorEvent) {
      const event = document.createEvent("Event");
      event.detail = sensorEvent;
      event.initEvent(sensorEvent.type, true, true);
      element.dispatchEvent(event);
      this.lastEvent = sensorEvent;
      return sensorEvent;
    }
  };
  function calcDelay(optionsDelay) {
    const delay = {};
    if (optionsDelay === void 0) {
      return __spreadValues({}, defaultDelay);
    }
    if (typeof optionsDelay === "number") {
      for (const key in defaultDelay) {
        if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {
          delay[key] = optionsDelay;
        }
      }
      return delay;
    }
    for (const key in defaultDelay) {
      if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {
        if (optionsDelay[key] === void 0) {
          delay[key] = defaultDelay[key];
        } else {
          delay[key] = optionsDelay[key];
        }
      }
    }
    return delay;
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/closest/closest.mjs
  function closest(node, value) {
    if (node == null) {
      return null;
    }
    function conditionFn(currentNode) {
      if (currentNode == null || value == null) {
        return false;
      } else if (isSelector(value)) {
        return Element.prototype.matches.call(currentNode, value);
      } else if (isNodeList(value)) {
        return [...value].includes(currentNode);
      } else if (isElement(value)) {
        return value === currentNode;
      } else if (isFunction(value)) {
        return value(currentNode);
      } else {
        return false;
      }
    }
    let current = node;
    do {
      current = current.correspondingUseElement || current.correspondingElement || current;
      if (conditionFn(current)) {
        return current;
      }
      current = (current == null ? void 0 : current.parentNode) || null;
    } while (current != null && current !== document.body && current !== document);
    return null;
  }
  function isSelector(value) {
    return Boolean(typeof value === "string");
  }
  function isNodeList(value) {
    return Boolean(value instanceof NodeList || value instanceof Array);
  }
  function isElement(value) {
    return Boolean(value instanceof Node);
  }
  function isFunction(value) {
    return Boolean(typeof value === "function");
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/distance/distance.mjs
  function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/SensorEvent/SensorEvent.mjs
  var SensorEvent = class extends AbstractEvent {
    get originalEvent() {
      return this.data.originalEvent;
    }
    get clientX() {
      return this.data.clientX;
    }
    get clientY() {
      return this.data.clientY;
    }
    get target() {
      return this.data.target;
    }
    get container() {
      return this.data.container;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get pressure() {
      return this.data.pressure;
    }
  };
  var DragStartSensorEvent = class extends SensorEvent {
  };
  DragStartSensorEvent.type = "drag:start";
  var DragMoveSensorEvent = class extends SensorEvent {
  };
  DragMoveSensorEvent.type = "drag:move";
  var DragStopSensorEvent = class extends SensorEvent {
  };
  DragStopSensorEvent.type = "drag:stop";
  var DragPressureSensorEvent = class extends SensorEvent {
  };
  DragPressureSensorEvent.type = "drag:pressure";

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/MouseSensor/MouseSensor.mjs
  var onContextMenuWhileDragging = Symbol("onContextMenuWhileDragging");
  var onMouseDown = Symbol("onMouseDown");
  var onMouseMove = Symbol("onMouseMove");
  var onMouseUp = Symbol("onMouseUp");
  var startDrag = Symbol("startDrag");
  var onDistanceChange = Symbol("onDistanceChange");
  var MouseSensor = class extends Sensor {
    constructor(containers = [], options = {}) {
      super(containers, options);
      this.mouseDownTimeout = null;
      this.pageX = null;
      this.pageY = null;
      this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);
      this[onMouseDown] = this[onMouseDown].bind(this);
      this[onMouseMove] = this[onMouseMove].bind(this);
      this[onMouseUp] = this[onMouseUp].bind(this);
      this[startDrag] = this[startDrag].bind(this);
      this[onDistanceChange] = this[onDistanceChange].bind(this);
    }
    attach() {
      document.addEventListener("mousedown", this[onMouseDown], true);
    }
    detach() {
      document.removeEventListener("mousedown", this[onMouseDown], true);
    }
    [onMouseDown](event) {
      if (event.button !== 0 || event.ctrlKey || event.metaKey) {
        return;
      }
      const container = closest(event.target, this.containers);
      if (!container) {
        return;
      }
      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {
        return;
      }
      const originalSource = closest(event.target, this.options.draggable);
      if (!originalSource) {
        return;
      }
      const {
        delay
      } = this;
      const {
        pageX,
        pageY
      } = event;
      Object.assign(this, {
        pageX,
        pageY
      });
      this.onMouseDownAt = Date.now();
      this.startEvent = event;
      this.currentContainer = container;
      this.originalSource = originalSource;
      document.addEventListener("mouseup", this[onMouseUp]);
      document.addEventListener("dragstart", preventNativeDragStart);
      document.addEventListener("mousemove", this[onDistanceChange]);
      this.mouseDownTimeout = window.setTimeout(() => {
        this[onDistanceChange]({
          pageX: this.pageX,
          pageY: this.pageY
        });
      }, delay.mouse);
    }
    [startDrag]() {
      const startEvent = this.startEvent;
      const container = this.currentContainer;
      const originalSource = this.originalSource;
      const dragStartEvent = new DragStartSensorEvent({
        clientX: startEvent.clientX,
        clientY: startEvent.clientY,
        target: startEvent.target,
        container,
        originalSource,
        originalEvent: startEvent
      });
      this.trigger(this.currentContainer, dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (this.dragging) {
        document.addEventListener("contextmenu", this[onContextMenuWhileDragging], true);
        document.addEventListener("mousemove", this[onMouseMove]);
      }
    }
    [onDistanceChange](event) {
      const {
        pageX,
        pageY
      } = event;
      const {
        distance: distance$1
      } = this.options;
      const {
        startEvent,
        delay
      } = this;
      Object.assign(this, {
        pageX,
        pageY
      });
      if (!this.currentContainer) {
        return;
      }
      const timeElapsed = Date.now() - this.onMouseDownAt;
      const distanceTravelled = distance(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;
      clearTimeout(this.mouseDownTimeout);
      if (timeElapsed < delay.mouse) {
        document.removeEventListener("mousemove", this[onDistanceChange]);
      } else if (distanceTravelled >= distance$1) {
        document.removeEventListener("mousemove", this[onDistanceChange]);
        this[startDrag]();
      }
    }
    [onMouseMove](event) {
      if (!this.dragging) {
        return;
      }
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const dragMoveEvent = new DragMoveSensorEvent({
        clientX: event.clientX,
        clientY: event.clientY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragMoveEvent);
    }
    [onMouseUp](event) {
      clearTimeout(this.mouseDownTimeout);
      if (event.button !== 0) {
        return;
      }
      document.removeEventListener("mouseup", this[onMouseUp]);
      document.removeEventListener("dragstart", preventNativeDragStart);
      document.removeEventListener("mousemove", this[onDistanceChange]);
      if (!this.dragging) {
        return;
      }
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const dragStopEvent = new DragStopSensorEvent({
        clientX: event.clientX,
        clientY: event.clientY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragStopEvent);
      document.removeEventListener("contextmenu", this[onContextMenuWhileDragging], true);
      document.removeEventListener("mousemove", this[onMouseMove]);
      this.currentContainer = null;
      this.dragging = false;
      this.startEvent = null;
    }
    [onContextMenuWhileDragging](event) {
      event.preventDefault();
    }
  };
  function preventNativeDragStart(event) {
    event.preventDefault();
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/touchCoords/touchCoords.mjs
  function touchCoords(event) {
    const {
      touches,
      changedTouches
    } = event;
    return touches && touches[0] || changedTouches && changedTouches[0];
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/TouchSensor/TouchSensor.mjs
  var onTouchStart = Symbol("onTouchStart");
  var onTouchEnd = Symbol("onTouchEnd");
  var onTouchMove = Symbol("onTouchMove");
  var startDrag2 = Symbol("startDrag");
  var onDistanceChange2 = Symbol("onDistanceChange");
  var preventScrolling = false;
  window.addEventListener("touchmove", (event) => {
    if (!preventScrolling) {
      return;
    }
    event.preventDefault();
  }, {
    passive: false
  });
  var TouchSensor = class extends Sensor {
    constructor(containers = [], options = {}) {
      super(containers, options);
      this.currentScrollableParent = null;
      this.tapTimeout = null;
      this.touchMoved = false;
      this.pageX = null;
      this.pageY = null;
      this[onTouchStart] = this[onTouchStart].bind(this);
      this[onTouchEnd] = this[onTouchEnd].bind(this);
      this[onTouchMove] = this[onTouchMove].bind(this);
      this[startDrag2] = this[startDrag2].bind(this);
      this[onDistanceChange2] = this[onDistanceChange2].bind(this);
    }
    attach() {
      document.addEventListener("touchstart", this[onTouchStart]);
    }
    detach() {
      document.removeEventListener("touchstart", this[onTouchStart]);
    }
    [onTouchStart](event) {
      const container = closest(event.target, this.containers);
      if (!container) {
        return;
      }
      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {
        return;
      }
      const originalSource = closest(event.target, this.options.draggable);
      if (!originalSource) {
        return;
      }
      const {
        distance: distance2 = 0
      } = this.options;
      const {
        delay
      } = this;
      const {
        pageX,
        pageY
      } = touchCoords(event);
      Object.assign(this, {
        pageX,
        pageY
      });
      this.onTouchStartAt = Date.now();
      this.startEvent = event;
      this.currentContainer = container;
      this.originalSource = originalSource;
      document.addEventListener("touchend", this[onTouchEnd]);
      document.addEventListener("touchcancel", this[onTouchEnd]);
      document.addEventListener("touchmove", this[onDistanceChange2]);
      container.addEventListener("contextmenu", onContextMenu);
      if (distance2) {
        preventScrolling = true;
      }
      this.tapTimeout = window.setTimeout(() => {
        this[onDistanceChange2]({
          touches: [{
            pageX: this.pageX,
            pageY: this.pageY
          }]
        });
      }, delay.touch);
    }
    [startDrag2]() {
      const startEvent = this.startEvent;
      const container = this.currentContainer;
      const touch = touchCoords(startEvent);
      const originalSource = this.originalSource;
      const dragStartEvent = new DragStartSensorEvent({
        clientX: touch.pageX,
        clientY: touch.pageY,
        target: startEvent.target,
        container,
        originalSource,
        originalEvent: startEvent
      });
      this.trigger(this.currentContainer, dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (this.dragging) {
        document.addEventListener("touchmove", this[onTouchMove]);
      }
      preventScrolling = this.dragging;
    }
    [onDistanceChange2](event) {
      const {
        distance: distance$1
      } = this.options;
      const {
        startEvent,
        delay
      } = this;
      const start = touchCoords(startEvent);
      const current = touchCoords(event);
      const timeElapsed = Date.now() - this.onTouchStartAt;
      const distanceTravelled = distance(start.pageX, start.pageY, current.pageX, current.pageY);
      Object.assign(this, current);
      clearTimeout(this.tapTimeout);
      if (timeElapsed < delay.touch) {
        document.removeEventListener("touchmove", this[onDistanceChange2]);
      } else if (distanceTravelled >= distance$1) {
        document.removeEventListener("touchmove", this[onDistanceChange2]);
        this[startDrag2]();
      }
    }
    [onTouchMove](event) {
      if (!this.dragging) {
        return;
      }
      const {
        pageX,
        pageY
      } = touchCoords(event);
      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);
      const dragMoveEvent = new DragMoveSensorEvent({
        clientX: pageX,
        clientY: pageY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragMoveEvent);
    }
    [onTouchEnd](event) {
      clearTimeout(this.tapTimeout);
      preventScrolling = false;
      document.removeEventListener("touchend", this[onTouchEnd]);
      document.removeEventListener("touchcancel", this[onTouchEnd]);
      document.removeEventListener("touchmove", this[onDistanceChange2]);
      if (this.currentContainer) {
        this.currentContainer.removeEventListener("contextmenu", onContextMenu);
      }
      if (!this.dragging) {
        return;
      }
      document.removeEventListener("touchmove", this[onTouchMove]);
      const {
        pageX,
        pageY
      } = touchCoords(event);
      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);
      event.preventDefault();
      const dragStopEvent = new DragStopSensorEvent({
        clientX: pageX,
        clientY: pageY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragStopEvent);
      this.currentContainer = null;
      this.dragging = false;
      this.startEvent = null;
    }
  };
  function onContextMenu(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/DragSensor/DragSensor.mjs
  var onMouseDown2 = Symbol("onMouseDown");
  var onMouseUp2 = Symbol("onMouseUp");
  var onDragStart = Symbol("onDragStart");
  var onDragOver = Symbol("onDragOver");
  var onDragEnd = Symbol("onDragEnd");
  var onDrop = Symbol("onDrop");
  var reset = Symbol("reset");

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/ForceTouchSensor/ForceTouchSensor.mjs
  var onMouseForceWillBegin = Symbol("onMouseForceWillBegin");
  var onMouseForceDown = Symbol("onMouseForceDown");
  var onMouseDown3 = Symbol("onMouseDown");
  var onMouseForceChange = Symbol("onMouseForceChange");
  var onMouseMove2 = Symbol("onMouseMove");
  var onMouseUp3 = Symbol("onMouseUp");
  var onMouseForceGlobalChange = Symbol("onMouseForceGlobalChange");

  // node_modules/@shopify/draggable/build/esm/Plugins/index.mjs
  var Plugins_exports = {};
  __export(Plugins_exports, {
    Collidable: () => Collidable,
    ResizeMirror: () => ResizeMirror,
    Snappable: () => Snappable,
    SortAnimation: () => SortAnimation,
    SwapAnimation: () => SwapAnimation,
    defaultResizeMirrorOptions: () => defaultOptions,
    defaultSortAnimationOptions: () => defaultOptions3,
    defaultSwapAnimationOptions: () => defaultOptions2
  });

  // node_modules/@shopify/draggable/build/esm/Plugins/Collidable/CollidableEvent/CollidableEvent.mjs
  var CollidableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  CollidableEvent.type = "collidable";
  var CollidableInEvent = class extends CollidableEvent {
    get collidingElement() {
      return this.data.collidingElement;
    }
  };
  CollidableInEvent.type = "collidable:in";
  var CollidableOutEvent = class extends CollidableEvent {
    get collidingElement() {
      return this.data.collidingElement;
    }
  };
  CollidableOutEvent.type = "collidable:out";

  // node_modules/@shopify/draggable/build/esm/Plugins/Collidable/Collidable.mjs
  var onDragMove = Symbol("onDragMove");
  var onDragStop = Symbol("onDragStop");
  var onRequestAnimationFrame = Symbol("onRequestAnimationFrame");
  var Collidable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.currentlyCollidingElement = null;
      this.lastCollidingElement = null;
      this.currentAnimationFrame = null;
      this[onDragMove] = this[onDragMove].bind(this);
      this[onDragStop] = this[onDragStop].bind(this);
      this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);
    }
    attach() {
      this.draggable.on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
    }
    detach() {
      this.draggable.off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
    }
    getCollidables() {
      const collidables = this.draggable.options.collidables;
      if (typeof collidables === "string") {
        return Array.prototype.slice.call(document.querySelectorAll(collidables));
      } else if (collidables instanceof NodeList || collidables instanceof Array) {
        return Array.prototype.slice.call(collidables);
      } else if (collidables instanceof HTMLElement) {
        return [collidables];
      } else if (typeof collidables === "function") {
        return collidables();
      } else {
        return [];
      }
    }
    [onDragMove](event) {
      const target = event.sensorEvent.target;
      this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));
      if (this.currentlyCollidingElement) {
        event.cancel();
      }
      const collidableInEvent = new CollidableInEvent({
        dragEvent: event,
        collidingElement: this.currentlyCollidingElement
      });
      const collidableOutEvent = new CollidableOutEvent({
        dragEvent: event,
        collidingElement: this.lastCollidingElement
      });
      const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);
      const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);
      if (enteringCollidable) {
        if (this.lastCollidingElement) {
          this.draggable.trigger(collidableOutEvent);
        }
        this.draggable.trigger(collidableInEvent);
      } else if (leavingCollidable) {
        this.draggable.trigger(collidableOutEvent);
      }
      this.lastCollidingElement = this.currentlyCollidingElement;
    }
    [onDragStop](event) {
      const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;
      const collidableOutEvent = new CollidableOutEvent({
        dragEvent: event,
        collidingElement: lastCollidingElement
      });
      if (lastCollidingElement) {
        this.draggable.trigger(collidableOutEvent);
      }
      this.lastCollidingElement = null;
      this.currentlyCollidingElement = null;
    }
    [onRequestAnimationFrame](target) {
      return () => {
        const collidables = this.getCollidables();
        this.currentlyCollidingElement = closest(target, (element) => collidables.includes(element));
      };
    }
  };

  // node_modules/@shopify/draggable/build/esm/_virtual/_rollupPluginBabelHelpers.mjs
  function createAddInitializerMethod(e, t) {
    return function(r) {
      assertNotFinished(t, "addInitializer"), assertCallable(r, "An initializer"), e.push(r);
    };
  }
  function assertInstanceIfPrivate(e, t) {
    if (!e(t))
      throw new TypeError("Attempted to access private element on non-instance");
  }
  function memberDec(e, t, r, a, n, i, s, o, c, l, u) {
    var f;
    switch (i) {
      case 1:
        f = "accessor";
        break;
      case 2:
        f = "method";
        break;
      case 3:
        f = "getter";
        break;
      case 4:
        f = "setter";
        break;
      default:
        f = "field";
    }
    var d, p, h = {
      kind: f,
      name: o ? "#" + r : r,
      static: s,
      private: o,
      metadata: u
    }, v = {
      v: false
    };
    if (i !== 0 && (h.addInitializer = createAddInitializerMethod(n, v)), o || i !== 0 && i !== 2) {
      if (i === 2)
        d = function(e2) {
          return assertInstanceIfPrivate(l, e2), a.value;
        };
      else {
        var y = i === 0 || i === 1;
        (y || i === 3) && (d = o ? function(e2) {
          return assertInstanceIfPrivate(l, e2), a.get.call(e2);
        } : function(e2) {
          return a.get.call(e2);
        }), (y || i === 4) && (p = o ? function(e2, t2) {
          assertInstanceIfPrivate(l, e2), a.set.call(e2, t2);
        } : function(e2, t2) {
          a.set.call(e2, t2);
        });
      }
    } else
      d = function(e2) {
        return e2[r];
      }, i === 0 && (p = function(e2, t2) {
        e2[r] = t2;
      });
    var m = o ? l.bind() : function(e2) {
      return r in e2;
    };
    h.access = d && p ? {
      get: d,
      set: p,
      has: m
    } : d ? {
      get: d,
      has: m
    } : {
      set: p,
      has: m
    };
    try {
      return e.call(t, c, h);
    } finally {
      v.v = true;
    }
  }
  function assertNotFinished(e, t) {
    if (e.v)
      throw new Error("attempted to call " + t + " after decoration was finished");
  }
  function assertCallable(e, t) {
    if (typeof e != "function")
      throw new TypeError(t + " must be a function");
  }
  function assertValidReturnValue(e, t) {
    var r = typeof t;
    if (e === 1) {
      if (r !== "object" || t === null)
        throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
      t.get !== void 0 && assertCallable(t.get, "accessor.get"), t.set !== void 0 && assertCallable(t.set, "accessor.set"), t.init !== void 0 && assertCallable(t.init, "accessor.init");
    } else if (r !== "function") {
      var a;
      throw a = e === 0 ? "field" : e === 5 ? "class" : "method", new TypeError(a + " decorators must return a function or void 0");
    }
  }
  function curryThis1(e) {
    return function() {
      return e(this);
    };
  }
  function curryThis2(e) {
    return function(t) {
      e(this, t);
    };
  }
  function applyMemberDec(e, t, r, a, n, i, s, o, c, l, u) {
    var f, d, p, h, v, y, m = r[0];
    a || Array.isArray(m) || (m = [m]), o ? f = i === 0 || i === 1 ? {
      get: curryThis1(r[3]),
      set: curryThis2(r[4])
    } : i === 3 ? {
      get: r[3]
    } : i === 4 ? {
      set: r[3]
    } : {
      value: r[3]
    } : i !== 0 && (f = Object.getOwnPropertyDescriptor(t, n)), i === 1 ? p = {
      get: f.get,
      set: f.set
    } : i === 2 ? p = f.value : i === 3 ? p = f.get : i === 4 && (p = f.set);
    for (var g = a ? 2 : 1, b = m.length - 1; b >= 0; b -= g) {
      var I;
      if ((h = memberDec(m[b], a ? m[b - 1] : void 0, n, f, c, i, s, o, p, l, u)) !== void 0)
        assertValidReturnValue(i, h), i === 0 ? I = h : i === 1 ? (I = h.init, v = h.get || p.get, y = h.set || p.set, p = {
          get: v,
          set: y
        }) : p = h, I !== void 0 && (d === void 0 ? d = I : typeof d == "function" ? d = [d, I] : d.push(I));
    }
    if (i === 0 || i === 1) {
      if (d === void 0)
        d = function(e2, t2) {
          return t2;
        };
      else if (typeof d != "function") {
        var w = d;
        d = function(e2, t2) {
          for (var r2 = t2, a2 = w.length - 1; a2 >= 0; a2--)
            r2 = w[a2].call(e2, r2);
          return r2;
        };
      } else {
        var M = d;
        d = function(e2, t2) {
          return M.call(e2, t2);
        };
      }
      e.push(d);
    }
    i !== 0 && (i === 1 ? (f.get = p.get, f.set = p.set) : i === 2 ? f.value = p : i === 3 ? f.get = p : i === 4 && (f.set = p), o ? i === 1 ? (e.push(function(e2, t2) {
      return p.get.call(e2, t2);
    }), e.push(function(e2, t2) {
      return p.set.call(e2, t2);
    })) : i === 2 ? e.push(p) : e.push(function(e2, t2) {
      return p.call(e2, t2);
    }) : Object.defineProperty(t, n, f));
  }
  function applyMemberDecs(e, t, r, a) {
    for (var n, i, s, o = [], c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), u = 0; u < t.length; u++) {
      var f = t[u];
      if (Array.isArray(f)) {
        var d, p, h = f[1], v = f[2], y = f.length > 3, m = 16 & h, g = !!(8 & h), b = r;
        if (h &= 7, g ? (d = e, h !== 0 && (p = i = i || []), y && !s && (s = function(t2) {
          return _checkInRHS(t2) === e;
        }), b = s) : (d = e.prototype, h !== 0 && (p = n = n || [])), h !== 0 && !y) {
          var I = g ? l : c, w = I.get(v) || 0;
          if (w === true || w === 3 && h !== 4 || w === 4 && h !== 3)
            throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + v);
          I.set(v, !(!w && h > 2) || h);
        }
        applyMemberDec(o, d, f, m, v, h, g, y, p, b, a);
      }
    }
    return pushInitializers(o, n), pushInitializers(o, i), o;
  }
  function pushInitializers(e, t) {
    t && e.push(function(e2) {
      for (var r = 0; r < t.length; r++)
        t[r].call(e2);
      return e2;
    });
  }
  function applyClassDecs(e, t, r, a) {
    if (t.length) {
      for (var n = [], i = e, s = e.name, o = r ? 2 : 1, c = t.length - 1; c >= 0; c -= o) {
        var l = {
          v: false
        };
        try {
          var u = t[c].call(r ? t[c - 1] : void 0, i, {
            kind: "class",
            name: s,
            addInitializer: createAddInitializerMethod(n, l),
            metadata: a
          });
        } finally {
          l.v = true;
        }
        u !== void 0 && (assertValidReturnValue(5, u), i = u);
      }
      return [defineMetadata(i, a), function() {
        for (var e2 = 0; e2 < n.length; e2++)
          n[e2].call(i);
      }];
    }
  }
  function defineMetadata(e, t) {
    return Object.defineProperty(e, Symbol.metadata || Symbol.for("Symbol.metadata"), {
      configurable: true,
      enumerable: true,
      value: t
    });
  }
  function _applyDecs2305(e, t, r, a, n, i) {
    if (arguments.length >= 6)
      var s = i[Symbol.metadata || Symbol.for("Symbol.metadata")];
    var o = Object.create(s === void 0 ? null : s), c = applyMemberDecs(e, t, n, o);
    return r.length || defineMetadata(e, o), {
      e: c,
      get c() {
        return applyClassDecs(e, r, a, o);
      }
    };
  }
  function _checkInRHS(e) {
    if (Object(e) !== e)
      throw TypeError("right-hand side of 'in' should be an object, got " + (e !== null ? typeof e : "null"));
    return e;
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/decorators/AutoBind.mjs
  function AutoBind(originalMethod, {
    name,
    addInitializer
  }) {
    addInitializer(function() {
      this[name] = originalMethod.bind(this);
    });
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/requestNextAnimationFrame/requestNextAnimationFrame.mjs
  function requestNextAnimationFrame(callback) {
    return requestAnimationFrame(() => {
      requestAnimationFrame(callback);
    });
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/DragEvent/DragEvent.mjs
  var DragEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get source() {
      return this.data.source;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get mirror() {
      return this.data.mirror;
    }
    get sourceContainer() {
      return this.data.sourceContainer;
    }
    get sensorEvent() {
      return this.data.sensorEvent;
    }
    get originalEvent() {
      if (this.sensorEvent) {
        return this.sensorEvent.originalEvent;
      }
      return null;
    }
  };
  DragEvent.type = "drag";
  var DragStartEvent = class extends DragEvent {
  };
  DragStartEvent.type = "drag:start";
  DragStartEvent.cancelable = true;
  var DragMoveEvent = class extends DragEvent {
  };
  DragMoveEvent.type = "drag:move";
  var DragOverEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
    get over() {
      return this.data.over;
    }
  };
  DragOverEvent.type = "drag:over";
  DragOverEvent.cancelable = true;
  function isDragOverEvent(event) {
    return event.type === DragOverEvent.type;
  }
  var DragOutEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
    get over() {
      return this.data.over;
    }
  };
  DragOutEvent.type = "drag:out";
  var DragOverContainerEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
  };
  DragOverContainerEvent.type = "drag:over:container";
  var DragOutContainerEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
  };
  DragOutContainerEvent.type = "drag:out:container";
  var DragPressureEvent = class extends DragEvent {
    get pressure() {
      return this.data.pressure;
    }
  };
  DragPressureEvent.type = "drag:pressure";
  var DragStopEvent = class extends DragEvent {
  };
  DragStopEvent.type = "drag:stop";
  DragStopEvent.cancelable = true;
  var DragStoppedEvent = class extends DragEvent {
  };
  DragStoppedEvent.type = "drag:stopped";

  // node_modules/@shopify/draggable/build/esm/Plugins/ResizeMirror/ResizeMirror.mjs
  var _initProto;
  var _class;
  var defaultOptions = {};
  var ResizeMirror = class extends AbstractPlugin {
    constructor(draggable) {
      _initProto(super(draggable));
      this.lastWidth = 0;
      this.lastHeight = 0;
      this.mirror = null;
    }
    attach() {
      this.draggable.on("mirror:created", this.onMirrorCreated).on("drag:over", this.onDragOver).on("drag:over:container", this.onDragOver);
    }
    detach() {
      this.draggable.off("mirror:created", this.onMirrorCreated).off("mirror:destroy", this.onMirrorDestroy).off("drag:over", this.onDragOver).off("drag:over:container", this.onDragOver);
    }
    getOptions() {
      return this.draggable.options.resizeMirror || {};
    }
    onMirrorCreated({
      mirror
    }) {
      this.mirror = mirror;
    }
    onMirrorDestroy() {
      this.mirror = null;
    }
    onDragOver(dragEvent) {
      this.resize(dragEvent);
    }
    resize(dragEvent) {
      requestAnimationFrame(() => {
        let over = null;
        const {
          overContainer
        } = dragEvent;
        if (this.mirror == null || this.mirror.parentNode == null) {
          return;
        }
        if (this.mirror.parentNode !== overContainer) {
          overContainer.appendChild(this.mirror);
        }
        if (isDragOverEvent(dragEvent)) {
          over = dragEvent.over;
        }
        const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];
        if (!overElement) {
          return;
        }
        requestNextAnimationFrame(() => {
          const overRect = overElement.getBoundingClientRect();
          if (this.mirror == null || this.lastHeight === overRect.height && this.lastWidth === overRect.width) {
            return;
          }
          this.mirror.style.width = `${overRect.width}px`;
          this.mirror.style.height = `${overRect.height}px`;
          this.lastWidth = overRect.width;
          this.lastHeight = overRect.height;
        });
      });
    }
  };
  _class = ResizeMirror;
  [_initProto] = _applyDecs2305(_class, [[AutoBind, 2, "onMirrorCreated"], [AutoBind, 2, "onMirrorDestroy"], [AutoBind, 2, "onDragOver"]], [], 0, void 0, AbstractPlugin).e;

  // node_modules/@shopify/draggable/build/esm/Plugins/Snappable/SnappableEvent/SnappableEvent.mjs
  var SnapEvent = class extends AbstractEvent {
    get dragEvent() {
      return this.data.dragEvent;
    }
    get snappable() {
      return this.data.snappable;
    }
  };
  SnapEvent.type = "snap";
  var SnapInEvent = class extends SnapEvent {
  };
  SnapInEvent.type = "snap:in";
  SnapInEvent.cancelable = true;
  var SnapOutEvent = class extends SnapEvent {
  };
  SnapOutEvent.type = "snap:out";
  SnapOutEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Plugins/Snappable/Snappable.mjs
  var onDragStart2 = Symbol("onDragStart");
  var onDragStop2 = Symbol("onDragStop");
  var onDragOver2 = Symbol("onDragOver");
  var onDragOut = Symbol("onDragOut");
  var onMirrorCreated = Symbol("onMirrorCreated");
  var onMirrorDestroy = Symbol("onMirrorDestroy");
  var Snappable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.firstSource = null;
      this.mirror = null;
      this[onDragStart2] = this[onDragStart2].bind(this);
      this[onDragStop2] = this[onDragStop2].bind(this);
      this[onDragOver2] = this[onDragOver2].bind(this);
      this[onDragOut] = this[onDragOut].bind(this);
      this[onMirrorCreated] = this[onMirrorCreated].bind(this);
      this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart2]).on("drag:stop", this[onDragStop2]).on("drag:over", this[onDragOver2]).on("drag:out", this[onDragOut]).on("droppable:over", this[onDragOver2]).on("droppable:out", this[onDragOut]).on("mirror:created", this[onMirrorCreated]).on("mirror:destroy", this[onMirrorDestroy]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart2]).off("drag:stop", this[onDragStop2]).off("drag:over", this[onDragOver2]).off("drag:out", this[onDragOut]).off("droppable:over", this[onDragOver2]).off("droppable:out", this[onDragOut]).off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]);
    }
    [onDragStart2](event) {
      if (event.canceled()) {
        return;
      }
      this.firstSource = event.source;
    }
    [onDragStop2]() {
      this.firstSource = null;
    }
    [onDragOver2](event) {
      if (event.canceled()) {
        return;
      }
      const source = event.source || event.dragEvent.source;
      if (source === this.firstSource) {
        this.firstSource = null;
        return;
      }
      const snapInEvent = new SnapInEvent({
        dragEvent: event,
        snappable: event.over || event.droppable
      });
      this.draggable.trigger(snapInEvent);
      if (snapInEvent.canceled()) {
        return;
      }
      if (this.mirror) {
        this.mirror.style.display = "none";
      }
      source.classList.remove(...this.draggable.getClassNamesFor("source:dragging"));
      source.classList.add(...this.draggable.getClassNamesFor("source:placed"));
      setTimeout(() => {
        source.classList.remove(...this.draggable.getClassNamesFor("source:placed"));
      }, this.draggable.options.placedTimeout);
    }
    [onDragOut](event) {
      if (event.canceled()) {
        return;
      }
      const source = event.source || event.dragEvent.source;
      const snapOutEvent = new SnapOutEvent({
        dragEvent: event,
        snappable: event.over || event.droppable
      });
      this.draggable.trigger(snapOutEvent);
      if (snapOutEvent.canceled()) {
        return;
      }
      if (this.mirror) {
        this.mirror.style.display = "";
      }
      source.classList.add(...this.draggable.getClassNamesFor("source:dragging"));
    }
    [onMirrorCreated]({
      mirror
    }) {
      this.mirror = mirror;
    }
    [onMirrorDestroy]() {
      this.mirror = null;
    }
  };

  // node_modules/@shopify/draggable/build/esm/Plugins/SwapAnimation/SwapAnimation.mjs
  var _initProto2;
  var _class2;
  var defaultOptions2 = {
    duration: 150,
    easingFunction: "ease-in-out",
    horizontal: false
  };
  var SwapAnimation = class extends AbstractPlugin {
    constructor(draggable) {
      _initProto2(super(draggable));
      this.options = __spreadValues(__spreadValues({}, defaultOptions2), this.getOptions());
      this.lastAnimationFrame = null;
    }
    attach() {
      this.draggable.on("sortable:sorted", this.onSortableSorted);
    }
    detach() {
      this.draggable.off("sortable:sorted", this.onSortableSorted);
    }
    getOptions() {
      return this.draggable.options.swapAnimation || {};
    }
    onSortableSorted({
      oldIndex,
      newIndex,
      dragEvent
    }) {
      const {
        source,
        over
      } = dragEvent;
      if (this.lastAnimationFrame) {
        cancelAnimationFrame(this.lastAnimationFrame);
      }
      this.lastAnimationFrame = requestAnimationFrame(() => {
        if (oldIndex >= newIndex) {
          animate(source, over, this.options);
        } else {
          animate(over, source, this.options);
        }
      });
    }
  };
  _class2 = SwapAnimation;
  [_initProto2] = _applyDecs2305(_class2, [[AutoBind, 2, "onSortableSorted"]], [], 0, void 0, AbstractPlugin).e;
  function animate(from, to, {
    duration,
    easingFunction,
    horizontal
  }) {
    for (const element of [from, to]) {
      element.style.pointerEvents = "none";
    }
    if (horizontal) {
      const width = from.offsetWidth;
      from.style.transform = `translate3d(${width}px, 0, 0)`;
      to.style.transform = `translate3d(-${width}px, 0, 0)`;
    } else {
      const height = from.offsetHeight;
      from.style.transform = `translate3d(0, ${height}px, 0)`;
      to.style.transform = `translate3d(0, -${height}px, 0)`;
    }
    requestAnimationFrame(() => {
      for (const element of [from, to]) {
        element.addEventListener("transitionend", resetElementOnTransitionEnd);
        element.style.transition = `transform ${duration}ms ${easingFunction}`;
        element.style.transform = "";
      }
    });
  }
  function resetElementOnTransitionEnd(event) {
    if (event.target == null || !isHTMLElement(event.target)) {
      return;
    }
    event.target.style.transition = "";
    event.target.style.pointerEvents = "";
    event.target.removeEventListener("transitionend", resetElementOnTransitionEnd);
  }
  function isHTMLElement(eventTarget) {
    return Boolean("style" in eventTarget);
  }

  // node_modules/@shopify/draggable/build/esm/Plugins/SortAnimation/SortAnimation.mjs
  var onSortableSorted = Symbol("onSortableSorted");
  var onSortableSort = Symbol("onSortableSort");
  var defaultOptions3 = {
    duration: 150,
    easingFunction: "ease-in-out"
  };
  var SortAnimation = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions3), this.getOptions());
      this.lastAnimationFrame = null;
      this.lastElements = [];
      this[onSortableSorted] = this[onSortableSorted].bind(this);
      this[onSortableSort] = this[onSortableSort].bind(this);
    }
    attach() {
      this.draggable.on("sortable:sort", this[onSortableSort]);
      this.draggable.on("sortable:sorted", this[onSortableSorted]);
    }
    detach() {
      this.draggable.off("sortable:sort", this[onSortableSort]);
      this.draggable.off("sortable:sorted", this[onSortableSorted]);
    }
    getOptions() {
      return this.draggable.options.sortAnimation || {};
    }
    [onSortableSort]({
      dragEvent
    }) {
      const {
        sourceContainer
      } = dragEvent;
      const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);
      this.lastElements = Array.from(elements).map((el) => {
        return {
          domEl: el,
          offsetTop: el.offsetTop,
          offsetLeft: el.offsetLeft
        };
      });
    }
    [onSortableSorted]({
      oldIndex,
      newIndex
    }) {
      if (oldIndex === newIndex) {
        return;
      }
      const effectedElements = [];
      let start;
      let end;
      let num;
      if (oldIndex > newIndex) {
        start = newIndex;
        end = oldIndex - 1;
        num = 1;
      } else {
        start = oldIndex + 1;
        end = newIndex;
        num = -1;
      }
      for (let i = start; i <= end; i++) {
        const from = this.lastElements[i];
        const to = this.lastElements[i + num];
        effectedElements.push({
          from,
          to
        });
      }
      cancelAnimationFrame(this.lastAnimationFrame);
      this.lastAnimationFrame = requestAnimationFrame(() => {
        effectedElements.forEach((element) => animate2(element, this.options));
      });
    }
  };
  function animate2({
    from,
    to
  }, {
    duration,
    easingFunction
  }) {
    const domEl = from.domEl;
    const x = from.offsetLeft - to.offsetLeft;
    const y = from.offsetTop - to.offsetTop;
    domEl.style.pointerEvents = "none";
    domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    requestAnimationFrame(() => {
      domEl.addEventListener("transitionend", resetElementOnTransitionEnd2);
      domEl.style.transition = `transform ${duration}ms ${easingFunction}`;
      domEl.style.transform = "";
    });
  }
  function resetElementOnTransitionEnd2(event) {
    event.target.style.transition = "";
    event.target.style.pointerEvents = "";
    event.target.removeEventListener("transitionend", resetElementOnTransitionEnd2);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Announcement/Announcement.mjs
  var onInitialize = Symbol("onInitialize");
  var onDestroy = Symbol("onDestroy");
  var announceEvent = Symbol("announceEvent");
  var announceMessage = Symbol("announceMessage");
  var ARIA_RELEVANT = "aria-relevant";
  var ARIA_ATOMIC = "aria-atomic";
  var ARIA_LIVE = "aria-live";
  var ROLE = "role";
  var defaultOptions4 = {
    expire: 7e3
  };
  var Announcement = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions4), this.getOptions());
      this.originalTriggerMethod = this.draggable.trigger;
      this[onInitialize] = this[onInitialize].bind(this);
      this[onDestroy] = this[onDestroy].bind(this);
    }
    attach() {
      this.draggable.on("draggable:initialize", this[onInitialize]);
    }
    detach() {
      this.draggable.off("draggable:destroy", this[onDestroy]);
    }
    getOptions() {
      return this.draggable.options.announcements || {};
    }
    [announceEvent](event) {
      const message = this.options[event.type];
      if (message && typeof message === "string") {
        this[announceMessage](message);
      }
      if (message && typeof message === "function") {
        this[announceMessage](message(event));
      }
    }
    [announceMessage](message) {
      announce(message, {
        expire: this.options.expire
      });
    }
    [onInitialize]() {
      this.draggable.trigger = (event) => {
        try {
          this[announceEvent](event);
        } finally {
          this.originalTriggerMethod.call(this.draggable, event);
        }
      };
    }
    [onDestroy]() {
      this.draggable.trigger = this.originalTriggerMethod;
    }
  };
  var liveRegion = createRegion();
  function announce(message, {
    expire
  }) {
    const element = document.createElement("div");
    element.textContent = message;
    liveRegion.appendChild(element);
    return setTimeout(() => {
      liveRegion.removeChild(element);
    }, expire);
  }
  function createRegion() {
    const element = document.createElement("div");
    element.setAttribute("id", "draggable-live-region");
    element.setAttribute(ARIA_RELEVANT, "additions");
    element.setAttribute(ARIA_ATOMIC, "true");
    element.setAttribute(ARIA_LIVE, "assertive");
    element.setAttribute(ROLE, "log");
    element.style.position = "fixed";
    element.style.width = "1px";
    element.style.height = "1px";
    element.style.top = "-1px";
    element.style.overflow = "hidden";
    return element;
  }
  document.addEventListener("DOMContentLoaded", () => {
    document.body.appendChild(liveRegion);
  });

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Focusable/Focusable.mjs
  var onInitialize2 = Symbol("onInitialize");
  var onDestroy2 = Symbol("onDestroy");
  var defaultOptions5 = {};
  var Focusable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions5), this.getOptions());
      this[onInitialize2] = this[onInitialize2].bind(this);
      this[onDestroy2] = this[onDestroy2].bind(this);
    }
    attach() {
      this.draggable.on("draggable:initialize", this[onInitialize2]).on("draggable:destroy", this[onDestroy2]);
    }
    detach() {
      this.draggable.off("draggable:initialize", this[onInitialize2]).off("draggable:destroy", this[onDestroy2]);
      this[onDestroy2]();
    }
    getOptions() {
      return this.draggable.options.focusable || {};
    }
    getElements() {
      return [...this.draggable.containers, ...this.draggable.getDraggableElements()];
    }
    [onInitialize2]() {
      requestAnimationFrame(() => {
        this.getElements().forEach((element) => decorateElement(element));
      });
    }
    [onDestroy2]() {
      requestAnimationFrame(() => {
        this.getElements().forEach((element) => stripElement(element));
      });
    }
  };
  var elementsWithMissingTabIndex = [];
  function decorateElement(element) {
    const hasMissingTabIndex = Boolean(!element.getAttribute("tabindex") && element.tabIndex === -1);
    if (hasMissingTabIndex) {
      elementsWithMissingTabIndex.push(element);
      element.tabIndex = 0;
    }
  }
  function stripElement(element) {
    const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);
    if (tabIndexElementPosition !== -1) {
      element.tabIndex = -1;
      elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);
    }
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Mirror/MirrorEvent/MirrorEvent.mjs
  var MirrorEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get source() {
      return this.data.source;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get sourceContainer() {
      return this.data.sourceContainer;
    }
    get sensorEvent() {
      return this.data.sensorEvent;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
    get originalEvent() {
      if (this.sensorEvent) {
        return this.sensorEvent.originalEvent;
      }
      return null;
    }
  };
  var MirrorCreateEvent = class extends MirrorEvent {
  };
  MirrorCreateEvent.type = "mirror:create";
  var MirrorCreatedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorCreatedEvent.type = "mirror:created";
  var MirrorAttachedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorAttachedEvent.type = "mirror:attached";
  var MirrorMoveEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
    get passedThreshX() {
      return this.data.passedThreshX;
    }
    get passedThreshY() {
      return this.data.passedThreshY;
    }
  };
  MirrorMoveEvent.type = "mirror:move";
  MirrorMoveEvent.cancelable = true;
  var MirrorMovedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
    get passedThreshX() {
      return this.data.passedThreshX;
    }
    get passedThreshY() {
      return this.data.passedThreshY;
    }
  };
  MirrorMovedEvent.type = "mirror:moved";
  var MirrorDestroyEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorDestroyEvent.type = "mirror:destroy";
  MirrorDestroyEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Mirror/Mirror.mjs
  var onDragStart3 = Symbol("onDragStart");
  var onDragMove2 = Symbol("onDragMove");
  var onDragStop3 = Symbol("onDragStop");
  var onMirrorCreated2 = Symbol("onMirrorCreated");
  var onMirrorMove = Symbol("onMirrorMove");
  var onScroll = Symbol("onScroll");
  var getAppendableContainer = Symbol("getAppendableContainer");
  var defaultOptions6 = {
    constrainDimensions: false,
    xAxis: true,
    yAxis: true,
    cursorOffsetX: null,
    cursorOffsetY: null,
    thresholdX: null,
    thresholdY: null
  };
  var Mirror = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions6), this.getOptions());
      this.scrollOffset = {
        x: 0,
        y: 0
      };
      this.initialScrollOffset = {
        x: window.scrollX,
        y: window.scrollY
      };
      this[onDragStart3] = this[onDragStart3].bind(this);
      this[onDragMove2] = this[onDragMove2].bind(this);
      this[onDragStop3] = this[onDragStop3].bind(this);
      this[onMirrorCreated2] = this[onMirrorCreated2].bind(this);
      this[onMirrorMove] = this[onMirrorMove].bind(this);
      this[onScroll] = this[onScroll].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart3]).on("drag:move", this[onDragMove2]).on("drag:stop", this[onDragStop3]).on("mirror:created", this[onMirrorCreated2]).on("mirror:move", this[onMirrorMove]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart3]).off("drag:move", this[onDragMove2]).off("drag:stop", this[onDragStop3]).off("mirror:created", this[onMirrorCreated2]).off("mirror:move", this[onMirrorMove]);
    }
    getOptions() {
      return this.draggable.options.mirror || {};
    }
    [onDragStart3](dragEvent) {
      if (dragEvent.canceled()) {
        return;
      }
      if ("ontouchstart" in window) {
        document.addEventListener("scroll", this[onScroll], true);
      }
      this.initialScrollOffset = {
        x: window.scrollX,
        y: window.scrollY
      };
      const {
        source,
        originalSource,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      this.lastMirrorMovedClient = {
        x: sensorEvent.clientX,
        y: sensorEvent.clientY
      };
      const mirrorCreateEvent = new MirrorCreateEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent
      });
      this.draggable.trigger(mirrorCreateEvent);
      if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {
        return;
      }
      const appendableContainer = this[getAppendableContainer](source) || sourceContainer;
      this.mirror = source.cloneNode(true);
      const mirrorCreatedEvent = new MirrorCreatedEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror
      });
      const mirrorAttachedEvent = new MirrorAttachedEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror
      });
      this.draggable.trigger(mirrorCreatedEvent);
      appendableContainer.appendChild(this.mirror);
      this.draggable.trigger(mirrorAttachedEvent);
    }
    [onDragMove2](dragEvent) {
      if (!this.mirror || dragEvent.canceled()) {
        return;
      }
      const {
        source,
        originalSource,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      let passedThreshX = true;
      let passedThreshY = true;
      if (this.options.thresholdX || this.options.thresholdY) {
        const {
          x: lastX,
          y: lastY
        } = this.lastMirrorMovedClient;
        if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {
          passedThreshX = false;
        } else {
          this.lastMirrorMovedClient.x = sensorEvent.clientX;
        }
        if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {
          passedThreshY = false;
        } else {
          this.lastMirrorMovedClient.y = sensorEvent.clientY;
        }
        if (!passedThreshX && !passedThreshY) {
          return;
        }
      }
      const mirrorMoveEvent = new MirrorMoveEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror,
        passedThreshX,
        passedThreshY
      });
      this.draggable.trigger(mirrorMoveEvent);
    }
    [onDragStop3](dragEvent) {
      if ("ontouchstart" in window) {
        document.removeEventListener("scroll", this[onScroll], true);
      }
      this.initialScrollOffset = {
        x: 0,
        y: 0
      };
      this.scrollOffset = {
        x: 0,
        y: 0
      };
      if (!this.mirror) {
        return;
      }
      const {
        source,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      const mirrorDestroyEvent = new MirrorDestroyEvent({
        source,
        mirror: this.mirror,
        sourceContainer,
        sensorEvent,
        dragEvent
      });
      this.draggable.trigger(mirrorDestroyEvent);
      if (!mirrorDestroyEvent.canceled()) {
        this.mirror.remove();
      }
    }
    [onScroll]() {
      this.scrollOffset = {
        x: window.scrollX - this.initialScrollOffset.x,
        y: window.scrollY - this.initialScrollOffset.y
      };
    }
    [onMirrorCreated2]({
      mirror,
      source,
      sensorEvent
    }) {
      const mirrorClasses = this.draggable.getClassNamesFor("mirror");
      const setState = (_a) => {
        var _b = _a, {
          mirrorOffset,
          initialX,
          initialY
        } = _b, args = __objRest(_b, [
          "mirrorOffset",
          "initialX",
          "initialY"
        ]);
        this.mirrorOffset = mirrorOffset;
        this.initialX = initialX;
        this.initialY = initialY;
        this.lastMovedX = initialX;
        this.lastMovedY = initialY;
        return __spreadValues({
          mirrorOffset,
          initialX,
          initialY
        }, args);
      };
      mirror.style.display = "none";
      const initialState = {
        mirror,
        source,
        sensorEvent,
        mirrorClasses,
        scrollOffset: this.scrollOffset,
        options: this.options,
        passedThreshX: true,
        passedThreshY: true
      };
      return Promise.resolve(initialState).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({
        initial: true
      })).then(removeMirrorID).then(setState);
    }
    [onMirrorMove](mirrorEvent) {
      if (mirrorEvent.canceled()) {
        return null;
      }
      const setState = (_a) => {
        var _b = _a, {
          lastMovedX,
          lastMovedY
        } = _b, args = __objRest(_b, [
          "lastMovedX",
          "lastMovedY"
        ]);
        this.lastMovedX = lastMovedX;
        this.lastMovedY = lastMovedY;
        return __spreadValues({
          lastMovedX,
          lastMovedY
        }, args);
      };
      const triggerMoved = (args) => {
        const mirrorMovedEvent = new MirrorMovedEvent({
          source: mirrorEvent.source,
          originalSource: mirrorEvent.originalSource,
          sourceContainer: mirrorEvent.sourceContainer,
          sensorEvent: mirrorEvent.sensorEvent,
          dragEvent: mirrorEvent.dragEvent,
          mirror: this.mirror,
          passedThreshX: mirrorEvent.passedThreshX,
          passedThreshY: mirrorEvent.passedThreshY
        });
        this.draggable.trigger(mirrorMovedEvent);
        return args;
      };
      const initialState = {
        mirror: mirrorEvent.mirror,
        sensorEvent: mirrorEvent.sensorEvent,
        mirrorOffset: this.mirrorOffset,
        options: this.options,
        initialX: this.initialX,
        initialY: this.initialY,
        scrollOffset: this.scrollOffset,
        passedThreshX: mirrorEvent.passedThreshX,
        passedThreshY: mirrorEvent.passedThreshY,
        lastMovedX: this.lastMovedX,
        lastMovedY: this.lastMovedY
      };
      return Promise.resolve(initialState).then(positionMirror({
        raf: true
      })).then(setState).then(triggerMoved);
    }
    [getAppendableContainer](source) {
      const appendTo = this.options.appendTo;
      if (typeof appendTo === "string") {
        return document.querySelector(appendTo);
      } else if (appendTo instanceof HTMLElement) {
        return appendTo;
      } else if (typeof appendTo === "function") {
        return appendTo(source);
      } else {
        return source.parentNode;
      }
    }
  };
  function computeMirrorDimensions(_a) {
    var _b = _a, {
      source
    } = _b, args = __objRest(_b, [
      "source"
    ]);
    return withPromise((resolve) => {
      const sourceRect = source.getBoundingClientRect();
      resolve(__spreadValues({
        source,
        sourceRect
      }, args));
    });
  }
  function calculateMirrorOffset(_a) {
    var _b = _a, {
      sensorEvent,
      sourceRect,
      options
    } = _b, args = __objRest(_b, [
      "sensorEvent",
      "sourceRect",
      "options"
    ]);
    return withPromise((resolve) => {
      const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;
      const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;
      const mirrorOffset = {
        top,
        left
      };
      resolve(__spreadValues({
        sensorEvent,
        sourceRect,
        mirrorOffset,
        options
      }, args));
    });
  }
  function resetMirror(_a) {
    var _b = _a, {
      mirror,
      source,
      options
    } = _b, args = __objRest(_b, [
      "mirror",
      "source",
      "options"
    ]);
    return withPromise((resolve) => {
      let offsetHeight;
      let offsetWidth;
      if (options.constrainDimensions) {
        const computedSourceStyles = getComputedStyle(source);
        offsetHeight = computedSourceStyles.getPropertyValue("height");
        offsetWidth = computedSourceStyles.getPropertyValue("width");
      }
      mirror.style.display = null;
      mirror.style.position = "fixed";
      mirror.style.pointerEvents = "none";
      mirror.style.top = 0;
      mirror.style.left = 0;
      mirror.style.margin = 0;
      if (options.constrainDimensions) {
        mirror.style.height = offsetHeight;
        mirror.style.width = offsetWidth;
      }
      resolve(__spreadValues({
        mirror,
        source,
        options
      }, args));
    });
  }
  function addMirrorClasses(_a) {
    var _b = _a, {
      mirror,
      mirrorClasses
    } = _b, args = __objRest(_b, [
      "mirror",
      "mirrorClasses"
    ]);
    return withPromise((resolve) => {
      mirror.classList.add(...mirrorClasses);
      resolve(__spreadValues({
        mirror,
        mirrorClasses
      }, args));
    });
  }
  function removeMirrorID(_a) {
    var _b = _a, {
      mirror
    } = _b, args = __objRest(_b, [
      "mirror"
    ]);
    return withPromise((resolve) => {
      mirror.removeAttribute("id");
      delete mirror.id;
      resolve(__spreadValues({
        mirror
      }, args));
    });
  }
  function positionMirror({
    withFrame = false,
    initial = false
  } = {}) {
    return (_a) => {
      var _b = _a, {
        mirror,
        sensorEvent,
        mirrorOffset,
        initialY,
        initialX,
        scrollOffset,
        options,
        passedThreshX,
        passedThreshY,
        lastMovedX,
        lastMovedY
      } = _b, args = __objRest(_b, [
        "mirror",
        "sensorEvent",
        "mirrorOffset",
        "initialY",
        "initialX",
        "scrollOffset",
        "options",
        "passedThreshX",
        "passedThreshY",
        "lastMovedX",
        "lastMovedY"
      ]);
      return withPromise((resolve) => {
        const result = __spreadValues({
          mirror,
          sensorEvent,
          mirrorOffset,
          options
        }, args);
        if (mirrorOffset) {
          const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);
          const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);
          if (options.xAxis && options.yAxis || initial) {
            mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;
          } else if (options.xAxis && !options.yAxis) {
            mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;
          } else if (options.yAxis && !options.xAxis) {
            mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;
          }
          if (initial) {
            result.initialX = x;
            result.initialY = y;
          }
          result.lastMovedX = x;
          result.lastMovedY = y;
        }
        resolve(result);
      }, {
        frame: withFrame
      });
    };
  }
  function withPromise(callback, {
    raf = false
  } = {}) {
    return new Promise((resolve, reject) => {
      if (raf) {
        requestAnimationFrame(() => {
          callback(resolve, reject);
        });
      } else {
        callback(resolve, reject);
      }
    });
  }
  function isNativeDragEvent(sensorEvent) {
    return /^drag/.test(sensorEvent.originalEvent.type);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Scrollable/Scrollable.mjs
  var onDragStart4 = Symbol("onDragStart");
  var onDragMove3 = Symbol("onDragMove");
  var onDragStop4 = Symbol("onDragStop");
  var scroll = Symbol("scroll");
  var defaultOptions7 = {
    speed: 6,
    sensitivity: 50,
    scrollableElements: []
  };
  var Scrollable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions7), this.getOptions());
      this.currentMousePosition = null;
      this.scrollAnimationFrame = null;
      this.scrollableElement = null;
      this.findScrollableElementFrame = null;
      this[onDragStart4] = this[onDragStart4].bind(this);
      this[onDragMove3] = this[onDragMove3].bind(this);
      this[onDragStop4] = this[onDragStop4].bind(this);
      this[scroll] = this[scroll].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart4]).on("drag:move", this[onDragMove3]).on("drag:stop", this[onDragStop4]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart4]).off("drag:move", this[onDragMove3]).off("drag:stop", this[onDragStop4]);
    }
    getOptions() {
      return this.draggable.options.scrollable || {};
    }
    getScrollableElement(target) {
      if (this.hasDefinedScrollableElements()) {
        return closest(target, this.options.scrollableElements) || document.documentElement;
      } else {
        return closestScrollableElement(target);
      }
    }
    hasDefinedScrollableElements() {
      return Boolean(this.options.scrollableElements.length !== 0);
    }
    [onDragStart4](dragEvent) {
      this.findScrollableElementFrame = requestAnimationFrame(() => {
        this.scrollableElement = this.getScrollableElement(dragEvent.source);
      });
    }
    [onDragMove3](dragEvent) {
      this.findScrollableElementFrame = requestAnimationFrame(() => {
        this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);
      });
      if (!this.scrollableElement) {
        return;
      }
      const sensorEvent = dragEvent.sensorEvent;
      const scrollOffset = {
        x: 0,
        y: 0
      };
      if ("ontouchstart" in window) {
        scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
      }
      this.currentMousePosition = {
        clientX: sensorEvent.clientX - scrollOffset.x,
        clientY: sensorEvent.clientY - scrollOffset.y
      };
      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
    }
    [onDragStop4]() {
      cancelAnimationFrame(this.scrollAnimationFrame);
      cancelAnimationFrame(this.findScrollableElementFrame);
      this.scrollableElement = null;
      this.scrollAnimationFrame = null;
      this.findScrollableElementFrame = null;
      this.currentMousePosition = null;
    }
    [scroll]() {
      if (!this.scrollableElement || !this.currentMousePosition) {
        return;
      }
      cancelAnimationFrame(this.scrollAnimationFrame);
      const {
        speed,
        sensitivity
      } = this.options;
      const rect = this.scrollableElement.getBoundingClientRect();
      const bottomCutOff = rect.bottom > window.innerHeight;
      const topCutOff = rect.top < 0;
      const cutOff = topCutOff || bottomCutOff;
      const documentScrollingElement = getDocumentScrollingElement();
      const scrollableElement = this.scrollableElement;
      const clientX = this.currentMousePosition.clientX;
      const clientY = this.currentMousePosition.clientY;
      if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {
        const {
          offsetHeight,
          offsetWidth
        } = scrollableElement;
        if (rect.top + offsetHeight - clientY < sensitivity) {
          scrollableElement.scrollTop += speed;
        } else if (clientY - rect.top < sensitivity) {
          scrollableElement.scrollTop -= speed;
        }
        if (rect.left + offsetWidth - clientX < sensitivity) {
          scrollableElement.scrollLeft += speed;
        } else if (clientX - rect.left < sensitivity) {
          scrollableElement.scrollLeft -= speed;
        }
      } else {
        const {
          innerHeight,
          innerWidth
        } = window;
        if (clientY < sensitivity) {
          documentScrollingElement.scrollTop -= speed;
        } else if (innerHeight - clientY < sensitivity) {
          documentScrollingElement.scrollTop += speed;
        }
        if (clientX < sensitivity) {
          documentScrollingElement.scrollLeft -= speed;
        } else if (innerWidth - clientX < sensitivity) {
          documentScrollingElement.scrollLeft += speed;
        }
      }
      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
    }
  };
  function hasOverflow(element) {
    const overflowRegex = /(auto|scroll)/;
    const computedStyles = getComputedStyle(element, null);
    const overflow = computedStyles.getPropertyValue("overflow") + computedStyles.getPropertyValue("overflow-y") + computedStyles.getPropertyValue("overflow-x");
    return overflowRegex.test(overflow);
  }
  function isStaticallyPositioned(element) {
    const position = getComputedStyle(element).getPropertyValue("position");
    return position === "static";
  }
  function closestScrollableElement(element) {
    if (!element) {
      return getDocumentScrollingElement();
    }
    const position = getComputedStyle(element).getPropertyValue("position");
    const excludeStaticParents = position === "absolute";
    const scrollableElement = closest(element, (parent) => {
      if (excludeStaticParents && isStaticallyPositioned(parent)) {
        return false;
      }
      return hasOverflow(parent);
    });
    if (position === "fixed" || !scrollableElement) {
      return getDocumentScrollingElement();
    } else {
      return scrollableElement;
    }
  }
  function getDocumentScrollingElement() {
    return document.scrollingElement || document.documentElement;
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Emitter/Emitter.mjs
  var Emitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(type, ...callbacks) {
      if (!this.callbacks[type]) {
        this.callbacks[type] = [];
      }
      this.callbacks[type].push(...callbacks);
      return this;
    }
    off(type, callback) {
      if (!this.callbacks[type]) {
        return null;
      }
      const copy = this.callbacks[type].slice(0);
      for (let i = 0; i < copy.length; i++) {
        if (callback === copy[i]) {
          this.callbacks[type].splice(i, 1);
        }
      }
      return this;
    }
    trigger(event) {
      if (!this.callbacks[event.type]) {
        return null;
      }
      const callbacks = [...this.callbacks[event.type]];
      const caughtErrors = [];
      for (let i = callbacks.length - 1; i >= 0; i--) {
        const callback = callbacks[i];
        try {
          callback(event);
        } catch (error) {
          caughtErrors.push(error);
        }
      }
      if (caughtErrors.length) {
        console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);
      }
      return this;
    }
  };

  // node_modules/@shopify/draggable/build/esm/Draggable/DraggableEvent/DraggableEvent.mjs
  var DraggableEvent = class extends AbstractEvent {
    get draggable() {
      return this.data.draggable;
    }
  };
  DraggableEvent.type = "draggable";
  var DraggableInitializedEvent = class extends DraggableEvent {
  };
  DraggableInitializedEvent.type = "draggable:initialize";
  var DraggableDestroyEvent = class extends DraggableEvent {
  };
  DraggableDestroyEvent.type = "draggable:destroy";

  // node_modules/@shopify/draggable/build/esm/Draggable/Draggable.mjs
  var onDragStart5 = Symbol("onDragStart");
  var onDragMove4 = Symbol("onDragMove");
  var onDragStop5 = Symbol("onDragStop");
  var onDragPressure = Symbol("onDragPressure");
  var dragStop = Symbol("dragStop");
  var defaultAnnouncements = {
    "drag:start": (event) => `Picked up ${event.source.textContent.trim() || event.source.id || "draggable element"}`,
    "drag:stop": (event) => `Released ${event.source.textContent.trim() || event.source.id || "draggable element"}`
  };
  var defaultClasses = {
    "container:dragging": "draggable-container--is-dragging",
    "source:dragging": "draggable-source--is-dragging",
    "source:placed": "draggable-source--placed",
    "container:placed": "draggable-container--placed",
    "body:dragging": "draggable--is-dragging",
    "draggable:over": "draggable--over",
    "container:over": "draggable-container--over",
    "source:original": "draggable--original",
    mirror: "draggable-mirror"
  };
  var defaultOptions8 = {
    draggable: ".draggable-source",
    handle: null,
    delay: {},
    distance: 0,
    placedTimeout: 800,
    plugins: [],
    sensors: [],
    exclude: {
      plugins: [],
      sensors: []
    }
  };
  var Draggable = class {
    constructor(containers = [document.body], options = {}) {
      if (containers instanceof NodeList || containers instanceof Array) {
        this.containers = [...containers];
      } else if (containers instanceof HTMLElement) {
        this.containers = [containers];
      } else {
        throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");
      }
      this.options = __spreadProps(__spreadValues(__spreadValues({}, defaultOptions8), options), {
        classes: __spreadValues(__spreadValues({}, defaultClasses), options.classes || {}),
        announcements: __spreadValues(__spreadValues({}, defaultAnnouncements), options.announcements || {}),
        exclude: {
          plugins: options.exclude && options.exclude.plugins || [],
          sensors: options.exclude && options.exclude.sensors || []
        }
      });
      this.emitter = new Emitter();
      this.dragging = false;
      this.plugins = [];
      this.sensors = [];
      this[onDragStart5] = this[onDragStart5].bind(this);
      this[onDragMove4] = this[onDragMove4].bind(this);
      this[onDragStop5] = this[onDragStop5].bind(this);
      this[onDragPressure] = this[onDragPressure].bind(this);
      this[dragStop] = this[dragStop].bind(this);
      document.addEventListener("drag:start", this[onDragStart5], true);
      document.addEventListener("drag:move", this[onDragMove4], true);
      document.addEventListener("drag:stop", this[onDragStop5], true);
      document.addEventListener("drag:pressure", this[onDragPressure], true);
      const defaultPlugins = Object.values(Draggable.Plugins).filter((Plugin) => !this.options.exclude.plugins.includes(Plugin));
      const defaultSensors = Object.values(Draggable.Sensors).filter((sensor) => !this.options.exclude.sensors.includes(sensor));
      this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);
      this.addSensor(...[...defaultSensors, ...this.options.sensors]);
      const draggableInitializedEvent = new DraggableInitializedEvent({
        draggable: this
      });
      this.on("mirror:created", ({
        mirror
      }) => this.mirror = mirror);
      this.on("mirror:destroy", () => this.mirror = null);
      this.trigger(draggableInitializedEvent);
    }
    destroy() {
      document.removeEventListener("drag:start", this[onDragStart5], true);
      document.removeEventListener("drag:move", this[onDragMove4], true);
      document.removeEventListener("drag:stop", this[onDragStop5], true);
      document.removeEventListener("drag:pressure", this[onDragPressure], true);
      const draggableDestroyEvent = new DraggableDestroyEvent({
        draggable: this
      });
      this.trigger(draggableDestroyEvent);
      this.removePlugin(...this.plugins.map((plugin) => plugin.constructor));
      this.removeSensor(...this.sensors.map((sensor) => sensor.constructor));
    }
    addPlugin(...plugins) {
      const activePlugins = plugins.map((Plugin) => new Plugin(this));
      activePlugins.forEach((plugin) => plugin.attach());
      this.plugins = [...this.plugins, ...activePlugins];
      return this;
    }
    removePlugin(...plugins) {
      const removedPlugins = this.plugins.filter((plugin) => plugins.includes(plugin.constructor));
      removedPlugins.forEach((plugin) => plugin.detach());
      this.plugins = this.plugins.filter((plugin) => !plugins.includes(plugin.constructor));
      return this;
    }
    addSensor(...sensors) {
      const activeSensors = sensors.map((Sensor2) => new Sensor2(this.containers, this.options));
      activeSensors.forEach((sensor) => sensor.attach());
      this.sensors = [...this.sensors, ...activeSensors];
      return this;
    }
    removeSensor(...sensors) {
      const removedSensors = this.sensors.filter((sensor) => sensors.includes(sensor.constructor));
      removedSensors.forEach((sensor) => sensor.detach());
      this.sensors = this.sensors.filter((sensor) => !sensors.includes(sensor.constructor));
      return this;
    }
    addContainer(...containers) {
      this.containers = [...this.containers, ...containers];
      this.sensors.forEach((sensor) => sensor.addContainer(...containers));
      return this;
    }
    removeContainer(...containers) {
      this.containers = this.containers.filter((container) => !containers.includes(container));
      this.sensors.forEach((sensor) => sensor.removeContainer(...containers));
      return this;
    }
    on(type, ...callbacks) {
      this.emitter.on(type, ...callbacks);
      return this;
    }
    off(type, callback) {
      this.emitter.off(type, callback);
      return this;
    }
    trigger(event) {
      this.emitter.trigger(event);
      return this;
    }
    getClassNameFor(name) {
      return this.getClassNamesFor(name)[0];
    }
    getClassNamesFor(name) {
      const classNames = this.options.classes[name];
      if (classNames instanceof Array) {
        return classNames;
      } else if (typeof classNames === "string" || classNames instanceof String) {
        return [classNames];
      } else {
        return [];
      }
    }
    isDragging() {
      return Boolean(this.dragging);
    }
    getDraggableElements() {
      return this.containers.reduce((current, container) => {
        return [...current, ...this.getDraggableElementsForContainer(container)];
      }, []);
    }
    getDraggableElementsForContainer(container) {
      const allDraggableElements = container.querySelectorAll(this.options.draggable);
      return [...allDraggableElements].filter((childElement) => {
        return childElement !== this.originalSource && childElement !== this.mirror;
      });
    }
    cancel() {
      this[dragStop]();
    }
    [onDragStart5](event) {
      const sensorEvent = getSensorEvent(event);
      const {
        target,
        container,
        originalSource
      } = sensorEvent;
      if (!this.containers.includes(container)) {
        return;
      }
      if (this.options.handle && target && !closest(target, this.options.handle)) {
        sensorEvent.cancel();
        return;
      }
      this.originalSource = originalSource;
      this.sourceContainer = container;
      if (this.lastPlacedSource && this.lastPlacedContainer) {
        clearTimeout(this.placedTimeoutID);
        this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));
        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));
      }
      this.source = this.originalSource.cloneNode(true);
      this.originalSource.parentNode.insertBefore(this.source, this.originalSource);
      this.originalSource.style.display = "none";
      const dragStartEvent = new DragStartEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: container,
        sensorEvent
      });
      this.trigger(dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (dragStartEvent.canceled()) {
        this.source.remove();
        this.originalSource.style.display = null;
        return;
      }
      this.originalSource.classList.add(...this.getClassNamesFor("source:original"));
      this.source.classList.add(...this.getClassNamesFor("source:dragging"));
      this.sourceContainer.classList.add(...this.getClassNamesFor("container:dragging"));
      document.body.classList.add(...this.getClassNamesFor("body:dragging"));
      applyUserSelect(document.body, "none");
      requestAnimationFrame(() => {
        const oldSensorEvent = getSensorEvent(event);
        const newSensorEvent = oldSensorEvent.clone({
          target: this.source
        });
        this[onDragMove4](__spreadProps(__spreadValues({}, event), {
          detail: newSensorEvent
        }));
      });
    }
    [onDragMove4](event) {
      if (!this.dragging) {
        return;
      }
      const sensorEvent = getSensorEvent(event);
      const {
        container
      } = sensorEvent;
      let target = sensorEvent.target;
      const dragMoveEvent = new DragMoveEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: container,
        sensorEvent
      });
      this.trigger(dragMoveEvent);
      if (dragMoveEvent.canceled()) {
        sensorEvent.cancel();
      }
      target = closest(target, this.options.draggable);
      const withinCorrectContainer = closest(sensorEvent.target, this.containers);
      const overContainer = sensorEvent.overContainer || withinCorrectContainer;
      const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;
      const isLeavingDraggable = this.currentOver && target !== this.currentOver;
      const isOverContainer = overContainer && this.currentOverContainer !== overContainer;
      const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;
      if (isLeavingDraggable) {
        const dragOutEvent = new DragOutEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          over: this.currentOver,
          overContainer: this.currentOverContainer
        });
        this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));
        this.currentOver = null;
        this.trigger(dragOutEvent);
      }
      if (isLeavingContainer) {
        const dragOutContainerEvent = new DragOutContainerEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer: this.currentOverContainer
        });
        this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));
        this.currentOverContainer = null;
        this.trigger(dragOutContainerEvent);
      }
      if (isOverContainer) {
        overContainer.classList.add(...this.getClassNamesFor("container:over"));
        const dragOverContainerEvent = new DragOverContainerEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer
        });
        this.currentOverContainer = overContainer;
        this.trigger(dragOverContainerEvent);
      }
      if (isOverDraggable) {
        target.classList.add(...this.getClassNamesFor("draggable:over"));
        const dragOverEvent = new DragOverEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer,
          over: target
        });
        this.currentOver = target;
        this.trigger(dragOverEvent);
      }
    }
    [dragStop](event) {
      if (!this.dragging) {
        return;
      }
      this.dragging = false;
      const dragStopEvent = new DragStopEvent({
        source: this.source,
        originalSource: this.originalSource,
        sensorEvent: event ? event.sensorEvent : null,
        sourceContainer: this.sourceContainer
      });
      this.trigger(dragStopEvent);
      if (!dragStopEvent.canceled())
        this.source.parentNode.insertBefore(this.originalSource, this.source);
      this.source.remove();
      this.originalSource.style.display = "";
      this.source.classList.remove(...this.getClassNamesFor("source:dragging"));
      this.originalSource.classList.remove(...this.getClassNamesFor("source:original"));
      this.originalSource.classList.add(...this.getClassNamesFor("source:placed"));
      this.sourceContainer.classList.add(...this.getClassNamesFor("container:placed"));
      this.sourceContainer.classList.remove(...this.getClassNamesFor("container:dragging"));
      document.body.classList.remove(...this.getClassNamesFor("body:dragging"));
      applyUserSelect(document.body, "");
      if (this.currentOver) {
        this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));
      }
      if (this.currentOverContainer) {
        this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));
      }
      this.lastPlacedSource = this.originalSource;
      this.lastPlacedContainer = this.sourceContainer;
      this.placedTimeoutID = setTimeout(() => {
        if (this.lastPlacedSource) {
          this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));
        }
        if (this.lastPlacedContainer) {
          this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));
        }
        this.lastPlacedSource = null;
        this.lastPlacedContainer = null;
      }, this.options.placedTimeout);
      const dragStoppedEvent = new DragStoppedEvent({
        source: this.source,
        originalSource: this.originalSource,
        sensorEvent: event ? event.sensorEvent : null,
        sourceContainer: this.sourceContainer
      });
      this.trigger(dragStoppedEvent);
      this.source = null;
      this.originalSource = null;
      this.currentOverContainer = null;
      this.currentOver = null;
      this.sourceContainer = null;
    }
    [onDragStop5](event) {
      this[dragStop](event);
    }
    [onDragPressure](event) {
      if (!this.dragging) {
        return;
      }
      const sensorEvent = getSensorEvent(event);
      const source = this.source || closest(sensorEvent.originalEvent.target, this.options.draggable);
      const dragPressureEvent = new DragPressureEvent({
        sensorEvent,
        source,
        pressure: sensorEvent.pressure
      });
      this.trigger(dragPressureEvent);
    }
  };
  Draggable.Plugins = {
    Announcement,
    Focusable,
    Mirror,
    Scrollable
  };
  Draggable.Sensors = {
    MouseSensor,
    TouchSensor
  };
  function getSensorEvent(event) {
    return event.detail;
  }
  function applyUserSelect(element, value) {
    element.style.webkitUserSelect = value;
    element.style.mozUserSelect = value;
    element.style.msUserSelect = value;
    element.style.oUserSelect = value;
    element.style.userSelect = value;
  }

  // node_modules/@shopify/draggable/build/esm/Droppable/DroppableEvent/DroppableEvent.mjs
  var DroppableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  DroppableEvent.type = "droppable";
  var DroppableStartEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableStartEvent.type = "droppable:start";
  DroppableStartEvent.cancelable = true;
  var DroppableDroppedEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableDroppedEvent.type = "droppable:dropped";
  DroppableDroppedEvent.cancelable = true;
  var DroppableReturnedEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableReturnedEvent.type = "droppable:returned";
  DroppableReturnedEvent.cancelable = true;
  var DroppableStopEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableStopEvent.type = "droppable:stop";
  DroppableStopEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Droppable/Droppable.mjs
  var onDragStart6 = Symbol("onDragStart");
  var onDragMove5 = Symbol("onDragMove");
  var onDragStop6 = Symbol("onDragStop");
  var dropInDropzone = Symbol("dropInDropZone");
  var returnToOriginalDropzone = Symbol("returnToOriginalDropzone");
  var closestDropzone = Symbol("closestDropzone");
  var getDropzones = Symbol("getDropzones");

  // node_modules/@shopify/draggable/build/esm/Swappable/SwappableEvent/SwappableEvent.mjs
  var SwappableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  SwappableEvent.type = "swappable";
  var SwappableStartEvent = class extends SwappableEvent {
  };
  SwappableStartEvent.type = "swappable:start";
  SwappableStartEvent.cancelable = true;
  var SwappableSwapEvent = class extends SwappableEvent {
    get over() {
      return this.data.over;
    }
    get overContainer() {
      return this.data.overContainer;
    }
  };
  SwappableSwapEvent.type = "swappable:swap";
  SwappableSwapEvent.cancelable = true;
  var SwappableSwappedEvent = class extends SwappableEvent {
    get swappedElement() {
      return this.data.swappedElement;
    }
  };
  SwappableSwappedEvent.type = "swappable:swapped";
  var SwappableStopEvent = class extends SwappableEvent {
  };
  SwappableStopEvent.type = "swappable:stop";

  // node_modules/@shopify/draggable/build/esm/Swappable/Swappable.mjs
  var onDragStart7 = Symbol("onDragStart");
  var onDragOver3 = Symbol("onDragOver");
  var onDragStop7 = Symbol("onDragStop");

  // node_modules/@shopify/draggable/build/esm/Sortable/SortableEvent/SortableEvent.mjs
  var SortableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  SortableEvent.type = "sortable";
  var SortableStartEvent = class extends SortableEvent {
    get startIndex() {
      return this.data.startIndex;
    }
    get startContainer() {
      return this.data.startContainer;
    }
  };
  SortableStartEvent.type = "sortable:start";
  SortableStartEvent.cancelable = true;
  var SortableSortEvent = class extends SortableEvent {
    get currentIndex() {
      return this.data.currentIndex;
    }
    get over() {
      return this.data.over;
    }
    get overContainer() {
      return this.data.dragEvent.overContainer;
    }
  };
  SortableSortEvent.type = "sortable:sort";
  SortableSortEvent.cancelable = true;
  var SortableSortedEvent = class extends SortableEvent {
    get oldIndex() {
      return this.data.oldIndex;
    }
    get newIndex() {
      return this.data.newIndex;
    }
    get oldContainer() {
      return this.data.oldContainer;
    }
    get newContainer() {
      return this.data.newContainer;
    }
  };
  SortableSortedEvent.type = "sortable:sorted";
  var SortableStopEvent = class extends SortableEvent {
    get oldIndex() {
      return this.data.oldIndex;
    }
    get newIndex() {
      return this.data.newIndex;
    }
    get oldContainer() {
      return this.data.oldContainer;
    }
    get newContainer() {
      return this.data.newContainer;
    }
  };
  SortableStopEvent.type = "sortable:stop";

  // node_modules/@shopify/draggable/build/esm/Sortable/Sortable.mjs
  var onDragStart8 = Symbol("onDragStart");
  var onDragOverContainer = Symbol("onDragOverContainer");
  var onDragOver4 = Symbol("onDragOver");
  var onDragStop8 = Symbol("onDragStop");
  function onSortableSortedDefaultAnnouncement({
    dragEvent
  }) {
    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "sortable element";
    if (dragEvent.over) {
      const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || "sortable element";
      const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;
      if (isFollowing) {
        return `Placed ${sourceText} after ${overText}`;
      } else {
        return `Placed ${sourceText} before ${overText}`;
      }
    } else {
      return `Placed ${sourceText} into a different container`;
    }
  }
  var defaultAnnouncements2 = {
    "sortable:sorted": onSortableSortedDefaultAnnouncement
  };
  var Sortable = class extends Draggable {
    constructor(containers = [], options = {}) {
      super(containers, __spreadProps(__spreadValues({}, options), {
        announcements: __spreadValues(__spreadValues({}, defaultAnnouncements2), options.announcements || {})
      }));
      this.startIndex = null;
      this.startContainer = null;
      this[onDragStart8] = this[onDragStart8].bind(this);
      this[onDragOverContainer] = this[onDragOverContainer].bind(this);
      this[onDragOver4] = this[onDragOver4].bind(this);
      this[onDragStop8] = this[onDragStop8].bind(this);
      this.on("drag:start", this[onDragStart8]).on("drag:over:container", this[onDragOverContainer]).on("drag:over", this[onDragOver4]).on("drag:stop", this[onDragStop8]);
    }
    destroy() {
      super.destroy();
      this.off("drag:start", this[onDragStart8]).off("drag:over:container", this[onDragOverContainer]).off("drag:over", this[onDragOver4]).off("drag:stop", this[onDragStop8]);
    }
    index(element) {
      return this.getSortableElementsForContainer(element.parentNode).indexOf(element);
    }
    getSortableElementsForContainer(container) {
      const allSortableElements = container.querySelectorAll(this.options.draggable);
      return [...allSortableElements].filter((childElement) => {
        return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;
      });
    }
    [onDragStart8](event) {
      this.startContainer = event.source.parentNode;
      this.startIndex = this.index(event.source);
      const sortableStartEvent = new SortableStartEvent({
        dragEvent: event,
        startIndex: this.startIndex,
        startContainer: this.startContainer
      });
      this.trigger(sortableStartEvent);
      if (sortableStartEvent.canceled()) {
        event.cancel();
      }
    }
    [onDragOverContainer](event) {
      if (event.canceled()) {
        return;
      }
      const {
        source,
        over,
        overContainer
      } = event;
      const oldIndex = this.index(source);
      const sortableSortEvent = new SortableSortEvent({
        dragEvent: event,
        currentIndex: oldIndex,
        source,
        over
      });
      this.trigger(sortableSortEvent);
      if (sortableSortEvent.canceled()) {
        return;
      }
      const children = this.getSortableElementsForContainer(overContainer);
      const moves = move({
        source,
        over,
        overContainer,
        children
      });
      if (!moves) {
        return;
      }
      const {
        oldContainer,
        newContainer
      } = moves;
      const newIndex = this.index(event.source);
      const sortableSortedEvent = new SortableSortedEvent({
        dragEvent: event,
        oldIndex,
        newIndex,
        oldContainer,
        newContainer
      });
      this.trigger(sortableSortedEvent);
    }
    [onDragOver4](event) {
      if (event.over === event.originalSource || event.over === event.source) {
        return;
      }
      const {
        source,
        over,
        overContainer
      } = event;
      const oldIndex = this.index(source);
      const sortableSortEvent = new SortableSortEvent({
        dragEvent: event,
        currentIndex: oldIndex,
        source,
        over
      });
      this.trigger(sortableSortEvent);
      if (sortableSortEvent.canceled()) {
        return;
      }
      const children = this.getDraggableElementsForContainer(overContainer);
      const moves = move({
        source,
        over,
        overContainer,
        children
      });
      if (!moves) {
        return;
      }
      const {
        oldContainer,
        newContainer
      } = moves;
      const newIndex = this.index(source);
      const sortableSortedEvent = new SortableSortedEvent({
        dragEvent: event,
        oldIndex,
        newIndex,
        oldContainer,
        newContainer
      });
      this.trigger(sortableSortedEvent);
    }
    [onDragStop8](event) {
      const sortableStopEvent = new SortableStopEvent({
        dragEvent: event,
        oldIndex: this.startIndex,
        newIndex: this.index(event.source),
        oldContainer: this.startContainer,
        newContainer: event.source.parentNode
      });
      this.trigger(sortableStopEvent);
      this.startIndex = null;
      this.startContainer = null;
    }
  };
  function index(element) {
    return Array.prototype.indexOf.call(element.parentNode.children, element);
  }
  function move({
    source,
    over,
    overContainer,
    children
  }) {
    const emptyOverContainer = !children.length;
    const differentContainer = source.parentNode !== overContainer;
    const sameContainer = over && source.parentNode === over.parentNode;
    if (emptyOverContainer) {
      return moveInsideEmptyContainer(source, overContainer);
    } else if (sameContainer) {
      return moveWithinContainer(source, over);
    } else if (differentContainer) {
      return moveOutsideContainer(source, over, overContainer);
    } else {
      return null;
    }
  }
  function moveInsideEmptyContainer(source, overContainer) {
    const oldContainer = source.parentNode;
    overContainer.appendChild(source);
    return {
      oldContainer,
      newContainer: overContainer
    };
  }
  function moveWithinContainer(source, over) {
    const oldIndex = index(source);
    const newIndex = index(over);
    if (oldIndex < newIndex) {
      source.parentNode.insertBefore(source, over.nextElementSibling);
    } else {
      source.parentNode.insertBefore(source, over);
    }
    return {
      oldContainer: source.parentNode,
      newContainer: source.parentNode
    };
  }
  function moveOutsideContainer(source, over, overContainer) {
    const oldContainer = source.parentNode;
    if (over) {
      over.parentNode.insertBefore(source, over);
    } else {
      overContainer.appendChild(source);
    }
    return {
      oldContainer,
      newContainer: source.parentNode
    };
  }

  // js/app.js
  var import_topbar = __toModule(require_topbar());

  // js/chart.js
  var import_chart = __toModule(require_chart());
  var import_chartjs_plugin_datalabels = __toModule(require_chartjs_plugin_datalabels());

  // node_modules/chart.js-plugin-labels-dv/dist/chartjs-plugin-labels.min.js
  !function(t) {
    typeof define == "function" && define.amd ? define(t) : t();
  }(function() {
    "use strict";
    !function() {
      if (typeof Chart == "undefined")
        return void console.error("Cannot find Chart object.");
      const t = Chart.helpers;
      typeof Object.assign != "function" && (Object.assign = function(t2) {
        if (!t2)
          throw new TypeError("Cannot convert undefined or null to object");
        const e2 = Object(t2);
        for (let t3 = 1; t3 < arguments.length; t3++) {
          const o2 = arguments[t3];
          if (o2)
            for (const t4 in o2)
              Object.prototype.hasOwnProperty.call(o2, t4) && (e2[t4] = o2[t4]);
        }
        return e2;
      });
      const e = {};
      function o() {
        this.renderToDataset = this.renderToDataset.bind(this);
      }
      function n(t2) {
        const e2 = t2._context.chart.config._config;
        return !(!e2.options || !e2.options.plugins) && !!e2.options.plugins.labels;
      }
      ["pie", "doughnut", "polarArea", "bar"].forEach(function(t2) {
        e[t2] = true;
      }), o.prototype.setup = function(t2, e2) {
        this.chart = t2, this.ctx = t2.ctx, this.args = {}, this.barTotal = {};
        const o2 = t2.config.options;
        this.options = Object.assign({ position: "default", precision: 0, fontSize: o2.font ? o2.font.size : 12, fontColor: o2.color || "#333333", fontStyle: o2.font ? o2.font.style : "normal", fontFamily: o2.font ? o2.font.family : "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", shadowOffsetX: 3, shadowOffsetY: 3, shadowColor: "rgba(0,0,0,0.3)", shadowBlur: 6, images: [], outsidePadding: 2, textMargin: 2, overlap: true }, e2), t2.config.type === "bar" && (this.options.position = "default", this.options.arc = false, this.options.overlap = true);
      }, o.prototype.render = function() {
        this.labelBounds = [], this.chart.data.datasets.forEach(this.renderToDataset);
      }, o.prototype.renderToDataset = function(t2, e2) {
        this.totalPercentage = 0, this.total = null;
        const o2 = this.args[e2];
        o2.meta.data.forEach(function(e3, n2) {
          this.renderToElement(t2, o2, e3, n2);
        }.bind(this));
      }, o.prototype.renderToElement = function(e2, o2, n2, i) {
        if (!this.shouldRenderToElement(o2.meta, n2))
          return;
        this.percentage = null;
        const s = this.getLabel(e2, n2, i);
        if (!s)
          return;
        const r = this.ctx;
        r.save(), r.font = t.fontString(this.options.fontSize, this.options.fontStyle, this.options.fontFamily);
        const a = this.getRenderInfo(n2, s);
        this.drawable(n2, s, a) ? (r.beginPath(), r.fillStyle = this.getFontColor(e2, n2, i), this.renderLabel(s, a), r.restore()) : r.restore();
      }, o.prototype.renderLabel = function(t2, e2) {
        return this.options.arc ? this.renderArcLabel(t2, e2) : this.renderBaseLabel(t2, e2);
      }, o.prototype.renderBaseLabel = function(t2, e2) {
        const o2 = this.ctx;
        if (typeof t2 == "object")
          o2.drawImage(t2, e2.x - t2.width / 2, e2.y - t2.height / 2, t2.width, t2.height);
        else {
          o2.save(), o2.textBaseline = "top", o2.textAlign = "center", this.options.textShadow && (o2.shadowOffsetX = this.options.shadowOffsetX, o2.shadowOffsetY = this.options.shadowOffsetY, o2.shadowColor = this.options.shadowColor, o2.shadowBlur = this.options.shadowBlur);
          const n2 = t2.split("\n");
          for (let t3 = 0; t3 < n2.length; t3++) {
            const i = e2.y - this.options.fontSize / 2 * n2.length + this.options.fontSize * t3;
            o2.fillText(n2[t3], e2.x, i);
          }
          o2.restore();
        }
      }, o.prototype.renderArcLabel = function(t2, e2) {
        const o2 = this.ctx, n2 = e2.radius, i = e2.view;
        if (o2.save(), o2.translate(i.x, i.y), typeof t2 == "string") {
          o2.rotate(e2.startAngle), o2.textBaseline = "middle", o2.textAlign = "left";
          const i2 = t2.split("\n");
          let s = 0;
          const r = [];
          let a, h = 0;
          this.options.position === "border" && (h = (i2.length - 1) * this.options.fontSize / 2);
          for (let t3 = 0; t3 < i2.length; ++t3)
            a = o2.measureText(i2[t3]), a.width > s && (s = a.width), r.push(a.width);
          for (let t3 = 0; t3 < i2.length; ++t3) {
            const e3 = i2[t3], l = (i2.length - 1 - t3) * -this.options.fontSize + h;
            o2.save();
            const c = (s - r[t3]) / 2;
            o2.rotate(c / n2);
            for (let t4 = 0; t4 < e3.length; t4++) {
              const i3 = e3.charAt(t4);
              a = o2.measureText(i3), o2.save(), o2.translate(0, -1 * n2), o2.fillText(i3, 0, l), o2.restore(), o2.rotate(a.width / n2);
            }
            o2.restore();
          }
        } else
          o2.rotate((i.startAngle + Math.PI / 2 + e2.endAngle) / 2), o2.translate(0, -1 * n2), this.renderLabel(t2, { x: 0, y: 0 });
        o2.restore();
      }, o.prototype.shouldRenderToElement = function(t2, e2) {
        return !t2.hidden && (this.options.showZero || this.chart.config.type === "polarArea" ? e2.outerRadius !== 0 : e2.circumference !== 0);
      }, o.prototype.getLabel = function(t2, e2, o2) {
        let n2;
        if (typeof this.options.render == "function")
          n2 = this.options.render({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), dataset: t2, index: o2 });
        else
          switch (this.options.render) {
            case "value":
              n2 = t2.data[o2];
              break;
            case "label":
              n2 = this.chart.config.data.labels[o2];
              break;
            case "image":
              n2 = this.options.images[o2] ? this.loadImage(this.options.images[o2]) : "";
              break;
            default:
              n2 = this.getPercentage(t2, e2, o2) + "%";
          }
        return typeof n2 == "object" ? n2 = this.loadImage(n2) : n2 && (n2 = n2.toString()), n2;
      }, o.prototype.getFontColor = function(t2, e2, o2) {
        let n2 = this.options.fontColor;
        return typeof n2 == "function" ? n2 = n2({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), backgroundColor: t2.backgroundColor[o2], dataset: t2, index: o2 }) : typeof n2 != "string" && (n2 = n2[o2] || this.chart.config.options.color), n2;
      }, o.prototype.getPercentage = function(t2, e2, o2) {
        if (this.percentage)
          return this.percentage;
        let n2;
        if (this.chart.config.type === "polarArea" || this.chart.config.type === "doughnut" || this.chart.config.type === "pie") {
          if (!this.total) {
            this.total = 0;
            for (let e3 = 0; e3 < t2.data.length; ++e3)
              this.total += t2.data[e3];
          }
          n2 = t2.data[o2] / this.total * 100;
        } else if (this.chart.config.type === "bar") {
          if (!this.barTotal[o2]) {
            this.barTotal[o2] = 0;
            for (let t3 = 0; t3 < this.chart.data.datasets.length; ++t3)
              this.barTotal[o2] += this.chart.data.datasets[t3].data[o2];
          }
          n2 = t2.data[o2] / this.barTotal[o2] * 100;
        } else
          n2 = e2.circumference / this.chart.config.options.circumference * 100;
        return n2 = parseFloat(n2.toFixed(this.options.precision)), this.options.showActualPercentages || (this.chart.config.type === "bar" && (this.totalPercentage = this.barTotalPercentage[o2] || 0), this.totalPercentage += n2, this.totalPercentage > 100 && (n2 -= this.totalPercentage - 100, n2 = parseFloat(n2.toFixed(this.options.precision))), this.chart.config.type === "bar" && (this.barTotalPercentage[o2] = this.totalPercentage)), this.percentage = n2, n2;
      }, o.prototype.getRenderInfo = function(t2, e2) {
        return this.chart.config.type === "bar" ? this.getBarRenderInfo(t2, e2) : this.options.arc ? this.getArcRenderInfo(t2, e2) : this.getBaseRenderInfo(t2, e2);
      }, o.prototype.getBaseRenderInfo = function(t2, e2) {
        if (this.options.position === "outside" || this.options.position === "border") {
          let o2, n2 = {};
          const i = t2, s = i.startAngle + (i.endAngle - i.startAngle) / 2, r = i.outerRadius / 2;
          if (this.options.position === "border" ? o2 = (i.outerRadius - r) / 2 + r : this.options.position === "outside" && (o2 = i.outerRadius - r + r + this.options.textMargin), n2 = { x: i.x + Math.cos(s) * o2, y: i.y + Math.sin(s) * o2 }, this.options.position === "outside") {
            const t3 = this.options.textMargin + this.measureLabel(e2).width / 2;
            n2.x += n2.x < i.x ? -t3 : t3;
          }
          return n2;
        }
        return t2.tooltipPosition();
      }, o.prototype.getArcRenderInfo = function(t2, e2) {
        let o2;
        const n2 = t2;
        o2 = this.options.position === "outside" ? n2.outerRadius + this.options.fontSize + this.options.textMargin : this.options.position === "border" ? (n2.outerRadius / 2 + n2.outerRadius) / 2 : (n2.innerRadius + n2.outerRadius) / 2;
        let i = n2.startAngle, s = n2.endAngle;
        const r = s - i;
        i += Math.PI / 2, s += Math.PI / 2;
        return i += (s - (this.measureLabel(e2).width / o2 + i)) / 2, { radius: o2, startAngle: i, endAngle: s, totalAngle: r, view: n2 };
      }, o.prototype.getBarRenderInfo = function(t2, e2) {
        const o2 = t2.tooltipPosition();
        return o2.y -= this.measureLabel(e2).height / 2 + this.options.textMargin, o2;
      }, o.prototype.drawable = function(t2, e2, o2) {
        if (this.options.overlap)
          return true;
        if (this.options.arc)
          return o2.endAngle - o2.startAngle <= o2.totalAngle;
        {
          const n2 = this.measureLabel(e2), i = o2.x - n2.width / 2, s = o2.x + n2.width / 2, r = o2.y - n2.height / 2, a = o2.y + n2.height / 2;
          return this.options.position === "outside" ? this.outsideInRange(i, s, r, a) : t2.inRange(i, r) && t2.inRange(i, a) && t2.inRange(s, r) && t2.inRange(s, a);
        }
      }, o.prototype.outsideInRange = function(t2, e2, o2, n2) {
        const i = this.labelBounds;
        for (let s = 0; s < i.length; ++s) {
          const r = i[s];
          let a = [[t2, o2], [t2, n2], [e2, o2], [e2, n2]];
          for (let t3 = 0; t3 < a.length; ++t3) {
            const e3 = a[t3][0], o3 = a[t3][1];
            if (e3 >= r.left && e3 <= r.right && o3 >= r.top && o3 <= r.bottom)
              return false;
          }
          a = [[r.left, r.top], [r.left, r.bottom], [r.right, r.top], [r.right, r.bottom]];
          for (let i2 = 0; i2 < a.length; ++i2) {
            const s2 = a[i2][0], r2 = a[i2][1];
            if (s2 >= t2 && s2 <= e2 && r2 >= o2 && r2 <= n2)
              return false;
          }
        }
        return i.push({ left: t2, right: e2, top: o2, bottom: n2 }), true;
      }, o.prototype.measureLabel = function(t2) {
        if (typeof t2 == "object")
          return { width: t2.width, height: t2.height };
        {
          let e2 = 0;
          const o2 = t2.split("\n");
          for (let t3 = 0; t3 < o2.length; ++t3) {
            const n2 = this.ctx.measureText(o2[t3]);
            n2.width > e2 && (e2 = n2.width);
          }
          return { width: e2, height: this.options.fontSize * o2.length };
        }
      }, o.prototype.loadImage = function(t2) {
        const e2 = new Image();
        return e2.src = t2.src, e2.width = t2.width, e2.height = t2.height, e2;
      }, Chart.register({ id: "labels", beforeDatasetsUpdate: function(t2, i, s) {
        if (!e[t2.config.type] || !n(s))
          return;
        s.length || (s = [s]);
        const r = s.length;
        t2._labels && r === t2._labels.length || (t2._labels = s.map(function() {
          return new o();
        }));
        let a = false, h = 0;
        for (let e2 = 0; e2 < r; ++e2) {
          const o2 = t2._labels[e2];
          if (o2.setup(t2, s[e2]), o2.options.position === "outside") {
            a = true;
            const t3 = 1.5 * o2.options.fontSize + o2.options.outsidePadding;
            t3 > h && (h = t3);
          }
        }
        a && (t2.chartArea.top += h, t2.chartArea.bottom -= h);
      }, afterDatasetUpdate: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.args[o2.index] = o2;
        }));
      }, beforeDraw: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.barTotalPercentage = {};
        }));
      }, afterDatasetsDraw: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.render();
        }));
      } });
    }();
  });

  // js/chart.js
  var colors = ["#36a2eb"];
  var month = [
    "Janvier",
    "F\xE9vrier",
    "Mars",
    "Avril",
    "Mai",
    "Juin",
    "Juillet",
    "Ao\xFBt",
    "Septembre",
    "Octobre",
    "Novembre",
    "D\xE9cembre"
  ];
  var SURVEY = [
    "Qualit\xE9 du travail effectu\xE9",
    "Gain de temps du client",
    "Respect du d\xE9lai de livraison",
    "Qualit\xE9 de la communication"
  ];
  var HorizontalBarChart = class {
    constructor(ctx, labels, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              axis: "x",
              label: "Liste des t\xE2ches",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 1,
              color: "#fff"
            }
          ]
        },
        options: {
          indexAxis: "x",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Liste des t\xE2ches par contributeurs"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };
  var StackedBarChart = class {
    constructor(ctx, todo_tasks, blocked_tasks, tasks_in_progress, tasks_in_control, achieved_tasks) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: month,
          datasets: [
            {
              label: "T\xE2ches \xE0 faire",
              data: todo_tasks,
              backgroundColor: "#36a2eb"
            },
            {
              label: "T\xE2ches en blocage",
              data: blocked_tasks,
              backgroundColor: "#e67e22"
            },
            {
              label: "T\xE2ches en cours",
              data: tasks_in_progress,
              backgroundColor: "#27ae60"
            },
            {
              label: "T\xE2ches en contr\xF4le",
              data: tasks_in_control,
              backgroundColor: "#8e44ad"
            },
            {
              label: "T\xE2ches achev\xE9es",
              data: achieved_tasks,
              backgroundColor: "#ff6384"
            }
          ]
        },
        options: {
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "T\xE2ches par mois"
            }
          },
          responsive: true
        }
      });
    }
  };
  var SurveyChart = class {
    constructor(ctx, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: SURVEY,
          datasets: [
            {
              axis: "x",
              label: "Pourcentage de satisfaction en %",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 2,
              color: "#fff"
            }
          ]
        },
        options: {
          maintainAspectRatio: false,
          indexAxis: "y",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Taux de satisfaction du client"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };

  // js/app.js
  var import_chart3 = __toModule(require_chart());
  require_();
  require_2();
  var Hooks2 = {};
  Hooks2.saisieAction = {
    mounted() {
      const tableBody = document.getElementById("record-table-body");
      const addRowLink = document.getElementById("addRowIcon");
      const dataContainer = document.getElementById("data-container");
      if (tableBody && addRowLink && dataContainer) {
        const userId = dataContainer.dataset.userId;
        const date = dataContainer.dataset.today;
        const username = dataContainer.dataset.username;
        const projects = JSON.parse(dataContainer.dataset.projects);
        addRowLink.addEventListener("click", function() {
          lineNotSaved = haveLineNotSaved(tableBody);
          console.log(lineNotSaved);
          if (!lineNotSaved) {
            addRow(tableBody, import_tom_select5.default, userId, date, username, projects);
          } else {
            var addRowIcon = document.querySelector("#addRowIcon i");
            console.log(addRowIcon);
            addRowLink.classList.add("non-cliquable");
            addRowIcon.style.cursor = "not-allowed";
          }
        });
      }
    }
  };
  Hooks2.dynamicFavicon = {
    mounted() {
      changeFaviconByTheme();
    }
  };
  Hooks2.showTask = {
    mounted() {
      desactivateAllinputs();
      const profile = this.el.dataset.profile;
      console.log(profile);
      showTask(profile);
    },
    updated() {
      desactivateAllinputs();
    }
  };
  Hooks2.newTask = {
    updated() {
      loadForm();
    }
  };
  Hooks2.tableHover = {
    mounted() {
      const table = this.el;
      table.querySelectorAll("tbody tr").forEach((row) => {
        let currentColor = "";
        row.addEventListener("mouseover", () => {
          currentColor = row.style.backgroundColor;
          row.style.backgroundColor = "#60b0f0";
        });
        row.addEventListener("mouseout", () => {
          row.style.backgroundColor = currentColor;
        });
      });
    }
  };
  Hooks2.CustomSampleSelect = {
    mounted() {
      console.log("CustomSampleSelect hook initialized");
      var selectElement = document.getElementById("mySelect");
      if (selectElement) {
        console.log("Element found:", selectElement);
        if (!selectElement.tomselect) {
          selectElement.tomselect = new import_tom_select5.default(selectElement, {
            create: false,
            sortField: {
              field: "text",
              direction: "asc"
            }
          });
          console.log("TomSelect options:", selectElement.tomselect.options);
        }
      } else {
        console.error("Select element not found");
      }
    },
    updated() {
      console.log("CustomSampleSelect hook updated");
      var selectElement = document.getElementById("mySelect");
      if (selectElement && selectElement.tomselect) {
        console.log("Element found:", selectElement);
        selectElement.tomselect.clearOptions();
        var selectOptions = selectElement.querySelectorAll("option");
        selectOptions.forEach(function(option) {
          selectElement.tomselect.addOption({
            value: option.value,
            text: option.textContent
          });
        });
        selectElement.tomselect.refreshOptions();
      } else {
        console.error("Select element or TomSelect instance not found");
      }
    }
  };
  Hooks2.CsvExportHook = {
    mounted() {
      this.handleExportClick = this.handleExportClick.bind(this);
      this.el.addEventListener("click", this.handleExportClick);
    },
    destroyed() {
      this.el.removeEventListener("click", this.handleExportClick);
    },
    handleExportClick(event) {
      let csvData = this.el.getAttribute("data-csv");
      console.log("avant :", csvData);
      csvData = csvData.replace(/\\r\\n/g, "\n");
      console.log("apres :", csvData);
      const blob = new Blob([csvData], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = "exemple.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };
  Hooks2.HorizontalBarChart = {
    mounted() {
      const { labels_tasks_by_contributors, values_tasks_by_contributors } = JSON.parse(this.el.dataset.chartData);
      this.chart = new HorizontalBarChart(this.el, labels_tasks_by_contributors, values_tasks_by_contributors);
    }
  };
  Hooks2.StackedBarChart = {
    mounted() {
      const {
        values_tasks_todo_by_month,
        values_blocking_tasks_by_month,
        values_tasks_in_progress_by_month,
        values_tasks_in_control_by_month,
        values_tasks_achieved_by_month
      } = JSON.parse(this.el.dataset.chartData);
      this.chart = new StackedBarChart(this.el, values_tasks_todo_by_month, values_blocking_tasks_by_month, values_tasks_in_progress_by_month, values_tasks_in_control_by_month, values_tasks_achieved_by_month);
    }
  };
  Hooks2.SurveyChart = {
    mounted() {
      console.log("is mounted");
      const { values } = JSON.parse(this.el.dataset.chartData);
      this.mychart = new SurveyChart(this.el, values);
    }
  };
  Hooks2.Board = {
    mounted() {
      this.initDraggables();
    },
    updated() {
      this.sortableCard.destroy();
      this.sortableStage.destroy();
      this.initDraggables();
    },
    initDraggables() {
      this.sortableCard = new Sortable(document.querySelectorAll(".stage__cards"), {
        draggable: ".card",
        mirror: {
          constrainDimensions: true
        },
        swapAnimation: {
          duration: 200,
          easingFunction: "ease-in-out"
        },
        plugins: [Plugins_exports.SwapAnimation]
      });
      this.sortableCard.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const cardId = parseInt(source.getAttribute("data-card-id"));
        const newStageId = parseInt(event.data.newContainer.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const cardPayload = {
          card: {
            id: cardId,
            stage_id: newStageId,
            position: newIndex
          }
        };
        this.pushEvent("update_card", cardPayload);
      });
      this.sortableStage = new Sortable(document.querySelectorAll(".board"), {
        draggable: ".stage",
        handle: ".draggable-handle",
        mirror: {
          constrainDimensions: true,
          yAxis: false
        }
      });
      this.sortableStage.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const stageId = parseInt(source.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const stagePayload = {
          stage: {
            id: stageId,
            position: newIndex
          }
        };
        this.pushEvent("update_stage", stagePayload);
      });
    }
  };
  Hooks2.AnimateAlert = {
    mounted() {
      this.handleEvent("AnimateAlert", ({}) => this.reset_opacity());
    },
    updated() {
    },
    reset_opacity() {
      var alert2 = document.querySelector("#alert_anim");
      alert2.style.opacity = 1;
      window.setTimeout(function() {
        alert2.style.display = "none";
      }, 2e3);
    },
    anim_onload() {
      var alerts2 = document.querySelectorAll(".alert");
      alerts2.forEach((item) => {
        item.style.opacity = 1;
        item.onload = window.setTimeout(function() {
          item.style.opacity = 0;
        }, 2e3);
      });
      for (var i = 0; i < alerts2.length; i++) {
        alerts2[i].style.opacity = 1;
        alerts2[i].onload = window.setTimeout(function() {
          alerts2[i].style.opacity = 0;
        }, 2e3);
      }
    }
  };
  Hooks2.blurHook = {
    mounted() {
      this.handleEvent("blurBody", ({ param1, param2 }) => this.blurBody());
    },
    blurBody() {
      var body = document.body;
      var request_form = document.querySelector("#the_request_form");
      body.style.opacity = 0.5;
      request_form.style.opacity = 1;
    }
  };
  Hooks2.MessageBody = {
    mounted() {
      var messageBody = document.querySelector("#messageBody");
      this.handleEvent("updateScroll", ({}) => messageBody.scrollTop = messageBody.scrollHeight - messageBody.clientHeight);
    }
  };
  Hooks2.urlProcess = {
    mounted() {
      let main = document.querySelector("#main");
      var url = window.location.href;
      url.includes("/logs") ? main.classList.remove("container") : main.classList.add("container");
    }
  };
  Hooks2.SpinTest = {
    mounted() {
      this.handleEvent("SpinTest", ({}) => this.spin_icon());
      this.handleEvent("SpinComment", ({}) => this.spin_comment_icon());
    },
    spin_icon() {
      var spins = document.querySelectorAll(".notif__load");
      spins.forEach((item) => {
        item.classList.add("new__rotate__icon");
      });
      spins.forEach((item) => {
        window.setTimeout(function() {
          item.classList.remove("new__rotate__icon");
        }, 500);
      });
    },
    spin_comment_icon() {
      var clock_comment = document.getElementById("clock_comment");
      clock_comment.classList.add("rotate__icon");
      window.setTimeout(function() {
        clock_comment.classList.remove("rotate__icon");
      }, 500);
    }
  };
  var navToggle = document.querySelector(".nav__toggle");
  var navWrapper = document.querySelector(".nav__wrapper");
  navToggle.addEventListener("click", function() {
    if (navWrapper.classList.contains("active")) {
      this.setAttribute("aria-expanded", "false");
      this.setAttribute("aria-label", "menu");
      navWrapper.classList.remove("active");
    } else {
      navWrapper.classList.add("active");
      this.setAttribute("aria-label", "close menu");
      this.setAttribute("aria-expanded", "true");
    }
  });
  var copyrightIcon = document.getElementById("copyright__icon");
  if (copyrightIcon) {
    copyrightIcon.innerHTML = "copyright PHIDIA / Project monitoring -2024";
  }
  var menuBtn = document.querySelector(".menu-btn");
  var menuOpen = false;
  menuBtn.addEventListener("click", () => {
    if (!menuOpen) {
      menuBtn.classList.add("open");
      menuOpen = true;
    } else {
      menuBtn.classList.remove("open");
      menuOpen = false;
    }
  });
  var alerts = document.querySelectorAll(".alert");
  alerts.forEach((item) => {
    item.style.opacity = 1;
    item.onload = window.setTimeout(function() {
      item.style.opacity = 0;
    }, 2e3);
  });
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    params: { _csrf_token: csrfToken },
    hooks: Hooks2
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
/**
   * [chartjs-plugin-labels]{@link https://github.com/DavideViolante/chartjs-plugin-labels}
   *
   * @version 3.1.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com], Davide Violante, Yousef Altaher
   * @copyright Chen, Yi-Cyuan 2017-2018
   * @license MIT
   */
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL21pY3JvZXZlbnQudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL21pY3JvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vcmVnZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvdW5pY29kZS12YXJpYW50cy9kaXN0L2VzbS9zdHJpbmdzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vaW5kZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2Rpc3QvZXNtL3V0aWxzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3NpZnRlci9kaXN0L2VzbS9zaWZ0ZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2xpYi91dGlscy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3ZhbmlsbGEudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL2hpZ2hsaWdodC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL2NvbnN0YW50cy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL2RlZmF1bHRzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvdXRpbHMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9nZXRTZXR0aW5ncy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3RvbS1zZWxlY3QudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2NoYW5nZV9saXN0ZW5lci9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2NoZWNrYm94X29wdGlvbnMvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9jbGVhcl9idXR0b24vcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9kcmFnX2Ryb3AvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9kcm9wZG93bl9oZWFkZXIvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9jYXJldF9wb3NpdGlvbi9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvaW5wdXRfYXV0b2dyb3cvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9ub19iYWNrc3BhY2VfZGVsZXRlL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvb3B0Z3JvdXBfY29sdW1ucy9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9yZXN0b3JlX29uX2JhY2tzcGFjZS9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL3ZpcnR1YWxfc2Nyb2xsL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3RvbS1zZWxlY3QuY29tcGxldGUudHMiLCAiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2FwcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvdG9tX3NlbGVjdF9zYWlzaWVfcGFnZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvc2hvd2luZ190YXNrLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9uZXdfdGFzay5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvZmF2aWNvbi5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfaHRtbC9wcml2L3N0YXRpYy9waG9lbml4X2h0bWwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3B1c2guanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3RpbWVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9jaGFubmVsLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9hamF4LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9sb25ncG9sbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3NlcmlhbGl6ZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3NvY2tldC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZW50cnlfdXBsb2FkZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdXRpbHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb20uanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdXBsb2FkX2VudHJ5LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfdXBsb2FkZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvbm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20tZXNtLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wYXRjaC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3X2hvb2suanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvanMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlldy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9TZW5zb3JzL1NlbnNvci9TZW5zb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL3V0aWxzL2Rpc3RhbmNlL2Rpc3RhbmNlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvU2Vuc29ycy9Nb3VzZVNlbnNvci9Nb3VzZVNlbnNvci5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL3NoYXJlZC91dGlscy90b3VjaENvb3Jkcy90b3VjaENvb3Jkcy5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9TZW5zb3JzL1RvdWNoU2Vuc29yL1RvdWNoU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvRHJhZ1NlbnNvci9EcmFnU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvRm9yY2VUb3VjaFNlbnNvci9Gb3JjZVRvdWNoU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9pbmRleC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvQ29sbGlkYWJsZS9Db2xsaWRhYmxlRXZlbnQvQ29sbGlkYWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9Db2xsaWRhYmxlL0NvbGxpZGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL3V0aWxzL2RlY29yYXRvcnMvQXV0b0JpbmQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvdXRpbHMvcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZS9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL0RyYWdFdmVudC9EcmFnRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL1Jlc2l6ZU1pcnJvci9SZXNpemVNaXJyb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL1NuYXBwYWJsZS9TbmFwcGFibGVFdmVudC9TbmFwcGFibGVFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvU25hcHBhYmxlL1NuYXBwYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvU3dhcEFuaW1hdGlvbi9Td2FwQW5pbWF0aW9uLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9Tb3J0QW5pbWF0aW9uL1NvcnRBbmltYXRpb24ubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvUGx1Z2lucy9Bbm5vdW5jZW1lbnQvQW5ub3VuY2VtZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1BsdWdpbnMvRm9jdXNhYmxlL0ZvY3VzYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9QbHVnaW5zL01pcnJvci9NaXJyb3JFdmVudC9NaXJyb3JFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9QbHVnaW5zL01pcnJvci9NaXJyb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvUGx1Z2lucy9TY3JvbGxhYmxlL1Njcm9sbGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvRW1pdHRlci9FbWl0dGVyLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL0RyYWdnYWJsZUV2ZW50L0RyYWdnYWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0Ryb3BwYWJsZS9Ecm9wcGFibGVFdmVudC9Ecm9wcGFibGVFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0Ryb3BwYWJsZS9Ecm9wcGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9Td2FwcGFibGUvU3dhcHBhYmxlRXZlbnQvU3dhcHBhYmxlRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9Td2FwcGFibGUvU3dhcHBhYmxlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vU29ydGFibGUvU29ydGFibGVFdmVudC9Tb3J0YWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vU29ydGFibGUvU29ydGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9jaGFydC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzLXBsdWdpbi1sYWJlbHMtZHYvZGlzdC9jaGFydGpzLXBsdWdpbi1sYWJlbHMubWluLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlclxuICpcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0bHksIG5vIG1pc3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG4gKlxuICogQGF1dGhvciBKZXJvbWUgRXRpZW5uZSAoaHR0cHM6Ly9naXRodWIuY29tL2plcm9tZWV0aWVubmUpXG4gKi9cblxudHlwZSBUQ2FsbGJhY2sgPSAoLi4uYXJnczphbnkpID0+IGFueTtcblxuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrIGZvciBlYWNoIGV2ZW50IGluIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50IG5hbWVzXG4gKlxuICovXG5mdW5jdGlvbiBmb3JFdmVudHMoZXZlbnRzOnN0cmluZyxjYWxsYmFjazooZXZlbnQ6c3RyaW5nKT0+YW55KXtcblx0ZXZlbnRzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoZXZlbnQpID0+e1xuXHRcdGNhbGxiYWNrKGV2ZW50KTtcblx0fSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pY3JvRXZlbnR7XG5cblx0cHVibGljIF9ldmVudHM6IHtba2V5OnN0cmluZ106VENhbGxiYWNrW119O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5fZXZlbnRzID0ge307XG5cdH1cblxuXHRvbihldmVudHM6c3RyaW5nLCBmY3Q6VENhbGxiYWNrKXtcblx0XHRmb3JFdmVudHMoZXZlbnRzLChldmVudCkgPT4ge1xuXHRcdFx0Y29uc3QgZXZlbnRfYXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuXHRcdFx0ZXZlbnRfYXJyYXkucHVzaChmY3QpO1xuXHRcdFx0dGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50X2FycmF5O1xuXHRcdH0pO1xuXHR9XG5cblx0b2ZmKGV2ZW50czpzdHJpbmcsIGZjdDpUQ2FsbGJhY2spe1xuXHRcdHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiggbiA9PT0gMCApe1xuXHRcdFx0dGhpcy5fZXZlbnRzID0ge307XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yRXZlbnRzKGV2ZW50cywoZXZlbnQpID0+IHtcblxuXHRcdFx0aWYgKG4gPT09IDEpe1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGV2ZW50X2FycmF5ID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdGlmKCBldmVudF9hcnJheSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRldmVudF9hcnJheS5zcGxpY2UoZXZlbnRfYXJyYXkuaW5kZXhPZihmY3QpLCAxKTtcblx0XHRcdHRoaXMuX2V2ZW50c1tldmVudF0gPSBldmVudF9hcnJheTtcblx0XHR9KTtcblx0fVxuXG5cdHRyaWdnZXIoZXZlbnRzOnN0cmluZywgLi4uYXJnczphbnkpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGZvckV2ZW50cyhldmVudHMsKGV2ZW50KSA9PiB7XG5cdFx0XHRjb25zdCBldmVudF9hcnJheSA9IHNlbGYuX2V2ZW50c1tldmVudF07XG5cdFx0XHRpZiggZXZlbnRfYXJyYXkgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblx0XHRcdGV2ZW50X2FycmF5LmZvckVhY2goZmN0ID0+IHtcblx0XHRcdFx0ZmN0LmFwcGx5KHNlbGYsIGFyZ3MgKTtcblx0XHRcdH0pO1xuXG5cdFx0fSk7XG5cdH1cbn07XG4iLCAiLyoqXG4gKiBtaWNyb3BsdWdpbi5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cblxudHlwZSBUU2V0dGluZ3MgPSB7XG5cdFtrZXk6c3RyaW5nXTphbnlcbn1cblxudHlwZSBUUGx1Z2lucyA9IHtcblx0bmFtZXM6IHN0cmluZ1tdLFxuXHRzZXR0aW5nczogVFNldHRpbmdzLFxuXHRyZXF1ZXN0ZWQ6IHtba2V5OnN0cmluZ106Ym9vbGVhbn0sXG5cdGxvYWRlZDoge1trZXk6c3RyaW5nXTphbnl9XG59O1xuXG5leHBvcnQgdHlwZSBUUGx1Z2luSXRlbSA9IHtuYW1lOnN0cmluZyxvcHRpb25zOnt9fTtcbmV4cG9ydCB0eXBlIFRQbHVnaW5IYXNoID0ge1trZXk6c3RyaW5nXTp7fX07XG5cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1pY3JvUGx1Z2luKEludGVyZmFjZTogYW55ICl7XG5cblx0SW50ZXJmYWNlLnBsdWdpbnMgPSB7fTtcblxuXHRyZXR1cm4gY2xhc3MgZXh0ZW5kcyBJbnRlcmZhY2V7XG5cblx0XHRwdWJsaWMgcGx1Z2luczpUUGx1Z2lucyA9IHtcblx0XHRcdG5hbWVzICAgICA6IFtdLFxuXHRcdFx0c2V0dGluZ3MgIDoge30sXG5cdFx0XHRyZXF1ZXN0ZWQgOiB7fSxcblx0XHRcdGxvYWRlZCAgICA6IHt9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdFx0ICovXG5cdFx0c3RhdGljIGRlZmluZShuYW1lOnN0cmluZywgZm46KHRoaXM6YW55LHNldHRpbmdzOlRTZXR0aW5ncyk9PmFueSl7XG5cdFx0XHRJbnRlcmZhY2UucGx1Z2luc1tuYW1lXSA9IHtcblx0XHRcdFx0J25hbWUnIDogbmFtZSxcblx0XHRcdFx0J2ZuJyAgIDogZm5cblx0XHRcdH07XG5cdFx0fVxuXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyB0aGUgbGlzdGVkIHBsdWdpbnMgKHdpdGggb3B0aW9ucykuXG5cdFx0ICogQWNjZXB0YWJsZSBmb3JtYXRzOlxuXHRcdCAqXG5cdFx0ICogTGlzdCAod2l0aG91dCBvcHRpb25zKTpcblx0XHQgKiAgIFsnYScsICdiJywgJ2MnXVxuXHRcdCAqXG5cdFx0ICogTGlzdCAod2l0aCBvcHRpb25zKTpcblx0XHQgKiAgIFt7J25hbWUnOiAnYScsIG9wdGlvbnM6IHt9fSwgeyduYW1lJzogJ2InLCBvcHRpb25zOiB7fX1dXG5cdFx0ICpcblx0XHQgKiBIYXNoICh3aXRoIG9wdGlvbnMpOlxuXHRcdCAqICAgeydhJzogeyAuLi4gfSwgJ2InOiB7IC4uLiB9LCAnYyc6IHsgLi4uIH19XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gcGx1Z2luc1xuXHRcdCAqL1xuXHRcdGluaXRpYWxpemVQbHVnaW5zKHBsdWdpbnM6c3RyaW5nW118VFBsdWdpbkl0ZW1bXXxUUGx1Z2luSGFzaCkge1xuXHRcdFx0dmFyIGtleSwgbmFtZTtcblx0XHRcdGNvbnN0IHNlbGYgID0gdGhpcztcblx0XHRcdGNvbnN0IHF1ZXVlOnN0cmluZ1tdID0gW107XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG5cdFx0XHRcdHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luOnN0cmluZ3xUUGx1Z2luSXRlbSk9Pntcblx0XHRcdFx0XHRpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2gocGx1Z2luKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5wbHVnaW5zLnNldHRpbmdzW3BsdWdpbi5uYW1lXSA9IHBsdWdpbi5vcHRpb25zO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChwbHVnaW4ubmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAocGx1Z2lucykge1xuXHRcdFx0XHRmb3IgKGtleSBpbiBwbHVnaW5zKSB7XG5cdFx0XHRcdFx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0c2VsZi5wbHVnaW5zLnNldHRpbmdzW2tleV0gPSBwbHVnaW5zW2tleV07XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlKCBuYW1lID0gcXVldWUuc2hpZnQoKSApe1xuXHRcdFx0XHRzZWxmLnJlcXVpcmUobmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bG9hZFBsdWdpbihuYW1lOnN0cmluZykge1xuXHRcdFx0dmFyIHNlbGYgICAgPSB0aGlzO1xuXHRcdFx0dmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG5cdFx0XHR2YXIgcGx1Z2luICA9IEludGVyZmFjZS5wbHVnaW5zW25hbWVdO1xuXG5cdFx0XHRpZiAoIUludGVyZmFjZS5wbHVnaW5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgXCInICsgIG5hbWUgKyAnXCIgcGx1Z2luJyk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucmVxdWVzdGVkW25hbWVdID0gdHJ1ZTtcblx0XHRcdHBsdWdpbnMubG9hZGVkW25hbWVdID0gcGx1Z2luLmZuLmFwcGx5KHNlbGYsIFtzZWxmLnBsdWdpbnMuc2V0dGluZ3NbbmFtZV0gfHwge31dKTtcblx0XHRcdHBsdWdpbnMubmFtZXMucHVzaChuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyBhIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqL1xuXHRcdHJlcXVpcmUobmFtZTpzdHJpbmcpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBwbHVnaW5zID0gc2VsZi5wbHVnaW5zO1xuXG5cdFx0XHRpZiAoIXNlbGYucGx1Z2lucy5sb2FkZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0aWYgKHBsdWdpbnMucmVxdWVzdGVkW25hbWVdKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gaGFzIGNpcmN1bGFyIGRlcGVuZGVuY3kgKFwiJyArIG5hbWUgKyAnXCIpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5sb2FkUGx1Z2luKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGx1Z2lucy5sb2FkZWRbbmFtZV07XG5cdFx0fVxuXG5cdH07XG5cbn1cbiIsICIvKiEgQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IEFwYWNoZSBMaWNlbnNlICh2MikgKi9cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gKlx0ZXggWydhYicsJ2EnXSA9PiAoPzphYnxhKVxuICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuICogQHBhcmFtIHtzdHJpbmdbXX0gY2hhcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgYXJyYXlUb1BhdHRlcm4gPSBjaGFycyA9PiB7XG4gIGNoYXJzID0gY2hhcnMuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIGlmIChjaGFycy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGNoYXJzWzBdIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIG1heFZhbHVlTGVuZ3RoKGNoYXJzKSA9PSAxID8gJ1snICsgY2hhcnMuam9pbignJykgKyAnXScgOiAnKD86JyArIGNoYXJzLmpvaW4oJ3wnKSArICcpJztcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3Qgc2VxdWVuY2VQYXR0ZXJuID0gYXJyYXkgPT4ge1xuICBpZiAoIWhhc0R1cGxpY2F0ZXMoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJycpO1xuICB9XG5cbiAgbGV0IHBhdHRlcm4gPSAnJztcbiAgbGV0IHByZXZfY2hhcl9jb3VudCA9IDA7XG5cbiAgY29uc3QgcHJldl9wYXR0ZXJuID0gKCkgPT4ge1xuICAgIGlmIChwcmV2X2NoYXJfY291bnQgPiAxKSB7XG4gICAgICBwYXR0ZXJuICs9ICd7JyArIHByZXZfY2hhcl9jb3VudCArICd9JztcbiAgICB9XG4gIH07XG5cbiAgYXJyYXkuZm9yRWFjaCgoY2hhciwgaSkgPT4ge1xuICAgIGlmIChjaGFyID09PSBhcnJheVtpIC0gMV0pIHtcbiAgICAgIHByZXZfY2hhcl9jb3VudCsrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZXZfcGF0dGVybigpO1xuICAgIHBhdHRlcm4gKz0gY2hhcjtcbiAgICBwcmV2X2NoYXJfY291bnQgPSAxO1xuICB9KTtcbiAgcHJldl9wYXR0ZXJuKCk7XG4gIHJldHVybiBwYXR0ZXJuO1xufTtcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gKlx0ZXggWydhYicsJ2EnXSA9PiAoPzphYnxhKVxuICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gY2hhcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5jb25zdCBzZXRUb1BhdHRlcm4gPSBjaGFycyA9PiB7XG4gIGxldCBhcnJheSA9IHRvQXJyYXkoY2hhcnMpO1xuICByZXR1cm4gYXJyYXlUb1BhdHRlcm4oYXJyYXkpO1xufTtcbi8qKlxuICpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNzY1OTgvaW4tamF2YXNjcmlwdC1ob3ctZG8taS1jaGVjay1pZi1hbi1hcnJheS1oYXMtZHVwbGljYXRlLXZhbHVlc1xuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqL1xuXG5jb25zdCBoYXNEdXBsaWNhdGVzID0gYXJyYXkgPT4ge1xuICByZXR1cm4gbmV3IFNldChhcnJheSkuc2l6ZSAhPT0gYXJyYXkubGVuZ3RoO1xufTtcbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMwMDY2MDEvd2h5LWRvZXMtdS10aHJvdy1hbi1pbnZhbGlkLWVzY2FwZS1lcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IGVzY2FwZV9yZWdleCA9IHN0ciA9PiB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoLyhbXFwkXFwoXFwpXFwqXFwrXFwuXFw/XFxbXFxdXFxeXFx7XFx8XFx9XFxcXF0pL2d1LCAnXFxcXCQxJyk7XG59O1xuLyoqXG4gKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgYXJyYXkgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcnJheVxuICpcbiAqL1xuXG5jb25zdCBtYXhWYWx1ZUxlbmd0aCA9IGFycmF5ID0+IHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgobG9uZ2VzdCwgdmFsdWUpID0+IE1hdGgubWF4KGxvbmdlc3QsIHVuaWNvZGVMZW5ndGgodmFsdWUpKSwgMCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cblxuY29uc3QgdW5pY29kZUxlbmd0aCA9IHN0ciA9PiB7XG4gIHJldHVybiB0b0FycmF5KHN0cikubGVuZ3RoO1xufTtcbi8qKlxuICogQHBhcmFtIHthbnl9IHBcbiAqIEByZXR1cm4ge2FueVtdfVxuICovXG5cbmNvbnN0IHRvQXJyYXkgPSBwID0+IEFycmF5LmZyb20ocCk7XG5cbmV4cG9ydCB7IGFycmF5VG9QYXR0ZXJuLCBlc2NhcGVfcmVnZXgsIGhhc0R1cGxpY2F0ZXMsIG1heFZhbHVlTGVuZ3RoLCBzZXF1ZW5jZVBhdHRlcm4sIHNldFRvUGF0dGVybiwgdG9BcnJheSwgdW5pY29kZUxlbmd0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnZXguanMubWFwXG4iLCAiLyohIEBvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBBcGFjaGUgTGljZW5zZSAodjIpICovXG4vKipcbiAqIEdldCBhbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIHN1YnN0cmluZ3MgdGhhdCBhZGQgdXAgdG8gdGhlIGdpdmVuIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAxNjk1ODcvZmluZC1hbGwtdGhlLWNvbWJpbmF0aW9uLW9mLXN1YnN0cmluZ3MtdGhhdC1hZGQtdXAtdG8tdGhlLWdpdmVuLXN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICovXG5jb25zdCBhbGxTdWJzdHJpbmdzID0gaW5wdXQgPT4ge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAxKSByZXR1cm4gW1tpbnB1dF1dO1xuICAvKiogQHR5cGUge3N0cmluZ1tdW119ICovXG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFydCA9IGlucHV0LnN1YnN0cmluZygxKTtcbiAgY29uc3Qgc3ViYSA9IGFsbFN1YnN0cmluZ3Moc3RhcnQpO1xuICBzdWJhLmZvckVhY2goZnVuY3Rpb24gKHN1YnJlc3VsdCkge1xuICAgIGxldCB0bXAgPSBzdWJyZXN1bHQuc2xpY2UoMCk7XG4gICAgdG1wWzBdID0gaW5wdXQuY2hhckF0KDApICsgdG1wWzBdO1xuICAgIHJlc3VsdC5wdXNoKHRtcCk7XG4gICAgdG1wID0gc3VicmVzdWx0LnNsaWNlKDApO1xuICAgIHRtcC51bnNoaWZ0KGlucHV0LmNoYXJBdCgwKSk7XG4gICAgcmVzdWx0LnB1c2godG1wKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgeyBhbGxTdWJzdHJpbmdzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcFxuIiwgIi8qISBAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuaW1wb3J0IHsgdG9BcnJheSwgc2V0VG9QYXR0ZXJuLCBlc2NhcGVfcmVnZXgsIGFycmF5VG9QYXR0ZXJuLCBzZXF1ZW5jZVBhdHRlcm4gfSBmcm9tICcuL3JlZ2V4LmpzJztcbmV4cG9ydCB7IGVzY2FwZV9yZWdleCB9IGZyb20gJy4vcmVnZXguanMnO1xuaW1wb3J0IHsgYWxsU3Vic3RyaW5ncyB9IGZyb20gJy4vc3RyaW5ncy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tba2V5OnN0cmluZ106c3RyaW5nfX0gVFVuaWNvZGVNYXBcbiAqIEB0eXBlZGVmIHt7W2tleTpzdHJpbmddOlNldDxzdHJpbmc+fX0gVFVuaWNvZGVTZXRzXG4gKiBAdHlwZWRlZiB7W1tudW1iZXIsbnVtYmVyXV19IFRDb2RlUG9pbnRzXG4gKiBAdHlwZWRlZiB7e2ZvbGRlZDpzdHJpbmcsY29tcG9zZWQ6c3RyaW5nLGNvZGVfcG9pbnQ6bnVtYmVyfX0gVENvZGVQb2ludE9ialxuICogQHR5cGVkZWYge3tzdGFydDpudW1iZXIsZW5kOm51bWJlcixsZW5ndGg6bnVtYmVyLHN1YnN0cjpzdHJpbmd9fSBUU2VxdWVuY2VQYXJ0XG4gKi9cbi8qKiBAdHlwZSB7VENvZGVQb2ludHN9ICovXG5cbmNvbnN0IGNvZGVfcG9pbnRzID0gW1swLCA2NTUzNV1dO1xuY29uc3QgYWNjZW50X3BhdCA9ICdbXFx1MDMwMC1cXHUwMzZGXFx1e2I3fVxcdXsyYmV9XFx1ezJiY31dJztcbi8qKiBAdHlwZSB7VFVuaWNvZGVNYXB9ICovXG5cbmxldCB1bmljb2RlX21hcDtcbi8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXG5sZXQgbXVsdGlfY2hhcl9yZWc7XG5jb25zdCBtYXhfY2hhcl9sZW5ndGggPSAzO1xuLyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuY29uc3QgbGF0aW5fY29udmVydCA9IHt9O1xuLyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuY29uc3QgbGF0aW5fY29uZGVuc2VkID0ge1xuICAnLyc6ICdcdTIwNDRcdTIyMTUnLFxuICAnMCc6ICdcdTA3QzAnLFxuICBcImFcIjogXCJcdTJDNjVcdTAyNTBcdTAyNTFcIixcbiAgXCJhYVwiOiBcIlx1QTczM1wiLFxuICBcImFlXCI6IFwiXHUwMEU2XHUwMUZEXHUwMUUzXCIsXG4gIFwiYW9cIjogXCJcdUE3MzVcIixcbiAgXCJhdVwiOiBcIlx1QTczN1wiLFxuICBcImF2XCI6IFwiXHVBNzM5XHVBNzNCXCIsXG4gIFwiYXlcIjogXCJcdUE3M0RcIixcbiAgXCJiXCI6IFwiXHUwMTgwXHUwMjUzXHUwMTgzXCIsXG4gIFwiY1wiOiBcIlx1QTczRlx1MDE4OFx1MDIzQ1x1MjE4NFwiLFxuICBcImRcIjogXCJcdTAxMTFcdTAyNTdcdTAyNTZcdTFEMDVcdTAxOENcdUFCQjdcdTA1MDFcdTAyNjZcIixcbiAgXCJlXCI6IFwiXHUwMjVCXHUwMUREXHUxRDA3XHUwMjQ3XCIsXG4gIFwiZlwiOiBcIlx1QTc3Q1x1MDE5MlwiLFxuICBcImdcIjogXCJcdTAxRTVcdTAyNjBcdUE3QTFcdTFENzlcdUE3N0ZcdTAyNjJcIixcbiAgXCJoXCI6IFwiXHUwMTI3XHUyQzY4XHUyQzc2XHUwMjY1XCIsXG4gIFwiaVwiOiBcIlx1MDI2OFx1MDEzMVwiLFxuICBcImpcIjogXCJcdTAyNDlcdTAyMzdcIixcbiAgXCJrXCI6IFwiXHUwMTk5XHUyQzZBXHVBNzQxXHVBNzQzXHVBNzQ1XHVBN0EzXCIsXG4gIFwibFwiOiBcIlx1MDE0Mlx1MDE5QVx1MDI2Qlx1MkM2MVx1QTc0OVx1QTc0N1x1QTc4MVx1MDI2RFwiLFxuICBcIm1cIjogXCJcdTAyNzFcdTAyNkZcdTAzRkJcIixcbiAgXCJuXCI6IFwiXHVBN0E1XHUwMTlFXHUwMjcyXHVBNzkxXHUxRDBFXHUwNDNCXHUwNTA5XCIsXG4gIFwib1wiOiBcIlx1MDBGOFx1MDFGRlx1MDI1NFx1MDI3NVx1QTc0Qlx1QTc0RFx1MUQxMVwiLFxuICBcIm9lXCI6IFwiXHUwMTUzXCIsXG4gIFwib2lcIjogXCJcdTAxQTNcIixcbiAgXCJvb1wiOiBcIlx1QTc0RlwiLFxuICBcIm91XCI6IFwiXHUwMjIzXCIsXG4gIFwicFwiOiBcIlx1MDFBNVx1MUQ3RFx1QTc1MVx1QTc1M1x1QTc1NVx1MDNDMVwiLFxuICBcInFcIjogXCJcdUE3NTdcdUE3NTlcdTAyNEJcIixcbiAgXCJyXCI6IFwiXHUwMjREXHUwMjdEXHVBNzVCXHVBN0E3XHVBNzgzXCIsXG4gIFwic1wiOiBcIlx1MDBERlx1MDIzRlx1QTdBOVx1QTc4NVx1MDI4MlwiLFxuICBcInRcIjogXCJcdTAxNjdcdTAxQURcdTAyODhcdTJDNjZcdUE3ODdcIixcbiAgXCJ0aFwiOiBcIlx1MDBGRVwiLFxuICBcInR6XCI6IFwiXHVBNzI5XCIsXG4gIFwidVwiOiBcIlx1MDI4OVwiLFxuICBcInZcIjogXCJcdTAyOEJcdUE3NUZcdTAyOENcIixcbiAgXCJ2eVwiOiBcIlx1QTc2MVwiLFxuICBcIndcIjogXCJcdTJDNzNcIixcbiAgXCJ5XCI6IFwiXHUwMUI0XHUwMjRGXHUxRUZGXCIsXG4gIFwielwiOiBcIlx1MDFCNlx1MDIyNVx1MDI0MFx1MkM2Q1x1QTc2M1wiLFxuICBcImh2XCI6IFwiXHUwMTk1XCJcbn07XG5cbmZvciAobGV0IGxhdGluIGluIGxhdGluX2NvbmRlbnNlZCkge1xuICBsZXQgdW5pY29kZSA9IGxhdGluX2NvbmRlbnNlZFtsYXRpbl0gfHwgJyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmljb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoYXIgPSB1bmljb2RlLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgbGF0aW5fY29udmVydFtjaGFyXSA9IGxhdGluO1xuICB9XG59XG5cbmNvbnN0IGNvbnZlcnRfcGF0ID0gbmV3IFJlZ0V4cChPYmplY3Qua2V5cyhsYXRpbl9jb252ZXJ0KS5qb2luKCd8JykgKyAnfCcgKyBhY2NlbnRfcGF0LCAnZ3UnKTtcbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgdW5pY29kZV9tYXAgZnJvbSB0aGUgZ2l2ZSBjb2RlIHBvaW50IHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7VENvZGVQb2ludHM9fSBfY29kZV9wb2ludHNcbiAqL1xuXG5jb25zdCBpbml0aWFsaXplID0gX2NvZGVfcG9pbnRzID0+IHtcbiAgaWYgKHVuaWNvZGVfbWFwICE9PSB1bmRlZmluZWQpIHJldHVybjtcbiAgdW5pY29kZV9tYXAgPSBnZW5lcmF0ZU1hcChfY29kZV9wb2ludHMgfHwgY29kZV9wb2ludHMpO1xufTtcbi8qKlxuICogSGVscGVyIG1ldGhvZCBmb3Igbm9ybWFsaXplIGEgc3RyaW5nXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybVxuICovXG5cbmNvbnN0IG5vcm1hbGl6ZSA9IChzdHIsIGZvcm0gPSAnTkZLRCcpID0+IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4vKipcbiAqIFJlbW92ZSBhY2NlbnRzIHdpdGhvdXQgcmVvcmRlcmluZyBzdHJpbmdcbiAqIGNhbGxpbmcgc3RyLm5vcm1hbGl6ZSgnTkZLRCcpIG9uIFxcdXs1OTR9XFx1ezU5NX1cXHV7NTk2fSBiZWNvbWVzIFxcdXs1OTZ9XFx1ezU5NH1cXHV7NTk1fVxuICogdmlhIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlzay9GdXNlL2lzc3Vlcy8xMzMjaXNzdWVjb21tZW50LTMxODY5MjcwM1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IGFzY2lpZm9sZCA9IHN0ciA9PiB7XG4gIHJldHVybiB0b0FycmF5KHN0cikucmVkdWNlKFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3VsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICAgKi9cbiAgKHJlc3VsdCwgY2hhcikgPT4ge1xuICAgIHJldHVybiByZXN1bHQgKyBfYXNjaWlmb2xkKGNoYXIpO1xuICB9LCAnJyk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3QgX2FzY2lpZm9sZCA9IHN0ciA9PiB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShjb252ZXJ0X3BhdCwgKFxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgY2hhcikgPT4ge1xuICAgIHJldHVybiBsYXRpbl9jb252ZXJ0W2NoYXJdIHx8ICcnO1xuICB9KTsgLy9yZXR1cm4gc3RyO1xuXG4gIHJldHVybiBub3JtYWxpemUoc3RyLCAnTkZDJyk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgdW5pY29kZSB2YXJpYW50cyBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKiBAcGFyYW0ge1RDb2RlUG9pbnRzfSBjb2RlX3BvaW50c1xuICogQHlpZWxkIHtUQ29kZVBvaW50T2JqfVxuICovXG5cbmZ1bmN0aW9uKiBnZW5lcmF0b3IoY29kZV9wb2ludHMpIHtcbiAgZm9yIChjb25zdCBbY29kZV9wb2ludF9taW4sIGNvZGVfcG9pbnRfbWF4XSBvZiBjb2RlX3BvaW50cykge1xuICAgIGZvciAobGV0IGkgPSBjb2RlX3BvaW50X21pbjsgaSA8PSBjb2RlX3BvaW50X21heDsgaSsrKSB7XG4gICAgICBsZXQgY29tcG9zZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgbGV0IGZvbGRlZCA9IGFzY2lpZm9sZChjb21wb3NlZCk7XG5cbiAgICAgIGlmIChmb2xkZWQgPT0gY29tcG9zZWQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gc2tpcCB3aGVuIGZvbGRlZCBpcyBhIHN0cmluZyBsb25nZXIgdGhhbiAzIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgLy8gYmMgdGhlIHJlc3VsdGluZyByZWdleCBwYXR0ZXJucyB3aWxsIGJlIGxvbmdcbiAgICAgIC8vIGVnOlxuICAgICAgLy8gZm9sZGVkIFx1MDYzNVx1MDY0NFx1MDY0OSBcdTA2MjdcdTA2NDRcdTA2NDRcdTA2NDcgXHUwNjM5XHUwNjQ0XHUwNjRBXHUwNjQ3IFx1MDY0OFx1MDYzM1x1MDY0NFx1MDY0NSBsZW5ndGggMTggY29kZSBwb2ludCA2NTAxOFxuICAgICAgLy8gZm9sZGVkIFx1MDYyQ1x1MDY0NCBcdTA2MkNcdTA2NDRcdTA2MjdcdTA2NDRcdTA2NDcgbGVuZ3RoIDggY29kZSBwb2ludCA2NTAxOVxuXG5cbiAgICAgIGlmIChmb2xkZWQubGVuZ3RoID4gbWF4X2NoYXJfbGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9sZGVkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCB7XG4gICAgICAgIGZvbGRlZDogZm9sZGVkLFxuICAgICAgICBjb21wb3NlZDogY29tcG9zZWQsXG4gICAgICAgIGNvZGVfcG9pbnQ6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pY29kZSBtYXAgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuICogQHBhcmFtIHtUQ29kZVBvaW50c30gY29kZV9wb2ludHNcbiAqIEByZXR1cm4ge1RVbmljb2RlU2V0c31cbiAqL1xuXG5jb25zdCBnZW5lcmF0ZVNldHMgPSBjb2RlX3BvaW50cyA9PiB7XG4gIC8qKiBAdHlwZSB7e1trZXk6c3RyaW5nXTpTZXQ8c3RyaW5nPn19ICovXG4gIGNvbnN0IHVuaWNvZGVfc2V0cyA9IHt9O1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9fYWRkXG4gICAqL1xuXG4gIGNvbnN0IGFkZE1hdGNoaW5nID0gKGZvbGRlZCwgdG9fYWRkKSA9PiB7XG4gICAgLyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cbiAgICBjb25zdCBmb2xkZWRfc2V0ID0gdW5pY29kZV9zZXRzW2ZvbGRlZF0gfHwgbmV3IFNldCgpO1xuICAgIGNvbnN0IHBhdHQgPSBuZXcgUmVnRXhwKCdeJyArIHNldFRvUGF0dGVybihmb2xkZWRfc2V0KSArICckJywgJ2l1Jyk7XG5cbiAgICBpZiAodG9fYWRkLm1hdGNoKHBhdHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9sZGVkX3NldC5hZGQoZXNjYXBlX3JlZ2V4KHRvX2FkZCkpO1xuICAgIHVuaWNvZGVfc2V0c1tmb2xkZWRdID0gZm9sZGVkX3NldDtcbiAgfTtcblxuICBmb3IgKGxldCB2YWx1ZSBvZiBnZW5lcmF0b3IoY29kZV9wb2ludHMpKSB7XG4gICAgYWRkTWF0Y2hpbmcodmFsdWUuZm9sZGVkLCB2YWx1ZS5mb2xkZWQpO1xuICAgIGFkZE1hdGNoaW5nKHZhbHVlLmZvbGRlZCwgdmFsdWUuY29tcG9zZWQpO1xuICB9XG5cbiAgcmV0dXJuIHVuaWNvZGVfc2V0cztcbn07XG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pY29kZSBtYXAgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuICogYWUgPT4gKD86KD86YWV8XHUwMEM2fFx1MDFGQ3xcdTAxRTIpfCg/OkF8XHUyNEI2fFx1RkYyMS4uLikoPzpFfFx1MDI1QnxcdTI0QkEuLi4pKVxuICpcbiAqIEBwYXJhbSB7VENvZGVQb2ludHN9IGNvZGVfcG9pbnRzXG4gKiBAcmV0dXJuIHtUVW5pY29kZU1hcH1cbiAqL1xuXG5jb25zdCBnZW5lcmF0ZU1hcCA9IGNvZGVfcG9pbnRzID0+IHtcbiAgLyoqIEB0eXBlIHtUVW5pY29kZVNldHN9ICovXG4gIGNvbnN0IHVuaWNvZGVfc2V0cyA9IGdlbmVyYXRlU2V0cyhjb2RlX3BvaW50cyk7XG4gIC8qKiBAdHlwZSB7VFVuaWNvZGVNYXB9ICovXG5cbiAgY29uc3QgdW5pY29kZV9tYXAgPSB7fTtcbiAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblxuICBsZXQgbXVsdGlfY2hhciA9IFtdO1xuXG4gIGZvciAobGV0IGZvbGRlZCBpbiB1bmljb2RlX3NldHMpIHtcbiAgICBsZXQgc2V0ID0gdW5pY29kZV9zZXRzW2ZvbGRlZF07XG5cbiAgICBpZiAoc2V0KSB7XG4gICAgICB1bmljb2RlX21hcFtmb2xkZWRdID0gc2V0VG9QYXR0ZXJuKHNldCk7XG4gICAgfVxuXG4gICAgaWYgKGZvbGRlZC5sZW5ndGggPiAxKSB7XG4gICAgICBtdWx0aV9jaGFyLnB1c2goZXNjYXBlX3JlZ2V4KGZvbGRlZCkpO1xuICAgIH1cbiAgfVxuXG4gIG11bHRpX2NoYXIuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG4gIGNvbnN0IG11bHRpX2NoYXJfcGF0dCA9IGFycmF5VG9QYXR0ZXJuKG11bHRpX2NoYXIpO1xuICBtdWx0aV9jaGFyX3JlZyA9IG5ldyBSZWdFeHAoJ14nICsgbXVsdGlfY2hhcl9wYXR0LCAndScpO1xuICByZXR1cm4gdW5pY29kZV9tYXA7XG59O1xuLyoqXG4gKiBNYXAgZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5IGZyb20gaXQncyBmb2xkZWQgdmFsdWUgdG8gYWxsIHBvc3NpYmxlIHVuaWNvZGUgbWF0Y2hlc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gc3RyaW5nc1xuICogQHBhcmFtIHtudW1iZXJ9IG1pbl9yZXBsYWNlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IG1hcFNlcXVlbmNlID0gKHN0cmluZ3MsIG1pbl9yZXBsYWNlbWVudCA9IDEpID0+IHtcbiAgbGV0IGNoYXJzX3JlcGxhY2VkID0gMDtcbiAgc3RyaW5ncyA9IHN0cmluZ3MubWFwKHN0ciA9PiB7XG4gICAgaWYgKHVuaWNvZGVfbWFwW3N0cl0pIHtcbiAgICAgIGNoYXJzX3JlcGxhY2VkICs9IHN0ci5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWNvZGVfbWFwW3N0cl0gfHwgc3RyO1xuICB9KTtcblxuICBpZiAoY2hhcnNfcmVwbGFjZWQgPj0gbWluX3JlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlUGF0dGVybihzdHJpbmdzKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG4vKipcbiAqIENvbnZlcnQgYSBzaG9ydCBzdHJpbmcgYW5kIHNwbGl0IGl0IGludG8gYWxsIHBvc3NpYmxlIHBhdHRlcm5zXG4gKiBLZWVwIGEgcGF0dGVybiBvbmx5IGlmIG1pbl9yZXBsYWNlbWVudCBpcyBtZXRcbiAqXG4gKiAnYWJjJ1xuICogXHRcdD0+IFtbJ2FiYyddLFsnYWInLCdjJ10sWydhJywnYmMnXSxbJ2EnLCdiJywnYyddXVxuICpcdFx0PT4gWydhYmMtcGF0dGVybicsJ2FiLWMtcGF0dGVybicuLi5dXG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5fcmVwbGFjZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5jb25zdCBzdWJzdHJpbmdzVG9QYXR0ZXJuID0gKHN0ciwgbWluX3JlcGxhY2VtZW50ID0gMSkgPT4ge1xuICBtaW5fcmVwbGFjZW1lbnQgPSBNYXRoLm1heChtaW5fcmVwbGFjZW1lbnQsIHN0ci5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKGFsbFN1YnN0cmluZ3Moc3RyKS5tYXAoc3ViX3BhdCA9PiB7XG4gICAgcmV0dXJuIG1hcFNlcXVlbmNlKHN1Yl9wYXQsIG1pbl9yZXBsYWNlbWVudCk7XG4gIH0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2Ygc2VxdWVuY2VzIGludG8gYSBwYXR0ZXJuXG4gKiBbe3N0YXJ0OjAsZW5kOjMsbGVuZ3RoOjMsc3Vic3RyOidpaWknfS4uLl0gPT4gKD86aWlpLi4uKVxuICpcbiAqIEBwYXJhbSB7U2VxdWVuY2VbXX0gc2VxdWVuY2VzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbFxuICovXG5cbmNvbnN0IHNlcXVlbmNlc1RvUGF0dGVybiA9IChzZXF1ZW5jZXMsIGFsbCA9IHRydWUpID0+IHtcbiAgbGV0IG1pbl9yZXBsYWNlbWVudCA9IHNlcXVlbmNlcy5sZW5ndGggPiAxID8gMSA6IDA7XG4gIHJldHVybiBhcnJheVRvUGF0dGVybihzZXF1ZW5jZXMubWFwKHNlcXVlbmNlID0+IHtcbiAgICBsZXQgc2VxID0gW107XG4gICAgY29uc3QgbGVuID0gYWxsID8gc2VxdWVuY2UubGVuZ3RoKCkgOiBzZXF1ZW5jZS5sZW5ndGgoKSAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzZXEucHVzaChzdWJzdHJpbmdzVG9QYXR0ZXJuKHNlcXVlbmNlLnN1YnN0cnNbal0gfHwgJycsIG1pbl9yZXBsYWNlbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzZXF1ZW5jZVBhdHRlcm4oc2VxKTtcbiAgfSkpO1xufTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHNlcXVlbmNlIGlzIGFscmVhZHkgaW4gdGhlIHNlcXVlbmNlc1xuICogQHBhcmFtIHtTZXF1ZW5jZX0gbmVlZGxlX3NlcVxuICogQHBhcmFtIHtTZXF1ZW5jZVtdfSBzZXF1ZW5jZXNcbiAqL1xuXG5cbmNvbnN0IGluU2VxdWVuY2VzID0gKG5lZWRsZV9zZXEsIHNlcXVlbmNlcykgPT4ge1xuICBmb3IgKGNvbnN0IHNlcSBvZiBzZXF1ZW5jZXMpIHtcbiAgICBpZiAoc2VxLnN0YXJ0ICE9IG5lZWRsZV9zZXEuc3RhcnQgfHwgc2VxLmVuZCAhPSBuZWVkbGVfc2VxLmVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNlcS5zdWJzdHJzLmpvaW4oJycpICE9PSBuZWVkbGVfc2VxLnN1YnN0cnMuam9pbignJykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBuZWVkbGVfcGFydHMgPSBuZWVkbGVfc2VxLnBhcnRzO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VFNlcXVlbmNlUGFydH0gcGFydFxuICAgICAqL1xuXG4gICAgY29uc3QgZmlsdGVyID0gcGFydCA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG5lZWRsZV9wYXJ0IG9mIG5lZWRsZV9wYXJ0cykge1xuICAgICAgICBpZiAobmVlZGxlX3BhcnQuc3RhcnQgPT09IHBhcnQuc3RhcnQgJiYgbmVlZGxlX3BhcnQuc3Vic3RyID09PSBwYXJ0LnN1YnN0cikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAxIHx8IG5lZWRsZV9wYXJ0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY2hlY2sgZm9yIG92ZXJsYXBwaW5nIHBhcnRzXG4gICAgICAgIC8vIGEgPSBbJzo6PScsJz09J11cbiAgICAgICAgLy8gYiA9IFsnOjonLCc9PT0nXVxuICAgICAgICAvLyBhID0gWydyJywnc20nXVxuICAgICAgICAvLyBiID0gWydycycsJ20nXVxuXG5cbiAgICAgICAgaWYgKHBhcnQuc3RhcnQgPCBuZWVkbGVfcGFydC5zdGFydCAmJiBwYXJ0LmVuZCA+IG5lZWRsZV9wYXJ0LnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZGxlX3BhcnQuc3RhcnQgPCBwYXJ0LnN0YXJ0ICYmIG5lZWRsZV9wYXJ0LmVuZCA+IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCBmaWx0ZXJlZCA9IHNlcS5wYXJ0cy5maWx0ZXIoZmlsdGVyKTtcblxuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNsYXNzIFNlcXVlbmNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHtUU2VxdWVuY2VQYXJ0W119ICovXG4gICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cbiAgICB0aGlzLnN1YnN0cnMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7VFNlcXVlbmNlUGFydHx1bmRlZmluZWR9IHBhcnRcbiAgICovXG5cblxuICBhZGQocGFydCkge1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICB0aGlzLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICB0aGlzLnN1YnN0cnMucHVzaChwYXJ0LnN1YnN0cik7XG4gICAgICB0aGlzLnN0YXJ0ID0gTWF0aC5taW4ocGFydC5zdGFydCwgdGhpcy5zdGFydCk7XG4gICAgICB0aGlzLmVuZCA9IE1hdGgubWF4KHBhcnQuZW5kLCB0aGlzLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7VFNlcXVlbmNlUGFydH0gbGFzdF9waWVjZVxuICAgKi9cblxuXG4gIGNsb25lKHBvc2l0aW9uLCBsYXN0X3BpZWNlKSB7XG4gICAgbGV0IGNsb25lID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgbGV0IHBhcnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcnRzKSk7XG4gICAgbGV0IGxhc3RfcGFydCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICBjbG9uZS5hZGQocGFydCk7XG4gICAgfVxuXG4gICAgbGV0IGxhc3Rfc3Vic3RyID0gbGFzdF9waWVjZS5zdWJzdHIuc3Vic3RyaW5nKDAsIHBvc2l0aW9uIC0gbGFzdF9wYXJ0LnN0YXJ0KTtcbiAgICBsZXQgY2xvbmVfbGFzdF9sZW4gPSBsYXN0X3N1YnN0ci5sZW5ndGg7XG4gICAgY2xvbmUuYWRkKHtcbiAgICAgIHN0YXJ0OiBsYXN0X3BhcnQuc3RhcnQsXG4gICAgICBlbmQ6IGxhc3RfcGFydC5zdGFydCArIGNsb25lX2xhc3RfbGVuLFxuICAgICAgbGVuZ3RoOiBjbG9uZV9sYXN0X2xlbixcbiAgICAgIHN1YnN0cjogbGFzdF9zdWJzdHJcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBhbmQgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBpbmNsdWRlIHVuaWNvZGUgdmFyaWFudHNcbiAqIFx0ZWcgL2EvIGJlY29tZXMgL2FcdTI0RDBcdUZGNDFcdTFFOUFcdTAwRTBcdTAwRTFcdTAwRTJcdTFFQTdcdTFFQTVcdTFFQUJcdTFFQTlcdTAwRTNcdTAxMDFcdTAxMDNcdTFFQjFcdTFFQUZcdTFFQjVcdTFFQjNcdTAyMjdcdTAxRTFcdTAwRTRcdTAxREZcdTFFQTNcdTAwRTVcdTAxRkJcdTAxQ0VcdTAyMDFcdTAyMDNcdTFFQTFcdTFFQURcdTFFQjdcdTFFMDFcdTAxMDVcdTJDNjVcdTAyNTBcdTAyNTFBXHUyNEI2XHVGRjIxXHUwMEMwXHUwMEMxXHUwMEMyXHUxRUE2XHUxRUE0XHUxRUFBXHUxRUE4XHUwMEMzXHUwMTAwXHUwMTAyXHUxRUIwXHUxRUFFXHUxRUI0XHUxRUIyXHUwMjI2XHUwMUUwXHUwMEM0XHUwMURFXHUxRUEyXHUwMEM1XHUwMUZBXHUwMUNEXHUwMjAwXHUwMjAyXHUxRUEwXHUxRUFDXHUxRUI2XHUxRTAwXHUwMTA0XHUwMjNBXHUyQzZGL1xuICpcbiAqIElzc3VlOlxuICogIFx1RkU4QVx1RkU4QiBbICdcdUZFOEEgPSBcXFxcdXtmZThhfScsICdcdUZFOEIgPSBcXFxcdXtmZThifScgXVxuICpcdGJlY29tZXM6XHRcdTA2NEFcdTA2NTRcdTA2NEFcdTA2NTQgWyAnXHUwNjRBID0gXFxcXHV7NjRhfScsICdcdTA2NTQgPSBcXFxcdXs2NTR9JywgJ1x1MDY0QSA9IFxcXFx1ezY0YX0nLCAnXHUwNjU0ID0gXFxcXHV7NjU0fScgXVxuICpcbiAqXHRcdTAxMzBcdTAxMzIgPSBJSUogPSBcdTIxNjFKXG4gKlxuICogXHQxLzIvNFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cblxuXG5jb25zdCBnZXRQYXR0ZXJuID0gc3RyID0+IHtcbiAgaW5pdGlhbGl6ZSgpO1xuICBzdHIgPSBhc2NpaWZvbGQoc3RyKTtcbiAgbGV0IHBhdHRlcm4gPSAnJztcbiAgbGV0IHNlcXVlbmNlcyA9IFtuZXcgU2VxdWVuY2UoKV07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgc3Vic3RyID0gc3RyLnN1YnN0cmluZyhpKTtcbiAgICBsZXQgbWF0Y2ggPSBzdWJzdHIubWF0Y2gobXVsdGlfY2hhcl9yZWcpO1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICBjb25zdCBtYXRjaF9zdHIgPSBtYXRjaCA/IG1hdGNoWzBdIDogbnVsbDsgLy8gbG9vcCB0aHJvdWdoIHNlcXVlbmNlc1xuICAgIC8vIGFkZCBlaXRoZXIgdGhlIGNoYXIgb3IgbXVsdGlfbWF0Y2hcblxuICAgIGxldCBvdmVybGFwcGluZyA9IFtdO1xuICAgIGxldCBhZGRlZF90eXBlcyA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qgc2VxdWVuY2Ugb2Ygc2VxdWVuY2VzKSB7XG4gICAgICBjb25zdCBsYXN0X3BpZWNlID0gc2VxdWVuY2UubGFzdCgpO1xuXG4gICAgICBpZiAoIWxhc3RfcGllY2UgfHwgbGFzdF9waWVjZS5sZW5ndGggPT0gMSB8fCBsYXN0X3BpZWNlLmVuZCA8PSBpKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtdWx0aSBtYXRjaFxuICAgICAgICBpZiAobWF0Y2hfc3RyKSB7XG4gICAgICAgICAgY29uc3QgbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcbiAgICAgICAgICBzZXF1ZW5jZS5hZGQoe1xuICAgICAgICAgICAgc3RhcnQ6IGksXG4gICAgICAgICAgICBlbmQ6IGkgKyBsZW4sXG4gICAgICAgICAgICBsZW5ndGg6IGxlbixcbiAgICAgICAgICAgIHN1YnN0cjogbWF0Y2hfc3RyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCcxJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VxdWVuY2UuYWRkKHtcbiAgICAgICAgICAgIHN0YXJ0OiBpLFxuICAgICAgICAgICAgZW5kOiBpICsgMSxcbiAgICAgICAgICAgIGxlbmd0aDogMSxcbiAgICAgICAgICAgIHN1YnN0cjogY2hhclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZGVkX3R5cGVzLmFkZCgnMicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoX3N0cikge1xuICAgICAgICBsZXQgY2xvbmUgPSBzZXF1ZW5jZS5jbG9uZShpLCBsYXN0X3BpZWNlKTtcbiAgICAgICAgY29uc3QgbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcbiAgICAgICAgY2xvbmUuYWRkKHtcbiAgICAgICAgICBzdGFydDogaSxcbiAgICAgICAgICBlbmQ6IGkgKyBsZW4sXG4gICAgICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICAgICAgc3Vic3RyOiBtYXRjaF9zdHJcbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJsYXBwaW5nLnB1c2goY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uJ3QgYWRkIGNoYXJcbiAgICAgICAgLy8gYWRkaW5nIHdvdWxkIGNyZWF0ZSBpbnZhbGlkIHBhdHRlcm5zOiAyMzQgPT4gWzIsMzQsNF1cbiAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCczJyk7XG4gICAgICB9XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG92ZXJsYXBwaW5nXG5cblxuICAgIGlmIChvdmVybGFwcGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBbJ2lpJywnaWlpJ10gYmVmb3JlIFsnaScsJ2knLCdpaWknXVxuICAgICAgb3ZlcmxhcHBpbmcgPSBvdmVybGFwcGluZy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCgpIC0gYi5sZW5ndGgoKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGxldCBjbG9uZSBvZiBvdmVybGFwcGluZykge1xuICAgICAgICAvLyBkb24ndCBhZGQgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGVxdWl2YWxlbnQgc2VxdWVuY2VcbiAgICAgICAgaWYgKGluU2VxdWVuY2VzKGNsb25lLCBzZXF1ZW5jZXMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXF1ZW5jZXMucHVzaChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gaWYgd2UgaGF2ZW4ndCBkb25lIGFueXRoaW5nIHVuaXF1ZVxuICAgIC8vIGNsZWFuIHVwIHRoZSBwYXR0ZXJuc1xuICAgIC8vIGhlbHBzIGtlZXAgcGF0dGVybnMgc21hbGxlclxuICAgIC8vIGlmIHN0ciA9ICdyXHUyMEE4XHUzM0E3YWFyc3MnLCBwYXR0ZXJuIHdpbGwgYmUgNDQ2IGluc3RlYWQgb2YgNjU1XG5cblxuICAgIGlmIChpID4gMCAmJiBhZGRlZF90eXBlcy5zaXplID09IDEgJiYgIWFkZGVkX3R5cGVzLmhhcygnMycpKSB7XG4gICAgICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIGZhbHNlKTtcbiAgICAgIGxldCBuZXdfc2VxID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICBjb25zdCBvbGRfc2VxID0gc2VxdWVuY2VzWzBdO1xuXG4gICAgICBpZiAob2xkX3NlcSkge1xuICAgICAgICBuZXdfc2VxLmFkZChvbGRfc2VxLmxhc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIHNlcXVlbmNlcyA9IFtuZXdfc2VxXTtcbiAgICB9XG4gIH1cblxuICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIHRydWUpO1xuICByZXR1cm4gcGF0dGVybjtcbn07XG5cbmV4cG9ydCB7IF9hc2NpaWZvbGQsIGFzY2lpZm9sZCwgY29kZV9wb2ludHMsIGdlbmVyYXRlTWFwLCBnZW5lcmF0ZVNldHMsIGdlbmVyYXRvciwgZ2V0UGF0dGVybiwgaW5pdGlhbGl6ZSwgbWFwU2VxdWVuY2UsIG5vcm1hbGl6ZSwgc3Vic3RyaW5nc1RvUGF0dGVybiwgdW5pY29kZV9tYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwgIi8qISBzaWZ0ZXIuanMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvc2lmdGVyLmpzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuaW1wb3J0IHsgYXNjaWlmb2xkIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuXG4vKipcbiAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuICovXG5jb25zdCBnZXRBdHRyID0gKG9iaiwgbmFtZSkgPT4ge1xuICBpZiAoIW9iaikgcmV0dXJuO1xuICByZXR1cm4gb2JqW25hbWVdO1xufTtcbi8qKlxuICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG4gKi9cblxuY29uc3QgZ2V0QXR0ck5lc3RpbmcgPSAob2JqLCBuYW1lKSA9PiB7XG4gIGlmICghb2JqKSByZXR1cm47XG4gIHZhciBwYXJ0LFxuICAgICAgbmFtZXMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcblxuICB3aGlsZSAoKHBhcnQgPSBuYW1lcy5zaGlmdCgpKSAmJiAob2JqID0gb2JqW3BhcnRdKSk7XG5cbiAgcmV0dXJuIG9iajtcbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgaG93IGNsb3NlIG9mIGEgbWF0Y2ggdGhlXG4gKiBnaXZlbiB2YWx1ZSBpcyBhZ2FpbnN0IGEgc2VhcmNoIHRva2VuLlxuICpcbiAqL1xuXG5jb25zdCBzY29yZVZhbHVlID0gKHZhbHVlLCB0b2tlbiwgd2VpZ2h0KSA9PiB7XG4gIHZhciBzY29yZSwgcG9zO1xuICBpZiAoIXZhbHVlKSByZXR1cm4gMDtcbiAgdmFsdWUgPSB2YWx1ZSArICcnO1xuICBpZiAodG9rZW4ucmVnZXggPT0gbnVsbCkgcmV0dXJuIDA7XG4gIHBvcyA9IHZhbHVlLnNlYXJjaCh0b2tlbi5yZWdleCk7XG4gIGlmIChwb3MgPT09IC0xKSByZXR1cm4gMDtcbiAgc2NvcmUgPSB0b2tlbi5zdHJpbmcubGVuZ3RoIC8gdmFsdWUubGVuZ3RoO1xuICBpZiAocG9zID09PSAwKSBzY29yZSArPSAwLjU7XG4gIHJldHVybiBzY29yZSAqIHdlaWdodDtcbn07XG4vKipcbiAqIENhc3Qgb2JqZWN0IHByb3BlcnR5IHRvIGFuIGFycmF5IGlmIGl0IGV4aXN0cyBhbmQgaGFzIGEgdmFsdWVcbiAqXG4gKi9cblxuY29uc3QgcHJvcFRvQXJyYXkgPSAob2JqLCBrZXkpID0+IHtcbiAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBvYmpba2V5XSA9IFt2YWx1ZV07XG4gIH1cbn07XG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5cbmNvbnN0IGl0ZXJhdGUgPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5jb25zdCBjbXAgPSAoYSwgYikgPT4ge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgfVxuXG4gIGEgPSBhc2NpaWZvbGQoYSArICcnKS50b0xvd2VyQ2FzZSgpO1xuICBiID0gYXNjaWlmb2xkKGIgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYgKGIgPiBhKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufTtcblxuZXhwb3J0IHsgY21wLCBnZXRBdHRyLCBnZXRBdHRyTmVzdGluZywgaXRlcmF0ZSwgcHJvcFRvQXJyYXksIHNjb3JlVmFsdWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIiwgIi8qISBzaWZ0ZXIuanMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvc2lmdGVyLmpzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuaW1wb3J0IHsgaXRlcmF0ZSwgY21wLCBwcm9wVG9BcnJheSwgZ2V0QXR0ck5lc3RpbmcsIGdldEF0dHIsIHNjb3JlVmFsdWUgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCB7IGNtcCwgZ2V0QXR0ciwgZ2V0QXR0ck5lc3RpbmcsIGl0ZXJhdGUsIHByb3BUb0FycmF5LCBzY29yZVZhbHVlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVfcmVnZXgsIGdldFBhdHRlcm4gfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5leHBvcnQgeyBnZXRQYXR0ZXJuIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuXG4vKipcbiAqIHNpZnRlci5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzXHUyMDEzMjAyMCBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGF1dGhvciBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPlxuICovXG5cbmNsYXNzIFNpZnRlciB7XG4gIC8vIFtdfHt9O1xuXG4gIC8qKlxuICAgKiBUZXh0dWFsbHkgc2VhcmNoZXMgYXJyYXlzIGFuZCBoYXNoZXMgb2Ygb2JqZWN0c1xuICAgKiBieSBwcm9wZXJ0eSAob3IgbXVsdGlwbGUgcHJvcGVydGllcykuIERlc2lnbmVkXG4gICAqIHNwZWNpZmljYWxseSBmb3IgYXV0b2NvbXBsZXRlLlxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXRlbXMsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5pdGVtcyA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3MgfHwge1xuICAgICAgZGlhY3JpdGljczogdHJ1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgc2VhcmNoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWxcbiAgICogcmVnZXhwcyB0byBiZSB1c2VkIHRvIG1hdGNoIHJlc3VsdHMuXG4gICAqXG4gICAqL1xuICB0b2tlbml6ZShxdWVyeSwgcmVzcGVjdF93b3JkX2JvdW5kYXJpZXMsIHdlaWdodHMpIHtcbiAgICBpZiAoIXF1ZXJ5IHx8ICFxdWVyeS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCB3b3JkcyA9IHF1ZXJ5LnNwbGl0KC9cXHMrLyk7XG4gICAgdmFyIGZpZWxkX3JlZ2V4O1xuXG4gICAgaWYgKHdlaWdodHMpIHtcbiAgICAgIGZpZWxkX3JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgT2JqZWN0LmtleXMod2VpZ2h0cykubWFwKGVzY2FwZV9yZWdleCkuam9pbignfCcpICsgJylcXDooLiopJCcpO1xuICAgIH1cblxuICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgICBsZXQgZmllbGRfbWF0Y2g7XG4gICAgICBsZXQgZmllbGQgPSBudWxsO1xuICAgICAgbGV0IHJlZ2V4ID0gbnVsbDsgLy8gbG9vayBmb3IgXCJmaWVsZDpxdWVyeVwiIHRva2Vuc1xuXG4gICAgICBpZiAoZmllbGRfcmVnZXggJiYgKGZpZWxkX21hdGNoID0gd29yZC5tYXRjaChmaWVsZF9yZWdleCkpKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRfbWF0Y2hbMV07XG4gICAgICAgIHdvcmQgPSBmaWVsZF9tYXRjaFsyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kaWFjcml0aWNzKSB7XG4gICAgICAgICAgcmVnZXggPSBnZXRQYXR0ZXJuKHdvcmQpIHx8IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnZXggPSBlc2NhcGVfcmVnZXgod29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVnZXggJiYgcmVzcGVjdF93b3JkX2JvdW5kYXJpZXMpIHJlZ2V4ID0gXCJcXFxcYlwiICsgcmVnZXg7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgc3RyaW5nOiB3b3JkLFxuICAgICAgICByZWdleDogcmVnZXggPyBuZXcgUmVnRXhwKHJlZ2V4LCAnaXUnKSA6IG51bGwsXG4gICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCB0byBzY29yZSBpbmRpdmlkdWFsIHJlc3VsdHMuXG4gICAqXG4gICAqIEdvb2QgbWF0Y2hlcyB3aWxsIGhhdmUgYSBoaWdoZXIgc2NvcmUgdGhhbiBwb29yIG1hdGNoZXMuXG4gICAqIElmIGFuIGl0ZW0gaXMgbm90IGEgbWF0Y2gsIDAgd2lsbCBiZSByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtULlNjb3JlRm59XG4gICAqL1xuICBnZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge1QuU2NvcmVGbn1cbiAgICpcbiAgICovXG5cblxuICBfZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzZWFyY2gudG9rZW5zLFxuICAgICAgICAgIHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIGlmICghdG9rZW5fY291bnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZHMgPSBzZWFyY2gub3B0aW9ucy5maWVsZHMsXG4gICAgICAgICAgd2VpZ2h0cyA9IHNlYXJjaC53ZWlnaHRzLFxuICAgICAgICAgIGZpZWxkX2NvdW50ID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBnZXRBdHRyRm4gPSBzZWFyY2guZ2V0QXR0ckZuO1xuXG4gICAgaWYgKCFmaWVsZF9jb3VudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzY29yZSBvZiBhbiBvYmplY3RcbiAgICAgKiBhZ2FpbnN0IHRoZSBzZWFyY2ggcXVlcnkuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgY29uc3Qgc2NvcmVPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZmllbGRfY291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzWzBdLmZpZWxkO1xuICAgICAgICAgIHJldHVybiBzY29yZVZhbHVlKGdldEF0dHJGbihkYXRhLCBmaWVsZCksIHRva2VuLCB3ZWlnaHRzW2ZpZWxkXSB8fCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICB2YXIgc3VtID0gMDsgLy8gaXMgdGhlIHRva2VuIHNwZWNpZmljIHRvIGEgZmllbGQ/XG5cbiAgICAgICAgaWYgKHRva2VuLmZpZWxkKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyRm4oZGF0YSwgdG9rZW4uZmllbGQpO1xuXG4gICAgICAgICAgaWYgKCF0b2tlbi5yZWdleCAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgc3VtICs9IDEgLyBmaWVsZF9jb3VudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUodmFsdWUsIHRva2VuLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZSh3ZWlnaHRzLCAod2VpZ2h0LCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUoZ2V0QXR0ckZuKGRhdGEsIGZpZWxkKSwgdG9rZW4sIHdlaWdodCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtIC8gZmllbGRfY291bnQ7XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0b2tlbl9jb3VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBzY29yZU9iamVjdCh0b2tlbnNbMF0sIGRhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoc2VhcmNoLm9wdGlvbnMuY29uanVuY3Rpb24gPT09ICdhbmQnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHNjb3JlLFxuICAgICAgICAgICAgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICBzY29yZSA9IHNjb3JlT2JqZWN0KHRva2VuLCBkYXRhKTtcbiAgICAgICAgICBpZiAoc2NvcmUgPD0gMCkgcmV0dXJuIDA7XG4gICAgICAgICAgc3VtICs9IHNjb3JlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBpdGVyYXRlKHRva2VucywgdG9rZW4gPT4ge1xuICAgICAgICAgIHN1bSArPSBzY29yZU9iamVjdCh0b2tlbiwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3VtIC8gdG9rZW5fY291bnQ7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wYXJlIHR3b1xuICAgKiByZXN1bHRzLCBmb3Igc29ydGluZyBwdXJwb3Nlcy4gSWYgbm8gc29ydGluZyBzaG91bGRcbiAgICogYmUgcGVyZm9ybWVkLCBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHJldHVybiBmdW5jdGlvbihhLGIpXG4gICAqL1xuICBnZXRTb3J0RnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCk7XG4gIH1cblxuICBfZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCkge1xuICAgIHZhciBpbXBsaWNpdF9zY29yZSxcbiAgICAgICAgc29ydF9mbGRzID0gW107XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zLFxuICAgICAgICAgIHNvcnQgPSAhc2VhcmNoLnF1ZXJ5ICYmIG9wdGlvbnMuc29ydF9lbXB0eSA/IG9wdGlvbnMuc29ydF9lbXB0eSA6IG9wdGlvbnMuc29ydDtcblxuICAgIGlmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc29ydC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBzcGVjaWZpZWQgc29ydCBmaWVsZCB2YWx1ZVxuICAgICAqIGZyb20gYSBzZWFyY2ggcmVzdWx0IGl0ZW0uXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgY29uc3QgZ2V0X2ZpZWxkID0gZnVuY3Rpb24gZ2V0X2ZpZWxkKG5hbWUsIHJlc3VsdCkge1xuICAgICAgaWYgKG5hbWUgPT09ICckc2NvcmUnKSByZXR1cm4gcmVzdWx0LnNjb3JlO1xuICAgICAgcmV0dXJuIHNlYXJjaC5nZXRBdHRyRm4oc2VsZi5pdGVtc1tyZXN1bHQuaWRdLCBuYW1lKTtcbiAgICB9OyAvLyBwYXJzZSBvcHRpb25zXG5cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBmb3IgKGxldCBzIG9mIHNvcnQpIHtcbiAgICAgICAgaWYgKHNlYXJjaC5xdWVyeSB8fCBzLmZpZWxkICE9PSAnJHNjb3JlJykge1xuICAgICAgICAgIHNvcnRfZmxkcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyB0aGUgXCIkc2NvcmVcIiBmaWVsZCBpcyBpbXBsaWVkIHRvIGJlIHRoZSBwcmltYXJ5XG4gICAgLy8gc29ydCBmaWVsZCwgdW5sZXNzIGl0J3MgbWFudWFsbHkgc3BlY2lmaWVkXG5cblxuICAgIGlmIChzZWFyY2gucXVlcnkpIHtcbiAgICAgIGltcGxpY2l0X3Njb3JlID0gdHJ1ZTtcblxuICAgICAgZm9yIChsZXQgZmxkIG9mIHNvcnRfZmxkcykge1xuICAgICAgICBpZiAoZmxkLmZpZWxkID09PSAnJHNjb3JlJykge1xuICAgICAgICAgIGltcGxpY2l0X3Njb3JlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGltcGxpY2l0X3Njb3JlKSB7XG4gICAgICAgIHNvcnRfZmxkcy51bnNoaWZ0KHtcbiAgICAgICAgICBmaWVsZDogJyRzY29yZScsXG4gICAgICAgICAgZGlyZWN0aW9uOiAnZGVzYydcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHdpdGhvdXQgYSBzZWFyY2gucXVlcnksIGFsbCBpdGVtcyB3aWxsIGhhdmUgdGhlIHNhbWUgc2NvcmVcblxuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0X2ZsZHMgPSBzb3J0X2ZsZHMuZmlsdGVyKGZsZCA9PiBmbGQuZmllbGQgIT09ICckc2NvcmUnKTtcbiAgICB9IC8vIGJ1aWxkIGZ1bmN0aW9uXG5cblxuICAgIGNvbnN0IHNvcnRfZmxkc19jb3VudCA9IHNvcnRfZmxkcy5sZW5ndGg7XG5cbiAgICBpZiAoIXNvcnRfZmxkc19jb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgcmVzdWx0LCBmaWVsZDtcblxuICAgICAgZm9yIChsZXQgc29ydF9mbGQgb2Ygc29ydF9mbGRzKSB7XG4gICAgICAgIGZpZWxkID0gc29ydF9mbGQuZmllbGQ7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gc29ydF9mbGQuZGlyZWN0aW9uID09PSAnZGVzYycgPyAtMSA6IDE7XG4gICAgICAgIHJlc3VsdCA9IG11bHRpcGxpZXIgKiBjbXAoZ2V0X2ZpZWxkKGZpZWxkLCBhKSwgZ2V0X2ZpZWxkKGZpZWxkLCBiKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc2VhcmNoIHF1ZXJ5IGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICAgKiB3aXRoIHRva2VucyBhbmQgZmllbGRzIHJlYWR5IHRvIGJlIHBvcHVsYXRlZFxuICAgKiB3aXRoIHJlc3VsdHMuXG4gICAqXG4gICAqL1xuICBwcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRzVXNlcikge1xuICAgIGNvbnN0IHdlaWdodHMgPSB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHNVc2VyKTtcbiAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnc29ydCcpO1xuICAgIHByb3BUb0FycmF5KG9wdGlvbnMsICdzb3J0X2VtcHR5Jyk7IC8vIGNvbnZlcnQgZmllbGRzIHRvIG5ldyBmb3JtYXRcblxuICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgcHJvcFRvQXJyYXkob3B0aW9ucywgJ2ZpZWxkcycpO1xuICAgICAgY29uc3QgZmllbGRzID0gW107XG4gICAgICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgd2VpZ2h0OiAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgd2VpZ2h0c1tmaWVsZC5maWVsZF0gPSAnd2VpZ2h0JyBpbiBmaWVsZCA/IGZpZWxkLndlaWdodCA6IDE7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gZmllbGRzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgcXVlcnk6IHF1ZXJ5LnRvTG93ZXJDYXNlKCkudHJpbSgpLFxuICAgICAgdG9rZW5zOiB0aGlzLnRva2VuaXplKHF1ZXJ5LCBvcHRpb25zLnJlc3BlY3Rfd29yZF9ib3VuZGFyaWVzLCB3ZWlnaHRzKSxcbiAgICAgIHRvdGFsOiAwLFxuICAgICAgaXRlbXM6IFtdLFxuICAgICAgd2VpZ2h0czogd2VpZ2h0cyxcbiAgICAgIGdldEF0dHJGbjogb3B0aW9ucy5uZXN0aW5nID8gZ2V0QXR0ck5lc3RpbmcgOiBnZXRBdHRyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBpdGVtcyBhbmQgcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuICAgKlxuICAgKi9cbiAgc2VhcmNoKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzY29yZSxcbiAgICAgICAgc2VhcmNoO1xuICAgIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zO1xuICAgIHF1ZXJ5ID0gc2VhcmNoLnF1ZXJ5OyAvLyBnZW5lcmF0ZSByZXN1bHQgc2NvcmluZyBmdW5jdGlvblxuXG4gICAgY29uc3QgZm5fc2NvcmUgPSBvcHRpb25zLnNjb3JlIHx8IHNlbGYuX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTsgLy8gcGVyZm9ybSBzZWFyY2ggYW5kIHNvcnRcblxuXG4gICAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgaXRlcmF0ZShzZWxmLml0ZW1zLCAoaXRlbSwgaWQpID0+IHtcbiAgICAgICAgc2NvcmUgPSBmbl9zY29yZShpdGVtKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlIHx8IHNjb3JlID4gMCkge1xuICAgICAgICAgIHNlYXJjaC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICdzY29yZSc6IHNjb3JlLFxuICAgICAgICAgICAgJ2lkJzogaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGUoc2VsZi5pdGVtcywgKF8sIGlkKSA9PiB7XG4gICAgICAgIHNlYXJjaC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAnc2NvcmUnOiAxLFxuICAgICAgICAgICdpZCc6IGlkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZm5fc29ydCA9IHNlbGYuX2dldFNvcnRGdW5jdGlvbihzZWFyY2gpO1xuXG4gICAgaWYgKGZuX3NvcnQpIHNlYXJjaC5pdGVtcy5zb3J0KGZuX3NvcnQpOyAvLyBhcHBseSBsaW1pdHNcblxuICAgIHNlYXJjaC50b3RhbCA9IHNlYXJjaC5pdGVtcy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGltaXQgPT09ICdudW1iZXInKSB7XG4gICAgICBzZWFyY2guaXRlbXMgPSBzZWFyY2guaXRlbXMuc2xpY2UoMCwgb3B0aW9ucy5saW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaDtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFNpZnRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lmdGVyLmpzLm1hcFxuIiwgIlxuaW1wb3J0IHsgYXNjaWlmb2xkIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuaW1wb3J0ICogYXMgVCBmcm9tICcuL3R5cGVzJztcblxuXG4vKipcbiAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0QXR0ciA9IChvYmo6e1trZXk6c3RyaW5nXTphbnl9LCBuYW1lOnN0cmluZyApID0+IHtcbiAgICBpZiAoIW9iaiApIHJldHVybjtcbiAgICByZXR1cm4gb2JqW25hbWVdO1xufTtcblxuLyoqXG4gKiBBIHByb3BlcnR5IGdldHRlciByZXNvbHZpbmcgZG90LW5vdGF0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgIFRoZSByb290IG9iamVjdCB0byBmZXRjaCBwcm9wZXJ0eSBvblxuICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICBUaGUgb3B0aW9uYWxseSBkb3R0ZWQgcHJvcGVydHkgbmFtZSB0byBmZXRjaFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBUaGUgcmVzb2x2ZWQgcHJvcGVydHkgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF0dHJOZXN0aW5nID0gKG9iajp7W2tleTpzdHJpbmddOmFueX0sIG5hbWU6c3RyaW5nICkgPT4ge1xuICAgIGlmICghb2JqICkgcmV0dXJuO1xuICAgIHZhciBwYXJ0LCBuYW1lcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuXHR3aGlsZSggKHBhcnQgPSBuYW1lcy5zaGlmdCgpKSAmJiAob2JqID0gb2JqW3BhcnRdKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBob3cgY2xvc2Ugb2YgYSBtYXRjaCB0aGVcbiAqIGdpdmVuIHZhbHVlIGlzIGFnYWluc3QgYSBzZWFyY2ggdG9rZW4uXG4gKlxuICovXG5leHBvcnQgY29uc3Qgc2NvcmVWYWx1ZSA9ICh2YWx1ZTpzdHJpbmcsIHRva2VuOlQuVG9rZW4sIHdlaWdodDpudW1iZXIgKTpudW1iZXIgPT4ge1xuXHR2YXIgc2NvcmUsIHBvcztcblxuXHRpZiAoIXZhbHVlKSByZXR1cm4gMDtcblxuXHR2YWx1ZSA9IHZhbHVlICsgJyc7XG5cdGlmKCB0b2tlbi5yZWdleCA9PSBudWxsICkgcmV0dXJuIDA7XG5cdHBvcyA9IHZhbHVlLnNlYXJjaCh0b2tlbi5yZWdleCk7XG5cdGlmIChwb3MgPT09IC0xKSByZXR1cm4gMDtcblxuXHRzY29yZSA9IHRva2VuLnN0cmluZy5sZW5ndGggLyB2YWx1ZS5sZW5ndGg7XG5cdGlmIChwb3MgPT09IDApIHNjb3JlICs9IDAuNTtcblxuXHRyZXR1cm4gc2NvcmUgKiB3ZWlnaHQ7XG59O1xuXG5cbi8qKlxuICogQ2FzdCBvYmplY3QgcHJvcGVydHkgdG8gYW4gYXJyYXkgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHByb3BUb0FycmF5ID0gKG9iajp7W2tleTpzdHJpbmddOmFueX0sIGtleTpzdHJpbmcpID0+IHtcblx0dmFyIHZhbHVlID0gb2JqW2tleV07XG5cblx0aWYoIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICkgcmV0dXJuIHZhbHVlO1xuXG5cdGlmKCB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgKXtcblx0XHRvYmpba2V5XSA9IFt2YWx1ZV07XG5cdH1cbn1cblxuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZSA9IChvYmplY3Q6W118e1trZXk6c3RyaW5nXTphbnl9LCBjYWxsYmFjazoodmFsdWU6YW55LGtleTphbnkpPT5hbnkpID0+IHtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuXHRcdG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcblxuXHR9ZWxzZXtcblxuXHRcdGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0XHRcdGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cblxuXG5leHBvcnQgY29uc3QgY21wID0gKGE6bnVtYmVyfHN0cmluZywgYjpudW1iZXJ8c3RyaW5nKSA9PiB7XG5cdGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIGEgPiBiID8gMSA6IChhIDwgYiA/IC0xIDogMCk7XG5cdH1cblx0YSA9IGFzY2lpZm9sZChhICsgJycpLnRvTG93ZXJDYXNlKCk7XG5cdGIgPSBhc2NpaWZvbGQoYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoYSA+IGIpIHJldHVybiAxO1xuXHRpZiAoYiA+IGEpIHJldHVybiAtMTtcblx0cmV0dXJuIDA7XG59O1xuIiwgIlxuaW1wb3J0IHsgaXRlcmF0ZSB9IGZyb20gJ0BvcmNoaWRqcy9zaWZ0ZXIvbGliL3V0aWxzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDE0My9jcmVhdGluZy1hLW5ldy1kb20tZWxlbWVudC1mcm9tLWFuLWh0bWwtc3RyaW5nLXVzaW5nLWJ1aWx0LWluLWRvbS1tZXRob2RzLW9yLXByby8zNTM4NTUxOCMzNTM4NTUxOFxuICpcbiAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuICovXG5leHBvcnQgY29uc3QgZ2V0RG9tID0gKCBxdWVyeTphbnkgKTpIVE1MRWxlbWVudCA9PiB7XG5cblx0aWYoIHF1ZXJ5LmpxdWVyeSApe1xuXHRcdHJldHVybiBxdWVyeVswXTtcblx0fVxuXG5cdGlmKCBxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICl7XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9XG5cblx0aWYoIGlzSHRtbFN0cmluZyhxdWVyeSkgKXtcblx0XHR2YXIgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0XHR0cGwuaW5uZXJIVE1MID0gcXVlcnkudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG5cdFx0cmV0dXJuIHRwbC5jb250ZW50LmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQ7XG5cdH1cblxuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNIdG1sU3RyaW5nID0gKGFyZzphbnkpOiBib29sZWFuID0+IHtcblx0aWYoIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSApe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGNvbnN0IGVzY2FwZVF1ZXJ5ID0gKHF1ZXJ5OnN0cmluZyk6c3RyaW5nID0+IHtcblx0cmV0dXJuIHF1ZXJ5LnJlcGxhY2UoL1snXCJcXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYW4gZXZlbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCB0cmlnZ2VyRXZlbnQgPSAoIGRvbV9lbDpIVE1MRWxlbWVudCwgZXZlbnRfbmFtZTpzdHJpbmcgKTp2b2lkID0+IHtcblx0dmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0ZXZlbnQuaW5pdEV2ZW50KGV2ZW50X25hbWUsIHRydWUsIGZhbHNlKTtcblx0ZG9tX2VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59O1xuXG4vKipcbiAqIEFwcGx5IENTUyBydWxlcyB0byBhIGRvbSBlbGVtZW50XG4gKlxuICovXG5leHBvcnQgY29uc3QgYXBwbHlDU1MgPSAoIGRvbV9lbDpIVE1MRWxlbWVudCwgY3NzOnsgW2tleTogc3RyaW5nXTogc3RyaW5nfG51bWJlciB9KTp2b2lkID0+IHtcblx0T2JqZWN0LmFzc2lnbihkb21fZWwuc3R5bGUsIGNzcyk7XG59XG5cblxuLyoqXG4gKiBBZGQgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDbGFzc2VzID0gKCBlbG10czpIVE1MRWxlbWVudHxIVE1MRWxlbWVudFtdLCAuLi5jbGFzc2VzOnN0cmluZ1tdfHN0cmluZ1tdW10gKSA9PiB7XG5cblx0dmFyIG5vcm1fY2xhc3NlcyBcdD0gY2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuXHRlbG10c1x0XHRcdFx0PSBjYXN0QXNBcnJheShlbG10cyk7XG5cblx0ZWxtdHMubWFwKCBlbCA9PiB7XG5cdFx0bm9ybV9jbGFzc2VzLm1hcCggY2xzID0+IHtcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoIGNscyApO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbiBleHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3NlcyA9ICggZWxtdHM6SFRNTEVsZW1lbnR8SFRNTEVsZW1lbnRbXSwgLi4uY2xhc3NlczpzdHJpbmdbXXxzdHJpbmdbXVtdICkgPT4ge1xuXG4gXHR2YXIgbm9ybV9jbGFzc2VzIFx0PSBjbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG5cdGVsbXRzXHRcdFx0XHQ9IGNhc3RBc0FycmF5KGVsbXRzKTtcblxuXHRlbG10cy5tYXAoIGVsID0+IHtcblx0XHRub3JtX2NsYXNzZXMubWFwKGNscyA9PiB7XG5cdCBcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZSggY2xzICk7XG5cdFx0fSk7XG4gXHR9KTtcbiB9XG5cblxuLyoqXG4gKiBSZXR1cm4gYXJndW1lbnRzXG4gKlxuICovXG5leHBvcnQgY29uc3QgY2xhc3Nlc0FycmF5ID0gKGFyZ3M6c3RyaW5nW118c3RyaW5nW11bXSk6c3RyaW5nW10gPT4ge1xuXHR2YXIgY2xhc3NlczpzdHJpbmdbXSA9IFtdO1xuXHRpdGVyYXRlKCBhcmdzLCAoX2NsYXNzZXMpID0+e1xuXHRcdGlmKCB0eXBlb2YgX2NsYXNzZXMgPT09ICdzdHJpbmcnICl7XG5cdFx0XHRfY2xhc3NlcyA9IF9jbGFzc2VzLnRyaW0oKS5zcGxpdCgvW1xcMTFcXDEyXFwxNFxcMTVcXDQwXS8pO1xuXHRcdH1cblx0XHRpZiggQXJyYXkuaXNBcnJheShfY2xhc3NlcykgKXtcblx0XHRcdGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChfY2xhc3Nlcyk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbik7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgZnJvbSBhcmcgaWYgaXQncyBub3QgYWxyZWFkeSBhbiBhcnJheVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGNhc3RBc0FycmF5ID0gKGFyZzphbnkpOkFycmF5PGFueT4gPT4ge1xuXHRpZiggIUFycmF5LmlzQXJyYXkoYXJnKSApe1xuIFx0XHRhcmcgPSBbYXJnXTtcbiBcdH1cblx0cmV0dXJuIGFyZztcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY2xvc2VzdCBub2RlIHRvIHRoZSBldnQudGFyZ2V0IG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuICogU3RvcHMgYXQgd3JhcHBlclxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcmVudE1hdGNoID0gKCB0YXJnZXQ6bnVsbHxIVE1MRWxlbWVudCwgc2VsZWN0b3I6c3RyaW5nLCB3cmFwcGVyPzpIVE1MRWxlbWVudCApOkhUTUxFbGVtZW50fHZvaWQgPT4ge1xuXG5cdGlmKCB3cmFwcGVyICYmICF3cmFwcGVyLmNvbnRhaW5zKHRhcmdldCkgKXtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR3aGlsZSggdGFyZ2V0ICYmIHRhcmdldC5tYXRjaGVzICl7XG5cblx0XHRpZiggdGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpICl7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50O1xuXHR9XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IG9yIGxhc3QgaXRlbSBmcm9tIGFuIGFycmF5XG4gKlxuICogPiAwIC0gcmlnaHQgKGxhc3QpXG4gKiA8PSAwIC0gbGVmdCAoZmlyc3QpXG4gKlxuICovXG5leHBvcnQgY29uc3QgZ2V0VGFpbCA9ICggbGlzdDpBcnJheTxhbnk+fE5vZGVMaXN0LCBkaXJlY3Rpb246bnVtYmVyPTAgKTphbnkgPT4ge1xuXG5cdGlmKCBkaXJlY3Rpb24gPiAwICl7XG5cdFx0cmV0dXJuIGxpc3RbbGlzdC5sZW5ndGgtMV07XG5cdH1cblxuXHRyZXR1cm4gbGlzdFswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5T2JqZWN0ID0gKG9iajpvYmplY3QpOmJvb2xlYW4gPT4ge1xuXHRyZXR1cm4gKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBhbW9uZ3N0IHNpYmxpbmcgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IG5vZGVJbmRleCA9ICggZWw6bnVsbHxFbGVtZW50LCBhbW9uZ3N0PzpzdHJpbmcgKTpudW1iZXIgPT4ge1xuXHRpZiAoIWVsKSByZXR1cm4gLTE7XG5cblx0YW1vbmdzdCA9IGFtb25nc3QgfHwgZWwubm9kZU5hbWU7XG5cblx0dmFyIGkgPSAwO1xuXHR3aGlsZSggZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICl7XG5cblx0XHRpZiggZWwubWF0Y2hlcyhhbW9uZ3N0KSApe1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaTtcbn1cblxuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdHRyID0gKGVsOkVsZW1lbnQsYXR0cnM6eyBba2V5OiBzdHJpbmddOiBudWxsfHN0cmluZ3xudW1iZXIgfSkgPT4ge1xuXHRpdGVyYXRlKCBhdHRycywodmFsLGF0dHIpID0+IHtcblx0XHRpZiggdmFsID09IG51bGwgKXtcblx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyIGFzIHN0cmluZyk7XG5cdFx0fWVsc2V7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoYXR0ciBhcyBzdHJpbmcsICcnK3ZhbCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG4vKipcbiAqIFJlcGxhY2UgYSBub2RlXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlTm9kZSA9ICggZXhpc3Rpbmc6Tm9kZSwgcmVwbGFjZW1lbnQ6Tm9kZSApID0+IHtcblx0aWYoIGV4aXN0aW5nLnBhcmVudE5vZGUgKSBleGlzdGluZy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudCwgZXhpc3RpbmcpO1xufVxuIiwgIi8qKlxuICogaGlnaGxpZ2h0IHYzIHwgTUlUIGxpY2Vuc2UgfCBKb2hhbm4gQnVya2FyZCA8amJAZWFpby5jb20+XG4gKiBIaWdobGlnaHRzIGFyYml0cmFyeSB0ZXJtcyBpbiBhIG5vZGUuXG4gKlxuICogLSBNb2RpZmllZCBieSBNYXJzaGFsIDxiZWF0Z2F0ZXNAZ21haWwuY29tPiAyMDExLTYtMjQgKGFkZGVkIHJlZ2V4KVxuICogLSBNb2RpZmllZCBieSBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPiAyMDEyLTgtMjcgKGNsZWFudXApXG4gKi9cblxuaW1wb3J0IHtyZXBsYWNlTm9kZX0gZnJvbSAnLi4vdmFuaWxsYSc7XG5cblxuZXhwb3J0IGNvbnN0IGhpZ2hsaWdodCA9IChlbGVtZW50OkhUTUxFbGVtZW50LCByZWdleDpzdHJpbmd8UmVnRXhwKSA9PiB7XG5cblx0aWYoIHJlZ2V4ID09PSBudWxsICkgcmV0dXJuO1xuXG5cdC8vIGNvbnZldCBzdHJpbmcgdG8gcmVnZXhcblx0aWYoIHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycgKXtcblxuXHRcdGlmKCAhcmVnZXgubGVuZ3RoICkgcmV0dXJuO1xuXHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCwgJ2knKTtcblx0fVxuXG5cblx0Ly8gV3JhcCBtYXRjaGluZyBwYXJ0IG9mIHRleHQgbm9kZSB3aXRoIGhpZ2hsaWdodGluZyA8c3Bhbj4sIGUuZy5cblx0Ly8gU29jY2VyICAtPiAgPHNwYW4gY2xhc3M9XCJoaWdobGlnaHRcIj5Tb2M8L3NwYW4+Y2VyICBmb3IgcmVnZXggPSAvc29jL2lcblx0Y29uc3QgaGlnaGxpZ2h0VGV4dCA9ICggbm9kZTpUZXh0ICk6bnVtYmVyID0+IHtcblxuXHRcdHZhciBtYXRjaCA9IG5vZGUuZGF0YS5tYXRjaChyZWdleCk7XG5cdFx0aWYoIG1hdGNoICYmIG5vZGUuZGF0YS5sZW5ndGggPiAwICl7XG5cdFx0XHR2YXIgc3Bhbm5vZGVcdFx0PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0XHRzcGFubm9kZS5jbGFzc05hbWVcdD0gJ2hpZ2hsaWdodCc7XG5cdFx0XHR2YXIgbWlkZGxlYml0XHRcdD0gbm9kZS5zcGxpdFRleHQobWF0Y2guaW5kZXggYXMgbnVtYmVyKTtcblxuXHRcdFx0bWlkZGxlYml0LnNwbGl0VGV4dChtYXRjaFswXSEubGVuZ3RoKTtcblx0XHRcdHZhciBtaWRkbGVjbG9uZVx0XHQ9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG5cblx0XHRcdHNwYW5ub2RlLmFwcGVuZENoaWxkKG1pZGRsZWNsb25lKTtcblx0XHRcdHJlcGxhY2VOb2RlKG1pZGRsZWJpdCwgc3Bhbm5vZGUpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0Ly8gUmVjdXJzZSBlbGVtZW50IG5vZGUsIGxvb2tpbmcgZm9yIGNoaWxkIHRleHQgbm9kZXMgdG8gaGlnaGxpZ2h0LCB1bmxlc3MgZWxlbWVudFxuXHQvLyBpcyBjaGlsZGxlc3MsIDxzY3JpcHQ+LCA8c3R5bGU+LCBvciBhbHJlYWR5IGhpZ2hsaWdodGVkOiA8c3BhbiBjbGFzcz1cImhpZ2h0bGlnaHRcIj5cblx0Y29uc3QgaGlnaGxpZ2h0Q2hpbGRyZW4gPSAoIG5vZGU6RWxlbWVudCApOnZvaWQgPT4ge1xuXHRcdGlmKCBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuY2hpbGROb2RlcyAmJiAhLyhzY3JpcHR8c3R5bGUpL2kudGVzdChub2RlLnRhZ05hbWUpICYmICggbm9kZS5jbGFzc05hbWUgIT09ICdoaWdobGlnaHQnIHx8IG5vZGUudGFnTmFtZSAhPT0gJ1NQQU4nICkgKXtcblx0XHRcdEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRoaWdobGlnaHRSZWN1cnNpdmUoZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblxuXHRjb25zdCBoaWdobGlnaHRSZWN1cnNpdmUgPSAoIG5vZGU6Tm9kZXxFbGVtZW50ICk6bnVtYmVyID0+IHtcblxuXHRcdGlmKCBub2RlLm5vZGVUeXBlID09PSAzICl7XG5cdFx0XHRyZXR1cm4gaGlnaGxpZ2h0VGV4dChub2RlIGFzIFRleHQpO1xuXHRcdH1cblxuXHRcdGhpZ2hsaWdodENoaWxkcmVuKG5vZGUgYXMgRWxlbWVudCk7XG5cblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHRoaWdobGlnaHRSZWN1cnNpdmUoIGVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogcmVtb3ZlSGlnaGxpZ2h0IGZuIGNvcGllZCBmcm9tIGhpZ2hsaWdodCB2NSBhbmRcbiAqIGVkaXRlZCB0byByZW1vdmUgd2l0aCgpLCBwYXNzIGpzIHN0cmljdCBtb2RlLCBhbmQgdXNlIHdpdGhvdXQganF1ZXJ5XG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVIaWdobGlnaHQgPSAoZWw6SFRNTEVsZW1lbnQpID0+IHtcblx0dmFyIGVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChcInNwYW4uaGlnaGxpZ2h0XCIpO1xuXHRBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbihlbDpIVE1MRWxlbWVudCl7XG5cdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGUgYXMgTm9kZTtcblx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKGVsLmZpcnN0Q2hpbGQgYXMgTm9kZSwgZWwpO1xuXHRcdHBhcmVudC5ub3JtYWxpemUoKTtcblx0fSk7XG59O1xuIiwgImV4cG9ydCBjb25zdCBLRVlfQVx0XHRcdFx0PSA2NTtcbmV4cG9ydCBjb25zdCBLRVlfUkVUVVJOXHRcdFx0PSAxMztcbmV4cG9ydCBjb25zdCBLRVlfRVNDXHRcdFx0PSAyNztcbmV4cG9ydCBjb25zdCBLRVlfTEVGVFx0XHRcdD0gMzc7XG5leHBvcnQgY29uc3QgS0VZX1VQXHRcdFx0XHQ9IDM4O1xuZXhwb3J0IGNvbnN0IEtFWV9SSUdIVFx0XHRcdD0gMzk7XG5leHBvcnQgY29uc3QgS0VZX0RPV05cdFx0XHQ9IDQwO1xuZXhwb3J0IGNvbnN0IEtFWV9CQUNLU1BBQ0VcdFx0PSA4O1xuZXhwb3J0IGNvbnN0IEtFWV9ERUxFVEVcdFx0XHQ9IDQ2O1xuZXhwb3J0IGNvbnN0IEtFWV9UQUJcdFx0XHQ9IDk7XG5cbmV4cG9ydCBjb25zdCBJU19NQUMgICAgICBcdFx0PSB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogL01hYy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmV4cG9ydCBjb25zdCBLRVlfU0hPUlRDVVRcdFx0PSBJU19NQUMgPyAnbWV0YUtleScgOiAnY3RybEtleSc7IC8vIGN0cmwga2V5IG9yIGFwcGxlIGtleSBmb3IgbWFcbiIsICJcbmV4cG9ydCBkZWZhdWx0IHtcblx0b3B0aW9uczogW10sXG5cdG9wdGdyb3VwczogW10sXG5cblx0cGx1Z2luczogW10sXG5cdGRlbGltaXRlcjogJywnLFxuXHRzcGxpdE9uOiBudWxsLCAvLyByZWdleHAgb3Igc3RyaW5nIGZvciBzcGxpdHRpbmcgdXAgdmFsdWVzIGZyb20gYSBwYXN0ZSBjb21tYW5kXG5cdHBlcnNpc3Q6IHRydWUsXG5cdGRpYWNyaXRpY3M6IHRydWUsXG5cdGNyZWF0ZTogbnVsbCxcblx0Y3JlYXRlT25CbHVyOiBmYWxzZSxcblx0Y3JlYXRlRmlsdGVyOiBudWxsLFxuXHRoaWdobGlnaHQ6IHRydWUsXG5cdG9wZW5PbkZvY3VzOiB0cnVlLFxuXHRzaG91bGRPcGVuOiBudWxsLFxuXHRtYXhPcHRpb25zOiA1MCxcblx0bWF4SXRlbXM6IG51bGwsXG5cdGhpZGVTZWxlY3RlZDogbnVsbCxcblx0ZHVwbGljYXRlczogZmFsc2UsXG5cdGFkZFByZWNlZGVuY2U6IGZhbHNlLFxuXHRzZWxlY3RPblRhYjogZmFsc2UsXG5cdHByZWxvYWQ6IG51bGwsXG5cdGFsbG93RW1wdHlPcHRpb246IGZhbHNlLFxuXHQvL2Nsb3NlQWZ0ZXJTZWxlY3Q6IGZhbHNlLFxuXHRyZWZyZXNoVGhyb3R0bGU6IDMwMCxcblxuXG5cdGxvYWRUaHJvdHRsZTogMzAwLFxuXHRsb2FkaW5nQ2xhc3M6ICdsb2FkaW5nJyxcblxuXHRkYXRhQXR0cjogbnVsbCwgLy8nZGF0YS1kYXRhJyxcblx0b3B0Z3JvdXBGaWVsZDogJ29wdGdyb3VwJyxcblx0dmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0bGFiZWxGaWVsZDogJ3RleHQnLFxuXHRkaXNhYmxlZEZpZWxkOiAnZGlzYWJsZWQnLFxuXHRvcHRncm91cExhYmVsRmllbGQ6ICdsYWJlbCcsXG5cdG9wdGdyb3VwVmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0bG9ja09wdGdyb3VwT3JkZXI6IGZhbHNlLFxuXG5cdHNvcnRGaWVsZDogJyRvcmRlcicsXG5cdHNlYXJjaEZpZWxkOiBbJ3RleHQnXSxcblx0c2VhcmNoQ29uanVuY3Rpb246ICdhbmQnLFxuXG5cdG1vZGU6IG51bGwsXG5cdHdyYXBwZXJDbGFzczogJ3RzLXdyYXBwZXInLFxuXHRjb250cm9sQ2xhc3M6ICd0cy1jb250cm9sJyxcblx0ZHJvcGRvd25DbGFzczogJ3RzLWRyb3Bkb3duJyxcblx0ZHJvcGRvd25Db250ZW50Q2xhc3M6ICd0cy1kcm9wZG93bi1jb250ZW50Jyxcblx0aXRlbUNsYXNzOiAnaXRlbScsXG5cdG9wdGlvbkNsYXNzOiAnb3B0aW9uJyxcblxuXHRkcm9wZG93blBhcmVudDogbnVsbCxcblx0Y29udHJvbElucHV0OiAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgc2l6ZT1cIjFcIiAvPicsXG5cblx0Y29weUNsYXNzZXNUb0Ryb3Bkb3duOiBmYWxzZSxcblxuXHRwbGFjZWhvbGRlcjogbnVsbCxcblx0aGlkZVBsYWNlaG9sZGVyOiBudWxsLFxuXG5cdHNob3VsZExvYWQ6IGZ1bmN0aW9uKHF1ZXJ5OnN0cmluZyk6Ym9vbGVhbntcblx0XHRyZXR1cm4gcXVlcnkubGVuZ3RoID4gMDtcblx0fSxcblxuXHQvKlxuXHRsb2FkICAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykgeyAuLi4gfVxuXHRzY29yZSAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHNlYXJjaCkgeyAuLi4gfVxuXHRvbkluaXRpYWxpemUgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRvbkNoYW5nZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG5cdG9uSXRlbUFkZCAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUsICRpdGVtKSB7IC4uLiB9XG5cdG9uSXRlbVJlbW92ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0b25DbGVhciAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cblx0b25PcHRpb25BZGQgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSwgZGF0YSkgeyAuLi4gfVxuXHRvbk9wdGlvblJlbW92ZSAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG5cdG9uT3B0aW9uQ2xlYXIgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdG9uT3B0aW9uR3JvdXBBZGQgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oaWQsIGRhdGEpIHsgLi4uIH1cblx0b25PcHRpb25Hcm91cFJlbW92ZSAgOiBudWxsLCAvLyBmdW5jdGlvbihpZCkgeyAuLi4gfVxuXHRvbk9wdGlvbkdyb3VwQ2xlYXIgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRvbkRyb3Bkb3duT3BlbiAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKGRyb3Bkb3duKSB7IC4uLiB9XG5cdG9uRHJvcGRvd25DbG9zZSAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oZHJvcGRvd24pIHsgLi4uIH1cblx0b25UeXBlICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzdHIpIHsgLi4uIH1cblx0b25EZWxldGUgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZXMpIHsgLi4uIH1cblx0Ki9cblxuXHRyZW5kZXI6IHtcblx0XHQvKlxuXHRcdGl0ZW06IG51bGwsXG5cdFx0b3B0Z3JvdXA6IG51bGwsXG5cdFx0b3B0Z3JvdXBfaGVhZGVyOiBudWxsLFxuXHRcdG9wdGlvbjogbnVsbCxcblx0XHRvcHRpb25fY3JlYXRlOiBudWxsXG5cdFx0Ki9cblx0fVxufTtcbiIsICJcbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi90b20tc2VsZWN0JztcbmltcG9ydCB7IFRvbUxvYWRDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMvaW5kZXgnO1xuXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5leHBvcnQgY29uc3QgaGFzaF9rZXkgPSAodmFsdWU6dW5kZWZpbmVkfG51bGx8Ym9vbGVhbnxzdHJpbmd8bnVtYmVyKTpzdHJpbmd8bnVsbCA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIGdldF9oYXNoKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRfaGFzaCA9ICh2YWx1ZTpib29sZWFufHN0cmluZ3xudW1iZXIpOnN0cmluZyA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlID8gJzEnIDogJzAnO1xuXHRyZXR1cm4gdmFsdWUgKyAnJztcbn07XG5cbi8qKlxuICogRXNjYXBlcyBhIHN0cmluZyBmb3IgdXNlIHdpdGhpbiBIVE1MLlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZV9odG1sID0gKHN0cjpzdHJpbmcpOnN0cmluZyA9PiB7XG5cdHJldHVybiAoc3RyICsgJycpXG5cdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xuXG5cbi8qKlxuICogdXNlIHNldFRpbWVvdXQgaWYgdGltZW91dCA+IDAgXG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gKGZuOigpPT52b2lkLHRpbWVvdXQ6bnVtYmVyKSA9PiB7XG5cdGlmKCB0aW1lb3V0ID4gMCApe1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KGZuLHRpbWVvdXQpO1xuXHR9XG5cblx0Zm4uY2FsbChudWxsKTtcblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVib3VuY2UgdGhlIHVzZXIgcHJvdmlkZWQgbG9hZCBmdW5jdGlvblxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWREZWJvdW5jZSA9IChmbjoodmFsdWU6c3RyaW5nLGNhbGxiYWNrOlRvbUxvYWRDYWxsYmFjaykgPT4gdm9pZCxkZWxheTpudW1iZXIpID0+IHtcblx0dmFyIHRpbWVvdXQ6IG51bGx8UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cdHJldHVybiBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdmFsdWU6c3RyaW5nLGNhbGxiYWNrOlRvbUxvYWRDYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCB0aW1lb3V0ICl7XG5cdFx0XHRzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR9XG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdHNlbGYubG9hZGVkU2VhcmNoZXNbdmFsdWVdID0gdHJ1ZTtcblx0XHRcdGZuLmNhbGwoc2VsZiwgdmFsdWUsIGNhbGxiYWNrKTtcblxuXHRcdH0sIGRlbGF5KTtcblx0fTtcbn07XG5cblxuLyoqXG4gKiBEZWJvdW5jZSBhbGwgZmlyZWQgZXZlbnRzIHR5cGVzIGxpc3RlZCBpbiBgdHlwZXNgXG4gKiB3aGlsZSBleGVjdXRpbmcgdGhlIHByb3ZpZGVkIGBmbmAuXG4gKlxuICovXG5leHBvcnQgY29uc3QgZGVib3VuY2VfZXZlbnRzID0gKCBzZWxmOlRvbVNlbGVjdCwgdHlwZXM6c3RyaW5nW10sIGZuOigpID0+IHZvaWQgKSA9PiB7XG5cdHZhciB0eXBlOnN0cmluZztcblx0dmFyIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXI7XG5cdHZhciBldmVudF9hcmdzOnsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuXHQvLyBvdmVycmlkZSB0cmlnZ2VyIG1ldGhvZFxuXHRzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbigpe1xuXHRcdHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuXHRcdGlmICh0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuXHRcdFx0ZXZlbnRfYXJnc1t0eXBlXSA9IGFyZ3VtZW50cztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRyaWdnZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gaW52b2tlIHByb3ZpZGVkIGZ1bmN0aW9uXG5cdGZuLmFwcGx5KHNlbGYsIFtdKTtcblx0c2VsZi50cmlnZ2VyID0gdHJpZ2dlcjtcblxuXHQvLyB0cmlnZ2VyIHF1ZXVlZCBldmVudHNcblx0Zm9yKCB0eXBlIG9mIHR5cGVzICl7XG5cdFx0aWYoIHR5cGUgaW4gZXZlbnRfYXJncyApe1xuXHRcdFx0dHJpZ2dlci5hcHBseShzZWxmLCBldmVudF9hcmdzW3R5cGVdKTtcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoaW4gYSB0ZXh0IGlucHV0IGNvbnRyb2wuXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHN0YXJ0XG4gKiAgIC0gbGVuZ3RoXG4gKlxuICogTm90ZTogXCJzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kIC4uLiBhcHBseSBvbmx5IHRvIGlucHV0cyBvZiB0eXBlcyB0ZXh0LCBzZWFyY2gsIFVSTCwgdGVsIGFuZCBwYXNzd29yZFwiXG4gKiBcdC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbnB1dEVsZW1lbnQvc2V0U2VsZWN0aW9uUmFuZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNlbGVjdGlvbiA9IChpbnB1dDpIVE1MSW5wdXRFbGVtZW50KTp7IHN0YXJ0OiBudW1iZXI7IGxlbmd0aDogbnVtYmVyIH0gPT4ge1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0XHQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDAsXG5cdFx0bGVuZ3RoXHQ6IChpbnB1dC5zZWxlY3Rpb25FbmR8fDApIC0gKGlucHV0LnNlbGVjdGlvblN0YXJ0fHwwKSxcblx0fTtcbn07XG5cblxuLyoqXG4gKiBQcmV2ZW50IGRlZmF1bHRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQ/OkV2ZW50LCBzdG9wOmJvb2xlYW49ZmFsc2UpOnZvaWQgPT4ge1xuXHRpZiggZXZ0ICl7XG5cdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0aWYoIHN0b3AgKXtcblx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEFkZCBldmVudCBoZWxwZXJcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRFdmVudCA9ICh0YXJnZXQ6RXZlbnRUYXJnZXQsIHR5cGU6c3RyaW5nLCBjYWxsYmFjazpFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0LCBvcHRpb25zPzpvYmplY3QpOnZvaWQgPT4ge1xuXHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLGNhbGxiYWNrLG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSByZXF1ZXN0ZWQga2V5IGlzIGRvd25cbiAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIG1vcmUgdGhhbiBvbmUgY29udHJvbCBjaGFyYWN0ZXIgaXMgcHJlc3NlZCAoIHdoZW4gW2N0cmwrc2hpZnQrYV0gIT0gW2N0cmwrYV0gKVxuICogVGhlIGN1cnJlbnQgZXZ0IG1heSBub3QgYWx3YXlzIHNldCAoIGVnIGNhbGxpbmcgYWR2YW5jZVNlbGVjdGlvbigpIClcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0tleURvd24gPSAoIGtleV9uYW1lOmtleW9mIChLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnQpLCBldnQ/OktleWJvYXJkRXZlbnR8TW91c2VFdmVudCApID0+IHtcblxuXHRpZiggIWV2dCApe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmKCAhZXZ0W2tleV9uYW1lXSApe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjb3VudCA9IChldnQuYWx0S2V5PzE6MCkgKyAoZXZ0LmN0cmxLZXk/MTowKSArIChldnQuc2hpZnRLZXk/MTowKSArIChldnQubWV0YUtleT8xOjApO1xuXG5cdGlmKCBjb3VudCA9PT0gMSApe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgaWQgb2YgYW4gZWxlbWVudFxuICogSWYgdGhlIGlkIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBpZFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldElkID0gKGVsOkVsZW1lbnQsaWQ6c3RyaW5nKSA9PiB7XG5cdGNvbnN0IGV4aXN0aW5nX2lkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRpZiggZXhpc3RpbmdfaWQgKXtcblx0XHRyZXR1cm4gZXhpc3RpbmdfaWQ7XG5cdH1cblxuXHRlbC5zZXRBdHRyaWJ1dGUoJ2lkJyxpZCk7XG5cdHJldHVybiBpZDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYmFja3NsYXNoZXMgYWRkZWQgYmVmb3JlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRTbGFzaGVzID0gKHN0cjpzdHJpbmcpOnN0cmluZyA9PiB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxcIiddL2csICdcXFxcJCYnKTtcbn07XG5cbi8qKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZCA9ICggcGFyZW50OkVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudCwgbm9kZTogc3RyaW5nfE5vZGV8bnVsbHx1bmRlZmluZWQgKTp2b2lkID0+e1xuXHRpZiggbm9kZSApIHBhcmVudC5hcHBlbmQobm9kZSk7XG59O1xuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzJztcbmltcG9ydCB7IGhhc2hfa2V5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBUb21PcHRpb24sIFRvbVNldHRpbmdzLCBSZWN1cnNpdmVQYXJ0aWFsIH0gZnJvbSAnLi90eXBlcy9pbmRleCc7XG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnQG9yY2hpZGpzL3NpZnRlci9saWIvdXRpbHMnO1xuaW1wb3J0IHsgVG9tSW5wdXQgfSBmcm9tICcuL3R5cGVzL2luZGV4JztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTZXR0aW5ncyggaW5wdXQ6VG9tSW5wdXQsIHNldHRpbmdzX3VzZXI6UmVjdXJzaXZlUGFydGlhbDxUb21TZXR0aW5ncz4pOlRvbVNldHRpbmdze1xuXHR2YXIgc2V0dGluZ3M6VG9tU2V0dGluZ3NcdD0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHNldHRpbmdzX3VzZXIpO1xuXG5cdHZhciBhdHRyX2RhdGFcdFx0XHRcdD0gc2V0dGluZ3MuZGF0YUF0dHI7XG5cdHZhciBmaWVsZF9sYWJlbFx0XHRcdFx0PSBzZXR0aW5ncy5sYWJlbEZpZWxkO1xuXHR2YXIgZmllbGRfdmFsdWVcdFx0XHRcdD0gc2V0dGluZ3MudmFsdWVGaWVsZDtcblx0dmFyIGZpZWxkX2Rpc2FibGVkXHRcdFx0PSBzZXR0aW5ncy5kaXNhYmxlZEZpZWxkO1xuXHR2YXIgZmllbGRfb3B0Z3JvdXBcdFx0XHQ9IHNldHRpbmdzLm9wdGdyb3VwRmllbGQ7XG5cdHZhciBmaWVsZF9vcHRncm91cF9sYWJlbFx0PSBzZXR0aW5ncy5vcHRncm91cExhYmVsRmllbGQ7XG5cdHZhciBmaWVsZF9vcHRncm91cF92YWx1ZVx0PSBzZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGQ7XG5cblx0dmFyIHRhZ19uYW1lXHRcdFx0XHQ9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0dmFyIHBsYWNlaG9sZGVyXHRcdFx0XHQ9IGlucHV0LmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInKTtcblxuXHRpZiAoIXBsYWNlaG9sZGVyICYmICFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uKSB7XG5cdFx0bGV0IG9wdGlvblx0XHQ9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvblt2YWx1ZT1cIlwiXScpO1xuXHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdHBsYWNlaG9sZGVyID0gb3B0aW9uLnRleHRDb250ZW50O1xuXHRcdH1cblxuXHR9XG5cblx0dmFyIHNldHRpbmdzX2VsZW1lbnQ6e1xuXHRcdHBsYWNlaG9sZGVyXHQ6IG51bGx8c3RyaW5nLFxuXHRcdG9wdGlvbnNcdFx0OiBUb21PcHRpb25bXSxcblx0XHRvcHRncm91cHNcdDogVG9tT3B0aW9uW10sXG5cdFx0aXRlbXNcdFx0OiBzdHJpbmdbXSxcblx0XHRtYXhJdGVtc1x0OiBudWxsfG51bWJlcixcblx0fSA9IHtcblx0XHRwbGFjZWhvbGRlclx0OiBwbGFjZWhvbGRlcixcblx0XHRvcHRpb25zXHRcdDogW10sXG5cdFx0b3B0Z3JvdXBzXHQ6IFtdLFxuXHRcdGl0ZW1zXHRcdDogW10sXG5cdFx0bWF4SXRlbXNcdDogbnVsbCxcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGZyb20gYSA8c2VsZWN0PiBlbGVtZW50LlxuXHQgKlxuXHQgKi9cblx0dmFyIGluaXRfc2VsZWN0ID0gKCkgPT4ge1xuXHRcdHZhciB0YWdOYW1lO1xuXHRcdHZhciBvcHRpb25zID0gc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zO1xuXHRcdHZhciBvcHRpb25zTWFwOntba2V5OnN0cmluZ106YW55fSA9IHt9O1xuXHRcdHZhciBncm91cF9jb3VudCA9IDE7XG5cdFx0bGV0ICRvcmRlciA9IDA7XG5cblx0XHR2YXIgcmVhZERhdGEgPSAoZWw6SFRNTEVsZW1lbnQpOlRvbU9wdGlvbiA9PiB7XG5cblx0XHRcdHZhciBkYXRhXHQ9IE9iamVjdC5hc3NpZ24oe30sZWwuZGF0YXNldCk7IC8vIGdldCBwbGFpbiBvYmplY3QgZnJvbSBET01TdHJpbmdNYXBcblx0XHRcdHZhciBqc29uXHQ9IGF0dHJfZGF0YSAmJiBkYXRhW2F0dHJfZGF0YV07XG5cblx0XHRcdGlmKCB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgJiYganNvbi5sZW5ndGggKXtcblx0XHRcdFx0ZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSxKU09OLnBhcnNlKGpzb24pKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblxuXHRcdHZhciBhZGRPcHRpb24gPSAob3B0aW9uOkhUTUxPcHRpb25FbGVtZW50LCBncm91cD86c3RyaW5nKSA9PiB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IGhhc2hfa2V5KG9wdGlvbi52YWx1ZSk7XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgKSByZXR1cm47XG5cdFx0XHRpZiAoICF2YWx1ZSAmJiAhc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbikgcmV0dXJuO1xuXG5cdFx0XHQvLyBpZiB0aGUgb3B0aW9uIGFscmVhZHkgZXhpc3RzLCBpdCdzIHByb2JhYmx5IGJlZW5cblx0XHRcdC8vIGR1cGxpY2F0ZWQgaW4gYW5vdGhlciBvcHRncm91cC4gaW4gdGhpcyBjYXNlLCBwdXNoXG5cdFx0XHQvLyB0aGUgY3VycmVudCBncm91cCB0byB0aGUgXCJvcHRncm91cFwiIHByb3BlcnR5IG9uIHRoZVxuXHRcdFx0Ly8gZXhpc3Rpbmcgb3B0aW9uIHNvIHRoYXQgaXQncyByZW5kZXJlZCBpbiBib3RoIHBsYWNlcy5cblx0XHRcdGlmIChvcHRpb25zTWFwLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHR2YXIgYXJyID0gb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdO1xuXHRcdFx0XHRcdGlmICghYXJyKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zTWFwW3ZhbHVlXVtmaWVsZF9vcHRncm91cF0gPSBncm91cDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXSA9IFthcnIsIGdyb3VwXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXJyLnB1c2goZ3JvdXApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9ZWxzZXtcblxuXHRcdFx0XHR2YXIgb3B0aW9uX2RhdGEgICAgICAgICAgICAgPSByZWFkRGF0YShvcHRpb24pO1xuXHRcdFx0XHRvcHRpb25fZGF0YVtmaWVsZF9sYWJlbF0gICAgPSBvcHRpb25fZGF0YVtmaWVsZF9sYWJlbF0gfHwgb3B0aW9uLnRleHRDb250ZW50O1xuXHRcdFx0XHRvcHRpb25fZGF0YVtmaWVsZF92YWx1ZV0gICAgPSBvcHRpb25fZGF0YVtmaWVsZF92YWx1ZV0gfHwgdmFsdWU7XG5cdFx0XHRcdG9wdGlvbl9kYXRhW2ZpZWxkX2Rpc2FibGVkXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX2Rpc2FibGVkXSB8fCBvcHRpb24uZGlzYWJsZWQ7XG5cdFx0XHRcdG9wdGlvbl9kYXRhW2ZpZWxkX29wdGdyb3VwXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX29wdGdyb3VwXSB8fCBncm91cDtcblx0XHRcdFx0b3B0aW9uX2RhdGEuJG9wdGlvblx0XHRcdD0gb3B0aW9uO1xuXHRcdFx0XHRvcHRpb25fZGF0YS4kb3JkZXJcdFx0XHQ9IG9wdGlvbl9kYXRhLiRvcmRlciB8fCArKyRvcmRlcjtcblxuXHRcdFx0XHRvcHRpb25zTWFwW3ZhbHVlXSA9IG9wdGlvbl9kYXRhO1xuXHRcdFx0XHRvcHRpb25zLnB1c2gob3B0aW9uX2RhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggb3B0aW9uLnNlbGVjdGVkICl7XG5cdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBhZGRHcm91cCA9ICggb3B0Z3JvdXA6SFRNTE9wdEdyb3VwRWxlbWVudCApID0+IHtcblx0XHRcdHZhciBpZDpzdHJpbmcsIG9wdGdyb3VwX2RhdGFcblxuXHRcdFx0b3B0Z3JvdXBfZGF0YVx0XHRcdFx0XHRcdFx0PSByZWFkRGF0YShvcHRncm91cCk7XG5cdFx0XHRvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX2xhYmVsXVx0XHQ9IG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfbGFiZWxdIHx8IG9wdGdyb3VwLmdldEF0dHJpYnV0ZSgnbGFiZWwnKSB8fCAnJztcblx0XHRcdG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfdmFsdWVdXHRcdD0gb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV0gfHwgZ3JvdXBfY291bnQrKztcblx0XHRcdG9wdGdyb3VwX2RhdGFbZmllbGRfZGlzYWJsZWRdXHRcdFx0PSBvcHRncm91cF9kYXRhW2ZpZWxkX2Rpc2FibGVkXSB8fCBvcHRncm91cC5kaXNhYmxlZDtcblx0XHRcdG9wdGdyb3VwX2RhdGEuJG9yZGVyXHRcdFx0XHRcdD0gb3B0Z3JvdXBfZGF0YS4kb3JkZXIgfHwgKyskb3JkZXI7XG5cblx0XHRcdHNldHRpbmdzX2VsZW1lbnQub3B0Z3JvdXBzLnB1c2gob3B0Z3JvdXBfZGF0YSk7XG5cblx0XHRcdGlkID0gb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV07XG5cblx0XHRcdGl0ZXJhdGUob3B0Z3JvdXAuY2hpbGRyZW4sIChvcHRpb24pPT57XG5cdFx0XHRcdGFkZE9wdGlvbihvcHRpb24gYXMgSFRNTE9wdGlvbkVsZW1lbnQsIGlkKTtcblx0XHRcdH0pO1xuXG5cdFx0fTtcblxuXHRcdHNldHRpbmdzX2VsZW1lbnQubWF4SXRlbXMgPSBpbnB1dC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykgPyBudWxsIDogMTtcblxuXHRcdGl0ZXJhdGUoaW5wdXQuY2hpbGRyZW4sKGNoaWxkKT0+e1xuXHRcdFx0dGFnTmFtZSA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICh0YWdOYW1lID09PSAnb3B0Z3JvdXAnKSB7XG5cdFx0XHRcdGFkZEdyb3VwKGNoaWxkIGFzIEhUTUxPcHRHcm91cEVsZW1lbnQpO1xuXHRcdFx0fSBlbHNlIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuXHRcdFx0XHRhZGRPcHRpb24oY2hpbGQgYXMgSFRNTE9wdGlvbkVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH07XG5cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBmcm9tIGEgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGVsZW1lbnQuXG5cdCAqXG5cdCAqL1xuXHR2YXIgaW5pdF90ZXh0Ym94ID0gKCkgPT4ge1xuXHRcdGNvbnN0IGRhdGFfcmF3ID0gaW5wdXQuZ2V0QXR0cmlidXRlKGF0dHJfZGF0YSk7XG5cblx0XHRpZiAoIWRhdGFfcmF3KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZS50cmltKCkgfHwgJyc7XG5cdFx0XHRpZiAoIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24gJiYgIXZhbHVlLmxlbmd0aCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVsaW1pdGVyKTtcblxuXHRcdFx0aXRlcmF0ZSggdmFsdWVzLCAodmFsdWUpID0+IHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9uOlRvbU9wdGlvbiA9IHt9O1xuXHRcdFx0XHRvcHRpb25bZmllbGRfbGFiZWxdID0gdmFsdWU7XG5cdFx0XHRcdG9wdGlvbltmaWVsZF92YWx1ZV0gPSB2YWx1ZTtcblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRpb25zLnB1c2gob3B0aW9uKTtcblx0XHRcdH0pO1xuXHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcyA9IHZhbHVlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRpb25zID0gSlNPTi5wYXJzZShkYXRhX3Jhdyk7XG5cdFx0XHRpdGVyYXRlKCBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMsIChvcHQpID0+IHtcblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKG9wdFtmaWVsZF92YWx1ZV0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cblx0aWYgKHRhZ19uYW1lID09PSAnc2VsZWN0Jykge1xuXHRcdGluaXRfc2VsZWN0KCk7XG5cdH0gZWxzZSB7XG5cdFx0aW5pdF90ZXh0Ym94KCk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRzLCBzZXR0aW5nc19lbGVtZW50LCBzZXR0aW5nc191c2VyKSBhcyBUb21TZXR0aW5ncztcbn07XG4iLCAiXG5pbXBvcnQgTWljcm9FdmVudCBmcm9tICcuL2NvbnRyaWIvbWljcm9ldmVudCc7XG5pbXBvcnQgTWljcm9QbHVnaW4gZnJvbSAnLi9jb250cmliL21pY3JvcGx1Z2luJztcbmltcG9ydCB7IFNpZnRlciwgaXRlcmF0ZSB9IGZyb20gJ0BvcmNoaWRqcy9zaWZ0ZXInO1xuaW1wb3J0IHsgZXNjYXBlX3JlZ2V4IH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuaW1wb3J0IHsgVG9tSW5wdXQsIFRvbUFyZ09iamVjdCwgVG9tT3B0aW9uLCBUb21PcHRpb25zLCBUb21DcmVhdGVGaWx0ZXIsIFRvbUNyZWF0ZUNhbGxiYWNrLCBUb21JdGVtLCBUb21TZXR0aW5ncywgVG9tVGVtcGxhdGVOYW1lcywgVG9tQ2xlYXJGaWx0ZXIsIFJlY3Vyc2l2ZVBhcnRpYWwgfSBmcm9tICcuL3R5cGVzL2luZGV4JztcbmltcG9ydCB7aGlnaGxpZ2h0LCByZW1vdmVIaWdobGlnaHR9IGZyb20gJy4vY29udHJpYi9oaWdobGlnaHQnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBnZXRTZXR0aW5ncyBmcm9tICcuL2dldFNldHRpbmdzJztcbmltcG9ydCB7XG5cdGhhc2hfa2V5LFxuXHRnZXRfaGFzaCxcblx0ZXNjYXBlX2h0bWwsXG5cdGRlYm91bmNlX2V2ZW50cyxcblx0Z2V0U2VsZWN0aW9uLFxuXHRwcmV2ZW50RGVmYXVsdCxcblx0YWRkRXZlbnQsXG5cdGxvYWREZWJvdW5jZSxcblx0dGltZW91dCxcblx0aXNLZXlEb3duLFxuXHRnZXRJZCxcblx0YWRkU2xhc2hlcyxcblx0YXBwZW5kXG59IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQge1xuXHRnZXREb20sXG5cdGlzSHRtbFN0cmluZyxcblx0ZXNjYXBlUXVlcnksXG5cdHRyaWdnZXJFdmVudCxcblx0YXBwbHlDU1MsXG5cdGFkZENsYXNzZXMsXG5cdHJlbW92ZUNsYXNzZXMsXG5cdHBhcmVudE1hdGNoLFxuXHRnZXRUYWlsLFxuXHRpc0VtcHR5T2JqZWN0LFxuXHRub2RlSW5kZXgsXG5cdHNldEF0dHIsXG5cdHJlcGxhY2VOb2RlXG59IGZyb20gJy4vdmFuaWxsYSc7XG5cbnZhciBpbnN0YW5jZV9pID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9tU2VsZWN0IGV4dGVuZHMgTWljcm9QbHVnaW4oTWljcm9FdmVudCl7XG5cblx0cHVibGljIGNvbnRyb2xfaW5wdXRcdFx0XHQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cdHB1YmxpYyB3cmFwcGVyXHRcdFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBkcm9wZG93blx0XHRcdFx0XHQ6IEhUTUxFbGVtZW50O1xuXHRwdWJsaWMgY29udHJvbFx0XHRcdFx0XHQ6IEhUTUxFbGVtZW50O1xuXHRwdWJsaWMgZHJvcGRvd25fY29udGVudFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBmb2N1c19ub2RlXHRcdFx0XHQ6IEhUTUxFbGVtZW50O1xuXG5cdHB1YmxpYyBvcmRlclx0XHRcdFx0XHQ6IG51bWJlciA9IDA7XG5cdHB1YmxpYyBzZXR0aW5nc1x0XHRcdFx0XHQ6IFRvbVNldHRpbmdzO1xuXHRwdWJsaWMgaW5wdXRcdFx0XHRcdFx0OiBUb21JbnB1dDtcblx0cHVibGljIHRhYkluZGV4XHRcdFx0XHRcdDogbnVtYmVyO1xuXHRwdWJsaWMgaXNfc2VsZWN0X3RhZ1x0XHRcdDogYm9vbGVhbjtcblx0cHVibGljIHJ0bFx0XHRcdFx0XHRcdDogYm9vbGVhbjtcblx0cHJpdmF0ZSBpbnB1dElkXHRcdFx0XHRcdDogc3RyaW5nO1xuXG5cdHByaXZhdGUgX2Rlc3Ryb3lcdFx0XHRcdCE6ICgpID0+IHZvaWQ7XG5cdHB1YmxpYyBzaWZ0ZXJcdFx0XHRcdFx0OiBTaWZ0ZXI7XG5cblxuXHRwdWJsaWMgaXNPcGVuXHRcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNEaXNhYmxlZFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc1JlYWRPbmx5XHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlzUmVxdWlyZWRcdFx0XHRcdDogYm9vbGVhbjtcblx0cHVibGljIGlzSW52YWxpZFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7IC8vIEBkZXByZWNhdGVkIDEuOFxuXHRwdWJsaWMgaXNWYWxpZFx0XHRcdFx0XHQ6IGJvb2xlYW4gPSB0cnVlO1xuXHRwdWJsaWMgaXNMb2NrZWRcdFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc0ZvY3VzZWRcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNJbnB1dEhpZGRlblx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNTZXR1cFx0XHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlnbm9yZUZvY3VzXHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlnbm9yZUhvdmVyXHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGhhc09wdGlvbnNcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgY3VycmVudFJlc3VsdHNcdFx0XHQ/OiBSZXR1cm5UeXBlPFNpZnRlclsnc2VhcmNoJ10+O1xuXHRwdWJsaWMgbGFzdFZhbHVlXHRcdFx0XHQ6IHN0cmluZyA9ICcnO1xuXHRwdWJsaWMgY2FyZXRQb3NcdFx0XHRcdFx0OiBudW1iZXIgPSAwO1xuXHRwdWJsaWMgbG9hZGluZ1x0XHRcdFx0XHQ6IG51bWJlciA9IDA7XG5cdHB1YmxpYyBsb2FkZWRTZWFyY2hlc1x0XHRcdDogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuXHRwdWJsaWMgYWN0aXZlT3B0aW9uXHRcdFx0XHQ6IG51bGx8SFRNTEVsZW1lbnQgPSBudWxsO1xuXHRwdWJsaWMgYWN0aXZlSXRlbXNcdFx0XHRcdDogVG9tSXRlbVtdID0gW107XG5cblx0cHVibGljIG9wdGdyb3Vwc1x0XHRcdFx0OiBUb21PcHRpb25zID0ge307XG5cdHB1YmxpYyBvcHRpb25zXHRcdFx0XHRcdDogVG9tT3B0aW9ucyA9IHt9O1xuXHRwdWJsaWMgdXNlck9wdGlvbnNcdFx0XHRcdDoge1trZXk6c3RyaW5nXTpib29sZWFufSA9IHt9O1xuXHRwdWJsaWMgaXRlbXNcdFx0XHRcdFx0OiBzdHJpbmdbXSA9IFtdO1xuXG5cdHByaXZhdGUgcmVmcmVzaFRpbWVvdXRcdFx0XHQ6IG51bGx8UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gPSBudWxsO1xuXG5cblx0Y29uc3RydWN0b3IoIGlucHV0X2FyZzogc3RyaW5nfFRvbUlucHV0LCB1c2VyX3NldHRpbmdzOlJlY3Vyc2l2ZVBhcnRpYWw8VG9tU2V0dGluZ3M+ICl7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGluc3RhbmNlX2krKztcblxuXHRcdHZhciBkaXI7XG5cdFx0dmFyIGlucHV0XHRcdFx0XHQ9IGdldERvbSggaW5wdXRfYXJnICkgYXMgVG9tSW5wdXQ7XG5cblx0XHRpZiggaW5wdXQudG9tc2VsZWN0ICl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RvbSBTZWxlY3QgYWxyZWFkeSBpbml0aWFsaXplZCBvbiB0aGlzIGVsZW1lbnQnKTtcblx0XHR9XG5cblxuXHRcdGlucHV0LnRvbXNlbGVjdFx0XHRcdD0gdGhpcztcblxuXG5cdFx0Ly8gZGV0ZWN0IHJ0bCBlbnZpcm9ubWVudFxuXHRcdHZhciBjb21wdXRlZFN0eWxlXHRcdD0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXQsIG51bGwpO1xuXHRcdGRpclx0XHRcdFx0XHRcdD0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKTtcblxuXHRcdC8vIHNldHVwIGRlZmF1bHQgc3RhdGVcblx0XHRjb25zdCBzZXR0aW5nc1x0XHRcdD0gZ2V0U2V0dGluZ3MoIGlucHV0LCB1c2VyX3NldHRpbmdzICk7XG5cdFx0dGhpcy5zZXR0aW5nc1x0XHRcdD0gc2V0dGluZ3M7XG5cdFx0dGhpcy5pbnB1dFx0XHRcdFx0PSBpbnB1dDtcblx0XHR0aGlzLnRhYkluZGV4XHRcdFx0PSBpbnB1dC50YWJJbmRleCB8fCAwO1xuXHRcdHRoaXMuaXNfc2VsZWN0X3RhZ1x0XHQ9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCc7XG5cdFx0dGhpcy5ydGxcdFx0XHRcdD0gL3J0bC9pLnRlc3QoZGlyKTtcblx0XHR0aGlzLmlucHV0SWRcdFx0XHQ9IGdldElkKGlucHV0LCAndG9tc2VsZWN0LScraW5zdGFuY2VfaSk7XG5cdFx0dGhpcy5pc1JlcXVpcmVkXHRcdFx0PSBpbnB1dC5yZXF1aXJlZDtcblxuXG5cdFx0Ly8gc2VhcmNoIHN5c3RlbVxuXHRcdHRoaXMuc2lmdGVyID0gbmV3IFNpZnRlcih0aGlzLm9wdGlvbnMsIHtkaWFjcml0aWNzOiBzZXR0aW5ncy5kaWFjcml0aWNzfSk7XG5cblx0XHQvLyBvcHRpb24tZGVwZW5kZW50IGRlZmF1bHRzXG5cdFx0c2V0dGluZ3MubW9kZSA9IHNldHRpbmdzLm1vZGUgfHwgKHNldHRpbmdzLm1heEl0ZW1zID09PSAxID8gJ3NpbmdsZScgOiAnbXVsdGknKTtcblx0XHRpZiAodHlwZW9mIHNldHRpbmdzLmhpZGVTZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRzZXR0aW5ncy5oaWRlU2VsZWN0ZWQgPSBzZXR0aW5ncy5tb2RlID09PSAnbXVsdGknO1xuXHRcdH1cblxuXHRcdGlmKCB0eXBlb2Ygc2V0dGluZ3MuaGlkZVBsYWNlaG9sZGVyICE9PSAnYm9vbGVhbicgKXtcblx0XHRcdHNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciA9IHNldHRpbmdzLm1vZGUgIT09ICdtdWx0aSc7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHVwIGNyZWF0ZUZpbHRlciBjYWxsYmFja1xuXHRcdHZhciBmaWx0ZXIgPSBzZXR0aW5ncy5jcmVhdGVGaWx0ZXI7XG5cdFx0aWYoIHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicgKXtcblxuXHRcdFx0aWYoIHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnICl7XG5cdFx0XHRcdGZpbHRlciA9IG5ldyBSZWdFeHAoZmlsdGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCApe1xuXHRcdFx0XHRzZXR0aW5ncy5jcmVhdGVGaWx0ZXIgPSAoaW5wdXQpID0+IChmaWx0ZXIgYXMgUmVnRXhwKS50ZXN0KGlucHV0KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRzZXR0aW5ncy5jcmVhdGVGaWx0ZXIgPSAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncy5kdXBsaWNhdGVzIHx8ICF0aGlzLm9wdGlvbnNbdmFsdWVdO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0dGhpcy5pbml0aWFsaXplUGx1Z2lucyhzZXR0aW5ncy5wbHVnaW5zKTtcblx0XHR0aGlzLnNldHVwQ2FsbGJhY2tzKCk7XG5cdFx0dGhpcy5zZXR1cFRlbXBsYXRlcygpO1xuXG5cblx0XHQvLyBDcmVhdGUgYWxsIGVsZW1lbnRzXG5cdFx0Y29uc3Qgd3JhcHBlclx0XHRcdD0gZ2V0RG9tKCc8ZGl2PicpO1xuXHRcdGNvbnN0IGNvbnRyb2xcdFx0XHQ9IGdldERvbSgnPGRpdj4nKTtcblx0XHRjb25zdCBkcm9wZG93blx0XHRcdD0gdGhpcy5fcmVuZGVyKCdkcm9wZG93bicpO1xuXHRcdGNvbnN0IGRyb3Bkb3duX2NvbnRlbnRcdD0gZ2V0RG9tKGA8ZGl2IHJvbGU9XCJsaXN0Ym94XCIgdGFiaW5kZXg9XCItMVwiPmApO1xuXG5cdFx0Y29uc3QgY2xhc3Nlc1x0XHRcdD0gdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG5cdFx0Y29uc3QgaW5wdXRNb2RlXHRcdFx0PSBzZXR0aW5ncy5tb2RlO1xuXG5cdFx0dmFyIGNvbnRyb2xfaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblxuXHRcdGFkZENsYXNzZXMoIHdyYXBwZXIsIHNldHRpbmdzLndyYXBwZXJDbGFzcywgY2xhc3NlcywgaW5wdXRNb2RlKTtcblxuXG5cdFx0YWRkQ2xhc3Nlcyhjb250cm9sLHNldHRpbmdzLmNvbnRyb2xDbGFzcyk7XG5cdFx0YXBwZW5kKCB3cmFwcGVyLCBjb250cm9sICk7XG5cblxuXHRcdGFkZENsYXNzZXMoZHJvcGRvd24sIHNldHRpbmdzLmRyb3Bkb3duQ2xhc3MsIGlucHV0TW9kZSk7XG5cdFx0aWYoIHNldHRpbmdzLmNvcHlDbGFzc2VzVG9Ecm9wZG93biApe1xuXHRcdFx0YWRkQ2xhc3NlcyggZHJvcGRvd24sIGNsYXNzZXMpO1xuXHRcdH1cblxuXG5cdFx0YWRkQ2xhc3Nlcyhkcm9wZG93bl9jb250ZW50LCBzZXR0aW5ncy5kcm9wZG93bkNvbnRlbnRDbGFzcyk7XG5cdFx0YXBwZW5kKCBkcm9wZG93biwgZHJvcGRvd25fY29udGVudCApO1xuXG5cdFx0Z2V0RG9tKCBzZXR0aW5ncy5kcm9wZG93blBhcmVudCB8fCB3cmFwcGVyICkuYXBwZW5kQ2hpbGQoIGRyb3Bkb3duICk7XG5cblxuXHRcdC8vIGRlZmF1bHQgY29udHJvbElucHV0XG5cdFx0aWYoIGlzSHRtbFN0cmluZyhzZXR0aW5ncy5jb250cm9sSW5wdXQpICl7XG5cdFx0XHRjb250cm9sX2lucHV0XHRcdD0gZ2V0RG9tKHNldHRpbmdzLmNvbnRyb2xJbnB1dCApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0XHRcdC8vIHNldCBhdHRyaWJ1dGVzXG5cdFx0XHR2YXIgYXR0cnMgPSBbJ2F1dG9jb3JyZWN0JywnYXV0b2NhcGl0YWxpemUnLCdhdXRvY29tcGxldGUnLCdzcGVsbGNoZWNrJ107XG5cdFx0XHRpdGVyYXRlKGF0dHJzLChhdHRyOnN0cmluZykgPT4ge1xuXHRcdFx0XHRpZiggaW5wdXQuZ2V0QXR0cmlidXRlKGF0dHIpICl7XG5cdFx0XHRcdFx0c2V0QXR0cihjb250cm9sX2lucHV0LHtbYXR0cl06aW5wdXQuZ2V0QXR0cmlidXRlKGF0dHIpfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRjb250cm9sX2lucHV0LnRhYkluZGV4ID0gLTE7XG5cdFx0XHRjb250cm9sLmFwcGVuZENoaWxkKCBjb250cm9sX2lucHV0ICk7XG5cdFx0XHR0aGlzLmZvY3VzX25vZGVcdFx0PSBjb250cm9sX2lucHV0O1xuXG5cdFx0Ly8gZG9tIGVsZW1lbnRcblx0XHR9ZWxzZSBpZiggc2V0dGluZ3MuY29udHJvbElucHV0ICl7XG5cdFx0XHRjb250cm9sX2lucHV0XHRcdD0gZ2V0RG9tKCBzZXR0aW5ncy5jb250cm9sSW5wdXQgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXHRcdFx0dGhpcy5mb2N1c19ub2RlXHRcdD0gY29udHJvbF9pbnB1dDtcblxuXHRcdH1lbHNle1xuXHRcdFx0Y29udHJvbF9pbnB1dFx0XHQ9IGdldERvbSgnPGlucHV0Lz4nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXHRcdFx0dGhpcy5mb2N1c19ub2RlXHRcdD0gY29udHJvbDtcblx0XHR9XG5cblx0XHR0aGlzLndyYXBwZXJcdFx0XHQ9IHdyYXBwZXI7XG5cdFx0dGhpcy5kcm9wZG93blx0XHRcdD0gZHJvcGRvd247XG5cdFx0dGhpcy5kcm9wZG93bl9jb250ZW50XHQ9IGRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0dGhpcy5jb250cm9sIFx0XHRcdD0gY29udHJvbDtcblx0XHR0aGlzLmNvbnRyb2xfaW5wdXRcdFx0PSBjb250cm9sX2lucHV0O1xuXG5cdFx0dGhpcy5zZXR1cCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIHNldCB1cCBldmVudCBiaW5kaW5ncy5cblx0ICpcblx0ICovXG5cdHNldHVwKCl7XG5cblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCBzZXR0aW5nc1x0XHRcdFx0PSBzZWxmLnNldHRpbmdzO1xuXHRcdGNvbnN0IGNvbnRyb2xfaW5wdXRcdFx0XHQ9IHNlbGYuY29udHJvbF9pbnB1dDtcblx0XHRjb25zdCBkcm9wZG93blx0XHRcdFx0PSBzZWxmLmRyb3Bkb3duO1xuXHRcdGNvbnN0IGRyb3Bkb3duX2NvbnRlbnRcdFx0PSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0Y29uc3Qgd3JhcHBlclx0XHRcdFx0PSBzZWxmLndyYXBwZXI7XG5cdFx0Y29uc3QgY29udHJvbFx0XHRcdFx0PSBzZWxmLmNvbnRyb2w7XG5cdFx0Y29uc3QgaW5wdXRcdFx0XHRcdFx0PSBzZWxmLmlucHV0O1xuXHRcdGNvbnN0IGZvY3VzX25vZGVcdFx0XHQ9IHNlbGYuZm9jdXNfbm9kZTtcblx0XHRjb25zdCBwYXNzaXZlX2V2ZW50XHRcdFx0PSB7IHBhc3NpdmU6IHRydWUgfTtcblx0XHRjb25zdCBsaXN0Ym94SWRcdFx0XHRcdD0gc2VsZi5pbnB1dElkICsnLXRzLWRyb3Bkb3duJztcblxuXG5cdFx0c2V0QXR0cihkcm9wZG93bl9jb250ZW50LHtcblx0XHRcdGlkOiBsaXN0Ym94SWRcblx0XHR9KTtcblxuXHRcdHNldEF0dHIoZm9jdXNfbm9kZSx7XG5cdFx0XHRyb2xlOidjb21ib2JveCcsXG5cdFx0XHQnYXJpYS1oYXNwb3B1cCc6J2xpc3Rib3gnLFxuXHRcdFx0J2FyaWEtZXhwYW5kZWQnOidmYWxzZScsXG5cdFx0XHQnYXJpYS1jb250cm9scyc6bGlzdGJveElkXG5cdFx0fSk7XG5cblx0XHRjb25zdCBjb250cm9sX2lkXHQ9IGdldElkKGZvY3VzX25vZGUsc2VsZi5pbnB1dElkICsgJy10cy1jb250cm9sJyk7XG5cdFx0Y29uc3QgcXVlcnlcdFx0XHQ9IFwibGFiZWxbZm9yPSdcIitlc2NhcGVRdWVyeShzZWxmLmlucHV0SWQpK1wiJ11cIjtcblx0XHRjb25zdCBsYWJlbFx0XHRcdD0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG5cdFx0Y29uc3QgbGFiZWxfY2xpY2tcdD0gc2VsZi5mb2N1cy5iaW5kKHNlbGYpO1xuXHRcdGlmKCBsYWJlbCApe1xuXHRcdFx0YWRkRXZlbnQobGFiZWwsJ2NsaWNrJywgbGFiZWxfY2xpY2sgKTtcblx0XHRcdHNldEF0dHIobGFiZWwse2Zvcjpjb250cm9sX2lkfSk7XG5cdFx0XHRjb25zdCBsYWJlbF9pZCA9IGdldElkKGxhYmVsLHNlbGYuaW5wdXRJZCsnLXRzLWxhYmVsJyk7XG5cdFx0XHRzZXRBdHRyKGZvY3VzX25vZGUseydhcmlhLWxhYmVsbGVkYnknOmxhYmVsX2lkfSk7XG5cdFx0XHRzZXRBdHRyKGRyb3Bkb3duX2NvbnRlbnQseydhcmlhLWxhYmVsbGVkYnknOmxhYmVsX2lkfSk7XG5cdFx0fVxuXG5cdFx0d3JhcHBlci5zdHlsZS53aWR0aCA9IGlucHV0LnN0eWxlLndpZHRoO1xuXG5cdFx0aWYgKHNlbGYucGx1Z2lucy5uYW1lcy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IGNsYXNzZXNfcGx1Z2lucyA9ICdwbHVnaW4tJyArIHNlbGYucGx1Z2lucy5uYW1lcy5qb2luKCcgcGx1Z2luLScpO1xuXHRcdFx0YWRkQ2xhc3NlcyggW3dyYXBwZXIsZHJvcGRvd25dLCBjbGFzc2VzX3BsdWdpbnMpO1xuXHRcdH1cblxuXHRcdGlmICgoc2V0dGluZ3MubWF4SXRlbXMgPT09IG51bGwgfHwgc2V0dGluZ3MubWF4SXRlbXMgPiAxKSAmJiBzZWxmLmlzX3NlbGVjdF90YWcgKXtcblx0XHRcdHNldEF0dHIoaW5wdXQse211bHRpcGxlOidtdWx0aXBsZSd9KTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MucGxhY2Vob2xkZXIpIHtcblx0XHRcdHNldEF0dHIoY29udHJvbF9pbnB1dCx7cGxhY2Vob2xkZXI6c2V0dGluZ3MucGxhY2Vob2xkZXJ9KTtcblx0XHR9XG5cblx0XHQvLyBpZiBzcGxpdE9uIHdhcyBub3QgcGFzc2VkIGluLCBjb25zdHJ1Y3QgaXQgZnJvbSB0aGUgZGVsaW1pdGVyIHRvIGFsbG93IHBhc3RpbmcgdW5pdmVyc2FsbHlcblx0XHRpZiAoIXNldHRpbmdzLnNwbGl0T24gJiYgc2V0dGluZ3MuZGVsaW1pdGVyKSB7XG5cdFx0XHRzZXR0aW5ncy5zcGxpdE9uID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZV9yZWdleChzZXR0aW5ncy5kZWxpbWl0ZXIpICsgJytcXFxccyonKTtcblx0XHR9XG5cblx0XHQvLyBkZWJvdW5jZSB1c2VyIGRlZmluZWQgbG9hZCgpIGlmIGxvYWRUaHJvdHRsZSA+IDBcblx0XHQvLyBhZnRlciBpbml0aWFsaXplUGx1Z2lucygpIHNvIHBsdWdpbnMgY2FuIGNyZWF0ZS9tb2RpZnkgdXNlciBkZWZpbmVkIGxvYWRlcnNcblx0XHRpZiggc2V0dGluZ3MubG9hZCAmJiBzZXR0aW5ncy5sb2FkVGhyb3R0bGUgKXtcblx0XHRcdHNldHRpbmdzLmxvYWQgPSBsb2FkRGVib3VuY2Uoc2V0dGluZ3MubG9hZCxzZXR0aW5ncy5sb2FkVGhyb3R0bGUpXG5cdFx0fVxuXG5cdFx0YWRkRXZlbnQoZHJvcGRvd24sJ21vdXNlbW92ZScsICgpID0+IHtcblx0XHRcdHNlbGYuaWdub3JlSG92ZXIgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRcdGFkZEV2ZW50KGRyb3Bkb3duLCdtb3VzZWVudGVyJywgKGUpID0+IHtcblxuXHRcdFx0dmFyIHRhcmdldF9tYXRjaCA9IHBhcmVudE1hdGNoKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCAnW2RhdGEtc2VsZWN0YWJsZV0nLCBkcm9wZG93bik7XG5cdFx0XHRpZiggdGFyZ2V0X21hdGNoICkgc2VsZi5vbk9wdGlvbkhvdmVyKCBlIGFzIE1vdXNlRXZlbnQsIHRhcmdldF9tYXRjaCApO1xuXG5cdFx0fSwge2NhcHR1cmU6dHJ1ZX0pO1xuXG5cdFx0Ly8gY2xpY2tpbmcgb24gYW4gb3B0aW9uIHNob3VsZCBzZWxlY3QgaXRcblx0XHRhZGRFdmVudChkcm9wZG93biwnY2xpY2snLChldnQpID0+IHtcblx0XHRcdGNvbnN0IG9wdGlvbiA9IHBhcmVudE1hdGNoKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsICdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHRcdFx0aWYoIG9wdGlvbiApe1xuXHRcdFx0XHRzZWxmLm9uT3B0aW9uU2VsZWN0KCBldnQgYXMgTW91c2VFdmVudCwgb3B0aW9uICk7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFkZEV2ZW50KGNvbnRyb2wsJ2NsaWNrJywgKGV2dCkgPT4ge1xuXG5cdFx0XHR2YXIgdGFyZ2V0X21hdGNoID0gcGFyZW50TWF0Y2goIGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsICdbZGF0YS10cy1pdGVtXScsIGNvbnRyb2wpO1xuXHRcdFx0aWYoIHRhcmdldF9tYXRjaCAmJiBzZWxmLm9uSXRlbVNlbGVjdChldnQgYXMgTW91c2VFdmVudCwgdGFyZ2V0X21hdGNoIGFzIFRvbUl0ZW0pICl7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXRhaW4gZm9jdXMgKHNlZSBjb250cm9sX2lucHV0IG1vdXNlZG93bilcblx0XHRcdGlmKCBjb250cm9sX2lucHV0LnZhbHVlICE9ICcnICl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5vbkNsaWNrKCk7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0fSk7XG5cblxuXHRcdC8vIGtleWRvd24gb24gZm9jdXNfbm9kZSBmb3IgYXJyb3dfZG93bi9hcnJvd191cFxuXHRcdGFkZEV2ZW50KGZvY3VzX25vZGUsJ2tleWRvd24nLFx0XHQoZSkgPT4gc2VsZi5vbktleURvd24oZSBhcyBLZXlib2FyZEV2ZW50KSApO1xuXG5cdFx0Ly8ga2V5cHJlc3MgYW5kIGlucHV0L2tleXVwXG5cdFx0YWRkRXZlbnQoY29udHJvbF9pbnB1dCwna2V5cHJlc3MnLFx0KGUpID0+IHNlbGYub25LZXlQcmVzcyhlIGFzIEtleWJvYXJkRXZlbnQpICk7XG5cdFx0YWRkRXZlbnQoY29udHJvbF9pbnB1dCwnaW5wdXQnLFx0XHQoZSkgPT4gc2VsZi5vbklucHV0KGUgYXMgS2V5Ym9hcmRFdmVudCkgKTtcblx0XHRhZGRFdmVudChmb2N1c19ub2RlLCdibHVyJywgXHRcdChlKSA9PiBzZWxmLm9uQmx1cihlIGFzIEZvY3VzRXZlbnQpICk7XG5cdFx0YWRkRXZlbnQoZm9jdXNfbm9kZSwnZm9jdXMnLFx0XHQoZSkgPT4gc2VsZi5vbkZvY3VzKGUgYXMgTW91c2VFdmVudCkgKTtcblx0XHRhZGRFdmVudChjb250cm9sX2lucHV0LCdwYXN0ZScsXHRcdChlKSA9PiBzZWxmLm9uUGFzdGUoZSBhcyBNb3VzZUV2ZW50KSApO1xuXG5cblx0XHRjb25zdCBkb2NfbW91c2Vkb3duID0gKGV2dDpFdmVudCkgPT4ge1xuXG5cdFx0XHQvLyBibHVyIGlmIHRhcmdldCBpcyBvdXRzaWRlIG9mIHRoaXMgaW5zdGFuY2Vcblx0XHRcdC8vIGRyb3Bkb3duIGlzIG5vdCBhbHdheXMgaW5zaWRlIHdyYXBwZXJcblx0XHRcdGNvbnN0IHRhcmdldCA9IGV2dC5jb21wb3NlZFBhdGgoKVswXTtcblx0XHRcdGlmKCAhd3JhcHBlci5jb250YWlucyh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpICYmICFkcm9wZG93bi5jb250YWlucyh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpICl7XG5cdFx0XHRcdGlmIChzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gcmV0YWluIGZvY3VzIGJ5IHByZXZlbnRpbmcgbmF0aXZlIGhhbmRsaW5nLiBpZiB0aGVcblx0XHRcdC8vIGV2ZW50IHRhcmdldCBpcyB0aGUgaW5wdXQgaXQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cblx0XHRcdC8vIG90aGVyd2lzZSwgdGV4dCBzZWxlY3Rpb24gd2l0aGluIHRoZSBpbnB1dCB3b24ndCB3b3JrLlxuXHRcdFx0Ly8gRml4ZXMgYnVnICMyMTIgd2hpY2ggaXMgbm8gY292ZXJlZCBieSB0ZXN0c1xuXHRcdFx0aWYoIHRhcmdldCA9PSBjb250cm9sX2lucHV0ICYmIHNlbGYuaXNPcGVuICl7XG5cdFx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0Ly8gY2xpY2tpbmcgYW55d2hlcmUgaW4gdGhlIGNvbnRyb2wgc2hvdWxkIG5vdCBibHVyIHRoZSBjb250cm9sX2lucHV0ICh3aGljaCB3b3VsZCBjbG9zZSB0aGUgZHJvcGRvd24pXG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGNvbnN0IHdpbl9zY3JvbGwgPSAoKSA9PiB7XG5cdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cdFx0YWRkRXZlbnQoZG9jdW1lbnQsJ21vdXNlZG93bicsIGRvY19tb3VzZWRvd24pO1xuXHRcdGFkZEV2ZW50KHdpbmRvdywnc2Nyb2xsJywgd2luX3Njcm9sbCwgcGFzc2l2ZV9ldmVudCk7XG5cdFx0YWRkRXZlbnQod2luZG93LCdyZXNpemUnLCB3aW5fc2Nyb2xsLCBwYXNzaXZlX2V2ZW50KTtcblxuXHRcdHRoaXMuX2Rlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLGRvY19tb3VzZWRvd24pO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsd2luX3Njcm9sbCk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJyx3aW5fc2Nyb2xsKTtcblx0XHRcdGlmKCBsYWJlbCApIGxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxsYWJlbF9jbGljayk7XG5cdFx0fTtcblxuXHRcdC8vIHN0b3JlIG9yaWdpbmFsIGh0bWwgYW5kIHRhYiBpbmRleCBzbyB0aGF0IHRoZXkgY2FuIGJlXG5cdFx0Ly8gcmVzdG9yZWQgd2hlbiB0aGUgZGVzdHJveSgpIG1ldGhvZCBpcyBjYWxsZWQuXG5cdFx0dGhpcy5yZXZlcnRTZXR0aW5ncyA9IHtcblx0XHRcdGlubmVySFRNTCA6IGlucHV0LmlubmVySFRNTCxcblx0XHRcdHRhYkluZGV4IDogaW5wdXQudGFiSW5kZXhcblx0XHR9O1xuXG5cblx0XHRpbnB1dC50YWJJbmRleCA9IC0xO1xuXHRcdGlucHV0Lmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBzZWxmLndyYXBwZXIpO1xuXG5cdFx0c2VsZi5zeW5jKGZhbHNlKTtcblx0XHRzZXR0aW5ncy5pdGVtcyA9IFtdO1xuXHRcdGRlbGV0ZSBzZXR0aW5ncy5vcHRncm91cHM7XG5cdFx0ZGVsZXRlIHNldHRpbmdzLm9wdGlvbnM7XG5cblx0XHRhZGRFdmVudChpbnB1dCwnaW52YWxpZCcsICgpID0+IHtcblx0XHRcdGlmKCBzZWxmLmlzVmFsaWQgKXtcblx0XHRcdFx0c2VsZi5pc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYuaXNJbnZhbGlkID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCgpO1xuXHRcdHNlbGYucmVmcmVzaEl0ZW1zKCk7XG5cdFx0c2VsZi5jbG9zZShmYWxzZSk7XG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0c2VsZi5pc1NldHVwID0gdHJ1ZTtcblxuXHRcdGlmKCBpbnB1dC5kaXNhYmxlZCApe1xuXHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0fWVsc2UgaWYoIGlucHV0LnJlYWRPbmx5ICl7XG5cdFx0XHRzZWxmLnNldFJlYWRPbmx5KHRydWUpO1xuXHRcdH1lbHNle1xuXHRcdFx0c2VsZi5lbmFibGUoKTsgLy9zZXRzIHRhYkluZGV4XG5cdFx0fVxuXG5cdFx0c2VsZi5vbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG5cblx0XHRhZGRDbGFzc2VzKGlucHV0LCd0b21zZWxlY3RlZCcsJ3RzLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG5cdFx0c2VsZi50cmlnZ2VyKCdpbml0aWFsaXplJyk7XG5cblx0XHQvLyBwcmVsb2FkIG9wdGlvbnNcblx0XHRpZiAoc2V0dGluZ3MucHJlbG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0c2VsZi5wcmVsb2FkKCk7XG5cdFx0fVxuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBvcHRpb25zIGFuZCBvcHRncm91cHNcblx0ICpcblx0ICovXG5cdHNldHVwT3B0aW9ucyhvcHRpb25zOlRvbU9wdGlvbltdID0gW10sIG9wdGdyb3VwczpUb21PcHRpb25bXSA9IFtdKXtcblxuXHRcdC8vIGJ1aWxkIG9wdGlvbnMgdGFibGVcblx0XHR0aGlzLmFkZE9wdGlvbnMob3B0aW9ucyk7XG5cblxuXHRcdC8vIGJ1aWxkIG9wdGdyb3VwIHRhYmxlXG5cdFx0aXRlcmF0ZSggb3B0Z3JvdXBzLCAob3B0Z3JvdXA6VG9tT3B0aW9uKSA9PiB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAob3B0Z3JvdXApO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdXAgZGVmYXVsdCByZW5kZXJpbmcgZnVuY3Rpb25zLlxuXHQgKi9cblx0c2V0dXBUZW1wbGF0ZXMoKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBmaWVsZF9sYWJlbCA9IHNlbGYuc2V0dGluZ3MubGFiZWxGaWVsZDtcblx0XHR2YXIgZmllbGRfb3B0Z3JvdXAgPSBzZWxmLnNldHRpbmdzLm9wdGdyb3VwTGFiZWxGaWVsZDtcblxuXHRcdHZhciB0ZW1wbGF0ZXMgPSB7XG5cdFx0XHQnb3B0Z3JvdXAnOiAoZGF0YTpUb21PcHRpb24pID0+IHtcblx0XHRcdFx0bGV0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdG9wdGdyb3VwLmNsYXNzTmFtZSA9ICdvcHRncm91cCc7XG5cdFx0XHRcdG9wdGdyb3VwLmFwcGVuZENoaWxkKGRhdGEub3B0aW9ucyk7XG5cdFx0XHRcdHJldHVybiBvcHRncm91cDtcblxuXHRcdFx0fSxcblx0XHRcdCdvcHRncm91cF9oZWFkZXInOiAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwib3B0Z3JvdXAtaGVhZGVyXCI+JyArIGVzY2FwZShkYXRhW2ZpZWxkX29wdGdyb3VwXSkgKyAnPC9kaXY+Jztcblx0XHRcdH0sXG5cdFx0XHQnb3B0aW9uJzogKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdpdGVtJzogKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdvcHRpb25fY3JlYXRlJzogKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cImNyZWF0ZVwiPkFkZCA8c3Ryb25nPicgKyBlc2NhcGUoZGF0YS5pbnB1dCkgKyAnPC9zdHJvbmc+JmhlbGxpcDs8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdub19yZXN1bHRzJzooKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cIm5vLXJlc3VsdHNcIj5ObyByZXN1bHRzIGZvdW5kPC9kaXY+Jztcblx0XHRcdH0sXG5cdFx0XHQnbG9hZGluZyc6KCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJzcGlubmVyXCI+PC9kaXY+Jztcblx0XHRcdH0sXG5cdFx0XHQnbm90X2xvYWRpbmcnOigpID0+IHt9LFxuXHRcdFx0J2Ryb3Bkb3duJzooKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdj48L2Rpdj4nO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVzLCBzZWxmLnNldHRpbmdzLnJlbmRlcik7XG5cdH1cblxuXHQvKipcblx0ICogTWFwcyBmaXJlZCBldmVudHMgdG8gY2FsbGJhY2tzIHByb3ZpZGVkXG5cdCAqIGluIHRoZSBzZXR0aW5ncyB1c2VkIHdoZW4gY3JlYXRpbmcgdGhlIGNvbnRyb2wuXG5cdCAqL1xuXHRzZXR1cENhbGxiYWNrcygpIHtcblx0XHR2YXIga2V5LCBmbjtcblx0XHR2YXIgY2FsbGJhY2tzOntba2V5OnN0cmluZ106c3RyaW5nfSA9IHtcblx0XHRcdCdpbml0aWFsaXplJyAgICAgIDogJ29uSW5pdGlhbGl6ZScsXG5cdFx0XHQnY2hhbmdlJyAgICAgICAgICA6ICdvbkNoYW5nZScsXG5cdFx0XHQnaXRlbV9hZGQnICAgICAgICA6ICdvbkl0ZW1BZGQnLFxuXHRcdFx0J2l0ZW1fcmVtb3ZlJyAgICAgOiAnb25JdGVtUmVtb3ZlJyxcblx0XHRcdCdpdGVtX3NlbGVjdCcgICAgIDogJ29uSXRlbVNlbGVjdCcsXG5cdFx0XHQnY2xlYXInICAgICAgICAgICA6ICdvbkNsZWFyJyxcblx0XHRcdCdvcHRpb25fYWRkJyAgICAgIDogJ29uT3B0aW9uQWRkJyxcblx0XHRcdCdvcHRpb25fcmVtb3ZlJyAgIDogJ29uT3B0aW9uUmVtb3ZlJyxcblx0XHRcdCdvcHRpb25fY2xlYXInICAgIDogJ29uT3B0aW9uQ2xlYXInLFxuXHRcdFx0J29wdGdyb3VwX2FkZCcgICAgOiAnb25PcHRpb25Hcm91cEFkZCcsXG5cdFx0XHQnb3B0Z3JvdXBfcmVtb3ZlJyA6ICdvbk9wdGlvbkdyb3VwUmVtb3ZlJyxcblx0XHRcdCdvcHRncm91cF9jbGVhcicgIDogJ29uT3B0aW9uR3JvdXBDbGVhcicsXG5cdFx0XHQnZHJvcGRvd25fb3BlbicgICA6ICdvbkRyb3Bkb3duT3BlbicsXG5cdFx0XHQnZHJvcGRvd25fY2xvc2UnICA6ICdvbkRyb3Bkb3duQ2xvc2UnLFxuXHRcdFx0J3R5cGUnICAgICAgICAgICAgOiAnb25UeXBlJyxcblx0XHRcdCdsb2FkJyAgICAgICAgICAgIDogJ29uTG9hZCcsXG5cdFx0XHQnZm9jdXMnICAgICAgICAgICA6ICdvbkZvY3VzJyxcblx0XHRcdCdibHVyJyAgICAgICAgICAgIDogJ29uQmx1cidcblx0XHR9O1xuXG5cdFx0Zm9yIChrZXkgaW4gY2FsbGJhY2tzKSB7XG5cblx0XHRcdGZuID0gdGhpcy5zZXR0aW5nc1tjYWxsYmFja3Nba2V5XSBhcyAoa2V5b2YgVG9tU2V0dGluZ3MpXTtcblx0XHRcdGlmIChmbikgdGhpcy5vbihrZXksIGZuKTtcblxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTeW5jIHRoZSBUb20gU2VsZWN0IGluc3RhbmNlIHdpdGggdGhlIG9yaWdpbmFsIGlucHV0IG9yIHNlbGVjdFxuXHQgKlxuXHQgKi9cblx0c3luYyhnZXRfc2V0dGluZ3M6Ym9vbGVhbj10cnVlKTp2b2lke1xuXHRcdGNvbnN0IHNlbGZcdFx0PSB0aGlzO1xuXHRcdGNvbnN0IHNldHRpbmdzXHQ9IGdldF9zZXR0aW5ncyA/IGdldFNldHRpbmdzKCBzZWxmLmlucHV0LCB7ZGVsaW1pdGVyOnNlbGYuc2V0dGluZ3MuZGVsaW1pdGVyfSBhcyBSZWN1cnNpdmVQYXJ0aWFsPFRvbVNldHRpbmdzPiApIDogc2VsZi5zZXR0aW5ncztcblxuXHRcdHNlbGYuc2V0dXBPcHRpb25zKHNldHRpbmdzLm9wdGlvbnMsc2V0dGluZ3Mub3B0Z3JvdXBzKTtcblxuXHRcdHNlbGYuc2V0VmFsdWUoc2V0dGluZ3MuaXRlbXN8fFtdLHRydWUpOyAvLyBzaWxlbnQgcHJldmVudHMgcmVjdXJzaW9uXG5cblx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7IC8vIHNvIHVwZGF0ZWQgb3B0aW9ucyB3aWxsIGJlIGRpc3BsYXllZCBpbiBkcm9wZG93blxuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSBtYWluIGNvbnRyb2wgZWxlbWVudFxuXHQgKiBoYXMgYSBjbGljayBldmVudC5cblx0ICpcblx0ICovXG5cdG9uQ2xpY2soKTp2b2lkIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGggPiAwICl7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiggc2VsZi5pc0ZvY3VzZWQgJiYgc2VsZi5pc09wZW4gKXtcblx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXByZWNhdGVkIHYxLjdcblx0ICpcblx0ICovXG5cdG9uTW91c2VEb3duKCk6dm9pZCB7fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICogVGhpcyBzaG91bGQgcHJvcGFnYXRlIHRoZSBldmVudCB0byB0aGUgb3JpZ2luYWwgRE9NXG5cdCAqIGlucHV0IC8gc2VsZWN0IGVsZW1lbnQuXG5cdCAqL1xuXHRvbkNoYW5nZSgpIHtcblx0XHR0cmlnZ2VyRXZlbnQodGhpcy5pbnB1dCwgJ2lucHV0Jyk7XG5cdFx0dHJpZ2dlckV2ZW50KHRoaXMuaW5wdXQsICdjaGFuZ2UnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBwYXN0ZS5cblx0ICpcblx0ICovXG5cdG9uUGFzdGUoZTpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpOnZvaWQge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCBzZWxmLmlzSW5wdXRIaWRkZW4gfHwgc2VsZi5pc0xvY2tlZCApe1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYSByZWdleCBvciBzdHJpbmcgaXMgaW5jbHVkZWQsIHRoaXMgd2lsbCBzcGxpdCB0aGUgcGFzdGVkXG5cdFx0Ly8gaW5wdXQgYW5kIGNyZWF0ZSBJdGVtcyBmb3IgZWFjaCBzZXBhcmF0ZSB2YWx1ZVxuXHRcdGlmKCAhc2VsZi5zZXR0aW5ncy5zcGxpdE9uICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV2FpdCBmb3IgcGFzdGVkIHRleHQgdG8gYmUgcmVjb2duaXplZCBpbiB2YWx1ZVxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dmFyIHBhc3RlZFRleHQgPSBzZWxmLmlucHV0VmFsdWUoKTtcblx0XHRcdGlmKCAhcGFzdGVkVGV4dC5tYXRjaChzZWxmLnNldHRpbmdzLnNwbGl0T24pKXtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzcGxpdElucHV0ID0gcGFzdGVkVGV4dC50cmltKCkuc3BsaXQoc2VsZi5zZXR0aW5ncy5zcGxpdE9uKTtcblx0XHRcdGl0ZXJhdGUoIHNwbGl0SW5wdXQsIChwaWVjZTpzdHJpbmcpID0+IHtcblxuXHRcdFx0XHRjb25zdCBoYXNoID0gaGFzaF9rZXkocGllY2UpO1xuXHRcdFx0XHRpZiggaGFzaCApe1xuXHRcdFx0XHRcdGlmKCB0aGlzLm9wdGlvbnNbcGllY2VdICl7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZEl0ZW0ocGllY2UpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0c2VsZi5jcmVhdGVJdGVtKHBpZWNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sIDApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5cHJlc3MuXG5cdCAqXG5cdCAqL1xuXHRvbktleVByZXNzKGU6S2V5Ym9hcmRFdmVudCk6dm9pZCB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHNlbGYuaXNMb2NrZWQpe1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSB8fCBlLndoaWNoKTtcblx0XHRpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknICYmIGNoYXJhY3RlciA9PT0gc2VsZi5zZXR0aW5ncy5kZWxpbWl0ZXIpIHtcblx0XHRcdHNlbGYuY3JlYXRlSXRlbSgpO1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGtleWRvd24uXG5cdCAqXG5cdCAqL1xuXHRvbktleURvd24oZTpLZXlib2FyZEV2ZW50KTp2b2lkIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRzZWxmLmlnbm9yZUhvdmVyID0gdHJ1ZTtcblxuXHRcdGlmIChzZWxmLmlzTG9ja2VkKSB7XG5cdFx0XHRpZiAoZS5rZXlDb2RlICE9PSBjb25zdGFudHMuS0VZX1RBQikge1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGUua2V5Q29kZSkge1xuXG5cdFx0XHQvLyBjdHJsK0E6IHNlbGVjdCBhbGxcblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9BOlxuXHRcdFx0XHRpZiggaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgKXtcblx0XHRcdFx0XHRpZiggc2VsZi5jb250cm9sX2lucHV0LnZhbHVlID09ICcnICl7XG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0XHRcdHNlbGYuc2VsZWN0QWxsKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBlc2M6IGNsb3NlIGRyb3Bkb3duXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfRVNDOlxuXHRcdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlLHRydWUpO1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBkb3duOiBvcGVuIGRyb3Bkb3duIG9yIG1vdmUgc2VsZWN0aW9uIGRvd25cblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9ET1dOOlxuXHRcdFx0XHRpZiAoIXNlbGYuaXNPcGVuICYmIHNlbGYuaGFzT3B0aW9ucykge1xuXHRcdFx0XHRcdHNlbGYub3BlbigpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuYWN0aXZlT3B0aW9uKSB7XG5cdFx0XHRcdFx0bGV0IG5leHQgPSBzZWxmLmdldEFkamFjZW50KHNlbGYuYWN0aXZlT3B0aW9uLCAxKTtcblx0XHRcdFx0XHRpZiAobmV4dCkgc2VsZi5zZXRBY3RpdmVPcHRpb24obmV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gdXA6IG1vdmUgc2VsZWN0aW9uIHVwXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfVVA6XG5cdFx0XHRcdGlmIChzZWxmLmFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdGxldCBwcmV2ID0gc2VsZi5nZXRBZGphY2VudChzZWxmLmFjdGl2ZU9wdGlvbiwgLTEpO1xuXHRcdFx0XHRcdGlmIChwcmV2KSBzZWxmLnNldEFjdGl2ZU9wdGlvbihwcmV2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyByZXR1cm46IHNlbGVjdCBhY3RpdmUgb3B0aW9uXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfUkVUVVJOOlxuXHRcdFx0XHRpZiggc2VsZi5jYW5TZWxlY3Qoc2VsZi5hY3RpdmVPcHRpb24pICl7XG5cdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdChlLHNlbGYuYWN0aXZlT3B0aW9uISk7XG5cdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cblx0XHRcdFx0Ly8gaWYgdGhlIG9wdGlvbl9jcmVhdGU9bnVsbCwgdGhlIGRyb3Bkb3duIG1pZ2h0IGJlIGNsb3NlZFxuXHRcdFx0XHR9ZWxzZSBpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5jcmVhdGVJdGVtKCkpIHtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdFx0XHQvLyBkb24ndCBzdWJtaXQgZm9ybSB3aGVuIHNlYXJjaGluZyBmb3IgYSB2YWx1ZVxuXHRcdFx0XHR9ZWxzZSBpZiggZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBzZWxmLmNvbnRyb2xfaW5wdXQgJiYgc2VsZi5pc09wZW4gKXtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gbGVmdDogbW9kaWZpeSBpdGVtIHNlbGVjdGlvbiB0byB0aGUgbGVmdFxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0xFRlQ6XG5cdFx0XHRcdHNlbGYuYWR2YW5jZVNlbGVjdGlvbigtMSwgZSk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gcmlnaHQ6IG1vZGlmaXkgaXRlbSBzZWxlY3Rpb24gdG8gdGhlIHJpZ2h0XG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfUklHSFQ6XG5cdFx0XHRcdHNlbGYuYWR2YW5jZVNlbGVjdGlvbigxLCBlKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyB0YWI6IHNlbGVjdCBhY3RpdmUgb3B0aW9uIGFuZC9vciBjcmVhdGUgaXRlbVxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX1RBQjpcblxuXHRcdFx0XHRpZiggc2VsZi5zZXR0aW5ncy5zZWxlY3RPblRhYiApe1xuXHRcdFx0XHRcdGlmKCBzZWxmLmNhblNlbGVjdChzZWxmLmFjdGl2ZU9wdGlvbikgKXtcblx0XHRcdFx0XHRcdHNlbGYub25PcHRpb25TZWxlY3QoZSxzZWxmLmFjdGl2ZU9wdGlvbiEpO1xuXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IGRlZmF1bHQgW3RhYl0gYmVoYXZpb3VyIG9mIGp1bXAgdG8gdGhlIG5leHQgZmllbGRcblx0XHRcdFx0XHRcdC8vIGlmIHNlbGVjdCBpc0Z1bGwsIHRoZW4gdGhlIGRyb3Bkb3duIHdvbid0IGJlIG9wZW4gYW5kIFt0YWJdIHdpbGwgd29yayBub3JtYWxseVxuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gZGVsZXRlfGJhY2tzcGFjZTogZGVsZXRlIGl0ZW1zXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfQkFDS1NQQUNFOlxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0RFTEVURTpcblx0XHRcdFx0c2VsZi5kZWxldGVTZWxlY3Rpb24oZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBlbnRlciB0ZXh0IGluIHRoZSBjb250cm9sX2lucHV0IHdoZW4gYWN0aXZlIGl0ZW1zIGFyZSBzZWxlY3RlZFxuXHRcdGlmKCBzZWxmLmlzSW5wdXRIaWRkZW4gJiYgIWlzS2V5RG93bihjb25zdGFudHMuS0VZX1NIT1JUQ1VULGUpICl7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5dXAuXG5cdCAqXG5cdCAqL1xuXHRvbklucHV0KGU6TW91c2VFdmVudHxLZXlib2FyZEV2ZW50KTp2b2lkIHtcblx0XHRcblx0XHRpZiggdGhpcy5pc0xvY2tlZCApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dFZhbHVlKCk7XG5cdFx0aWYoIHRoaXMubGFzdFZhbHVlID09PSB2YWx1ZSApIHJldHVybjtcblx0XHR0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuXHRcdFxuXHRcdGlmKCB2YWx1ZSA9PSAnJyApe1xuXHRcdFx0dGhpcy5fb25JbnB1dCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCB0aGlzLnJlZnJlc2hUaW1lb3V0ICl7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZWZyZXNoVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZWZyZXNoVGltZW91dCA9IHRpbWVvdXQoKCk9PiB7XG5cdFx0XHR0aGlzLnJlZnJlc2hUaW1lb3V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX29uSW5wdXQoKTtcblx0XHR9LCB0aGlzLnNldHRpbmdzLnJlZnJlc2hUaHJvdHRsZSk7XG5cdH1cblxuXHRfb25JbnB1dCgpOnZvaWQge1xuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5sYXN0VmFsdWU7XG5cblx0XHRpZiggdGhpcy5zZXR0aW5ncy5zaG91bGRMb2FkLmNhbGwodGhpcyx2YWx1ZSkgKXtcblx0XHRcdHRoaXMubG9hZCh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZWZyZXNoT3B0aW9ucygpO1xuXHRcdHRoaXMudHJpZ2dlcigndHlwZScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciByb2xscyBvdmVyXG5cdCAqIGFuIG9wdGlvbiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAqXG5cdCAqL1xuXHRvbk9wdGlvbkhvdmVyKCBldnQ6TW91c2VFdmVudHxLZXlib2FyZEV2ZW50LCBvcHRpb246SFRNTEVsZW1lbnQgKTp2b2lke1xuXHRcdGlmKCB0aGlzLmlnbm9yZUhvdmVyICkgcmV0dXJuO1xuXHRcdHRoaXMuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbiwgZmFsc2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGZvY3VzLlxuXHQgKlxuXHQgKi9cblx0b25Gb2N1cyhlPzpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpOnZvaWQge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgd2FzRm9jdXNlZCA9IHNlbGYuaXNGb2N1c2VkO1xuXG5cdFx0aWYoIHNlbGYuaXNEaXNhYmxlZCB8fCBzZWxmLmlzUmVhZE9ubHkgKXtcblx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuaWdub3JlRm9jdXMpIHJldHVybjtcblx0XHRzZWxmLmlzRm9jdXNlZCA9IHRydWU7XG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MucHJlbG9hZCA9PT0gJ2ZvY3VzJyApIHNlbGYucHJlbG9hZCgpO1xuXG5cdFx0aWYgKCF3YXNGb2N1c2VkKSBzZWxmLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cblx0XHRpZiAoIXNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoISFzZWxmLnNldHRpbmdzLm9wZW5PbkZvY3VzKTtcblx0XHR9XG5cblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGJsdXIuXG5cdCAqXG5cdCAqL1xuXHRvbkJsdXIoZT86Rm9jdXNFdmVudCk6dm9pZCB7XG5cblx0XHRpZiggZG9jdW1lbnQuaGFzRm9jdXMoKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCkgcmV0dXJuO1xuXHRcdHNlbGYuaXNGb2N1c2VkID0gZmFsc2U7XG5cdFx0c2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXG5cdFx0dmFyIGRlYWN0aXZhdGUgPSAoKSA9PiB7XG5cdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoc2VsZi5pdGVtcy5sZW5ndGgpO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdibHVyJyk7XG5cdFx0fTtcblxuXHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLmNyZWF0ZU9uQmx1cikge1xuXHRcdFx0c2VsZi5jcmVhdGVJdGVtKG51bGwsIGRlYWN0aXZhdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIG9wdGlvblxuXHQgKiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAqXG5cdCAqL1xuXHRvbk9wdGlvblNlbGVjdCggZXZ0Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCwgb3B0aW9uOkhUTUxFbGVtZW50ICl7XG5cdFx0dmFyIHZhbHVlLCBzZWxmID0gdGhpcztcblxuXG5cdFx0Ly8gc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byB0cmlnZ2VyIGEgb3B0aW9uIHVuZGVyIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRpZiggb3B0aW9uLnBhcmVudEVsZW1lbnQgJiYgb3B0aW9uLnBhcmVudEVsZW1lbnQubWF0Y2hlcygnW2RhdGEtZGlzYWJsZWRdJykgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblxuXHRcdGlmKCBvcHRpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdjcmVhdGUnKSApe1xuXHRcdFx0c2VsZi5jcmVhdGVJdGVtKG51bGwsICgpID0+IHtcblx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gb3B0aW9uLmRhdGFzZXQudmFsdWU7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0XHRcdHNlbGYuYWRkSXRlbSh2YWx1ZSk7XG5cdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QpIHtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggIXNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICYmIGV2dC50eXBlICYmIC9jbGljay8udGVzdChldnQudHlwZSkgKXtcblx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBvcHRpb24gY2FuIGJlIHNlbGVjdGVkXG5cdCAqXG5cdCAqL1xuXHRjYW5TZWxlY3Qob3B0aW9uOkhUTUxFbGVtZW50fG51bGwpOmJvb2xlYW57XG5cblx0XHRpZiggdGhpcy5pc09wZW4gJiYgb3B0aW9uICYmIHRoaXMuZHJvcGRvd25fY29udGVudC5jb250YWlucyhvcHRpb24pICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gaXRlbVxuXHQgKiB0aGF0IGhhcyBiZWVuIHNlbGVjdGVkLlxuXHQgKlxuXHQgKi9cblx0b25JdGVtU2VsZWN0KCBldnQ/Ok1vdXNlRXZlbnQsIGl0ZW0/OlRvbUl0ZW0gKTpib29sZWFue1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCAhc2VsZi5pc0xvY2tlZCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgKXtcblx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oaXRlbSwgZXZ0KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBpbnZva2Vcblx0ICogdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyIC8gbG9hZGVyXG5cdCAqXG5cdCAqIE5vdGUsIHRoZXJlIGlzIGEgc3VidGxlIGRpZmZlcmVuY2UgYmV0d2VlblxuXHQgKiB0aGlzLmNhbkxvYWQoKSBhbmQgdGhpcy5zZXR0aW5ncy5zaG91bGRMb2FkKCk7XG5cdCAqXG5cdCAqXHQtIHNldHRpbmdzLnNob3VsZExvYWQoKSBpcyBhIHVzZXItaW5wdXQgdmFsaWRhdG9yLlxuXHQgKlx0V2hlbiBmYWxzZSBpcyByZXR1cm5lZCwgdGhlIG5vdF9sb2FkaW5nIHRlbXBsYXRlXG5cdCAqXHR3aWxsIGJlIGFkZGVkIHRvIHRoZSBkcm9wZG93blxuXHQgKlxuXHQgKlx0LSBjYW5Mb2FkKCkgaXMgbG93ZXIgbGV2ZWwgdmFsaWRhdG9yIHRoYXQgY2hlY2tzXG5cdCAqIFx0dGhlIFRvbSBTZWxlY3QgaW5zdGFuY2UuIFRoZXJlIGlzIG5vIGluaGVyZW50IHVzZXJcblx0ICpcdGZlZWRiYWNrIHdoZW4gY2FuTG9hZCByZXR1cm5zIGZhbHNlXG5cdCAqXG5cdCAqL1xuXHRjYW5Mb2FkKHZhbHVlOnN0cmluZyk6Ym9vbGVhbntcblxuXHRcdGlmKCAhdGhpcy5zZXR0aW5ncy5sb2FkICkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmKCB0aGlzLmxvYWRlZFNlYXJjaGVzLmhhc093blByb3BlcnR5KHZhbHVlKSApIHJldHVybiBmYWxzZTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludm9rZXMgdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyIC8gbG9hZGVyLlxuXHQgKlxuXHQgKi9cblx0bG9hZCh2YWx1ZTpzdHJpbmcpOnZvaWQge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoICFzZWxmLmNhbkxvYWQodmFsdWUpICkgcmV0dXJuO1xuXG5cdFx0YWRkQ2xhc3NlcyhzZWxmLndyYXBwZXIsc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuXHRcdHNlbGYubG9hZGluZysrO1xuXG5cdFx0Y29uc3QgY2FsbGJhY2sgPSBzZWxmLmxvYWRDYWxsYmFjay5iaW5kKHNlbGYpO1xuXHRcdHNlbGYuc2V0dGluZ3MubG9hZC5jYWxsKHNlbGYsIHZhbHVlLCBjYWxsYmFjayk7XG5cdH1cblxuXHQvKipcblx0ICogSW52b2tlZCBieSB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXJcblx0ICpcblx0ICovXG5cdGxvYWRDYWxsYmFjayggb3B0aW9uczpUb21PcHRpb25bXSwgb3B0Z3JvdXBzOlRvbU9wdGlvbltdICk6dm9pZHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcblx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cblx0XHRzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7IC8vIHdoZW4gbmV3IHJlc3VsdHMgbG9hZCwgZm9jdXMgc2hvdWxkIGJlIG9uIGZpcnN0IG9wdGlvblxuXHRcdHNlbGYuc2V0dXBPcHRpb25zKG9wdGlvbnMsb3B0Z3JvdXBzKTtcblxuXHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgIXNlbGYuaXNJbnB1dEhpZGRlbik7XG5cblx0XHRpZiAoIXNlbGYubG9hZGluZykge1xuXHRcdFx0cmVtb3ZlQ2xhc3NlcyhzZWxmLndyYXBwZXIsc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuXHRcdH1cblxuXHRcdHNlbGYudHJpZ2dlcignbG9hZCcsIG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG5cdH1cblxuXHRwcmVsb2FkKCk6dm9pZHtcblx0XHR2YXIgY2xhc3NMaXN0ID0gdGhpcy53cmFwcGVyLmNsYXNzTGlzdDtcblx0XHRpZiggY2xhc3NMaXN0LmNvbnRhaW5zKCdwcmVsb2FkZWQnKSApIHJldHVybjtcblx0XHRjbGFzc0xpc3QuYWRkKCdwcmVsb2FkZWQnKTtcblx0XHR0aGlzLmxvYWQoJycpO1xuXHR9XG5cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaW5wdXQgZmllbGQgb2YgdGhlIGNvbnRyb2wgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cblx0ICpcblx0ICovXG5cdHNldFRleHRib3hWYWx1ZSh2YWx1ZTpzdHJpbmcgPSAnJykge1xuXHRcdHZhciBpbnB1dCA9IHRoaXMuY29udHJvbF9pbnB1dDtcblx0XHR2YXIgY2hhbmdlZCA9IGlucHV0LnZhbHVlICE9PSB2YWx1ZTtcblx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRyaWdnZXJFdmVudChpbnB1dCwndXBkYXRlJyk7XG5cdFx0XHR0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC4gSWYgbXVsdGlwbGUgaXRlbXNcblx0ICogY2FuIGJlIHNlbGVjdGVkIChlLmcuIDxzZWxlY3QgbXVsdGlwbGU+KSwgdGhpcyByZXR1cm5zXG5cdCAqIGFuIGFycmF5LiBJZiBvbmx5IG9uZSBpdGVtIGNhbiBiZSBzZWxlY3RlZCwgdGhpc1xuXHQgKiByZXR1cm5zIGEgc3RyaW5nLlxuXHQgKlxuXHQgKi9cblx0Z2V0VmFsdWUoKTpzdHJpbmd8c3RyaW5nW10ge1xuXG5cdFx0aWYoIHRoaXMuaXNfc2VsZWN0X3RhZyAmJiB0aGlzLmlucHV0Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXRlbXMuam9pbih0aGlzLnNldHRpbmdzLmRlbGltaXRlcik7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBzZWxlY3RlZCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqXG5cdCAqL1xuXHRzZXRWYWx1ZSggdmFsdWU6c3RyaW5nfHN0cmluZ1tdLCBzaWxlbnQ/OmJvb2xlYW4gKTp2b2lke1xuXHRcdHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJ107XG5cblx0XHRkZWJvdW5jZV9ldmVudHModGhpcywgZXZlbnRzLCgpID0+IHtcblx0XHRcdHRoaXMuY2xlYXIoc2lsZW50KTtcblx0XHRcdHRoaXMuYWRkSXRlbXModmFsdWUsIHNpbGVudCk7XG5cdFx0fSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIG51bWJlciBvZiBtYXggaXRlbXMgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqL1xuXHRzZXRNYXhJdGVtcyh2YWx1ZTpudWxsfG51bWJlcil7XG5cdFx0aWYodmFsdWUgPT09IDApIHZhbHVlID0gbnVsbDsgLy9yZXNldCB0byB1bmxpbWl0ZWQgaXRlbXMuXG5cdFx0dGhpcy5zZXR0aW5ncy5tYXhJdGVtcyA9IHZhbHVlO1xuXHRcdHRoaXMucmVmcmVzaFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc2VsZWN0ZWQgaXRlbS5cblx0ICpcblx0ICovXG5cdHNldEFjdGl2ZUl0ZW0oIGl0ZW0/OlRvbUl0ZW0sIGU/Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdHZhciBpLCBiZWdpbiwgZW5kLCBzd2FwO1xuXHRcdHZhciBsYXN0O1xuXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpIHJldHVybjtcblxuXHRcdC8vIGNsZWFyIHRoZSBhY3RpdmUgc2VsZWN0aW9uXG5cdFx0aWYoICFpdGVtICl7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdGlmIChzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBtb2RpZnkgc2VsZWN0aW9uXG5cdFx0ZXZlbnROYW1lID0gZSAmJiBlLnR5cGUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmIChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsZSkgJiYgc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdGxhc3RcdD0gc2VsZi5nZXRMYXN0QWN0aXZlKCk7XG5cdFx0XHRiZWdpblx0PSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgbGFzdCk7XG5cdFx0XHRlbmRcdFx0PSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgaXRlbSk7XG5cblx0XHRcdGlmIChiZWdpbiA+IGVuZCkge1xuXHRcdFx0XHRzd2FwICA9IGJlZ2luO1xuXHRcdFx0XHRiZWdpbiA9IGVuZDtcblx0XHRcdFx0ZW5kICAgPSBzd2FwO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gYmVnaW47IGkgPD0gZW5kOyBpKyspIHtcblx0XHRcdFx0aXRlbSA9IHNlbGYuY29udHJvbC5jaGlsZHJlbltpXSBhcyBUb21JdGVtO1xuXHRcdFx0XHRpZiAoc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuXHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbUNsYXNzKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHR9IGVsc2UgaWYgKChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgKSB8fCAoZXZlbnROYW1lID09PSAna2V5ZG93bicgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsZSkpKSB7XG5cdFx0XHRpZiggaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRcdHNlbGYucmVtb3ZlQWN0aXZlSXRlbSggaXRlbSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuXHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0fVxuXG5cdFx0Ly8gZW5zdXJlIGNvbnRyb2wgaGFzIGZvY3VzXG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGFjdGl2ZSBhbmQgbGFzdC1hY3RpdmUgY2xhc3Nlc1xuXHQgKlxuXHQgKi9cblx0c2V0QWN0aXZlSXRlbUNsYXNzKCBpdGVtOlRvbUl0ZW0gKXtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCBsYXN0X2FjdGl2ZSA9IHNlbGYuY29udHJvbC5xdWVyeVNlbGVjdG9yKCcubGFzdC1hY3RpdmUnKTtcblx0XHRpZiggbGFzdF9hY3RpdmUgKSByZW1vdmVDbGFzc2VzKGxhc3RfYWN0aXZlIGFzIEhUTUxFbGVtZW50LCdsYXN0LWFjdGl2ZScpO1xuXG5cdFx0YWRkQ2xhc3NlcyhpdGVtLCdhY3RpdmUgbGFzdC1hY3RpdmUnKTtcblx0XHRzZWxmLnRyaWdnZXIoJ2l0ZW1fc2VsZWN0JywgaXRlbSk7XG5cdFx0aWYoIHNlbGYuYWN0aXZlSXRlbXMuaW5kZXhPZihpdGVtKSA9PSAtMSApe1xuXHRcdFx0c2VsZi5hY3RpdmVJdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhY3RpdmUgaXRlbVxuXHQgKlxuXHQgKi9cblx0cmVtb3ZlQWN0aXZlSXRlbSggaXRlbTpUb21JdGVtICl7XG5cdFx0dmFyIGlkeCA9IHRoaXMuYWN0aXZlSXRlbXMuaW5kZXhPZihpdGVtKTtcblx0XHR0aGlzLmFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuXHRcdHJlbW92ZUNsYXNzZXMoaXRlbSwnYWN0aXZlJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCB0aGUgYWN0aXZlIGl0ZW1zXG5cdCAqXG5cdCAqL1xuXHRjbGVhckFjdGl2ZUl0ZW1zKCl7XG5cdFx0cmVtb3ZlQ2xhc3Nlcyh0aGlzLmFjdGl2ZUl0ZW1zLCdhY3RpdmUnKTtcblx0XHR0aGlzLmFjdGl2ZUl0ZW1zID0gW107XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc2VsZWN0ZWQgaXRlbSBpbiB0aGUgZHJvcGRvd24gbWVudVxuXHQgKiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cblx0ICpcblx0ICovXG5cdHNldEFjdGl2ZU9wdGlvbiggb3B0aW9uOm51bGx8SFRNTEVsZW1lbnQsc2Nyb2xsOmJvb2xlYW49dHJ1ZSApOnZvaWR7XG5cblx0XHRpZiggb3B0aW9uID09PSB0aGlzLmFjdGl2ZU9wdGlvbiApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xlYXJBY3RpdmVPcHRpb24oKTtcblx0XHRpZiggIW9wdGlvbiApIHJldHVybjtcblxuXHRcdHRoaXMuYWN0aXZlT3B0aW9uID0gb3B0aW9uO1xuXHRcdHNldEF0dHIodGhpcy5mb2N1c19ub2RlLHsnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzpvcHRpb24uZ2V0QXR0cmlidXRlKCdpZCcpfSk7XG5cdFx0c2V0QXR0cihvcHRpb24seydhcmlhLXNlbGVjdGVkJzondHJ1ZSd9KTtcblx0XHRhZGRDbGFzc2VzKG9wdGlvbiwnYWN0aXZlJyk7XG5cdFx0aWYoIHNjcm9sbCApIHRoaXMuc2Nyb2xsVG9PcHRpb24ob3B0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkcm9wZG93bl9jb250ZW50IHNjcm9sbFRvcCB0byBkaXNwbGF5IHRoZSBvcHRpb25cblx0ICpcblx0ICovXG5cdHNjcm9sbFRvT3B0aW9uKCBvcHRpb246bnVsbHxIVE1MRWxlbWVudCwgYmVoYXZpb3I/OnN0cmluZyApOnZvaWR7XG5cblx0XHRpZiggIW9wdGlvbiApIHJldHVybjtcblxuXHRcdGNvbnN0IGNvbnRlbnRcdFx0PSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0Y29uc3QgaGVpZ2h0X21lbnVcdD0gY29udGVudC5jbGllbnRIZWlnaHQ7XG5cdFx0Y29uc3Qgc2Nyb2xsVG9wXHRcdD0gY29udGVudC5zY3JvbGxUb3AgfHwgMDtcblx0XHRjb25zdCBoZWlnaHRfaXRlbVx0PSBvcHRpb24ub2Zmc2V0SGVpZ2h0O1xuXHRcdGNvbnN0IHlcdFx0XHRcdD0gb3B0aW9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgc2Nyb2xsVG9wO1xuXG5cdFx0aWYgKHkgKyBoZWlnaHRfaXRlbSA+IGhlaWdodF9tZW51ICsgc2Nyb2xsVG9wKSB7XG5cdFx0XHR0aGlzLnNjcm9sbCh5IC0gaGVpZ2h0X21lbnUgKyBoZWlnaHRfaXRlbSwgYmVoYXZpb3IpO1xuXG5cdFx0fSBlbHNlIGlmICh5IDwgc2Nyb2xsVG9wKSB7XG5cdFx0XHR0aGlzLnNjcm9sbCh5LCBiZWhhdmlvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNjcm9sbCB0aGUgZHJvcGRvd24gdG8gdGhlIGdpdmVuIHBvc2l0aW9uXG5cdCAqXG5cdCAqL1xuXHRzY3JvbGwoIHNjcm9sbFRvcDpudW1iZXIsIGJlaGF2aW9yPzpzdHJpbmcgKTp2b2lke1xuXHRcdGNvbnN0IGNvbnRlbnQgPSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0aWYoIGJlaGF2aW9yICl7XG5cdFx0XHRjb250ZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gYmVoYXZpb3I7XG5cdFx0fVxuXHRcdGNvbnRlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXHRcdGNvbnRlbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGFjdGl2ZSBvcHRpb25cblx0ICpcblx0ICovXG5cdGNsZWFyQWN0aXZlT3B0aW9uKCl7XG5cdFx0aWYoIHRoaXMuYWN0aXZlT3B0aW9uICl7XG5cdFx0XHRyZW1vdmVDbGFzc2VzKHRoaXMuYWN0aXZlT3B0aW9uLCdhY3RpdmUnKTtcblx0XHRcdHNldEF0dHIodGhpcy5hY3RpdmVPcHRpb24seydhcmlhLXNlbGVjdGVkJzpudWxsfSk7XG5cdFx0fVxuXHRcdHRoaXMuYWN0aXZlT3B0aW9uID0gbnVsbDtcblx0XHRzZXRBdHRyKHRoaXMuZm9jdXNfbm9kZSx7J2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6bnVsbH0pO1xuXHR9XG5cblxuXHQvKipcblx0ICogU2VsZWN0cyBhbGwgaXRlbXMgKENUUkwgKyBBKS5cblx0ICovXG5cdHNlbGVjdEFsbCgpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKSByZXR1cm47XG5cblx0XHRjb25zdCBhY3RpdmVJdGVtcyA9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG5cblx0XHRpZiggIWFjdGl2ZUl0ZW1zLmxlbmd0aCApIHJldHVybjtcblxuXHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdHNlbGYuY2xvc2UoKTtcblxuXHRcdHNlbGYuYWN0aXZlSXRlbXMgPSBhY3RpdmVJdGVtcztcblx0XHRpdGVyYXRlKCBhY3RpdmVJdGVtcywgKGl0ZW06VG9tSXRlbSkgPT4ge1xuXHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0fSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb250cm9sX2lucHV0IHNob3VsZCBiZSBpbiBhIGhpZGRlbiBvciB2aXNpYmxlIHN0YXRlXG5cdCAqXG5cdCAqL1xuXHRpbnB1dFN0YXRlKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoICFzZWxmLmNvbnRyb2wuY29udGFpbnMoc2VsZi5jb250cm9sX2lucHV0KSApIHJldHVybjtcblxuXHRcdHNldEF0dHIoc2VsZi5jb250cm9sX2lucHV0LHtwbGFjZWhvbGRlcjpzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyfSk7XG5cblx0XHRpZiggc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGggPiAwIHx8ICghc2VsZi5pc0ZvY3VzZWQgJiYgc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwKSApe1xuXHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcblx0XHRcdHNlbGYuaXNJbnB1dEhpZGRlbiA9IHRydWU7XG5cblx0XHR9ZWxzZXtcblxuXHRcdFx0aWYoIHNlbGYuc2V0dGluZ3MuaGlkZVBsYWNlaG9sZGVyICYmIHNlbGYuaXRlbXMubGVuZ3RoID4gMCApe1xuXHRcdFx0XHRzZXRBdHRyKHNlbGYuY29udHJvbF9pbnB1dCx7cGxhY2Vob2xkZXI6Jyd9KTtcblx0XHRcdH1cblx0XHRcdHNlbGYuaXNJbnB1dEhpZGRlbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1oaWRkZW4nLCBzZWxmLmlzSW5wdXRIaWRkZW4gKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGlucHV0IHZhbHVlXG5cdCAqL1xuXHRpbnB1dFZhbHVlKCl7XG5cdFx0cmV0dXJuIHRoaXMuY29udHJvbF9pbnB1dC52YWx1ZS50cmltKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2l2ZXMgdGhlIGNvbnRyb2wgZm9jdXMuXG5cdCAqL1xuXHRmb2N1cygpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIHNlbGYuaXNEaXNhYmxlZCB8fCBzZWxmLmlzUmVhZE9ubHkpIHJldHVybjtcblxuXHRcdHNlbGYuaWdub3JlRm9jdXMgPSB0cnVlO1xuXG5cdFx0aWYoIHNlbGYuY29udHJvbF9pbnB1dC5vZmZzZXRXaWR0aCApe1xuXHRcdFx0c2VsZi5jb250cm9sX2lucHV0LmZvY3VzKCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLmZvY3VzX25vZGUuZm9jdXMoKTtcblx0XHR9XG5cblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHNlbGYuaWdub3JlRm9jdXMgPSBmYWxzZTtcblx0XHRcdHNlbGYub25Gb2N1cygpO1xuXHRcdH0sIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZvcmNlcyB0aGUgY29udHJvbCBvdXQgb2YgZm9jdXMuXG5cdCAqXG5cdCAqL1xuXHRibHVyKCk6dm9pZCB7XG5cdFx0dGhpcy5mb2N1c19ub2RlLmJsdXIoKTtcblx0XHR0aGlzLm9uQmx1cigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHNjb3JlcyBhbiBvYmplY3Rcblx0ICogdG8gc2hvdyBob3cgZ29vZCBvZiBhIG1hdGNoIGl0IGlzIHRvIHRoZVxuXHQgKiBwcm92aWRlZCBxdWVyeS5cblx0ICpcblx0ICogQHJldHVybiB7ZnVuY3Rpb259XG5cdCAqL1xuXHRnZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5OnN0cmluZykge1xuXHRcdHJldHVybiB0aGlzLnNpZnRlci5nZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5LCB0aGlzLmdldFNlYXJjaE9wdGlvbnMoKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBzZWFyY2ggb3B0aW9ucyBmb3Igc2lmdGVyICh0aGUgc3lzdGVtXG5cdCAqIGZvciBzY29yaW5nIGFuZCBzb3J0aW5nIHJlc3VsdHMpLlxuXHQgKlxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy9zaWZ0ZXIuanNcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKi9cblx0Z2V0U2VhcmNoT3B0aW9ucygpIHtcblx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXHRcdHZhciBzb3J0ID0gc2V0dGluZ3Muc29ydEZpZWxkO1xuXHRcdGlmICh0eXBlb2Ygc2V0dGluZ3Muc29ydEZpZWxkID09PSAnc3RyaW5nJykge1xuXHRcdFx0c29ydCA9IFt7ZmllbGQ6IHNldHRpbmdzLnNvcnRGaWVsZH1dO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRmaWVsZHMgICAgICA6IHNldHRpbmdzLnNlYXJjaEZpZWxkLFxuXHRcdFx0Y29uanVuY3Rpb24gOiBzZXR0aW5ncy5zZWFyY2hDb25qdW5jdGlvbixcblx0XHRcdHNvcnQgICAgICAgIDogc29ydCxcblx0XHRcdG5lc3RpbmcgICAgIDogc2V0dGluZ3MubmVzdGluZ1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogU2VhcmNoZXMgdGhyb3VnaCBhdmFpbGFibGUgb3B0aW9ucyBhbmQgcmV0dXJuc1xuXHQgKiBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuXHQgKlxuXHQgKi9cblx0c2VhcmNoKHF1ZXJ5OnN0cmluZykgOiBSZXR1cm5UeXBlPFNpZnRlclsnc2VhcmNoJ10+e1xuXHRcdHZhciByZXN1bHQsIGNhbGN1bGF0ZVNjb3JlO1xuXHRcdHZhciBzZWxmICAgICA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgID0gdGhpcy5nZXRTZWFyY2hPcHRpb25zKCk7XG5cblx0XHQvLyB2YWxpZGF0ZSB1c2VyLXByb3ZpZGVkIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG5cdFx0aWYgKCBzZWxmLnNldHRpbmdzLnNjb3JlICl7XG5cdFx0XHRjYWxjdWxhdGVTY29yZSA9IHNlbGYuc2V0dGluZ3Muc2NvcmUuY2FsbChzZWxmLHF1ZXJ5KTtcblx0XHRcdGlmICh0eXBlb2YgY2FsY3VsYXRlU2NvcmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUb20gU2VsZWN0IFwic2NvcmVcIiBzZXR0aW5nIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHBlcmZvcm0gc2VhcmNoXG5cdFx0aWYgKHF1ZXJ5ICE9PSBzZWxmLmxhc3RRdWVyeSkge1xuXHRcdFx0c2VsZi5sYXN0UXVlcnlcdFx0XHQ9IHF1ZXJ5O1xuXHRcdFx0cmVzdWx0XHRcdFx0XHRcdD0gc2VsZi5zaWZ0ZXIuc2VhcmNoKHF1ZXJ5LCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtzY29yZTogY2FsY3VsYXRlU2NvcmV9KSk7XG5cdFx0XHRzZWxmLmN1cnJlbnRSZXN1bHRzXHRcdD0gcmVzdWx0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRcdFx0XHRcdFx0PSBPYmplY3QuYXNzaWduKCB7fSwgc2VsZi5jdXJyZW50UmVzdWx0cyk7XG5cdFx0fVxuXG5cdFx0Ly8gZmlsdGVyIG91dCBzZWxlY3RlZCBpdGVtc1xuXHRcdGlmKCBzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCApe1xuXHRcdFx0cmVzdWx0Lml0ZW1zID0gcmVzdWx0Lml0ZW1zLmZpbHRlcigoaXRlbSkgPT4ge1xuXHRcdFx0XHRsZXQgaGFzaGVkID0gaGFzaF9rZXkoaXRlbS5pZCk7XG5cdFx0XHRcdHJldHVybiAhKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogUmVmcmVzaGVzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIHNob3duXG5cdCAqIGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0ICpcblx0ICovXG5cdHJlZnJlc2hPcHRpb25zKCB0cmlnZ2VyRHJvcGRvd246Ym9vbGVhbiA9IHRydWUgKXtcblx0XHR2YXIgaSwgaiwgaywgbiwgb3B0Z3JvdXAsIG9wdGdyb3VwcywgaHRtbDpEb2N1bWVudEZyYWdtZW50LCBoYXNfY3JlYXRlX29wdGlvbiwgYWN0aXZlX2dyb3VwO1xuXHRcdHZhciBjcmVhdGU7XG5cblx0XHR0eXBlIEdyb3VwID0ge2ZyYWdtZW50OkRvY3VtZW50RnJhZ21lbnQsb3JkZXI6bnVtYmVyLG9wdGdyb3VwOnN0cmluZ31cblx0XHRjb25zdCBncm91cHM6IHtba2V5OnN0cmluZ106bnVtYmVyfSA9IHt9O1xuXHRcdGNvbnN0IGdyb3Vwc19vcmRlcjpHcm91cFtdXHQ9IFtdO1xuXG5cdFx0dmFyIHNlbGZcdFx0XHRcdFx0PSB0aGlzO1xuXHRcdHZhciBxdWVyeVx0XHRcdFx0XHQ9IHNlbGYuaW5wdXRWYWx1ZSgpO1xuXHRcdGNvbnN0IHNhbWVfcXVlcnlcdFx0XHQ9IHF1ZXJ5ID09PSBzZWxmLmxhc3RRdWVyeSB8fCAocXVlcnkgPT0gJycgJiYgc2VsZi5sYXN0UXVlcnkgPT0gbnVsbCk7XG5cdFx0dmFyIHJlc3VsdHNcdFx0XHRcdFx0PSBzZWxmLnNlYXJjaChxdWVyeSk7XG5cdFx0dmFyIGFjdGl2ZV9vcHRpb246SFRNTEVsZW1lbnR8bnVsbCA9IG51bGw7XG5cdFx0dmFyIHNob3dfZHJvcGRvd25cdFx0XHQ9IHNlbGYuc2V0dGluZ3Muc2hvdWxkT3BlbiB8fCBmYWxzZTtcblx0XHR2YXIgZHJvcGRvd25fY29udGVudFx0XHQ9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblxuXG5cdFx0aWYoIHNhbWVfcXVlcnkgKXtcblx0XHRcdGFjdGl2ZV9vcHRpb25cdFx0XHQ9IHNlbGYuYWN0aXZlT3B0aW9uO1xuXG5cdFx0XHRpZiggYWN0aXZlX29wdGlvbiApe1xuXHRcdFx0XHRhY3RpdmVfZ3JvdXAgPSBhY3RpdmVfb3B0aW9uLmNsb3Nlc3QoJ1tkYXRhLWdyb3VwXScpIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIG1hcmt1cFxuXHRcdG4gPSByZXN1bHRzLml0ZW1zLmxlbmd0aDtcblx0XHRpZiAodHlwZW9mIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdG4gPSBNYXRoLm1pbihuLCBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGlmKCBuID4gMCApe1xuXHRcdFx0c2hvd19kcm9wZG93biA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGZyYWdtZW50IGZvciBncm91cCBhbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBncm91cCBpbiBncm91cF9vcmRlclxuXHRcdGNvbnN0IGdldEdyb3VwRnJhZ21lbnQgPSAob3B0Z3JvdXA6c3RyaW5nLG9yZGVyOm51bWJlcik6W251bWJlcixEb2N1bWVudEZyYWdtZW50XSA9PiB7XG5cblx0XHRcdGxldCBncm91cF9vcmRlcl9pID0gZ3JvdXBzW29wdGdyb3VwXTtcblxuXHRcdFx0aWYoIGdyb3VwX29yZGVyX2kgIT09IHVuZGVmaW5lZCApe1xuXHRcdFx0XHRsZXQgb3JkZXJfZ3JvdXAgPSBncm91cHNfb3JkZXJbZ3JvdXBfb3JkZXJfaV07XG5cdFx0XHRcdGlmKCBvcmRlcl9ncm91cCAhPT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdFx0cmV0dXJuIFtncm91cF9vcmRlcl9pLG9yZGVyX2dyb3VwLmZyYWdtZW50XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZ3JvdXBfZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRncm91cF9vcmRlcl9pID0gZ3JvdXBzX29yZGVyLmxlbmd0aDtcblx0XHRcdGdyb3Vwc19vcmRlci5wdXNoKHtmcmFnbWVudDpncm91cF9mcmFnbWVudCxvcmRlcixvcHRncm91cH0pO1xuXG5cdFx0XHRyZXR1cm4gW2dyb3VwX29yZGVyX2ksZ3JvdXBfZnJhZ21lbnRdXG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIGFuZCBncm91cCBhdmFpbGFibGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcblx0XHRmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cblx0XHRcdC8vIGdldCBvcHRpb24gZG9tIGVsZW1lbnRcblx0XHRcdGxldCBpdGVtXHRcdFx0PSByZXN1bHRzLml0ZW1zW2ldO1xuXHRcdFx0aWYoICFpdGVtICkgY29udGludWU7XG5cblx0XHRcdGxldCBvcHRfdmFsdWVcdFx0PSBpdGVtLmlkO1xuXHRcdFx0bGV0IG9wdGlvblx0XHRcdD0gc2VsZi5vcHRpb25zW29wdF92YWx1ZV07XG5cblx0XHRcdGlmKCBvcHRpb24gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRsZXQgb3B0X2hhc2hcdFx0PSBnZXRfaGFzaChvcHRfdmFsdWUpO1xuXHRcdFx0bGV0IG9wdGlvbl9lbFx0XHQ9IHNlbGYuZ2V0T3B0aW9uKG9wdF9oYXNoLHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXG5cdFx0XHQvLyB0b2dnbGUgJ3NlbGVjdGVkJyBjbGFzc1xuXHRcdFx0aWYoICFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCApe1xuXHRcdFx0XHRvcHRpb25fZWwuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBzZWxmLml0ZW1zLmluY2x1ZGVzKG9wdF9oYXNoKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRncm91cCAgICA9IG9wdGlvbltzZWxmLnNldHRpbmdzLm9wdGdyb3VwRmllbGRdIHx8ICcnO1xuXHRcdFx0b3B0Z3JvdXBzICAgPSBBcnJheS5pc0FycmF5KG9wdGdyb3VwKSA/IG9wdGdyb3VwIDogW29wdGdyb3VwXTtcblx0XHRcdFxuXG5cdFx0XHRmb3IgKGogPSAwLCBrID0gb3B0Z3JvdXBzICYmIG9wdGdyb3Vwcy5sZW5ndGg7IGogPCBrOyBqKyspIHtcblx0XHRcdFx0b3B0Z3JvdXAgPSBvcHRncm91cHNbal07XG5cblx0XHRcdFx0bGV0IG9yZGVyID0gb3B0aW9uLiRvcmRlcjtcblx0XHRcdFx0bGV0IHNlbGZfb3B0Z3JvdXAgPSBzZWxmLm9wdGdyb3Vwc1tvcHRncm91cF07XG5cdFx0XHRcdGlmKCBzZWxmX29wdGdyb3VwID09PSB1bmRlZmluZWQgKXtcdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3B0Z3JvdXAgPSAnJztcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0b3JkZXIgPSBzZWxmX29wdGdyb3VwLiRvcmRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IFtncm91cF9vcmRlcl9pLGdyb3VwX2ZyYWdtZW50XSA9IGdldEdyb3VwRnJhZ21lbnQob3B0Z3JvdXAsb3JkZXIpO1xuXG5cblx0XHRcdFx0Ly8gbm9kZXMgY2FuIG9ubHkgaGF2ZSBvbmUgcGFyZW50LCBzbyBpZiB0aGUgb3B0aW9uIGlzIGluIG11dHBsZSBncm91cHMsIHdlIG5lZWQgYSBjbG9uZVxuXHRcdFx0XHRpZiggaiA+IDAgKXtcblx0XHRcdFx0XHRvcHRpb25fZWwgPSBvcHRpb25fZWwuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0XHRcdHNldEF0dHIob3B0aW9uX2VsLHtpZDogb3B0aW9uLiRpZCsnLWNsb25lLScraiwnYXJpYS1zZWxlY3RlZCc6bnVsbH0pO1xuXHRcdFx0XHRcdG9wdGlvbl9lbC5jbGFzc0xpc3QuYWRkKCd0cy1jbG9uZWQnKTtcblx0XHRcdFx0XHRyZW1vdmVDbGFzc2VzKG9wdGlvbl9lbCwnYWN0aXZlJyk7XG5cblxuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBrZWVwIHRoZSBhY3RpdmVPcHRpb24gaW4gdGhlIHNhbWUgZ3JvdXBcblx0XHRcdFx0XHRpZiggc2VsZi5hY3RpdmVPcHRpb24gJiYgc2VsZi5hY3RpdmVPcHRpb24uZGF0YXNldC52YWx1ZSA9PSBvcHRfdmFsdWUgKXtcblx0XHRcdFx0XHRcdGlmKCBhY3RpdmVfZ3JvdXAgJiYgYWN0aXZlX2dyb3VwLmRhdGFzZXQuZ3JvdXAgPT09IG9wdGdyb3VwLnRvU3RyaW5nKCkgKXtcblx0XHRcdFx0XHRcdFx0YWN0aXZlX29wdGlvbiA9IG9wdGlvbl9lbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cdFxuXHRcdFx0XHRcblx0XHRcdFx0Z3JvdXBfZnJhZ21lbnQuYXBwZW5kQ2hpbGQob3B0aW9uX2VsKTtcblx0XHRcdFx0aWYoIG9wdGdyb3VwICE9ICcnICl7XG5cdFx0XHRcdFx0Z3JvdXBzW29wdGdyb3VwXSA9IGdyb3VwX29yZGVyX2k7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IG9wdGdyb3Vwc1xuXHRcdGlmKCBzZWxmLnNldHRpbmdzLmxvY2tPcHRncm91cE9yZGVyICl7XG5cdFx0XHRncm91cHNfb3JkZXIuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRyZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyByZW5kZXIgb3B0Z3JvdXAgaGVhZGVycyAmIGpvaW4gZ3JvdXBzXG5cdFx0aHRtbCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRpdGVyYXRlKCBncm91cHNfb3JkZXIsIChncm91cF9vcmRlcjpHcm91cCkgPT4ge1xuXG5cdFx0XHRsZXQgZ3JvdXBfZnJhZ21lbnQgPSBncm91cF9vcmRlci5mcmFnbWVudDtcblx0XHRcdGxldCBvcHRncm91cCA9IGdyb3VwX29yZGVyLm9wdGdyb3VwXG5cblx0XHRcdGlmKCAhZ3JvdXBfZnJhZ21lbnQgfHwgIWdyb3VwX2ZyYWdtZW50LmNoaWxkcmVuLmxlbmd0aCApIHJldHVybjtcblxuXHRcdFx0bGV0IGdyb3VwX2hlYWRpbmcgPSBzZWxmLm9wdGdyb3Vwc1tvcHRncm91cF07XG5cblx0XHRcdGlmKCBncm91cF9oZWFkaW5nICE9PSB1bmRlZmluZWQgKXtcblxuXHRcdFx0XHRsZXQgZ3JvdXBfb3B0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0bGV0IGhlYWRlciA9IHNlbGYucmVuZGVyKCdvcHRncm91cF9oZWFkZXInLCBncm91cF9oZWFkaW5nKTtcblx0XHRcdFx0YXBwZW5kKCBncm91cF9vcHRpb25zLCBoZWFkZXIgKTtcblx0XHRcdFx0YXBwZW5kKCBncm91cF9vcHRpb25zLCBncm91cF9mcmFnbWVudCApO1xuXG5cdFx0XHRcdGxldCBncm91cF9odG1sID0gc2VsZi5yZW5kZXIoJ29wdGdyb3VwJywge2dyb3VwOmdyb3VwX2hlYWRpbmcsb3B0aW9uczpncm91cF9vcHRpb25zfSApO1xuXG5cdFx0XHRcdGFwcGVuZCggaHRtbCwgZ3JvdXBfaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcHBlbmQoIGh0bWwsIGdyb3VwX2ZyYWdtZW50ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRkcm9wZG93bl9jb250ZW50LmlubmVySFRNTCA9ICcnO1xuXHRcdGFwcGVuZCggZHJvcGRvd25fY29udGVudCwgaHRtbCApO1xuXG5cdFx0Ly8gaGlnaGxpZ2h0IG1hdGNoaW5nIHRlcm1zIGlubGluZVxuXHRcdGlmIChzZWxmLnNldHRpbmdzLmhpZ2hsaWdodCkge1xuXHRcdFx0cmVtb3ZlSGlnaGxpZ2h0KCBkcm9wZG93bl9jb250ZW50ICk7XG5cdFx0XHRpZiAocmVzdWx0cy5xdWVyeS5sZW5ndGggJiYgcmVzdWx0cy50b2tlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGl0ZXJhdGUoIHJlc3VsdHMudG9rZW5zLCAodG9rKSA9PiB7XG5cdFx0XHRcdFx0aGlnaGxpZ2h0KCBkcm9wZG93bl9jb250ZW50LCB0b2sucmVnZXgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBoZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgdGVtcGxhdGVzIHRvIGRyb3Bkb3duXG5cdFx0dmFyIGFkZF90ZW1wbGF0ZSA9ICh0ZW1wbGF0ZTpUb21UZW1wbGF0ZU5hbWVzKSA9PiB7XG5cdFx0XHRsZXQgY29udGVudCA9IHNlbGYucmVuZGVyKHRlbXBsYXRlLHtpbnB1dDpxdWVyeX0pO1xuXHRcdFx0aWYoIGNvbnRlbnQgKXtcblx0XHRcdFx0c2hvd19kcm9wZG93biA9IHRydWU7XG5cdFx0XHRcdGRyb3Bkb3duX2NvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGRyb3Bkb3duX2NvbnRlbnQuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHR9O1xuXG5cblx0XHQvLyBhZGQgbG9hZGluZyBtZXNzYWdlXG5cdFx0aWYoIHNlbGYubG9hZGluZyApe1xuXHRcdFx0YWRkX3RlbXBsYXRlKCdsb2FkaW5nJyk7XG5cblx0XHQvLyBpbnZhbGlkIHF1ZXJ5XG5cdFx0fWVsc2UgaWYoICFzZWxmLnNldHRpbmdzLnNob3VsZExvYWQuY2FsbChzZWxmLHF1ZXJ5KSApe1xuXHRcdFx0YWRkX3RlbXBsYXRlKCdub3RfbG9hZGluZycpO1xuXG5cdFx0Ly8gYWRkIG5vX3Jlc3VsdHMgbWVzc2FnZVxuXHRcdH1lbHNlIGlmKCByZXN1bHRzLml0ZW1zLmxlbmd0aCA9PT0gMCApe1xuXHRcdFx0YWRkX3RlbXBsYXRlKCdub19yZXN1bHRzJyk7XG5cblx0XHR9XG5cblxuXG5cdFx0Ly8gYWRkIGNyZWF0ZSBvcHRpb25cblx0XHRoYXNfY3JlYXRlX29wdGlvbiA9IHNlbGYuY2FuQ3JlYXRlKHF1ZXJ5KTtcblx0XHRpZiAoaGFzX2NyZWF0ZV9vcHRpb24pIHtcblx0XHRcdGNyZWF0ZSA9IGFkZF90ZW1wbGF0ZSgnb3B0aW9uX2NyZWF0ZScpO1xuXHRcdH1cblxuXG5cdFx0Ly8gYWN0aXZhdGVcblx0XHRzZWxmLmhhc09wdGlvbnMgPSByZXN1bHRzLml0ZW1zLmxlbmd0aCA+IDAgfHwgaGFzX2NyZWF0ZV9vcHRpb247XG5cdFx0aWYoIHNob3dfZHJvcGRvd24gKXtcblxuXHRcdFx0aWYgKHJlc3VsdHMuaXRlbXMubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRcdGlmKCAhYWN0aXZlX29wdGlvbiAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnICYmIHNlbGYuaXRlbXNbMF0gIT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdFx0YWN0aXZlX29wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHNlbGYuaXRlbXNbMF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoICFkcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKGFjdGl2ZV9vcHRpb24pICApe1xuXG5cdFx0XHRcdFx0bGV0IGFjdGl2ZV9pbmRleCA9IDA7XG5cdFx0XHRcdFx0aWYoIGNyZWF0ZSAmJiAhc2VsZi5zZXR0aW5ncy5hZGRQcmVjZWRlbmNlICl7XG5cdFx0XHRcdFx0XHRhY3RpdmVfaW5kZXggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhY3RpdmVfb3B0aW9uID0gc2VsZi5zZWxlY3RhYmxlKClbYWN0aXZlX2luZGV4XSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9ZWxzZSBpZiggY3JlYXRlICl7XG5cdFx0XHRcdGFjdGl2ZV9vcHRpb24gPSBjcmVhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCB0cmlnZ2VyRHJvcGRvd24gJiYgIXNlbGYuaXNPcGVuICl7XG5cdFx0XHRcdHNlbGYub3BlbigpO1xuXHRcdFx0XHRzZWxmLnNjcm9sbFRvT3B0aW9uKGFjdGl2ZV9vcHRpb24sJ2F1dG8nKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKGFjdGl2ZV9vcHRpb24pO1xuXG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7XG5cdFx0XHRpZiggdHJpZ2dlckRyb3Bkb3duICYmIHNlbGYuaXNPcGVuICl7XG5cdFx0XHRcdHNlbGYuY2xvc2UoZmFsc2UpOyAvLyBpZiBjcmVhdGVfb3B0aW9uPW51bGwsIHdlIHdhbnQgdGhlIGRyb3Bkb3duIHRvIGNsb3NlIGJ1dCBub3QgcmVzZXQgdGhlIHRleHRib3ggdmFsdWVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGxpc3Qgb2Ygc2VsZWN0YWJsZSBvcHRpb25zXG5cdCAqXG5cdCAqL1xuXHRzZWxlY3RhYmxlKCk6Tm9kZUxpc3R7XG5cdFx0cmV0dXJuIHRoaXMuZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHR9XG5cblxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGF2YWlsYWJsZSBvcHRpb24uIElmIGl0IGFscmVhZHkgZXhpc3RzLFxuXHQgKiBub3RoaW5nIHdpbGwgaGFwcGVuLiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlZnJlc2hcblx0ICogdGhlIG9wdGlvbnMgbGlzdCBkcm9wZG93biAodXNlIGByZWZyZXNoT3B0aW9uc2Bcblx0ICogZm9yIHRoYXQpLlxuXHQgKlxuXHQgKiBVc2FnZTpcblx0ICpcblx0ICogICB0aGlzLmFkZE9wdGlvbihkYXRhKVxuXHQgKlxuXHQgKi9cblx0YWRkT3B0aW9uKCBkYXRhOlRvbU9wdGlvbiwgdXNlcl9jcmVhdGVkID0gZmFsc2UgKTpmYWxzZXxzdHJpbmcge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gQGRlcHJlY2F0ZWQgMS43Ljdcblx0XHQvLyB1c2UgYWRkT3B0aW9ucyggYXJyYXksIHVzZXJfY3JlYXRlZCApIGZvciBhZGRpbmcgbXVsdGlwbGUgb3B0aW9uc1xuXHRcdGlmKCBBcnJheS5pc0FycmF5KGRhdGEpICl7XG5cdFx0XHRzZWxmLmFkZE9wdGlvbnMoIGRhdGEsIHVzZXJfY3JlYXRlZCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga2V5ID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblx0XHRpZigga2V5ID09PSBudWxsIHx8IHNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZGF0YS4kb3JkZXJcdFx0XHQ9IGRhdGEuJG9yZGVyIHx8ICsrc2VsZi5vcmRlcjtcblx0XHRkYXRhLiRpZFx0XHRcdD0gc2VsZi5pbnB1dElkICsgJy1vcHQtJyArIGRhdGEuJG9yZGVyO1xuXHRcdHNlbGYub3B0aW9uc1trZXldXHQ9IGRhdGE7XG5cdFx0c2VsZi5sYXN0UXVlcnlcdFx0PSBudWxsO1xuXG5cdFx0aWYoIHVzZXJfY3JlYXRlZCApe1xuXHRcdFx0c2VsZi51c2VyT3B0aW9uc1trZXldID0gdXNlcl9jcmVhdGVkO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdvcHRpb25fYWRkJywga2V5LCBkYXRhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ga2V5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBtdWx0aXBsZSBvcHRpb25zXG5cdCAqXG5cdCAqL1xuXHRhZGRPcHRpb25zKCBkYXRhOlRvbU9wdGlvbltdLCB1c2VyX2NyZWF0ZWQgPSBmYWxzZSApOnZvaWR7XG5cdFx0aXRlcmF0ZSggZGF0YSwgKGRhdDpUb21PcHRpb24pID0+IHtcblx0XHRcdHRoaXMuYWRkT3B0aW9uKGRhdCwgdXNlcl9jcmVhdGVkKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCAxLjcuN1xuXHQgKi9cblx0cmVnaXN0ZXJPcHRpb24oIGRhdGE6VG9tT3B0aW9uICk6ZmFsc2V8c3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRPcHRpb24oZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIG9wdGlvbiBncm91cCB0byB0aGUgcG9vbCBvZiBvcHRpb24gZ3JvdXBzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cblx0ICovXG5cdHJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YTpUb21PcHRpb24pIHtcblx0XHR2YXIga2V5ID0gaGFzaF9rZXkoZGF0YVt0aGlzLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF0pO1xuXG5cdFx0aWYgKCBrZXkgPT09IG51bGwgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8ICsrdGhpcy5vcmRlcjtcblx0XHR0aGlzLm9wdGdyb3Vwc1trZXldID0gZGF0YTtcblx0XHRyZXR1cm4ga2V5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIG5ldyBvcHRncm91cCBmb3Igb3B0aW9uc1xuXHQgKiB0byBiZSBidWNrZXRlZCBpbnRvLlxuXHQgKlxuXHQgKi9cblx0YWRkT3B0aW9uR3JvdXAoaWQ6c3RyaW5nLCBkYXRhOlRvbU9wdGlvbikge1xuXHRcdHZhciBoYXNoZWRfaWQ7XG5cdFx0ZGF0YVt0aGlzLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF0gPSBpZDtcblxuXHRcdGlmKCBoYXNoZWRfaWQgPSB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YSkgKXtcblx0XHRcdHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfYWRkJywgaGFzaGVkX2lkLCBkYXRhKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBleGlzdGluZyBvcHRpb24gZ3JvdXAuXG5cdCAqXG5cdCAqL1xuXHRyZW1vdmVPcHRpb25Hcm91cChpZDpzdHJpbmcpIHtcblx0XHRpZiAodGhpcy5vcHRncm91cHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5vcHRncm91cHNbaWRdO1xuXHRcdFx0dGhpcy5jbGVhckNhY2hlKCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX3JlbW92ZScsIGlkKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBleGlzdGluZyBvcHRpb24gZ3JvdXBzLlxuXHQgKi9cblx0Y2xlYXJPcHRpb25Hcm91cHMoKSB7XG5cdFx0dGhpcy5vcHRncm91cHMgPSB7fTtcblx0XHR0aGlzLmNsZWFyQ2FjaGUoKTtcblx0XHR0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX2NsZWFyJyk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyBhbiBvcHRpb24gYXZhaWxhYmxlIGZvciBzZWxlY3Rpb24uIElmXG5cdCAqIGl0IGlzIHZpc2libGUgaW4gdGhlIHNlbGVjdGVkIGl0ZW1zIG9yIG9wdGlvbnNcblx0ICogZHJvcGRvd24sIGl0IHdpbGwgYmUgcmUtcmVuZGVyZWQgYXV0b21hdGljYWxseS5cblx0ICpcblx0ICovXG5cdHVwZGF0ZU9wdGlvbih2YWx1ZTpzdHJpbmcsIGRhdGE6VG9tT3B0aW9uKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGl0ZW1fbmV3O1xuXHRcdHZhciBpbmRleF9pdGVtO1xuXG5cdFx0Y29uc3QgdmFsdWVfb2xkXHRcdD0gaGFzaF9rZXkodmFsdWUpO1xuXHRcdGNvbnN0IHZhbHVlX25ld1x0XHQ9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cblx0XHQvLyBzYW5pdHkgY2hlY2tzXG5cdFx0aWYoIHZhbHVlX29sZCA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdGNvbnN0IGRhdGFfb2xkXHRcdD0gc2VsZi5vcHRpb25zW3ZhbHVlX29sZF07XG5cblx0XHRpZiggZGF0YV9vbGQgPT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXHRcdGlmKCB0eXBlb2YgdmFsdWVfbmV3ICE9PSAnc3RyaW5nJyApIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBzZXQgaW4gb3B0aW9uIGRhdGEnKTtcblxuXG5cdFx0Y29uc3Qgb3B0aW9uXHRcdD0gc2VsZi5nZXRPcHRpb24odmFsdWVfb2xkKTtcblx0XHRjb25zdCBpdGVtXHRcdFx0PSBzZWxmLmdldEl0ZW0odmFsdWVfb2xkKTtcblxuXG5cdFx0ZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCBkYXRhX29sZC4kb3JkZXI7XG5cdFx0ZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV9vbGRdO1xuXG5cdFx0Ly8gaW52YWxpZGF0ZSByZW5kZXIgY2FjaGVcblx0XHQvLyBkb24ndCByZW1vdmUgZXhpc3Rpbmcgbm9kZSB5ZXQsIHdlJ2xsIHJlbW92ZSBpdCBhZnRlciByZXBsYWNpbmcgaXRcblx0XHRzZWxmLnVuY2FjaGVWYWx1ZSh2YWx1ZV9uZXcpO1xuXG5cdFx0c2VsZi5vcHRpb25zW3ZhbHVlX25ld10gPSBkYXRhO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSBvcHRpb24gaWYgaXQncyBpbiB0aGUgZHJvcGRvd25cblx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRpZiggc2VsZi5kcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKG9wdGlvbikgKXtcblxuXHRcdFx0XHRjb25zdCBvcHRpb25fbmV3XHQ9IHNlbGYuX3JlbmRlcignb3B0aW9uJywgZGF0YSk7XG5cdFx0XHRcdHJlcGxhY2VOb2RlKG9wdGlvbiwgb3B0aW9uX25ldyk7XG5cblx0XHRcdFx0aWYoIHNlbGYuYWN0aXZlT3B0aW9uID09PSBvcHRpb24gKXtcblx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb25fbmV3KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3B0aW9uLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSB0aGUgaXRlbSBpZiB3ZSBoYXZlIG9uZVxuXHRcdGlmKCBpdGVtICl7XG5cdFx0XHRpbmRleF9pdGVtID0gc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlX29sZCk7XG5cdFx0XHRpZiAoaW5kZXhfaXRlbSAhPT0gLTEpIHtcblx0XHRcdFx0c2VsZi5pdGVtcy5zcGxpY2UoaW5kZXhfaXRlbSwgMSwgdmFsdWVfbmV3KTtcblx0XHRcdH1cblxuXHRcdFx0aXRlbV9uZXdcdD0gc2VsZi5fcmVuZGVyKCdpdGVtJywgZGF0YSk7XG5cblx0XHRcdGlmKCBpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKSBhZGRDbGFzc2VzKGl0ZW1fbmV3LCdhY3RpdmUnKTtcblxuXHRcdFx0cmVwbGFjZU5vZGUoIGl0ZW0sIGl0ZW1fbmV3KTtcblx0XHR9XG5cblx0XHQvLyBpbnZhbGlkYXRlIGxhc3QgcXVlcnkgYmVjYXVzZSB3ZSBtaWdodCBoYXZlIHVwZGF0ZWQgdGhlIHNvcnRGaWVsZFxuXHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgc2luZ2xlIG9wdGlvbi5cblx0ICpcblx0ICovXG5cdHJlbW92ZU9wdGlvbih2YWx1ZTpzdHJpbmcsIHNpbGVudD86Ym9vbGVhbik6dm9pZCB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0dmFsdWUgPSBnZXRfaGFzaCh2YWx1ZSk7XG5cblx0XHRzZWxmLnVuY2FjaGVWYWx1ZSh2YWx1ZSk7XG5cblx0XHRkZWxldGUgc2VsZi51c2VyT3B0aW9uc1t2YWx1ZV07XG5cdFx0ZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdHNlbGYudHJpZ2dlcignb3B0aW9uX3JlbW92ZScsIHZhbHVlKTtcblx0XHRzZWxmLnJlbW92ZUl0ZW0odmFsdWUsIHNpbGVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBvcHRpb25zLlxuXHQgKi9cblx0Y2xlYXJPcHRpb25zKGZpbHRlcj86VG9tQ2xlYXJGaWx0ZXIgKSB7XG5cblx0XHRjb25zdCBib3VuZEZpbHRlciA9IChmaWx0ZXIgfHwgdGhpcy5jbGVhckZpbHRlcikuYmluZCh0aGlzKTtcblxuXHRcdHRoaXMubG9hZGVkU2VhcmNoZXNcdFx0PSB7fTtcblx0XHR0aGlzLnVzZXJPcHRpb25zXHRcdD0ge307XG5cdFx0dGhpcy5jbGVhckNhY2hlKCk7XG5cblx0XHRjb25zdCBzZWxlY3RlZDpUb21PcHRpb25zXHQ9IHt9O1xuXHRcdGl0ZXJhdGUodGhpcy5vcHRpb25zLChvcHRpb246VG9tT3B0aW9uLGtleTpzdHJpbmcpPT57XG5cdFx0XHRpZiggYm91bmRGaWx0ZXIob3B0aW9uLGtleSBhcyBzdHJpbmcpICl7XG5cdFx0XHRcdHNlbGVjdGVkW2tleV0gPSBvcHRpb247XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSB0aGlzLnNpZnRlci5pdGVtcyA9IHNlbGVjdGVkO1xuXHRcdHRoaXMubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHR0aGlzLnRyaWdnZXIoJ29wdGlvbl9jbGVhcicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgY2xlYXJPcHRpb25zKCkgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IGFuIG9wdGlvbiBzaG91bGQgYmUgcmVtb3ZlZFxuXHQgKiBSZXR1cm4gdHJ1ZSB0byBrZWVwIGFuIG9wdGlvbiwgZmFsc2UgdG8gcmVtb3ZlXG5cdCAqXG5cdCAqL1xuXHRjbGVhckZpbHRlcihvcHRpb246VG9tT3B0aW9uLHZhbHVlOnN0cmluZyl7XG5cdFx0aWYoIHRoaXMuaXRlbXMuaW5kZXhPZih2YWx1ZSkgPj0gMCApe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgb3B0aW9uXG5cdCAqIG1hdGNoaW5nIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICpcblx0ICovXG5cdGdldE9wdGlvbih2YWx1ZTp1bmRlZmluZWR8bnVsbHxib29sZWFufHN0cmluZ3xudW1iZXIsIGNyZWF0ZTpib29sZWFuPWZhbHNlKTpudWxsfEhUTUxFbGVtZW50IHtcblxuXHRcdGNvbnN0IGhhc2hlZCA9IGhhc2hfa2V5KHZhbHVlKTtcblx0XHRpZiggaGFzaGVkID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNbaGFzaGVkXTtcblx0XHRpZiggb3B0aW9uICE9IHVuZGVmaW5lZCApe1xuXG5cdFx0XHRpZiggb3B0aW9uLiRkaXYgKXtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbi4kZGl2O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggY3JlYXRlICl7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZW5kZXIoJ29wdGlvbicsIG9wdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG9tIGVsZW1lbnQgb2YgdGhlIG5leHQgb3IgcHJldmlvdXMgZG9tIGVsZW1lbnQgb2YgdGhlIHNhbWUgdHlwZVxuXHQgKiBOb3RlOiBhZGphY2VudCBvcHRpb25zIG1heSBub3QgYmUgYWRqYWNlbnQgRE9NIGVsZW1lbnRzIChvcHRncm91cHMpXG5cdCAqXG5cdCAqL1xuXHRnZXRBZGphY2VudCggb3B0aW9uOm51bGx8SFRNTEVsZW1lbnQsIGRpcmVjdGlvbjpudW1iZXIsIHR5cGU6c3RyaW5nID0gJ29wdGlvbicgKSA6IEhUTUxFbGVtZW50fG51bGx7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBhbGw7XG5cblx0XHRpZiggIW9wdGlvbiApe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoIHR5cGUgPT0gJ2l0ZW0nICl7XG5cdFx0XHRhbGxcdFx0XHQ9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRhbGxcdFx0XHQ9IHNlbGYuZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHRcdH1cblxuXHRcdGZvciggbGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG5cdFx0XHRpZiggYWxsW2ldICE9IG9wdGlvbiApe1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGRpcmVjdGlvbiA+IDAgKXtcblx0XHRcdFx0cmV0dXJuIGFsbFtpKzFdIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWxsW2ktMV0gYXMgSFRNTEVsZW1lbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG9tIGVsZW1lbnQgb2YgdGhlIGl0ZW1cblx0ICogbWF0Y2hpbmcgdGhlIGdpdmVuIHZhbHVlLlxuXHQgKlxuXHQgKi9cblx0Z2V0SXRlbShpdGVtOnN0cmluZ3xUb21JdGVtfG51bGwpOm51bGx8VG9tSXRlbSB7XG5cblx0XHRpZiggdHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcgKXtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZSA9IGhhc2hfa2V5KGl0ZW0pO1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gbnVsbFxuXHRcdFx0PyB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvcihgW2RhdGEtdmFsdWU9XCIke2FkZFNsYXNoZXModmFsdWUpfVwiXWApXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogXCJTZWxlY3RzXCIgbXVsdGlwbGUgaXRlbXMgYXQgb25jZS4gQWRkcyB0aGVtIHRvIHRoZSBsaXN0XG5cdCAqIGF0IHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuXHQgKlxuXHQgKi9cblx0YWRkSXRlbXMoIHZhbHVlczpzdHJpbmd8c3RyaW5nW10sIHNpbGVudD86Ym9vbGVhbiApOnZvaWR7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIGl0ZW1zID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG5cdFx0aXRlbXMgPSBpdGVtcy5maWx0ZXIoeCA9PiBzZWxmLml0ZW1zLmluZGV4T2YoeCkgPT09IC0xKTtcblx0XHRjb25zdCBsYXN0X2l0ZW0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcblx0XHRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0c2VsZi5pc1BlbmRpbmcgPSAoaXRlbSAhPT0gbGFzdF9pdGVtKTtcblx0XHRcdHNlbGYuYWRkSXRlbShpdGVtLCBzaWxlbnQpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFwiU2VsZWN0c1wiIGFuIGl0ZW0uIEFkZHMgaXQgdG8gdGhlIGxpc3Rcblx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdCAqXG5cdCAqL1xuXHRhZGRJdGVtKCB2YWx1ZTpzdHJpbmcsIHNpbGVudD86Ym9vbGVhbiApOnZvaWR7XG5cdFx0dmFyIGV2ZW50cyA9IHNpbGVudCA/IFtdIDogWydjaGFuZ2UnLCdkcm9wZG93bl9jbG9zZSddO1xuXG5cdFx0ZGVib3VuY2VfZXZlbnRzKHRoaXMsIGV2ZW50cywgKCkgPT4ge1xuXHRcdFx0dmFyIGl0ZW0sIHdhc0Z1bGw7XG5cdFx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHQgXHRjb25zdCBpbnB1dE1vZGUgPSBzZWxmLnNldHRpbmdzLm1vZGU7XG5cdFx0XHRjb25zdCBoYXNoZWQgPSBoYXNoX2tleSh2YWx1ZSk7XG5cblx0XHRcdGlmKCBoYXNoZWQgJiYgc2VsZi5pdGVtcy5pbmRleE9mKGhhc2hlZCkgIT09IC0xICl7XG5cblx0XHRcdFx0aWYoIGlucHV0TW9kZSA9PT0gJ3NpbmdsZScgKXtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggaW5wdXRNb2RlID09PSAnc2luZ2xlJyB8fCAhc2VsZi5zZXR0aW5ncy5kdXBsaWNhdGVzICl7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNoZWQgPT09IG51bGwgfHwgIXNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShoYXNoZWQpKSByZXR1cm47XG5cdFx0XHRpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykgc2VsZi5jbGVhcihzaWxlbnQpO1xuXHRcdFx0aWYgKGlucHV0TW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKSByZXR1cm47XG5cblx0XHRcdGl0ZW0gPSBzZWxmLl9yZW5kZXIoJ2l0ZW0nLCBzZWxmLm9wdGlvbnNbaGFzaGVkXSk7XG5cblx0XHRcdGlmKCBzZWxmLmNvbnRyb2wuY29udGFpbnMoaXRlbSkgKXsgLy8gZHVwbGljYXRlc1xuXHRcdFx0XHRpdGVtID0gaXRlbS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHdhc0Z1bGwgPSBzZWxmLmlzRnVsbCgpO1xuXHRcdFx0c2VsZi5pdGVtcy5zcGxpY2Uoc2VsZi5jYXJldFBvcywgMCwgaGFzaGVkKTtcblx0XHRcdHNlbGYuaW5zZXJ0QXRDYXJldChpdGVtKTtcblxuXHRcdFx0aWYgKHNlbGYuaXNTZXR1cCkge1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBtZW51IC8gcmVtb3ZlIHRoZSBvcHRpb24gKGlmIHRoaXMgaXMgbm90IG9uZSBpdGVtIGJlaW5nIGFkZGVkIGFzIHBhcnQgb2Ygc2VyaWVzKVxuXHRcdFx0XHRpZiggIXNlbGYuaXNQZW5kaW5nICYmIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICl7XG5cdFx0XHRcdFx0bGV0IG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKGhhc2hlZCk7XG5cdFx0XHRcdFx0bGV0IG5leHQgPSBzZWxmLmdldEFkamFjZW50KG9wdGlvbiwgMSk7XG5cdFx0XHRcdFx0aWYoIG5leHQgKXtcblx0XHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG5leHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlZnJlc2hPcHRpb25zIGFmdGVyIHNldEFjdGl2ZU9wdGlvbigpLFxuXHRcdFx0XHQvLyBvdGhlcndpc2Ugc2V0QWN0aXZlT3B0aW9uKCkgd2lsbCBiZSBjYWxsZWQgYnkgcmVmcmVzaE9wdGlvbnMoKSB3aXRoIHRoZSB3cm9uZyB2YWx1ZVxuXHRcdFx0XHRpZiggIXNlbGYuaXNQZW5kaW5nICYmICFzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QgKXtcblx0XHRcdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKHNlbGYuaXNGb2N1c2VkICYmIGlucHV0TW9kZSAhPT0gJ3NpbmdsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaGlkZSB0aGUgbWVudSBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgaGF2ZSBiZWVuIHNlbGVjdGVkIG9yIG5vIG9wdGlvbnMgYXJlIGxlZnRcblx0XHRcdFx0aWYoIHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCAhPSBmYWxzZSAmJiBzZWxmLmlzRnVsbCgpICl7XG5cdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdpdGVtX2FkZCcsIGhhc2hlZCwgaXRlbSk7XG5cblx0XHRcdFx0aWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7c2lsZW50OiBzaWxlbnR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNlbGYuaXNQZW5kaW5nIHx8ICghd2FzRnVsbCAmJiBzZWxmLmlzRnVsbCgpKSkge1xuXHRcdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNlbGVjdGVkIGl0ZW0gbWF0Y2hpbmdcblx0ICogdGhlIHByb3ZpZGVkIHZhbHVlLlxuXHQgKlxuXHQgKi9cblx0cmVtb3ZlSXRlbSggaXRlbTpzdHJpbmd8VG9tSXRlbXxudWxsPW51bGwsIHNpbGVudD86Ym9vbGVhbiApe1xuXHRcdGNvbnN0IHNlbGZcdFx0PSB0aGlzO1xuXHRcdGl0ZW1cdFx0XHQ9IHNlbGYuZ2V0SXRlbShpdGVtKTtcblxuXHRcdGlmKCAhaXRlbSApIHJldHVybjtcblxuXHRcdHZhciBpLGlkeDtcblx0XHRjb25zdCB2YWx1ZVx0PSBpdGVtLmRhdGFzZXQudmFsdWU7XG5cdFx0aSA9IG5vZGVJbmRleChpdGVtKTtcblxuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aWYoIGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSApe1xuXHRcdFx0aWR4ID0gc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuXHRcdFx0c2VsZi5hY3RpdmVJdGVtcy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdHJlbW92ZUNsYXNzZXMoaXRlbSwnYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0c2VsZi5pdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdGlmICghc2VsZi5zZXR0aW5ncy5wZXJzaXN0ICYmIHNlbGYudXNlck9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG5cdFx0XHRzZWxmLnJlbW92ZU9wdGlvbih2YWx1ZSwgc2lsZW50KTtcblx0XHR9XG5cblx0XHRpZiAoaSA8IHNlbGYuY2FyZXRQb3MpIHtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoc2VsZi5jYXJldFBvcyAtIDEpO1xuXHRcdH1cblxuXHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7c2lsZW50OiBzaWxlbnR9KTtcblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdHNlbGYudHJpZ2dlcignaXRlbV9yZW1vdmUnLCB2YWx1ZSwgaXRlbSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIHRoZSBgY3JlYXRlYCBtZXRob2QgcHJvdmlkZWQgaW4gdGhlXG5cdCAqIFRvbVNlbGVjdCBvcHRpb25zIHRoYXQgc2hvdWxkIHByb3ZpZGUgdGhlIGRhdGFcblx0ICogZm9yIHRoZSBuZXcgaXRlbSwgZ2l2ZW4gdGhlIHVzZXIgaW5wdXQuXG5cdCAqXG5cdCAqIE9uY2UgdGhpcyBjb21wbGV0ZXMsIGl0IHdpbGwgYmUgYWRkZWRcblx0ICogdG8gdGhlIGl0ZW0gbGlzdC5cblx0ICpcblx0ICovXG5cdGNyZWF0ZUl0ZW0oIGlucHV0Om51bGx8c3RyaW5nPW51bGwsIGNhbGxiYWNrOlRvbUNyZWF0ZUNhbGxiYWNrID0gKCk9Pnt9ICk6Ym9vbGVhbntcblxuXHRcdC8vIHRyaWdnZXJEcm9wZG93biBwYXJhbWV0ZXIgQGRlcHJlY2F0ZWQgMi4xLjFcblx0XHRpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApe1xuXHRcdFx0Y2FsbGJhY2sgPSBhcmd1bWVudHNbMl07XG5cdFx0fVxuXHRcdGlmKCB0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyApe1xuXHRcdFx0Y2FsbGJhY2sgPSAoKSA9PiB7fTtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiAgPSB0aGlzO1xuXHRcdHZhciBjYXJldCA9IHNlbGYuY2FyZXRQb3M7XG5cdFx0dmFyIG91dHB1dDtcblx0XHRpbnB1dCA9IGlucHV0IHx8IHNlbGYuaW5wdXRWYWx1ZSgpO1xuXG5cdFx0aWYgKCFzZWxmLmNhbkNyZWF0ZShpbnB1dCkpIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0c2VsZi5sb2NrKCk7XG5cblx0XHR2YXIgY3JlYXRlZCA9IGZhbHNlO1xuXHRcdHZhciBjcmVhdGUgPSAoZGF0YT86Ym9vbGVhbnxUb21PcHRpb24pID0+IHtcblx0XHRcdHNlbGYudW5sb2NrKCk7XG5cblx0XHRcdGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHJldHVybiBjYWxsYmFjaygpO1xuXHRcdFx0dmFyIHZhbHVlID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblx0XHRcdGlmKCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICl7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgpO1xuXHRcdFx0c2VsZi5hZGRPcHRpb24oZGF0YSx0cnVlKTtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoY2FyZXQpO1xuXHRcdFx0c2VsZi5hZGRJdGVtKHZhbHVlKTtcblx0XHRcdGNhbGxiYWNrKGRhdGEpO1xuXHRcdFx0Y3JlYXRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGlmKCB0eXBlb2Ygc2VsZi5zZXR0aW5ncy5jcmVhdGUgPT09ICdmdW5jdGlvbicgKXtcblx0XHRcdG91dHB1dCA9IHNlbGYuc2V0dGluZ3MuY3JlYXRlLmNhbGwodGhpcywgaW5wdXQsIGNyZWF0ZSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRvdXRwdXQgPSB7XG5cdFx0XHRcdFtzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdOiBpbnB1dCxcblx0XHRcdFx0W3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF06IGlucHV0LFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiggIWNyZWF0ZWQgKXtcblx0XHRcdGNyZWF0ZShvdXRwdXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlLXJlbmRlcnMgdGhlIHNlbGVjdGVkIGl0ZW0gbGlzdHMuXG5cdCAqL1xuXHRyZWZyZXNoSXRlbXMoKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblxuXHRcdGlmIChzZWxmLmlzU2V0dXApIHtcblx0XHRcdHNlbGYuYWRkSXRlbXMoc2VsZi5pdGVtcyk7XG5cdFx0fVxuXG5cdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBzdGF0ZS1kZXBlbmRlbnQgYXR0cmlidXRlc1xuXHQgKiBhbmQgQ1NTIGNsYXNzZXMuXG5cdCAqL1xuXHRyZWZyZXNoU3RhdGUoKSB7XG5cdFx0Y29uc3Qgc2VsZiAgICAgPSB0aGlzO1xuXG5cdFx0c2VsZi5yZWZyZXNoVmFsaWRpdHlTdGF0ZSgpO1xuXG5cdFx0Y29uc3QgaXNGdWxsXHQ9IHNlbGYuaXNGdWxsKCk7XG5cdFx0Y29uc3QgaXNMb2NrZWRcdD0gc2VsZi5pc0xvY2tlZDtcblxuXHRcdHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdydGwnLHNlbGYucnRsKTtcblxuXG5cdFx0Y29uc3Qgd3JhcF9jbGFzc0xpc3QgPSBzZWxmLndyYXBwZXIuY2xhc3NMaXN0O1xuXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdmb2N1cycsIHNlbGYuaXNGb2N1c2VkKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZGlzYWJsZWQnLCBzZWxmLmlzRGlzYWJsZWQpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdyZWFkb25seScsIHNlbGYuaXNSZWFkT25seSlcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ3JlcXVpcmVkJywgc2VsZi5pc1JlcXVpcmVkKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnaW52YWxpZCcsICFzZWxmLmlzVmFsaWQpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdsb2NrZWQnLCBpc0xvY2tlZClcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2Z1bGwnLCBpc0Z1bGwpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1hY3RpdmUnLCBzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZHJvcGRvd24tYWN0aXZlJywgc2VsZi5pc09wZW4pXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdoYXMtb3B0aW9ucycsIGlzRW1wdHlPYmplY3Qoc2VsZi5vcHRpb25zKSApXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdoYXMtaXRlbXMnLCBzZWxmLml0ZW1zLmxlbmd0aCA+IDApO1xuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlIG9mIGJvdGggaW5wdXQgYW5kIGNvbnRyb2wgaW5wdXQuXG5cdCAqXG5cdCAqIFRoZSBgcmVxdWlyZWRgIHByb3BlcnR5IG5lZWRzIHRvIGJlIGFjdGl2YXRlZCBvbiB0aGUgY29udHJvbCBpbnB1dFxuXHQgKiBmb3IgdGhlIGVycm9yIHRvIGJlIGRpc3BsYXllZCBhdCB0aGUgcmlnaHQgcGxhY2UuIGByZXF1aXJlZGAgYWxzb1xuXHQgKiBuZWVkcyB0byBiZSB0ZW1wb3JhcmlseSBkZWFjdGl2YXRlZCBvbiB0aGUgaW5wdXQgc2luY2UgdGhlIGlucHV0IGlzXG5cdCAqIGhpZGRlbiBhbmQgY2FuJ3Qgc2hvdyBlcnJvcnMuXG5cdCAqL1xuXHRyZWZyZXNoVmFsaWRpdHlTdGF0ZSgpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggIXNlbGYuaW5wdXQudmFsaWRpdHkgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzZWxmLmlzVmFsaWQgPSBzZWxmLmlucHV0LnZhbGlkaXR5LnZhbGlkO1xuXHRcdHNlbGYuaXNJbnZhbGlkID0gIXNlbGYuaXNWYWxpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IG1vcmUgaXRlbXMgY2FuIGJlIGFkZGVkXG5cdCAqIHRvIHRoZSBjb250cm9sIHdpdGhvdXQgZXhjZWVkaW5nIHRoZSB1c2VyLWRlZmluZWQgbWF4aW11bS5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Z1bGwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgIT09IG51bGwgJiYgdGhpcy5pdGVtcy5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy5tYXhJdGVtcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWZyZXNoZXMgdGhlIG9yaWdpbmFsIDxzZWxlY3Q+IG9yIDxpbnB1dD5cblx0ICogZWxlbWVudCB0byByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlLlxuXHQgKlxuXHQgKi9cblx0dXBkYXRlT3JpZ2luYWxJbnB1dCggb3B0czpUb21BcmdPYmplY3QgPSB7fSApe1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdHZhciBvcHRpb24sIGxhYmVsO1xuXG5cdFx0Y29uc3QgZW1wdHlfb3B0aW9uID0gc2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bdmFsdWU9XCJcIl0nKSBhcyBIVE1MT3B0aW9uRWxlbWVudDtcblxuXHRcdGlmKCBzZWxmLmlzX3NlbGVjdF90YWcgKXtcblxuXHRcdFx0Y29uc3Qgc2VsZWN0ZWQ6SFRNTE9wdGlvbkVsZW1lbnRbXVx0XHQ9IFtdO1xuXHRcdFx0Y29uc3QgaGFzX3NlbGVjdGVkOm51bWJlclx0XHRcdFx0PSBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykubGVuZ3RoO1xuXG5cdFx0XHRmdW5jdGlvbiBBZGRTZWxlY3RlZChvcHRpb25fZWw6SFRNTE9wdGlvbkVsZW1lbnR8bnVsbCwgdmFsdWU6c3RyaW5nLCBsYWJlbDpzdHJpbmcpOkhUTUxPcHRpb25FbGVtZW50e1xuXG5cdFx0XHRcdGlmKCAhb3B0aW9uX2VsICl7XG5cdFx0XHRcdFx0b3B0aW9uX2VsID0gZ2V0RG9tKCc8b3B0aW9uIHZhbHVlPVwiJyArIGVzY2FwZV9odG1sKHZhbHVlKSArICdcIj4nICsgZXNjYXBlX2h0bWwobGFiZWwpICsgJzwvb3B0aW9uPicpIGFzIEhUTUxPcHRpb25FbGVtZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZG9uJ3QgbW92ZSBlbXB0eSBvcHRpb24gZnJvbSB0b3Agb2YgbGlzdFxuXHRcdFx0XHQvLyBmaXhlcyBidWcgaW4gZmlyZWZveCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzI1MjkzXG5cdFx0XHRcdGlmKCBvcHRpb25fZWwgIT0gZW1wdHlfb3B0aW9uICl7XG5cdFx0XHRcdFx0c2VsZi5pbnB1dC5hcHBlbmQob3B0aW9uX2VsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNlbGVjdGVkLnB1c2gob3B0aW9uX2VsKTtcblxuXHRcdFx0XHQvLyBtYXJraW5nIGVtcHR5IG9wdGlvbiBhcyBzZWxlY3RlZCBjYW4gYnJlYWsgdmFsaWRhdGlvblxuXHRcdFx0XHQvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdG9tLXNlbGVjdC9pc3N1ZXMvMzAzXG5cdFx0XHRcdGlmKCBvcHRpb25fZWwgIT0gZW1wdHlfb3B0aW9uIHx8IGhhc19zZWxlY3RlZCA+IDAgKXtcblx0XHRcdFx0XHRvcHRpb25fZWwuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9wdGlvbl9lbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdW5zZWxlY3QgYWxsIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdHNlbGYuaW5wdXQucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uOmNoZWNrZWQnKS5mb3JFYWNoKChvcHRpb25fZWw6RWxlbWVudCkgPT4ge1xuXHRcdFx0XHQoPEhUTUxPcHRpb25FbGVtZW50Pm9wdGlvbl9lbCkuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIG5vdGhpbmcgc2VsZWN0ZWQ/XG5cdFx0XHRpZiggc2VsZi5pdGVtcy5sZW5ndGggPT0gMCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT0gJ3NpbmdsZScgKXtcblxuXHRcdFx0XHRBZGRTZWxlY3RlZChlbXB0eV9vcHRpb24sIFwiXCIsIFwiXCIpO1xuXG5cdFx0XHQvLyBvcmRlciBzZWxlY3RlZCA8b3B0aW9uPiB0YWdzIGZvciB2YWx1ZXMgaW4gc2VsZi5pdGVtc1xuXHRcdFx0fWVsc2V7XG5cblx0XHRcdFx0c2VsZi5pdGVtcy5mb3JFYWNoKCh2YWx1ZSk9Pntcblx0XHRcdFx0XHRvcHRpb25cdFx0XHQ9IHNlbGYub3B0aW9uc1t2YWx1ZV0hO1xuXHRcdFx0XHRcdGxhYmVsXHRcdFx0PSBvcHRpb25bc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXSB8fCAnJztcblxuXHRcdFx0XHRcdGlmKCBzZWxlY3RlZC5pbmNsdWRlcyhvcHRpb24uJG9wdGlvbikgKXtcblx0XHRcdFx0XHRcdGNvbnN0IHJldXNlX29wdCA9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3Rvcihgb3B0aW9uW3ZhbHVlPVwiJHthZGRTbGFzaGVzKHZhbHVlKX1cIl06bm90KDpjaGVja2VkKWApIGFzIEhUTUxPcHRpb25FbGVtZW50O1xuXHRcdFx0XHRcdFx0QWRkU2VsZWN0ZWQocmV1c2Vfb3B0LCB2YWx1ZSwgbGFiZWwpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0b3B0aW9uLiRvcHRpb25cdD0gQWRkU2VsZWN0ZWQob3B0aW9uLiRvcHRpb24sIHZhbHVlLCBsYWJlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuaW5wdXQudmFsdWUgPSBzZWxmLmdldFZhbHVlKCkgYXMgc3RyaW5nO1xuXHRcdH1cblxuXHRcdGlmIChzZWxmLmlzU2V0dXApIHtcblx0XHRcdGlmICghb3B0cy5zaWxlbnQpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdjaGFuZ2UnLCBzZWxmLmdldFZhbHVlKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBjb250YWluaW5nXG5cdCAqIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cblx0ICovXG5cdG9wZW4oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKHNlbGYuaXNMb2NrZWQgfHwgc2VsZi5pc09wZW4gfHwgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKSkgcmV0dXJuO1xuXHRcdHNlbGYuaXNPcGVuID0gdHJ1ZTtcblx0XHRzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSx7J2FyaWEtZXhwYW5kZWQnOiAndHJ1ZSd9KTtcblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdGFwcGx5Q1NTKHNlbGYuZHJvcGRvd24se3Zpc2liaWxpdHk6ICdoaWRkZW4nLCBkaXNwbGF5OiAnYmxvY2snfSk7XG5cdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0YXBwbHlDU1Moc2VsZi5kcm9wZG93bix7dmlzaWJpbGl0eTogJ3Zpc2libGUnLCBkaXNwbGF5OiAnYmxvY2snfSk7XG5cdFx0c2VsZi5mb2N1cygpO1xuXHRcdHNlbGYudHJpZ2dlcignZHJvcGRvd25fb3BlbicsIHNlbGYuZHJvcGRvd24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAqL1xuXHRjbG9zZShzZXRUZXh0Ym94VmFsdWU9dHJ1ZSkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgdHJpZ2dlciA9IHNlbGYuaXNPcGVuO1xuXG5cdFx0aWYoIHNldFRleHRib3hWYWx1ZSApe1xuXG5cdFx0XHQvLyBiZWZvcmUgYmx1cigpIHRvIHByZXZlbnQgZm9ybSBvbmNoYW5nZSBldmVudFxuXHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcblxuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5pc09wZW4gPSBmYWxzZTtcblx0XHRzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSx7J2FyaWEtZXhwYW5kZWQnOiAnZmFsc2UnfSk7XG5cdFx0YXBwbHlDU1Moc2VsZi5kcm9wZG93bix7ZGlzcGxheTogJ25vbmUnfSk7XG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICl7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7XG5cdFx0fVxuXHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cblx0XHRpZiAodHJpZ2dlcikgc2VsZi50cmlnZ2VyKCdkcm9wZG93bl9jbG9zZScsIHNlbGYuZHJvcGRvd24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYW5kIGFwcGxpZXMgdGhlIGFwcHJvcHJpYXRlXG5cdCAqIHBvc2l0aW9uIG9mIHRoZSBkcm9wZG93biBpZiBkcm9wZG93blBhcmVudCA9ICdib2R5Jy5cblx0ICogT3RoZXJ3aXNlLCBwb3NpdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGNzc1xuXHQgKi9cblx0cG9zaXRpb25Ecm9wZG93bigpe1xuXG5cdFx0aWYoIHRoaXMuc2V0dGluZ3MuZHJvcGRvd25QYXJlbnQgIT09ICdib2R5JyApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjb250ZXh0XHRcdFx0PSB0aGlzLmNvbnRyb2w7XG5cdFx0dmFyIHJlY3RcdFx0XHQ9IGNvbnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0dmFyIHRvcFx0XHRcdFx0PSBjb250ZXh0Lm9mZnNldEhlaWdodCArIHJlY3QudG9wICArIHdpbmRvdy5zY3JvbGxZO1xuXHRcdHZhciBsZWZ0XHRcdFx0PSByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcblxuXG5cdFx0YXBwbHlDU1ModGhpcy5kcm9wZG93bix7XG5cdFx0XHR3aWR0aCA6IHJlY3Qud2lkdGggKyAncHgnLFxuXHRcdFx0dG9wICAgOiB0b3AgKyAncHgnLFxuXHRcdFx0bGVmdCAgOiBsZWZ0ICsgJ3B4J1xuXHRcdH0pO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIC8gY2xlYXJzIGFsbCBzZWxlY3RlZCBpdGVtc1xuXHQgKiBmcm9tIHRoZSBjb250cm9sLlxuXHQgKlxuXHQgKi9cblx0Y2xlYXIoc2lsZW50Pzpib29sZWFuKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCFzZWxmLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0dmFyIGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0XHRpdGVyYXRlKGl0ZW1zLChpdGVtOlRvbUl0ZW0pPT57XG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0oaXRlbSx0cnVlKTtcblx0XHR9KTtcblxuXHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdGlmKCAhc2lsZW50ICkgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdFx0c2VsZi50cmlnZ2VyKCdjbGVhcicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgaGVscGVyIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIGFuIGVsZW1lbnRcblx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdCAqXG5cdCAqL1xuXHRpbnNlcnRBdENhcmV0KGVsOkhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3Qgc2VsZlx0XHQ9IHRoaXM7XG5cdFx0Y29uc3QgY2FyZXRcdFx0PSBzZWxmLmNhcmV0UG9zO1xuXHRcdGNvbnN0IHRhcmdldFx0PSBzZWxmLmNvbnRyb2w7XG5cblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQuY2hpbGRyZW5bY2FyZXRdIHx8IG51bGwpO1xuXHRcdHNlbGYuc2V0Q2FyZXQoY2FyZXQgKyAxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHNlbGVjdGVkIGl0ZW0ocykuXG5cdCAqXG5cdCAqL1xuXHRkZWxldGVTZWxlY3Rpb24oZTpLZXlib2FyZEV2ZW50KTpib29sZWFuIHtcblx0XHR2YXIgZGlyZWN0aW9uLCBzZWxlY3Rpb24sIGNhcmV0LCB0YWlsO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGRpcmVjdGlvbiA9IChlICYmIGUua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9CQUNLU1BBQ0UpID8gLTEgOiAxO1xuXHRcdHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihzZWxmLmNvbnRyb2xfaW5wdXQpO1xuXG5cblx0XHQvLyBkZXRlcm1pbmUgaXRlbXMgdGhhdCB3aWxsIGJlIHJlbW92ZWRcblx0XHRjb25zdCBybV9pdGVtczpUb21JdGVtW11cdD0gW107XG5cblx0XHRpZiAoc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGgpIHtcblxuXHRcdFx0dGFpbCA9IGdldFRhaWwoc2VsZi5hY3RpdmVJdGVtcywgZGlyZWN0aW9uKTtcblx0XHRcdGNhcmV0ID0gbm9kZUluZGV4KHRhaWwpO1xuXG5cdFx0XHRpZiAoZGlyZWN0aW9uID4gMCkgeyBjYXJldCsrOyB9XG5cblx0XHRcdGl0ZXJhdGUoc2VsZi5hY3RpdmVJdGVtcywgKGl0ZW06VG9tSXRlbSkgPT4gcm1faXRlbXMucHVzaChpdGVtKSApO1xuXG5cdFx0fSBlbHNlIGlmICgoc2VsZi5pc0ZvY3VzZWQgfHwgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0XHRcdGxldCBybV9pdGVtO1xuXHRcdFx0aWYoIGRpcmVjdGlvbiA8IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbi5sZW5ndGggPT09IDAgKXtcblx0XHRcdFx0cm1faXRlbSA9IGl0ZW1zW3NlbGYuY2FyZXRQb3MgLSAxXTtcblxuXHRcdFx0fWVsc2UgaWYoIGRpcmVjdGlvbiA+IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxmLmlucHV0VmFsdWUoKS5sZW5ndGggKXtcblx0XHRcdFx0cm1faXRlbSA9IGl0ZW1zW3NlbGYuY2FyZXRQb3NdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggcm1faXRlbSAhPT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdHJtX2l0ZW1zLnB1c2goIHJtX2l0ZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiggIXNlbGYuc2hvdWxkRGVsZXRlKHJtX2l0ZW1zLGUpICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJldmVudERlZmF1bHQoZSx0cnVlKTtcblxuXHRcdC8vIHBlcmZvcm0gcmVtb3ZhbFxuXHRcdGlmICh0eXBlb2YgY2FyZXQgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRzZWxmLnNldENhcmV0KGNhcmV0KTtcblx0XHR9XG5cblx0XHR3aGlsZSggcm1faXRlbXMubGVuZ3RoICl7XG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0ocm1faXRlbXMucG9wKCkpO1xuXHRcdH1cblxuXHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRydWUgaWYgdGhlIGl0ZW1zIHNob3VsZCBiZSBkZWxldGVkXG5cdCAqL1xuXHRzaG91bGREZWxldGUoaXRlbXM6VG9tSXRlbVtdLGV2dDpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpe1xuXG5cdFx0Y29uc3QgdmFsdWVzID0gaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhc2V0LnZhbHVlKTtcblxuXHRcdC8vIGFsbG93IHRoZSBjYWxsYmFjayB0byBhYm9ydFxuXHRcdGlmKCAhdmFsdWVzLmxlbmd0aCB8fCAodHlwZW9mIHRoaXMuc2V0dGluZ3Mub25EZWxldGUgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5zZXR0aW5ncy5vbkRlbGV0ZSh2YWx1ZXMsZXZ0KSA9PT0gZmFsc2UpICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0cyB0aGUgcHJldmlvdXMgLyBuZXh0IGl0ZW0gKGRlcGVuZGluZyBvbiB0aGUgYGRpcmVjdGlvbmAgYXJndW1lbnQpLlxuXHQgKlxuXHQgKiA+IDAgLSByaWdodFxuXHQgKiA8IDAgLSBsZWZ0XG5cdCAqXG5cdCAqL1xuXHRhZHZhbmNlU2VsZWN0aW9uKGRpcmVjdGlvbjpudW1iZXIsIGU/Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCkge1xuXHRcdHZhciBsYXN0X2FjdGl2ZSwgYWRqYWNlbnQsIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKHNlbGYucnRsKSBkaXJlY3Rpb24gKj0gLTE7XG5cdFx0aWYoIHNlbGYuaW5wdXRWYWx1ZSgpLmxlbmd0aCApIHJldHVybjtcblxuXG5cdFx0Ly8gYWRkIG9yIHJlbW92ZSB0byBhY3RpdmUgaXRlbXNcblx0XHRpZiggaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgfHwgaXNLZXlEb3duKCdzaGlmdEtleScsZSkgKXtcblxuXHRcdFx0bGFzdF9hY3RpdmVcdFx0XHQ9IHNlbGYuZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pO1xuXHRcdFx0aWYoIGxhc3RfYWN0aXZlICl7XG5cblx0XHRcdFx0aWYoICFsYXN0X2FjdGl2ZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRcdFx0YWRqYWNlbnRcdFx0XHQ9IGxhc3RfYWN0aXZlO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRhZGphY2VudFx0XHRcdD0gc2VsZi5nZXRBZGphY2VudChsYXN0X2FjdGl2ZSxkaXJlY3Rpb24sJ2l0ZW0nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBubyBhY3RpdmUgaXRlbSwgZ2V0IGl0ZW1zIGFkamFjZW50IHRvIHRoZSBjb250cm9sIGlucHV0XG5cdFx0XHR9ZWxzZSBpZiggZGlyZWN0aW9uID4gMCApe1xuXHRcdFx0XHRhZGphY2VudFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0Lm5leHRFbGVtZW50U2libGluZztcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRhZGphY2VudFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYoIGFkamFjZW50ICl7XG5cdFx0XHRcdGlmKCBhZGphY2VudC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRcdFx0c2VsZi5yZW1vdmVBY3RpdmVJdGVtKGxhc3RfYWN0aXZlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhhZGphY2VudCk7IC8vIG1hcmsgYXMgbGFzdF9hY3RpdmUgISEgYWZ0ZXIgcmVtb3ZlQWN0aXZlSXRlbSgpIG9uIGxhc3RfYWN0aXZlXG5cdFx0XHR9XG5cblx0XHQvLyBtb3ZlIGNhcmV0IHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLm1vdmVDYXJldChkaXJlY3Rpb24pO1xuXHRcdH1cblx0fVxuXG5cdG1vdmVDYXJldChkaXJlY3Rpb246bnVtYmVyKXt9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbGFzdCBhY3RpdmUgaXRlbVxuXHQgKlxuXHQgKi9cblx0Z2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24/Om51bWJlcil7XG5cblx0XHRsZXQgbGFzdF9hY3RpdmUgPSB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvcignLmxhc3QtYWN0aXZlJyk7XG5cdFx0aWYoIGxhc3RfYWN0aXZlICl7XG5cdFx0XHRyZXR1cm4gbGFzdF9hY3RpdmU7XG5cdFx0fVxuXG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hY3RpdmUnKTtcblx0XHRpZiggcmVzdWx0ICl7XG5cdFx0XHRyZXR1cm4gZ2V0VGFpbChyZXN1bHQsZGlyZWN0aW9uKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuXHQgKiBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuXHQgKiBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcblx0ICpcblx0ICovXG5cdHNldENhcmV0KG5ld19wb3M6bnVtYmVyKSB7XG5cdFx0dGhpcy5jYXJldFBvcyA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBsaXN0IG9mIGl0ZW0gZG9tIGVsZW1lbnRzXG5cdCAqXG5cdCAqL1xuXHRjb250cm9sQ2hpbGRyZW4oKTpUb21JdGVtW117XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oIHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10cy1pdGVtXScpICkgYXMgVG9tSXRlbVtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wuIFVzZWQgd2hpbGVcblx0ICogaXRlbXMgYXJlIGJlaW5nIGFzeW5jaHJvbm91c2x5IGNyZWF0ZWQuXG5cdCAqL1xuXHRsb2NrKCkge1xuXHRcdHRoaXMuc2V0TG9ja2VkKHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlLWVuYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbC5cblx0ICovXG5cdHVubG9jaygpIHtcblx0XHR0aGlzLnNldExvY2tlZChmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZSBvciBlbmFibGUgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbFxuXHQgKi9cblx0c2V0TG9ja2VkKCBsb2NrOmJvb2xlYW4gPSB0aGlzLmlzUmVhZE9ubHkgfHwgdGhpcy5pc0Rpc2FibGVkICl7XG5cdFx0dGhpcy5pc0xvY2tlZCA9IGxvY2s7XG5cdFx0dGhpcy5yZWZyZXNoU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sIGNvbXBsZXRlbHkuXG5cdCAqIFdoaWxlIGRpc2FibGVkLCBpdCBjYW5ub3QgcmVjZWl2ZSBmb2N1cy5cblx0ICovXG5cdGRpc2FibGUoKSB7XG5cdFx0dGhpcy5zZXREaXNhYmxlZCh0cnVlKTtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyB0aGUgY29udHJvbCBzbyB0aGF0IGl0IGNhbiByZXNwb25kXG5cdCAqIHRvIGZvY3VzIGFuZCB1c2VyIGlucHV0LlxuXHQgKi9cblx0ZW5hYmxlKCkge1xuXHRcdHRoaXMuc2V0RGlzYWJsZWQoZmFsc2UpO1xuXHR9XG5cblx0c2V0RGlzYWJsZWQoZGlzYWJsZWQ6Ym9vbGVhbil7XG5cdFx0dGhpcy5mb2N1c19ub2RlLnRhYkluZGV4XHRcdD0gZGlzYWJsZWQgPyAtMSA6IHRoaXMudGFiSW5kZXg7XG5cdFx0dGhpcy5pc0Rpc2FibGVkXHRcdFx0XHRcdD0gZGlzYWJsZWQ7XG5cdFx0dGhpcy5pbnB1dC5kaXNhYmxlZFx0XHRcdFx0PSBkaXNhYmxlZDtcblx0XHR0aGlzLmNvbnRyb2xfaW5wdXQuZGlzYWJsZWRcdFx0PSBkaXNhYmxlZDtcblx0XHR0aGlzLnNldExvY2tlZCgpO1xuXHR9XG5cblx0c2V0UmVhZE9ubHkoaXNSZWFkT25seTpib29sZWFuKXtcblx0XHR0aGlzLmlzUmVhZE9ubHlcdFx0XHRcdFx0PSBpc1JlYWRPbmx5O1xuXHRcdHRoaXMuaW5wdXQucmVhZE9ubHlcdFx0XHRcdD0gaXNSZWFkT25seTtcblx0XHR0aGlzLmNvbnRyb2xfaW5wdXQucmVhZE9ubHlcdFx0PSBpc1JlYWRPbmx5O1xuXHRcdHRoaXMuc2V0TG9ja2VkKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcGxldGVseSBkZXN0cm95cyB0aGUgY29udHJvbCBhbmRcblx0ICogdW5iaW5kcyBhbGwgZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXQgaXQgY2FuXG5cdCAqIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHJldmVydFNldHRpbmdzID0gc2VsZi5yZXZlcnRTZXR0aW5ncztcblxuXHRcdHNlbGYudHJpZ2dlcignZGVzdHJveScpO1xuXHRcdHNlbGYub2ZmKCk7XG5cdFx0c2VsZi53cmFwcGVyLnJlbW92ZSgpO1xuXHRcdHNlbGYuZHJvcGRvd24ucmVtb3ZlKCk7XG5cblx0XHRzZWxmLmlucHV0LmlubmVySFRNTCA9IHJldmVydFNldHRpbmdzLmlubmVySFRNTDtcblx0XHRzZWxmLmlucHV0LnRhYkluZGV4ID0gcmV2ZXJ0U2V0dGluZ3MudGFiSW5kZXg7XG5cblx0XHRyZW1vdmVDbGFzc2VzKHNlbGYuaW5wdXQsJ3RvbXNlbGVjdGVkJywndHMtaGlkZGVuLWFjY2Vzc2libGUnKTtcblxuXHRcdHNlbGYuX2Rlc3Ryb3koKTtcblxuXHRcdGRlbGV0ZSBzZWxmLmlucHV0LnRvbXNlbGVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGhlbHBlciBtZXRob2QgZm9yIHJlbmRlcmluZyBcIml0ZW1cIiBhbmRcblx0ICogXCJvcHRpb25cIiB0ZW1wbGF0ZXMsIGdpdmVuIHRoZSBkYXRhLlxuXHQgKlxuXHQgKi9cblx0cmVuZGVyKCB0ZW1wbGF0ZU5hbWU6VG9tVGVtcGxhdGVOYW1lcywgZGF0YT86YW55ICk6bnVsbHxIVE1MRWxlbWVudHtcblx0XHR2YXIgaWQsIGh0bWw7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggdHlwZW9mIHRoaXMuc2V0dGluZ3MucmVuZGVyW3RlbXBsYXRlTmFtZV0gIT09ICdmdW5jdGlvbicgKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIHJlbmRlciBtYXJrdXBcblx0XHRodG1sID0gc2VsZi5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXS5jYWxsKHRoaXMsIGRhdGEsIGVzY2FwZV9odG1sKTtcblxuXHRcdGlmKCAhaHRtbCApe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aHRtbCA9IGdldERvbSggaHRtbCApO1xuXG5cdFx0Ly8gYWRkIG1hbmRhdG9yeSBhdHRyaWJ1dGVzXG5cdFx0aWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnb3B0aW9uX2NyZWF0ZScpIHtcblxuXHRcdFx0aWYoIGRhdGFbc2VsZi5zZXR0aW5ncy5kaXNhYmxlZEZpZWxkXSApe1xuXHRcdFx0XHRzZXRBdHRyKGh0bWwseydhcmlhLWRpc2FibGVkJzondHJ1ZSd9KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRzZXRBdHRyKGh0bWwseydkYXRhLXNlbGVjdGFibGUnOiAnJ30pO1xuXHRcdFx0fVxuXG5cdFx0fWVsc2UgaWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGdyb3VwJykge1xuXHRcdFx0aWQgPSBkYXRhLmdyb3VwW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXTtcblx0XHRcdHNldEF0dHIoaHRtbCx7J2RhdGEtZ3JvdXAnOiBpZH0pO1xuXHRcdFx0aWYoZGF0YS5ncm91cFtzZWxmLnNldHRpbmdzLmRpc2FibGVkRmllbGRdKSB7XG5cdFx0XHRcdHNldEF0dHIoaHRtbCx7J2RhdGEtZGlzYWJsZWQnOiAnJ30pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRjb25zdCB2YWx1ZVx0PSBnZXRfaGFzaChkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdFx0c2V0QXR0cihodG1sLHsnZGF0YS12YWx1ZSc6IHZhbHVlIH0pO1xuXG5cblx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNvbWUgY2xhc3NlcyBpZiBhIHRlbXBsYXRlIGlzIG92ZXJ3cml0dGVuXG5cdFx0XHRpZiggdGVtcGxhdGVOYW1lID09PSAnaXRlbScgKXtcblx0XHRcdFx0YWRkQ2xhc3NlcyhodG1sLHNlbGYuc2V0dGluZ3MuaXRlbUNsYXNzKTtcblx0XHRcdFx0c2V0QXR0cihodG1sLHsnZGF0YS10cy1pdGVtJzonJ30pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGFkZENsYXNzZXMoaHRtbCxzZWxmLnNldHRpbmdzLm9wdGlvbkNsYXNzKTtcblx0XHRcdFx0c2V0QXR0cihodG1sLHtcblx0XHRcdFx0XHRyb2xlOidvcHRpb24nLFxuXHRcdFx0XHRcdGlkOmRhdGEuJGlkXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYWNoZVxuXHRcdFx0XHRkYXRhLiRkaXYgPSBodG1sO1xuXHRcdFx0XHRzZWxmLm9wdGlvbnNbdmFsdWVdID0gZGF0YTtcblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWw7XG5cblx0fVxuXG5cblx0LyoqXG5cdCAqIFR5cGUgZ3VhcmRlZCByZW5kZXJpbmdcblx0ICpcblx0ICovXG5cdF9yZW5kZXIoIHRlbXBsYXRlTmFtZTpUb21UZW1wbGF0ZU5hbWVzLCBkYXRhPzphbnkgKTpIVE1MRWxlbWVudHtcblx0XHRjb25zdCBodG1sID0gdGhpcy5yZW5kZXIodGVtcGxhdGVOYW1lLCBkYXRhKTtcblxuXHRcdGlmKCBodG1sID09IG51bGwgKXtcblx0XHRcdHRocm93ICdIVE1MRWxlbWVudCBleHBlY3RlZCc7XG5cdFx0fVxuXHRcdHJldHVybiBodG1sO1xuXHR9XG5cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSByZW5kZXIgY2FjaGUgZm9yIGEgdGVtcGxhdGUuIElmXG5cdCAqIG5vIHRlbXBsYXRlIGlzIGdpdmVuLCBjbGVhcnMgYWxsIHJlbmRlclxuXHQgKiBjYWNoZXMuXG5cdCAqXG5cdCAqL1xuXHRjbGVhckNhY2hlKCk6dm9pZHtcblxuXHRcdGl0ZXJhdGUodGhpcy5vcHRpb25zLCAob3B0aW9uOlRvbU9wdGlvbik9Pntcblx0XHRcdGlmKCBvcHRpb24uJGRpdiApe1xuXHRcdFx0XHRvcHRpb24uJGRpdi5yZW1vdmUoKTtcblx0XHRcdFx0ZGVsZXRlIG9wdGlvbi4kZGl2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gaXRlbSBhbmQgb3B0aW9uIGNhY2hlc1xuXHQgKlxuXHQgKi9cblx0dW5jYWNoZVZhbHVlKHZhbHVlOnN0cmluZyl7XG5cblx0XHRjb25zdCBvcHRpb25fZWxcdFx0XHQ9IHRoaXMuZ2V0T3B0aW9uKHZhbHVlKTtcblx0XHRpZiggb3B0aW9uX2VsICkgb3B0aW9uX2VsLnJlbW92ZSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBkaXNwbGF5IHRoZVxuXHQgKiBjcmVhdGUgaXRlbSBwcm9tcHQsIGdpdmVuIGEgdXNlciBpbnB1dC5cblx0ICpcblx0ICovXG5cdGNhbkNyZWF0ZSggaW5wdXQ6c3RyaW5nICk6Ym9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MuY3JlYXRlICYmIChpbnB1dC5sZW5ndGggPiAwKSAmJiAodGhpcy5zZXR0aW5ncy5jcmVhdGVGaWx0ZXIgYXMgVG9tQ3JlYXRlRmlsdGVyICkuY2FsbCh0aGlzLCBpbnB1dCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBXcmFwcyB0aGlzLmBtZXRob2RgIHNvIHRoYXQgYG5ld19mbmAgY2FuIGJlIGludm9rZWQgJ2JlZm9yZScsICdhZnRlcicsIG9yICdpbnN0ZWFkJyBvZiB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdCAqXG5cdCAqIHRoaXMuaG9vaygnaW5zdGVhZCcsJ29uS2V5RG93bicsZnVuY3Rpb24oIGFyZzEsIGFyZzIgLi4uKXtcblx0ICpcblx0ICogfSk7XG5cdCAqL1xuXHRob29rKCB3aGVuOnN0cmluZywgbWV0aG9kOnN0cmluZywgbmV3X2ZuOmFueSApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgb3JpZ19tZXRob2QgPSBzZWxmW21ldGhvZF07XG5cblxuXHRcdHNlbGZbbWV0aG9kXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVzdWx0LCByZXN1bHRfbmV3O1xuXG5cdFx0XHRpZiggd2hlbiA9PT0gJ2FmdGVyJyApe1xuXHRcdFx0XHRyZXN1bHQgPSBvcmlnX21ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHRfbmV3ID0gbmV3X2ZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRpZiggd2hlbiA9PT0gJ2luc3RlYWQnICl7XG5cdFx0XHRcdHJldHVybiByZXN1bHRfbmV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggd2hlbiA9PT0gJ2JlZm9yZScgKXtcblx0XHRcdFx0cmVzdWx0ID0gb3JpZ19tZXRob2QuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdH1cblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJjaGFuZ2VfbGlzdGVuZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgYWRkRXZlbnQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdGFkZEV2ZW50KHRoaXMuaW5wdXQsJ2NoYW5nZScsKCk9Pntcblx0XHR0aGlzLnN5bmMoKTtcblx0fSk7XG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImNoZWNrYm94X29wdGlvbnNcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgcHJldmVudERlZmF1bHQsIGhhc2hfa2V5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RG9tIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5pbXBvcnQgeyBDQk9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdXNlck9wdGlvbnM6Q0JPcHRpb25zKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIG9yaWdfb25PcHRpb25TZWxlY3QgPSBzZWxmLm9uT3B0aW9uU2VsZWN0O1xuXG5cdHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkID0gZmFsc2U7XG5cblx0Y29uc3QgY2JPcHRpb25zIDogQ0JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Ly8gc28gdGhhdCB0aGUgdXNlciBtYXkgYWRkIGRpZmZlcmVudCBvbmVzIGFzIHdlbGxcblx0XHRjbGFzc05hbWUgICAgICAgICAgICAgOiBcInRvbXNlbGVjdC1jaGVja2JveFwiLFxuXG5cdFx0Ly8gdGhlIGZvbGxvd2luZyBkZWZhdWx0IHRvIHRoZSBoaXN0b3JpYyBwbHVnaW4ncyB2YWx1ZXNcblx0XHRjaGVja2VkQ2xhc3NOYW1lcyAgICAgOiB1bmRlZmluZWQsXG5cdFx0dW5jaGVja2VkQ2xhc3NOYW1lcyAgIDogdW5kZWZpbmVkLFxuXHR9LCB1c2VyT3B0aW9ucyk7XG5cblxuXHR2YXIgVXBkYXRlQ2hlY2tlZCA9IGZ1bmN0aW9uKGNoZWNrYm94OkhUTUxJbnB1dEVsZW1lbnQsIHRvQ2hlY2sgOiBib29sZWFuKSB7XG5cdFx0aWYoIHRvQ2hlY2sgKXtcblx0XHRcdGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcykge1xuXHRcdFx0XHRjaGVja2JveC5jbGFzc0xpc3QuYWRkKC4uLmNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcyk7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHRpZiAoY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYk9wdGlvbnMudW5jaGVja2VkQ2xhc3NOYW1lcykge1xuXHRcdFx0XHRjaGVja2JveC5jbGFzc0xpc3QuYWRkKC4uLmNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyB1cGRhdGUgdGhlIGNoZWNrYm94IGZvciBhbiBvcHRpb25cblx0dmFyIFVwZGF0ZUNoZWNrYm94ID0gZnVuY3Rpb24ob3B0aW9uOkhUTUxFbGVtZW50KXtcblx0XHRzZXRUaW1lb3V0KCgpPT57XG5cdFx0XHR2YXIgY2hlY2tib3ggPSBvcHRpb24ucXVlcnlTZWxlY3RvcignaW5wdXQuJyArIGNiT3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdFx0aWYoIGNoZWNrYm94IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCApe1xuXHRcdFx0XHRVcGRhdGVDaGVja2VkKGNoZWNrYm94LCBvcHRpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKTtcblx0XHRcdH1cblx0XHR9LDEpO1xuXHR9O1xuXG5cdC8vIGFkZCBjaGVja2JveCB0byBvcHRpb24gdGVtcGxhdGVcblx0c2VsZi5ob29rKCdhZnRlcicsJ3NldHVwVGVtcGxhdGVzJywoKSA9PiB7XG5cblx0XHR2YXIgb3JpZ19yZW5kZXJfb3B0aW9uID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIub3B0aW9uO1xuXG5cdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIub3B0aW9uID0gKGRhdGEsIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHR2YXIgcmVuZGVyZWQgPSBnZXREb20ob3JpZ19yZW5kZXJfb3B0aW9uLmNhbGwoc2VsZiwgZGF0YSwgZXNjYXBlX2h0bWwpKTtcblx0XHRcdHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRpZiAoY2JPcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRjaGVja2JveC5jbGFzc0xpc3QuYWRkKGNiT3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG5cdFx0XHRjb25zdCBoYXNoZWQgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXG5cdFx0XHRVcGRhdGVDaGVja2VkKGNoZWNrYm94LCAhIShoYXNoZWQgJiYgc2VsZi5pdGVtcy5pbmRleE9mKGhhc2hlZCkgPiAtMSkgKTtcblxuXHRcdFx0cmVuZGVyZWQucHJlcGVuZChjaGVja2JveCk7XG5cdFx0XHRyZXR1cm4gcmVuZGVyZWQ7XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gdW5jaGVjayB3aGVuIGl0ZW0gcmVtb3ZlZFxuXHRzZWxmLm9uKCdpdGVtX3JlbW92ZScsKHZhbHVlOnN0cmluZykgPT4ge1xuXHRcdHZhciBvcHRpb24gPSBzZWxmLmdldE9wdGlvbih2YWx1ZSk7XG5cblx0XHRpZiggb3B0aW9uICl7IC8vIGlmIGRyb3Bkb3duIGhhc24ndCBiZWVuIG9wZW5lZCB5ZXQsIHRoZSBvcHRpb24gd29uJ3QgZXhpc3Rcblx0XHRcdG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpOyAvLyBzZWxlY3RlZCBjbGFzcyB3b24ndCBiZSByZW1vdmVkIHlldFxuXHRcdFx0VXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGNoZWNrIHdoZW4gaXRlbSBhZGRlZFxuXHRzZWxmLm9uKCdpdGVtX2FkZCcsKHZhbHVlOnN0cmluZykgPT4ge1xuXHRcdHZhciBvcHRpb24gPSBzZWxmLmdldE9wdGlvbih2YWx1ZSk7XG5cblx0XHRpZiggb3B0aW9uICl7IC8vIGlmIGRyb3Bkb3duIGhhc24ndCBiZWVuIG9wZW5lZCB5ZXQsIHRoZSBvcHRpb24gd29uJ3QgZXhpc3Rcblx0XHRcdFVwZGF0ZUNoZWNrYm94KG9wdGlvbik7XG5cdFx0fVxuXHR9KTtcblxuXG5cdC8vIHJlbW92ZSBpdGVtcyB3aGVuIHNlbGVjdGVkIG9wdGlvbiBpcyBjbGlja2VkXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ29uT3B0aW9uU2VsZWN0JywoIGV2dDpLZXlib2FyZEV2ZW50LCBvcHRpb246SFRNTEVsZW1lbnQgKT0+e1xuXG5cdFx0aWYoIG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykgKXtcblx0XHRcdG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpXG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0ob3B0aW9uLmRhdGFzZXQudmFsdWUpO1xuXHRcdFx0c2VsZi5yZWZyZXNoT3B0aW9ucygpO1xuXHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0cmV0dXJuO1xuICAgICAgICB9XG5cblx0XHRvcmlnX29uT3B0aW9uU2VsZWN0LmNhbGwoc2VsZiwgZXZ0LCBvcHRpb24pO1xuXG5cdFx0VXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faGVhZGVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGdldERvbSB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgQ0JPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0LCB1c2VyT3B0aW9uczpDQk9wdGlvbnMpIHtcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGNsYXNzTmFtZTogJ2NsZWFyLWJ1dHRvbicsXG5cdFx0dGl0bGU6ICdDbGVhciBBbGwnLFxuXHRcdGh0bWw6IChkYXRhOkNCT3B0aW9ucykgPT4ge1xuXHRcdFx0cmV0dXJuIGA8ZGl2IGNsYXNzPVwiJHtkYXRhLmNsYXNzTmFtZX1cIiB0aXRsZT1cIiR7ZGF0YS50aXRsZX1cIj4mIzEwNzk5OzwvZGl2PmA7XG5cdFx0fVxuXHR9LCB1c2VyT3B0aW9ucyk7XG5cblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9Pntcblx0XHR2YXIgYnV0dG9uID0gZ2V0RG9tKG9wdGlvbnMuaHRtbChvcHRpb25zKSk7XG5cdFx0YnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZXZ0KT0+e1xuXG5cdFx0XHRpZiggc2VsZi5pc0xvY2tlZCApIHJldHVybjtcblxuXHRcdFx0c2VsZi5jbGVhcigpO1xuXG5cdFx0XHRpZiggc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLnNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24gKXtcblx0XHRcdFx0c2VsZi5hZGRJdGVtKCcnKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fSk7XG5cdFx0c2VsZi5jb250cm9sLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImRyYWdfZHJvcFwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBUb21PcHRpb24sIFRvbUl0ZW0gfSBmcm9tICcuLi8uLi90eXBlcy9pbmRleCc7XG5pbXBvcnQgeyBlc2NhcGVfaHRtbCwgcHJldmVudERlZmF1bHQsIGFkZEV2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RG9tLCBzZXRBdHRyIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5cblxuY29uc3QgaW5zZXJ0QWZ0ZXIgPSAocmVmZXJlbmNlTm9kZTpFbGVtZW50LCBuZXdOb2RlOkVsZW1lbnQpID0+IHtcblx0cmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlPy5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG59XG5cbmNvbnN0IGluc2VydEJlZm9yZSA9IChyZWZlcmVuY2VOb2RlOkVsZW1lbnQsIG5ld05vZGU6RWxlbWVudCkgPT4ge1xuXHRyZWZlcmVuY2VOb2RlLnBhcmVudE5vZGU/Lmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuY29uc3QgaXNCZWZvcmUgPSAocmVmZXJlbmNlTm9kZTpFbGVtZW50fHVuZGVmaW5lZHxudWxsLCBuZXdOb2RlOkVsZW1lbnR8dW5kZWZpbmVkfG51bGwpID0+e1xuXHRcblx0ZG97XG5cdFx0bmV3Tm9kZSA9IG5ld05vZGU/LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cblx0XHRpZiggcmVmZXJlbmNlTm9kZSA9PSBuZXdOb2RlICl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0fXdoaWxlKCBuZXdOb2RlICYmIG5ld05vZGUucHJldmlvdXNFbGVtZW50U2libGluZyApO1xuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlICE9PSAnbXVsdGknKSByZXR1cm47XG5cblx0dmFyIG9yaWdfbG9ja1x0XHQ9IHNlbGYubG9jaztcblx0dmFyIG9yaWdfdW5sb2NrXHRcdD0gc2VsZi51bmxvY2s7XG5cdGxldCBzb3J0YWJsZSA9IHRydWU7XG5cdFx0bGV0IGRyYWdfaXRlbTpUb21JdGVtfHVuZGVmaW5lZDtcblxuXG5cdC8qKlxuXHQgKiBBZGQgZHJhZ2dhYmxlIGF0dHJpYnV0ZSB0byBpdGVtXG5cdCAqL1xuXHRzZWxmLmhvb2soJ2FmdGVyJywnc2V0dXBUZW1wbGF0ZXMnLCgpID0+IHtcblxuXHRcdHZhciBvcmlnX3JlbmRlcl9pdGVtID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbTtcblxuXHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdGNvbnN0IGl0ZW0gPSBnZXREb20ob3JpZ19yZW5kZXJfaXRlbS5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZSkpIGFzIFRvbUl0ZW07XG5cdFx0XHRzZXRBdHRyKGl0ZW0seydkcmFnZ2FibGUnOid0cnVlJ30pO1xuXG5cblx0XHRcdC8vIHByZXZlbnQgZG9jX21vdXNlZG93biAoc2VlIHRvbS1zZWxlY3QudHMpXG5cdFx0XHRjb25zdCBtb3VzZWRvd24gPSAoZXZ0OkV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmKCAhc29ydGFibGUgKSBwcmV2ZW50RGVmYXVsdChldnQpO1xuXHRcdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYWdTdGFydCA9IChldnQ6RXZlbnQpID0+IHtcblx0XHRcdFx0ZHJhZ19pdGVtID0gaXRlbTtcblx0XHRcdFx0XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGl0ZW0uY2xhc3NMaXN0LmFkZCgndHMtZHJhZ2dpbmcnKTtcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdFxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkcmFnT3ZlciA9IChldnQ6RXZlbnQpID0+e1xuXHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0aXRlbS5jbGFzc0xpc3QuYWRkKCd0cy1kcmFnLW92ZXInKTtcblx0XHRcdFx0bW92ZWl0ZW0oaXRlbSxkcmFnX2l0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkcmFnTGVhdmUgPSAoKSA9PiB7XG5cdFx0XHRcdGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZy1vdmVyJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1vdmVpdGVtID0gKHRhcmdldGl0ZW06VG9tSXRlbSwgZHJhZ2l0ZW06VG9tSXRlbXx1bmRlZmluZWQpID0+IHtcblx0XHRcdFx0aWYoIGRyYWdpdGVtID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiggaXNCZWZvcmUoZHJhZ2l0ZW0saXRlbSkgKXtcblx0XHRcdFx0XHRpbnNlcnRBZnRlcih0YXJnZXRpdGVtLGRyYWdpdGVtKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0aW5zZXJ0QmVmb3JlKHRhcmdldGl0ZW0sZHJhZ2l0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYWdlbmQgPSAoKSA9PiB7XG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50cy1kcmFnLW92ZXInKS5mb3JFYWNoKGVsPT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZy1vdmVyJykpO1xuXHRcdFx0XHRkcmFnX2l0ZW0/LmNsYXNzTGlzdC5yZW1vdmUoJ3RzLWRyYWdnaW5nJyk7XG5cdFx0XHRcdGRyYWdfaXRlbSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR2YXIgdmFsdWVzOnN0cmluZ1tdID0gW107XG5cdFx0XHRcdHNlbGYuY29udHJvbC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12YWx1ZV1gKS5mb3JFYWNoKChlbDpFbGVtZW50KT0+IHtcblx0XHRcdFx0XHRpZiggKDxIVE1MT3B0aW9uRWxlbWVudD5lbCkuZGF0YXNldC52YWx1ZSApe1xuXHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gKDxIVE1MT3B0aW9uRWxlbWVudD5lbCkuZGF0YXNldC52YWx1ZTtcblx0XHRcdFx0XHRcdGlmKCB2YWx1ZSApe1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzZWxmLnNldFZhbHVlKHZhbHVlcyk7XG5cdFx0XHR9XHRcblxuXG5cdFx0XHRhZGRFdmVudChpdGVtLCdtb3VzZWRvd24nLCBtb3VzZWRvd24pO1xuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KTtcblx0XHRcdGFkZEV2ZW50KGl0ZW0sJ2RyYWdlbnRlcicsIGRyYWdPdmVyKVxuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ292ZXInLCBkcmFnT3Zlcik7XG5cdFx0XHRhZGRFdmVudChpdGVtLCdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpO1xuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ2VuZCcsIGRyYWdlbmQpO1xuXHRcdFx0XHRcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cdFxuXHR9KTtcblxuXG5cblx0c2VsZi5ob29rKCdpbnN0ZWFkJywnbG9jaycsKCk9Pntcblx0XHRzb3J0YWJsZSA9IGZhbHNlO1xuXHRcdHJldHVybiBvcmlnX2xvY2suY2FsbChzZWxmKTtcblx0fSk7XG5cblx0c2VsZi5ob29rKCdpbnN0ZWFkJywndW5sb2NrJywoKT0+e1xuXHRcdHNvcnRhYmxlID0gdHJ1ZTtcblx0XHRyZXR1cm4gb3JpZ191bmxvY2suY2FsbChzZWxmKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faGVhZGVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGdldERvbSB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBESE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QsIHVzZXJPcHRpb25zOkRIT3B0aW9ucykge1xuXHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0dGl0bGUgICAgICAgICA6ICdVbnRpdGxlZCcsXG5cdFx0aGVhZGVyQ2xhc3MgICA6ICdkcm9wZG93bi1oZWFkZXInLFxuXHRcdHRpdGxlUm93Q2xhc3MgOiAnZHJvcGRvd24taGVhZGVyLXRpdGxlJyxcblx0XHRsYWJlbENsYXNzICAgIDogJ2Ryb3Bkb3duLWhlYWRlci1sYWJlbCcsXG5cdFx0Y2xvc2VDbGFzcyAgICA6ICdkcm9wZG93bi1oZWFkZXItY2xvc2UnLFxuXG5cdFx0aHRtbDogKGRhdGE6REhPcHRpb25zKSA9PiB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQnPGRpdiBjbGFzcz1cIicgKyBkYXRhLmhlYWRlckNsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiJyArIGRhdGEudGl0bGVSb3dDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cIicgKyBkYXRhLmxhYmVsQ2xhc3MgKyAnXCI+JyArIGRhdGEudGl0bGUgKyAnPC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0JzxhIGNsYXNzPVwiJyArIGRhdGEuY2xvc2VDbGFzcyArICdcIj4mdGltZXM7PC9hPicgK1xuXHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzwvZGl2Pidcblx0XHRcdCk7XG5cdFx0fVxuXHR9LCB1c2VyT3B0aW9ucyk7XG5cblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9Pntcblx0XHR2YXIgaGVhZGVyID0gZ2V0RG9tKG9wdGlvbnMuaHRtbChvcHRpb25zKSk7XG5cblx0XHR2YXIgY2xvc2VfbGluayA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCcuJytvcHRpb25zLmNsb3NlQ2xhc3MpO1xuXHRcdGlmKCBjbG9zZV9saW5rICl7XG5cdFx0XHRjbG9zZV9saW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZXZ0KT0+e1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGhlYWRlciwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faW5wdXRcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgbm9kZUluZGV4LCByZW1vdmVDbGFzc2VzIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuXHQgKiBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuXHQgKiBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcblx0ICpcblx0ICovXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ3NldENhcmV0JywobmV3X3BvczpudW1iZXIpID0+IHtcblxuXHRcdGlmKCBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnIHx8ICFzZWxmLmNvbnRyb2wuY29udGFpbnMoc2VsZi5jb250cm9sX2lucHV0KSApIHtcblx0XHRcdG5ld19wb3MgPSBzZWxmLml0ZW1zLmxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3X3BvcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlbGYuaXRlbXMubGVuZ3RoLCBuZXdfcG9zKSk7XG5cblx0XHRcdGlmKCBuZXdfcG9zICE9IHNlbGYuY2FyZXRQb3MgJiYgIXNlbGYuaXNQZW5kaW5nICl7XG5cblx0XHRcdFx0c2VsZi5jb250cm9sQ2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCxqKSA9PiB7XG5cdFx0XHRcdFx0aWYoIGogPCBuZXdfcG9zICl7XG5cdFx0XHRcdFx0XHRzZWxmLmNvbnRyb2xfaW5wdXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmViZWdpbicsIGNoaWxkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuY29udHJvbC5hcHBlbmRDaGlsZCggY2hpbGQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlbGYuY2FyZXRQb3MgPSBuZXdfcG9zO1xuXHR9KTtcblxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdtb3ZlQ2FyZXQnLChkaXJlY3Rpb246bnVtYmVyKSA9PiB7XG5cblx0XHRpZiggIXNlbGYuaXNGb2N1c2VkICkgcmV0dXJuO1xuXG5cdFx0Ly8gbW92ZSBjYXJldCBiZWZvcmUgb3IgYWZ0ZXIgc2VsZWN0ZWQgaXRlbXNcblx0XHRjb25zdCBsYXN0X2FjdGl2ZVx0XHQ9IHNlbGYuZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pO1xuXHRcdGlmKCBsYXN0X2FjdGl2ZSApe1xuXHRcdFx0Y29uc3QgaWR4ID0gbm9kZUluZGV4KGxhc3RfYWN0aXZlKTtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoZGlyZWN0aW9uID4gMCA/IGlkeCArIDE6IGlkeCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcblx0XHRcdHJlbW92ZUNsYXNzZXMobGFzdF9hY3RpdmUgYXMgSFRNTEVsZW1lbnQsJ2xhc3QtYWN0aXZlJyk7XG5cblx0XHQvLyBtb3ZlIGNhcmV0IGxlZnQgb3IgcmlnaHQgb2YgY3VycmVudCBwb3NpdGlvblxuXHRcdH1lbHNle1xuXHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLmNhcmV0UG9zICsgZGlyZWN0aW9uKTtcblxuXHRcdH1cblxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9pbnB1dFwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbSwgYWRkQ2xhc3NlcyB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgYWRkRXZlbnQsIHByZXZlbnREZWZhdWx0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdHNlbGYuc2V0dGluZ3Muc2hvdWxkT3BlbiA9IHRydWU7IC8vIG1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgc2hvd24gZXZlbiBpZiB0aGVyZSBhcmUgbm8gb3B0aW9ucyB0byBkaXNwbGF5IGluIHRoZSBkcm9wZG93blxuXG5cdHNlbGYuaG9vaygnYmVmb3JlJywnc2V0dXAnLCgpPT57XG5cdFx0c2VsZi5mb2N1c19ub2RlXHRcdD0gc2VsZi5jb250cm9sO1xuXG5cdFx0YWRkQ2xhc3Nlcyggc2VsZi5jb250cm9sX2lucHV0LCAnZHJvcGRvd24taW5wdXQnKTtcblxuXHQgXHRjb25zdCBkaXYgPSBnZXREb20oJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1pbnB1dC13cmFwXCI+Jyk7XG5cdFx0ZGl2LmFwcGVuZChzZWxmLmNvbnRyb2xfaW5wdXQpO1xuXHRcdHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGRpdiwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcblxuXHRcdC8vIHNldCBhIHBsYWNlaG9sZGVyIGluIHRoZSBzZWxlY3QgY29udHJvbFxuXHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gZ2V0RG9tKCc8aW5wdXQgY2xhc3M9XCJpdGVtcy1wbGFjZWhvbGRlclwiIHRhYmluZGV4PVwiLTFcIiAvPicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cdFx0cGxhY2Vob2xkZXIucGxhY2Vob2xkZXIgPSBzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyIHx8Jyc7XG5cdFx0c2VsZi5jb250cm9sLmFwcGVuZChwbGFjZWhvbGRlcik7XG5cblx0fSk7XG5cblxuXHRzZWxmLm9uKCdpbml0aWFsaXplJywoKT0+e1xuXG5cdFx0Ly8gc2V0IHRhYkluZGV4IG9uIGNvbnRyb2wgdG8gLTEsIG90aGVyd2lzZSBbc2hpZnQrdGFiXSB3aWxsIHB1dCBmb2N1cyByaWdodCBiYWNrIG9uIGNvbnRyb2xfaW5wdXRcblx0XHRzZWxmLmNvbnRyb2xfaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsKGV2dDpLZXlib2FyZEV2ZW50KSA9Pntcblx0XHQvL2FkZEV2ZW50KHNlbGYuY29udHJvbF9pbnB1dCwna2V5ZG93bicgYXMgY29uc3QsKGV2dDpLZXlib2FyZEV2ZW50KSA9Pntcblx0XHRcdHN3aXRjaCggZXZ0LmtleUNvZGUgKXtcblx0XHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0VTQzpcblx0XHRcdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX1RBQjpcblx0XHRcdFx0XHRzZWxmLmZvY3VzX25vZGUudGFiSW5kZXggPSAtMTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VsZi5vbktleURvd24uY2FsbChzZWxmLGV2dCk7XG5cdFx0fSk7XG5cblx0XHRzZWxmLm9uKCdibHVyJywoKT0+e1xuXHRcdFx0c2VsZi5mb2N1c19ub2RlLnRhYkluZGV4ID0gc2VsZi5pc0Rpc2FibGVkID8gLTEgOiBzZWxmLnRhYkluZGV4O1xuXHRcdH0pO1xuXG5cblx0XHQvLyBnaXZlIHRoZSBjb250cm9sX2lucHV0IGZvY3VzIHdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW5cblx0XHRzZWxmLm9uKCdkcm9wZG93bl9vcGVuJywoKSA9Pntcblx0XHRcdHNlbGYuY29udHJvbF9pbnB1dC5mb2N1cygpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gcHJldmVudCBvbkJsdXIgZnJvbSBjbG9zaW5nIHdoZW4gZm9jdXMgaXMgb24gdGhlIGNvbnRyb2xfaW5wdXRcblx0XHRjb25zdCBvcmlnX29uQmx1ciA9IHNlbGYub25CbHVyO1xuXHRcdHNlbGYuaG9vaygnaW5zdGVhZCcsJ29uQmx1cicsKGV2dD86Rm9jdXNFdmVudCk9Pntcblx0XHRcdGlmKCBldnQgJiYgZXZ0LnJlbGF0ZWRUYXJnZXQgPT0gc2VsZi5jb250cm9sX2lucHV0ICkgcmV0dXJuO1xuXHRcdFx0cmV0dXJuIG9yaWdfb25CbHVyLmNhbGwoc2VsZik7XG5cdFx0fSk7XG5cblx0XHRhZGRFdmVudChzZWxmLmNvbnRyb2xfaW5wdXQsJ2JsdXInLCAoKSA9PiBzZWxmLm9uQmx1cigpICk7XG5cblx0XHQvLyByZXR1cm4gZm9jdXMgdG8gY29udHJvbCB0byBhbGxvdyBmdXJ0aGVyIGtleWJvYXJkIGlucHV0XG5cdFx0c2VsZi5ob29rKCdiZWZvcmUnLCdjbG9zZScsKCkgPT57XG5cblx0XHRcdGlmKCAhc2VsZi5pc09wZW4gKSByZXR1cm47XG5cdFx0XHRzZWxmLmZvY3VzX25vZGUuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KTtcblx0XHR9KTtcblxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJpbnB1dF9hdXRvZ3Jvd1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGFkZEV2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHR2YXIgc2VsZlx0XHRcdFx0XHQ9IHRoaXM7XG5cblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9PntcblxuXG5cdFx0dmFyIHRlc3RfaW5wdXRcdFx0XHRcdD0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHRcdHZhciBjb250cm9sXHRcdFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0O1xuXHRcdHRlc3RfaW5wdXQuc3R5bGUuY3NzVGV4dFx0PSAncG9zaXRpb246YWJzb2x1dGU7IHRvcDotOTk5OTlweDsgbGVmdDotOTk5OTlweDsgd2lkdGg6YXV0bzsgcGFkZGluZzowOyB3aGl0ZS1zcGFjZTpwcmU7ICc7XG5cblx0XHRzZWxmLndyYXBwZXIuYXBwZW5kQ2hpbGQodGVzdF9pbnB1dCk7XG5cblxuXHRcdHZhciB0cmFuc2Zlcl9zdHlsZXNcdFx0XHQ9IFsgJ2xldHRlclNwYWNpbmcnLCAnZm9udFNpemUnLCAnZm9udEZhbWlseScsICdmb250V2VpZ2h0JywgJ3RleHRUcmFuc2Zvcm0nIF07XG5cblx0XHRmb3IoIGNvbnN0IHN0eWxlX25hbWUgb2YgdHJhbnNmZXJfc3R5bGVzICl7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFRTNzAxNSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTA1MDYxNTQvNjk3NTc2XG5cdFx0XHR0ZXN0X2lucHV0LnN0eWxlW3N0eWxlX25hbWVdID0gY29udHJvbC5zdHlsZVtzdHlsZV9uYW1lXTtcblx0XHR9XG5cblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgY29udHJvbCB3aWR0aFxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dmFyIHJlc2l6ZSA9ICgpPT57XG5cdFx0XHR0ZXN0X2lucHV0LnRleHRDb250ZW50XHQ9IGNvbnRyb2wudmFsdWU7XG5cdFx0XHRjb250cm9sLnN0eWxlLndpZHRoXHRcdD0gdGVzdF9pbnB1dC5jbGllbnRXaWR0aCsncHgnO1xuXHRcdH07XG5cblx0XHRyZXNpemUoKTtcblx0XHRzZWxmLm9uKCd1cGRhdGUgaXRlbV9hZGQgaXRlbV9yZW1vdmUnLHJlc2l6ZSk7XG5cdFx0YWRkRXZlbnQoY29udHJvbCwnaW5wdXQnLCByZXNpemUgKTtcblx0XHRhZGRFdmVudChjb250cm9sLCdrZXl1cCcsIHJlc2l6ZSApO1xuXHRcdGFkZEV2ZW50KGNvbnRyb2wsJ2JsdXInLCByZXNpemUgKTtcblx0XHRhZGRFdmVudChjb250cm9sLCd1cGRhdGUnLCByZXNpemUgKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiaW5wdXRfYXV0b2dyb3dcIiAoVG9tIFNlbGVjdClcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIG9yaWdfZGVsZXRlU2VsZWN0aW9uID0gc2VsZi5kZWxldGVTZWxlY3Rpb247XG5cblx0dGhpcy5ob29rKCdpbnN0ZWFkJywnZGVsZXRlU2VsZWN0aW9uJywoZXZ0OktleWJvYXJkRXZlbnQpID0+IHtcblxuXHRcdGlmKCBzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCApe1xuXHRcdFx0cmV0dXJuIG9yaWdfZGVsZXRlU2VsZWN0aW9uLmNhbGwoc2VsZiwgZXZ0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcIm5vX2FjdGl2ZV9pdGVtc1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dGhpcy5ob29rKCdpbnN0ZWFkJywnc2V0QWN0aXZlSXRlbScsKCkgPT4ge30pO1xuXHR0aGlzLmhvb2soJ2luc3RlYWQnLCdzZWxlY3RBbGwnLCgpID0+IHt9KTtcbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwib3B0Z3JvdXBfY29sdW1uc1wiIChUb20gU2VsZWN0LmpzKVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHBhcmVudE1hdGNoLCBub2RlSW5kZXggfSBmcm9tICcuLi8uLi92YW5pbGxhJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHZhciBvcmlnX2tleWRvd24gPSBzZWxmLm9uS2V5RG93bjtcblxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdvbktleURvd24nLChldnQ6S2V5Ym9hcmRFdmVudCk9Pntcblx0XHR2YXIgaW5kZXgsIG9wdGlvbiwgb3B0aW9ucywgb3B0Z3JvdXA7XG5cblx0XHRpZiggIXNlbGYuaXNPcGVuIHx8ICEoZXZ0LmtleUNvZGUgPT09IGNvbnN0YW50cy5LRVlfTEVGVCB8fCBldnQua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9SSUdIVCkpIHtcblx0XHRcdHJldHVybiBvcmlnX2tleWRvd24uY2FsbChzZWxmLGV2dCk7XG5cdFx0fVxuXG5cdFx0c2VsZi5pZ25vcmVIb3Zlclx0PSB0cnVlO1xuXHRcdG9wdGdyb3VwXHRcdFx0PSBwYXJlbnRNYXRjaChzZWxmLmFjdGl2ZU9wdGlvbiwnW2RhdGEtZ3JvdXBdJyk7XG5cdFx0aW5kZXhcdFx0XHRcdD0gbm9kZUluZGV4KHNlbGYuYWN0aXZlT3B0aW9uLCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXG5cdFx0aWYoICFvcHRncm91cCApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCBldnQua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9MRUZUICl7XG5cdFx0XHRvcHRncm91cCA9IG9wdGdyb3VwLnByZXZpb3VzU2libGluZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0Z3JvdXAgPSBvcHRncm91cC5uZXh0U2libGluZztcblx0XHR9XG5cblx0XHRpZiggIW9wdGdyb3VwICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3B0aW9uc1x0XHRcdFx0PSAoPEhUTUxPcHRHcm91cEVsZW1lbnQ+b3B0Z3JvdXApLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdFx0b3B0aW9uXHRcdFx0XHQ9IG9wdGlvbnNbIE1hdGgubWluKG9wdGlvbnMubGVuZ3RoIC0gMSwgaW5kZXgpIF0gYXMgSFRNTEVsZW1lbnQ7XG5cblx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb24pO1xuXHRcdH1cblxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJyZW1vdmVfYnV0dG9uXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGdldERvbSB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgZXNjYXBlX2h0bWwsIHByZXZlbnREZWZhdWx0LCBhZGRFdmVudCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IFRvbU9wdGlvbiwgVG9tSXRlbSB9IGZyb20gJy4uLy4uL3R5cGVzL2luZGV4JztcbmltcG9ydCB7IFJCT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdXNlck9wdGlvbnM6UkJPcHRpb25zKSB7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0bGFiZWwgICAgIDogJyZ0aW1lczsnLFxuXHRcdFx0dGl0bGUgICAgIDogJ1JlbW92ZScsXG5cdFx0XHRjbGFzc05hbWUgOiAncmVtb3ZlJyxcblx0XHRcdGFwcGVuZCAgICA6IHRydWVcblx0XHR9LCB1c2VyT3B0aW9ucyk7XG5cblxuXHQvL29wdGlvbnMuY2xhc3NOYW1lID0gJ3JlbW92ZS1zaW5nbGUnO1xuXHR2YXIgc2VsZlx0XHRcdD0gdGhpcztcblxuXHQvLyBvdmVycmlkZSB0aGUgcmVuZGVyIG1ldGhvZCB0byBhZGQgcmVtb3ZlIGJ1dHRvbiB0byBlYWNoIGl0ZW1cblx0aWYoICFvcHRpb25zLmFwcGVuZCApe1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBodG1sID0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyBvcHRpb25zLmNsYXNzTmFtZSArICdcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCInICsgZXNjYXBlX2h0bWwob3B0aW9ucy50aXRsZSkgKyAnXCI+JyArIG9wdGlvbnMubGFiZWwgKyAnPC9hPic7XG5cblx0c2VsZi5ob29rKCdhZnRlcicsJ3NldHVwVGVtcGxhdGVzJywoKSA9PiB7XG5cblx0XHR2YXIgb3JpZ19yZW5kZXJfaXRlbSA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW07XG5cblx0XHRzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtID0gKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cblx0XHRcdHZhciBpdGVtID0gZ2V0RG9tKG9yaWdfcmVuZGVyX2l0ZW0uY2FsbChzZWxmLCBkYXRhLCBlc2NhcGUpKSBhcyBUb21JdGVtO1xuXG5cdFx0XHR2YXIgY2xvc2VfYnV0dG9uID0gZ2V0RG9tKGh0bWwpO1xuXHRcdFx0aXRlbS5hcHBlbmRDaGlsZChjbG9zZV9idXR0b24pO1xuXG5cdFx0XHRhZGRFdmVudChjbG9zZV9idXR0b24sJ21vdXNlZG93bicsKGV2dCkgPT4ge1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0YWRkRXZlbnQoY2xvc2VfYnV0dG9uLCdjbGljaycsKGV2dCkgPT4ge1xuXG5cdFx0XHRcdGlmKCBzZWxmLmlzTG9ja2VkICkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIHByb3BhZ2F0aW5nIHdpbGwgdHJpZ2dlciB0aGUgZHJvcGRvd24gdG8gc2hvdyBmb3Igc2luZ2xlIG1vZGVcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXG5cdFx0XHRcdGlmKCBzZWxmLmlzTG9ja2VkICkgcmV0dXJuO1xuXHRcdFx0XHRpZiggIXNlbGYuc2hvdWxkRGVsZXRlKFtpdGVtXSxldnQgYXMgTW91c2VFdmVudCkgKSByZXR1cm47XG5cblx0XHRcdFx0c2VsZi5yZW1vdmVJdGVtKGl0ZW0pO1xuXHRcdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKGZhbHNlKTtcblx0XHRcdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fTtcblxuXHR9KTtcblxuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcInJlc3RvcmVfb25fYmFja3NwYWNlXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBUb21PcHRpb24gfSBmcm9tICcuLi8uLi90eXBlcy9pbmRleCc7XG5cbnR5cGUgVFBsdWdpbk9wdGlvbnMgPSB7XG5cdHRleHQ/OihvcHRpb246VG9tT3B0aW9uKT0+c3RyaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QsIHVzZXJPcHRpb25zOlRQbHVnaW5PcHRpb25zKSB7XG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHR0ZXh0OiAob3B0aW9uOlRvbU9wdGlvbikgPT4ge1xuXHRcdFx0cmV0dXJuIG9wdGlvbltzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdO1xuXHRcdH1cblx0fSx1c2VyT3B0aW9ucyk7XG5cblx0c2VsZi5vbignaXRlbV9yZW1vdmUnLGZ1bmN0aW9uKHZhbHVlOnN0cmluZyl7XG5cdFx0aWYoICFzZWxmLmlzRm9jdXNlZCApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCBzZWxmLmNvbnRyb2xfaW5wdXQudmFsdWUudHJpbSgpID09PSAnJyApe1xuXHRcdFx0dmFyIG9wdGlvbiA9IHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdFx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRcdHNlbGYuc2V0VGV4dGJveFZhbHVlKG9wdGlvbnMudGV4dC5jYWxsKHNlbGYsIG9wdGlvbikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwicmVzdG9yZV9vbl9iYWNrc3BhY2VcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgVG9tT3B0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXgnO1xuaW1wb3J0IHsgYWRkQ2xhc3NlcyB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHRjb25zdCBzZWxmXHRcdFx0XHRcdFx0XHQ9IHRoaXM7XG5cdGNvbnN0IG9yaWdfY2FuTG9hZFx0XHRcdFx0XHQ9IHNlbGYuY2FuTG9hZDtcblx0Y29uc3Qgb3JpZ19jbGVhckFjdGl2ZU9wdGlvblx0XHQ9IHNlbGYuY2xlYXJBY3RpdmVPcHRpb247XG5cdGNvbnN0IG9yaWdfbG9hZENhbGxiYWNrXHRcdFx0XHQ9IHNlbGYubG9hZENhbGxiYWNrO1xuXG5cdHZhciBwYWdpbmF0aW9uOntba2V5OnN0cmluZ106YW55fVx0PSB7fTtcblx0dmFyIGRyb3Bkb3duX2NvbnRlbnQ6SFRNTEVsZW1lbnQ7XG5cdHZhciBsb2FkaW5nX21vcmVcdFx0XHRcdFx0PSBmYWxzZTtcblx0dmFyIGxvYWRfbW9yZV9vcHQ6SFRNTEVsZW1lbnQ7XG5cdHZhciBkZWZhdWx0X3ZhbHVlczogc3RyaW5nW11cdFx0PSBbXTtcblxuXHRpZiggIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUgKXtcblxuXHRcdC8vIHJldHVybiB0cnVlIGlmIGFkZGl0aW9uYWwgcmVzdWx0cyBzaG91bGQgYmUgbG9hZGVkXG5cdFx0c2VsZi5zZXR0aW5ncy5zaG91bGRMb2FkTW9yZSA9ICgpOmJvb2xlYW49PntcblxuXHRcdFx0Y29uc3Qgc2Nyb2xsX3BlcmNlbnQgPSBkcm9wZG93bl9jb250ZW50LmNsaWVudEhlaWdodCAvIChkcm9wZG93bl9jb250ZW50LnNjcm9sbEhlaWdodCAtIGRyb3Bkb3duX2NvbnRlbnQuc2Nyb2xsVG9wKTtcblx0XHRcdGlmKCBzY3JvbGxfcGVyY2VudCA+IDAuOSApe1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIHNlbGYuYWN0aXZlT3B0aW9uICl7XG5cdFx0XHRcdHZhciBzZWxlY3RhYmxlXHQ9IHNlbGYuc2VsZWN0YWJsZSgpO1xuXHRcdFx0XHR2YXIgaW5kZXhcdFx0PSBBcnJheS5mcm9tKHNlbGVjdGFibGUpLmluZGV4T2Yoc2VsZi5hY3RpdmVPcHRpb24pO1xuXHRcdFx0XHRpZiggaW5kZXggPj0gKHNlbGVjdGFibGUubGVuZ3RoLTIpICl7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cblx0aWYoICFzZWxmLnNldHRpbmdzLmZpcnN0VXJsICl7XG5cdFx0dGhyb3cgJ3ZpcnR1YWxfc2Nyb2xsIHBsdWdpbiByZXF1aXJlcyBhIGZpcnN0VXJsKCkgbWV0aG9kJztcblx0fVxuXG5cblx0Ly8gaW4gb3JkZXIgZm9yIHZpcnR1YWwgc2Nyb2xsaW5nIHRvIHdvcmssXG5cdC8vIG9wdGlvbnMgbmVlZCB0byBiZSBvcmRlcmVkIHRoZSBzYW1lIHdheSB0aGV5J3JlIHJldHVybmVkIGZyb20gdGhlIHJlbW90ZSBkYXRhIHNvdXJjZVxuXHRzZWxmLnNldHRpbmdzLnNvcnRGaWVsZFx0XHRcdD0gW3tmaWVsZDonJG9yZGVyJ30se2ZpZWxkOickc2NvcmUnfV07XG5cblxuXHQvLyBjYW4gd2UgbG9hZCBtb3JlIHJlc3VsdHMgZm9yIGdpdmVuIHF1ZXJ5P1xuXHRjb25zdCBjYW5Mb2FkTW9yZSA9IChxdWVyeTpzdHJpbmcpOmJvb2xlYW4gPT4ge1xuXG5cdFx0aWYoIHR5cGVvZiBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMgPT09ICdudW1iZXInICYmIGRyb3Bkb3duX2NvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoID49IHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyApe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmKCAocXVlcnkgaW4gcGFnaW5hdGlvbikgJiYgcGFnaW5hdGlvbltxdWVyeV0gKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRjb25zdCBjbGVhckZpbHRlciA9IChvcHRpb246VG9tT3B0aW9uLCB2YWx1ZTpzdHJpbmcpOmJvb2xlYW4gPT4ge1xuXHRcdGlmKCBzZWxmLml0ZW1zLmluZGV4T2YodmFsdWUpID49IDAgfHwgZGVmYXVsdF92YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCApe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8vIHNldCB0aGUgbmV4dCB1cmwgdGhhdCB3aWxsIGJlXG5cdHNlbGYuc2V0TmV4dFVybCA9ICh2YWx1ZTpzdHJpbmcsbmV4dF91cmw6YW55KTp2b2lkID0+IHtcblx0XHRwYWdpbmF0aW9uW3ZhbHVlXSA9IG5leHRfdXJsO1xuXHR9O1xuXG5cdC8vIGdldFVybCgpIHRvIGJlIHVzZWQgaW4gc2V0dGluZ3MubG9hZCgpXG5cdHNlbGYuZ2V0VXJsID0gKHF1ZXJ5OnN0cmluZyk6YW55ID0+e1xuXG5cdFx0aWYoIHF1ZXJ5IGluIHBhZ2luYXRpb24gKXtcblx0XHRcdGNvbnN0IG5leHRfdXJsID0gcGFnaW5hdGlvbltxdWVyeV07XG5cdFx0XHRwYWdpbmF0aW9uW3F1ZXJ5XSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIG5leHRfdXJsO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSB1c2VyIGdvZXMgYmFjayB0byBhIHByZXZpb3VzIHF1ZXJ5XG5cdFx0Ly8gd2UgbmVlZCB0byBsb2FkIHRoZSBmaXJzdCBwYWdlIGFnYWluXG5cdFx0c2VsZi5jbGVhclBhZ2luYXRpb24oKTtcblxuXHRcdHJldHVybiBzZWxmLnNldHRpbmdzLmZpcnN0VXJsLmNhbGwoc2VsZixxdWVyeSk7XG5cdH07XG5cblx0Ly8gY2xlYXIgcGFnaW5hdGlvblxuXHRzZWxmLmNsZWFyUGFnaW5hdGlvbiA9ICgpOnZvaWQgPT57XG5cdFx0cGFnaW5hdGlvbiA9IHt9O1xuXHR9O1xuXG5cdC8vIGRvbid0IGNsZWFyIHRoZSBhY3RpdmUgb3B0aW9uIChhbmQgY2F1c2UgdW53YW50ZWQgZHJvcGRvd24gc2Nyb2xsKVxuXHQvLyB3aGlsZSBsb2FkaW5nIG1vcmUgcmVzdWx0c1xuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdjbGVhckFjdGl2ZU9wdGlvbicsKCk9PntcblxuXHRcdGlmKCBsb2FkaW5nX21vcmUgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3JpZ19jbGVhckFjdGl2ZU9wdGlvbi5jYWxsKHNlbGYpO1xuXHR9KTtcblxuXHQvLyBvdmVycmlkZSB0aGUgY2FuTG9hZCBtZXRob2Rcblx0c2VsZi5ob29rKCdpbnN0ZWFkJywnY2FuTG9hZCcsKHF1ZXJ5OnN0cmluZyk9PntcblxuXHRcdC8vIGZpcnN0IHRpbWUgdGhlIHF1ZXJ5IGhhcyBiZWVuIHNlZW5cblx0XHRpZiggIShxdWVyeSBpbiBwYWdpbmF0aW9uKSApe1xuXHRcdFx0cmV0dXJuIG9yaWdfY2FuTG9hZC5jYWxsKHNlbGYscXVlcnkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYW5Mb2FkTW9yZShxdWVyeSk7XG5cdH0pO1xuXG5cblx0Ly8gd3JhcCB0aGUgbG9hZFxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdsb2FkQ2FsbGJhY2snLCggb3B0aW9uczpUb21PcHRpb25bXSwgb3B0Z3JvdXBzOlRvbU9wdGlvbltdKT0+e1xuXG5cdFx0aWYoICFsb2FkaW5nX21vcmUgKXtcblx0XHRcdHNlbGYuY2xlYXJPcHRpb25zKGNsZWFyRmlsdGVyKTtcblx0XHR9ZWxzZSBpZiggbG9hZF9tb3JlX29wdCApe1xuXHRcdFx0Y29uc3QgZmlyc3Rfb3B0aW9uID0gb3B0aW9uc1swXTtcblx0XHRcdGlmKCBmaXJzdF9vcHRpb24gIT09IHVuZGVmaW5lZCApe1xuXHRcdFx0XHRsb2FkX21vcmVfb3B0LmRhdGFzZXQudmFsdWVcdFx0PSBmaXJzdF9vcHRpb25bc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvcmlnX2xvYWRDYWxsYmFjay5jYWxsKCBzZWxmLCBvcHRpb25zLCBvcHRncm91cHMpO1xuXG5cdFx0bG9hZGluZ19tb3JlID0gZmFsc2U7XG5cdH0pO1xuXG5cblx0Ly8gYWRkIHRlbXBsYXRlcyB0byBkcm9wZG93blxuXHQvL1x0bG9hZGluZ19tb3JlIGlmIHdlIGhhdmUgYW5vdGhlciB1cmwgaW4gdGhlIHF1ZXVlXG5cdC8vXHRub19tb3JlX3Jlc3VsdHMgaWYgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyIHVybCBpbiB0aGUgcXVldWVcblx0c2VsZi5ob29rKCdhZnRlcicsJ3JlZnJlc2hPcHRpb25zJywoKT0+e1xuXG5cdFx0Y29uc3QgcXVlcnlcdFx0PSBzZWxmLmxhc3RWYWx1ZTtcblx0XHR2YXIgb3B0aW9uO1xuXG5cdFx0aWYoIGNhbkxvYWRNb3JlKHF1ZXJ5KSApe1xuXG5cdFx0XHRvcHRpb24gPSBzZWxmLnJlbmRlcignbG9hZGluZ19tb3JlJyx7cXVlcnk6cXVlcnl9KTtcblx0XHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdFx0b3B0aW9uLnNldEF0dHJpYnV0ZSgnZGF0YS1zZWxlY3RhYmxlJywnJyk7IC8vIHNvIHRoYXQgbmF2aWdhdGluZyBkcm9wZG93biB3aXRoIFtkb3duXSBrZXlwcmVzc2VzIGNhbiBuYXZpZ2F0ZSB0byB0aGlzIG5vZGVcblx0XHRcdFx0bG9hZF9tb3JlX29wdCA9IG9wdGlvbjtcblx0XHRcdH1cblxuXHRcdH1lbHNlIGlmKCAocXVlcnkgaW4gcGFnaW5hdGlvbikgJiYgIWRyb3Bkb3duX2NvbnRlbnQucXVlcnlTZWxlY3RvcignLm5vLXJlc3VsdHMnKSApe1xuXHRcdFx0b3B0aW9uID0gc2VsZi5yZW5kZXIoJ25vX21vcmVfcmVzdWx0cycse3F1ZXJ5OnF1ZXJ5fSk7XG5cdFx0fVxuXG5cdFx0aWYoIG9wdGlvbiApe1xuXHRcdFx0YWRkQ2xhc3NlcyhvcHRpb24sc2VsZi5zZXR0aW5ncy5vcHRpb25DbGFzcyk7XG5cdFx0XHRkcm9wZG93bl9jb250ZW50LmFwcGVuZCggb3B0aW9uICk7XG5cdFx0fVxuXG5cdH0pO1xuXG5cblx0Ly8gYWRkIHNjcm9sbCBsaXN0ZW5lciBhbmQgZGVmYXVsdCB0ZW1wbGF0ZXNcblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9Pntcblx0XHRkZWZhdWx0X3ZhbHVlcyA9IE9iamVjdC5rZXlzKHNlbGYub3B0aW9ucyk7XG5cdFx0ZHJvcGRvd25fY29udGVudCA9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblxuXHRcdC8vIGRlZmF1bHQgdGVtcGxhdGVzXG5cdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdFx0XHRsb2FkaW5nX21vcmU6KCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gYDxkaXYgY2xhc3M9XCJsb2FkaW5nLW1vcmUtcmVzdWx0c1wiPkxvYWRpbmcgbW9yZSByZXN1bHRzIC4uLiA8L2Rpdj5gO1xuXHRcdFx0fSxcblx0XHRcdG5vX21vcmVfcmVzdWx0czooKSA9Pntcblx0XHRcdFx0cmV0dXJuIGA8ZGl2IGNsYXNzPVwibm8tbW9yZS1yZXN1bHRzXCI+Tm8gbW9yZSByZXN1bHRzPC9kaXY+YDtcblx0XHRcdH1cblx0XHR9LHNlbGYuc2V0dGluZ3MucmVuZGVyKTtcblxuXG5cdFx0Ly8gd2F0Y2ggZHJvcGRvd24gY29udGVudCBzY3JvbGwgcG9zaXRpb25cblx0XHRkcm9wZG93bl9jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsKCk9PntcblxuXHRcdFx0aWYoICFzZWxmLnNldHRpbmdzLnNob3VsZExvYWRNb3JlLmNhbGwoc2VsZikgKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAhaW1wb3J0YW50OiB0aGlzIHdpbGwgZ2V0IGNoZWNrZWQgYWdhaW4gaW4gbG9hZCgpIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIGhlcmUgb3RoZXJ3aXNlIGxvYWRpbmdfbW9yZSB3aWxsIGJlIHNldCB0byB0cnVlXG5cdFx0XHRpZiggIWNhbkxvYWRNb3JlKHNlbGYubGFzdFZhbHVlKSApe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRvbid0IGNhbGwgbG9hZCgpIHRvbyBtdWNoXG5cdFx0XHRpZiggbG9hZGluZ19tb3JlICkgcmV0dXJuO1xuXG5cblx0XHRcdGxvYWRpbmdfbW9yZSA9IHRydWU7XG5cdFx0XHRzZWxmLmxvYWQuY2FsbChzZWxmLHNlbGYubGFzdFZhbHVlKTtcblx0XHR9KTtcblx0fSk7XG5cbn07XG4iLCAiaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuL3RvbS1zZWxlY3QnO1xuXG5pbXBvcnQgY2hhbmdlX2xpc3RlbmVyIGZyb20gJy4vcGx1Z2lucy9jaGFuZ2VfbGlzdGVuZXIvcGx1Z2luJztcbmltcG9ydCBjaGVja2JveF9vcHRpb25zIGZyb20gJy4vcGx1Z2lucy9jaGVja2JveF9vcHRpb25zL3BsdWdpbic7XG5pbXBvcnQgY2xlYXJfYnV0dG9uIGZyb20gJy4vcGx1Z2lucy9jbGVhcl9idXR0b24vcGx1Z2luJztcbmltcG9ydCBkcmFnX2Ryb3AgZnJvbSAnLi9wbHVnaW5zL2RyYWdfZHJvcC9wbHVnaW4nO1xuaW1wb3J0IGRyb3Bkb3duX2hlYWRlciBmcm9tICcuL3BsdWdpbnMvZHJvcGRvd25faGVhZGVyL3BsdWdpbic7XG5pbXBvcnQgY2FyZXRfcG9zaXRpb24gZnJvbSAnLi9wbHVnaW5zL2NhcmV0X3Bvc2l0aW9uL3BsdWdpbic7XG5pbXBvcnQgZHJvcGRvd25faW5wdXQgZnJvbSAnLi9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbic7XG5pbXBvcnQgaW5wdXRfYXV0b2dyb3cgZnJvbSAnLi9wbHVnaW5zL2lucHV0X2F1dG9ncm93L3BsdWdpbic7XG5pbXBvcnQgbm9fYmFja3NwYWNlX2RlbGV0ZSBmcm9tICcuL3BsdWdpbnMvbm9fYmFja3NwYWNlX2RlbGV0ZS9wbHVnaW4nO1xuaW1wb3J0IG5vX2FjdGl2ZV9pdGVtcyBmcm9tICcuL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbic7XG5pbXBvcnQgb3B0Z3JvdXBfY29sdW1ucyBmcm9tICcuL3BsdWdpbnMvb3B0Z3JvdXBfY29sdW1ucy9wbHVnaW4nO1xuaW1wb3J0IHJlbW92ZV9idXR0b24gZnJvbSAnLi9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luJztcbmltcG9ydCByZXN0b3JlX29uX2JhY2tzcGFjZSBmcm9tICcuL3BsdWdpbnMvcmVzdG9yZV9vbl9iYWNrc3BhY2UvcGx1Z2luJztcbmltcG9ydCB2aXJ0dWFsX3Njcm9sbCBmcm9tICcuL3BsdWdpbnMvdmlydHVhbF9zY3JvbGwvcGx1Z2luJztcblxuVG9tU2VsZWN0LmRlZmluZSgnY2hhbmdlX2xpc3RlbmVyJywgY2hhbmdlX2xpc3RlbmVyKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NoZWNrYm94X29wdGlvbnMnLCBjaGVja2JveF9vcHRpb25zKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NsZWFyX2J1dHRvbicsIGNsZWFyX2J1dHRvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdkcmFnX2Ryb3AnLCBkcmFnX2Ryb3ApO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faGVhZGVyJywgZHJvcGRvd25faGVhZGVyKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NhcmV0X3Bvc2l0aW9uJywgY2FyZXRfcG9zaXRpb24pO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faW5wdXQnLCBkcm9wZG93bl9pbnB1dCk7XG5Ub21TZWxlY3QuZGVmaW5lKCdpbnB1dF9hdXRvZ3JvdycsIGlucHV0X2F1dG9ncm93KTtcblRvbVNlbGVjdC5kZWZpbmUoJ25vX2JhY2tzcGFjZV9kZWxldGUnLCBub19iYWNrc3BhY2VfZGVsZXRlKTtcblRvbVNlbGVjdC5kZWZpbmUoJ25vX2FjdGl2ZV9pdGVtcycsIG5vX2FjdGl2ZV9pdGVtcyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdvcHRncm91cF9jb2x1bW5zJywgb3B0Z3JvdXBfY29sdW1ucyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdyZW1vdmVfYnV0dG9uJywgcmVtb3ZlX2J1dHRvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdyZXN0b3JlX29uX2JhY2tzcGFjZScsIHJlc3RvcmVfb25fYmFja3NwYWNlKTtcblRvbVNlbGVjdC5kZWZpbmUoJ3ZpcnR1YWxfc2Nyb2xsJywgdmlydHVhbF9zY3JvbGwpO1xuXG5leHBvcnQgZGVmYXVsdCBUb21TZWxlY3Q7XG4iLCAiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqIHRvcGJhciAxLjAuMCwgMjAyMS0wMS0wNlxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogQ29weXJpZ2h0IChjKSAyMDIxIEJ1dSBOZ3V5ZW5cbiAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBjYW52YXMsXG4gICAgcHJvZ3Jlc3NUaW1lcklkLFxuICAgIGZhZGVUaW1lcklkLFxuICAgIGN1cnJlbnRQcm9ncmVzcyxcbiAgICBzaG93aW5nLFxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSBlbGVtLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgZWxzZSBlbGVtW1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhdXRvUnVuOiB0cnVlLFxuICAgICAgYmFyVGhpY2tuZXNzOiAzLFxuICAgICAgYmFyQ29sb3JzOiB7XG4gICAgICAgIDA6IFwicmdiYSgyNiwgIDE4OCwgMTU2LCAuOSlcIixcbiAgICAgICAgXCIuMjVcIjogXCJyZ2JhKDUyLCAgMTUyLCAyMTksIC45KVwiLFxuICAgICAgICBcIi41MFwiOiBcInJnYmEoMjQxLCAxOTYsIDE1LCAgLjkpXCIsXG4gICAgICAgIFwiLjc1XCI6IFwicmdiYSgyMzAsIDEyNiwgMzQsICAuOSlcIixcbiAgICAgICAgXCIxLjBcIjogXCJyZ2JhKDIxMSwgODQsICAwLCAgIC45KVwiLFxuICAgICAgfSxcbiAgICAgIHNoYWRvd0JsdXI6IDEwLFxuICAgICAgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAgIDAsICAgMCwgICAuNilcIixcbiAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICB9LFxuICAgIHJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDU7IC8vIG5lZWQgc3BhY2UgZm9yIHNoYWRvd1xuXG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gb3B0aW9ucy5zaGFkb3dCbHVyO1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5zaGFkb3dDb2xvcjtcblxuICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApO1xuICAgICAgZm9yICh2YXIgc3RvcCBpbiBvcHRpb25zLmJhckNvbG9ycylcbiAgICAgICAgbGluZUdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBvcHRpb25zLmJhckNvbG9yc1tzdG9wXSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKDAsIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMik7XG4gICAgICBjdHgubGluZVRvKFxuICAgICAgICBNYXRoLmNlaWwoY3VycmVudFByb2dyZXNzICogY2FudmFzLndpZHRoKSxcbiAgICAgICAgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUdyYWRpZW50O1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IHN0eWxlLnJpZ2h0ID0gc3R5bGUubWFyZ2luID0gc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAxMDAwMDE7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIGNhbnZhcy5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVwYWludCk7XG4gICAgfSxcbiAgICB0b3BiYXIgPSB7XG4gICAgICBjb25maWc6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoZmFkZVRpbWVySWQgIT09IG51bGwpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShmYWRlVGltZXJJZCk7XG4gICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxuICAgICAgICAgICAgICBcIitcIiArIDAuMDUgKiBNYXRoLnBvdygxIC0gTWF0aC5zcXJ0KGN1cnJlbnRQcm9ncmVzcyksIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0byA9XG4gICAgICAgICAgICAodG8uaW5kZXhPZihcIitcIikgPj0gMCB8fCB0by5pbmRleE9mKFwiLVwiKSA+PSAwXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXG4gICAgICAgICAgICAgIDogMCkgKyBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcztcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBzaG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9ncmVzc1RpbWVySWQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVySWQpO1xuICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcyhcIisuMVwiKSA+PSAxKSB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSAtPSAwLjA1O1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZS5vcGFjaXR5IDw9IDAuMDUpIHtcbiAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgZmFkZVRpbWVySWQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZhZGVUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvcGJhcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9wYmFyO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9wYmFyID0gdG9wYmFyO1xuICB9XG59LmNhbGwodGhpcywgd2luZG93LCBkb2N1bWVudCkpO1xuIiwgIi8qIVxuICogQ2hhcnQuanMgdjMuOS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjIgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4oZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ2hhcnQgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub29wKCkge31cbmNvbnN0IHVpZCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZCsrO1xuICB9O1xufSgpKTtcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuY29uc3QgaXNOdW1iZXJGaW5pdGUgPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xuZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6IHZhbHVlIC8gZGltZW5zaW9uO1xuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuZnVuY3Rpb24gY2FsbGJhY2soZm4sIGFyZ3MsIHRoaXNBcmcpIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuICBsZXQgaSwgbGVuLCBrZXlzO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xuICBsZXQgaSwgaWxlbiwgdjAsIHYxO1xuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9uZSQxKHNvdXJjZSkge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUkMSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lJDEoc291cmNlW2tleXNba11dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VJZih0YXJnZXQsIHNvdXJjZSkge1xuICByZXR1cm4gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuZnVuY3Rpb24gX21lcmdlcklmKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG5cdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuY29uc3Qga2V5UmVzb2x2ZXJzID0ge1xuICAnJzogdiA9PiB2LFxuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5mdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KSB7XG4gIGNvbnN0IHJlc29sdmVyID0ga2V5UmVzb2x2ZXJzW2tleV0gfHwgKGtleVJlc29sdmVyc1trZXldID0gX2dldEtleVJlc29sdmVyKGtleSkpO1xuICByZXR1cm4gcmVzb2x2ZXIob2JqKTtcbn1cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXkpIHtcbiAgY29uc3Qga2V5cyA9IF9zcGxpdEtleShrZXkpO1xuICByZXR1cm4gb2JqID0+IHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKGsgPT09ICcnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqICYmIG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cbmZ1bmN0aW9uIF9zcGxpdEtleShrZXkpIHtcbiAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmNvbnN0IGRlZmluZWQgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5jb25zdCBzZXRzRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cblxuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgVEFVID0gMiAqIFBJO1xuY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5jb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5jb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5jb25zdCBzaWduID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5mdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuZnVuY3Rpb24gYWxtb3N0V2hvbGUoeCwgZXBzaWxvbikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KGFycmF5LCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cbmZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHgpIHtcbiAgaWYgKCFpc051bWJlckZpbml0ZSh4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5mdW5jdGlvbiBfYW5nbGVEaWZmKGEsIGIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGEpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cbmZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0LCBlbmQsIHNhbWVBbmdsZUlzRnVsbENpcmNsZSkge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cbmZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZSwgc3RhcnQsIGVuZCwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG5cbmZ1bmN0aW9uIF9sb29rdXAodGFibGUsIHZhbHVlLCBjbXApIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDtcbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG8sIGhpfTtcbn1cbmNvbnN0IF9sb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSwgbGFzdCkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDw9IHZhbHVlXG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcbmNvbnN0IF9ybG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5mdW5jdGlvbiBfZmlsdGVyQmV0d2Vlbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG4gIHJldHVybiBzdGFydCA+IDAgfHwgZW5kIDwgdmFsdWVzLmxlbmd0aFxuICAgID8gdmFsdWVzLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgOiB2YWx1ZXM7XG59XG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ19vbkRhdGEnICsgX2NhcGl0YWxpemUoa2V5KTtcbiAgICBjb25zdCBiYXNlID0gYXJyYXlba2V5XTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG4gIGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcbn1cbmZ1bmN0aW9uIF9hcnJheVVuaXF1ZShpdGVtcykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc2V0LmFkZChpdGVtc1tpXSk7XG4gIH1cbiAgaWYgKHNldC5zaXplID09PSBpbGVuKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cbmNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5mdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcsIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IHVwZGF0ZUFyZ3MgPSB1cGRhdGVGbiB8fCAoKGFyZ3MpID0+IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcbiAgbGV0IGFyZ3MgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLnJlc3QpIHtcbiAgICBhcmdzID0gdXBkYXRlQXJncyhyZXN0KTtcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cbmNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5jb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbiwgc3RhcnQsIGVuZCkgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuY29uc3QgX3RleHRYID0gKGFsaWduLCBsZWZ0LCByaWdodCwgcnRsKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5mdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcbiAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWluKS5sbyxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKSxcbiAgICAgIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoTWF0aC5tYXgoXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5mdW5jdGlvbiBfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cblxuY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxudmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4yLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMiBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcm91bmQodikge1xuICByZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBuMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJuKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gbjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMTAwKSwgMCwgMTAwKTtcbn1cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcbiAgcmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcbiAgY29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcbiAgbGV0IGk7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBpID0gMSAvICh3ICsgYik7XG4gICAgdyAqPSBpO1xuICAgIGIgKj0gaTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcbiAgICByZ2JbaV0gKz0gdztcbiAgfVxuICByZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KSB7XG4gIGlmIChyID09PSBtYXgpIHtcbiAgICByZXR1cm4gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKTtcbiAgfVxuICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIChiIC0gcikgLyBkICsgMjtcbiAgfVxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG4gIGNvbnN0IHJhbmdlID0gMjU1O1xuICBjb25zdCByID0gdi5yIC8gcmFuZ2U7XG4gIGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGxldCBoLCBzLCBkO1xuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBoID0gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KTtcbiAgICBoID0gaCAqIDYwICsgMC41O1xuICB9XG4gIHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhKVxuICAgICAgPyBmKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgICA6IGYoYSwgYiwgYylcbiAgKS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgdjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzVdICE9PSB2KSB7XG4gICAgYSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcbiAgfVxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcbiAgY29uc3QgcDEgPSArbVszXSAvIDEwMDtcbiAgY29uc3QgcDIgPSArbVs0XSAvIDEwMDtcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XG4gICAgdiA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgdiA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHZbMF0sXG4gICAgZzogdlsxXSxcbiAgICBiOiB2WzJdLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xuICBoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuICBoID0gaHNsMnJnYihoKTtcbiAgdi5yID0gaFswXTtcbiAgdi5nID0gaFsxXTtcbiAgdi5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG4gIGlmICghdikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gcmdiMmhzbCh2KTtcbiAgY29uc3QgaCA9IGFbMF07XG4gIGNvbnN0IHMgPSBuMnAoYVsxXSk7XG4gIGNvbnN0IGwgPSBuMnAoYVsyXSk7XG4gIHJldHVybiB2LmEgPCAyNTVcbiAgICA/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuICAgIDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cbmNvbnN0IG1hcCQyID0ge1xuICB4OiAnZGFyaycsXG4gIFo6ICdsaWdodCcsXG4gIFk6ICdyZScsXG4gIFg6ICdibHUnLFxuICBXOiAnZ3InLFxuICBWOiAnbWVkaXVtJyxcbiAgVTogJ3NsYXRlJyxcbiAgQTogJ2VlJyxcbiAgVDogJ29sJyxcbiAgUzogJ29yJyxcbiAgQjogJ3JhJyxcbiAgQzogJ2xhdGVnJyxcbiAgRDogJ2lnaHRzJyxcbiAgUjogJ2luJyxcbiAgUTogJ3R1cnF1b2lzJyxcbiAgRTogJ2hpJyxcbiAgUDogJ3JvJyxcbiAgTzogJ2FsJyxcbiAgTjogJ2xlJyxcbiAgTTogJ2RlJyxcbiAgTDogJ3llbGxvJyxcbiAgRjogJ2VuJyxcbiAgSzogJ2NoJyxcbiAgRzogJ2Fya3MnLFxuICBIOiAnZWEnLFxuICBJOiAnaWdodGcnLFxuICBKOiAnd2gnXG59O1xuY29uc3QgbmFtZXMkMSA9IHtcbiAgT2ljZVhlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuICBhcXVhOiAnZmZmZicsXG4gIGFxdWFtYXJSZTogJzdmZmZkNCcsXG4gIGF6dVk6ICdmMGZmZmYnLFxuICBiZWlnZTogJ2Y1ZjVkYycsXG4gIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gIGJsYWNrOiAnMCcsXG4gIGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG4gIFhlOiAnZmYnLFxuICBYZXZpVGV0OiAnOGEyYmUyJyxcbiAgYlB3bjogJ2E1MmEyYScsXG4gIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gIGNhTXRYZTogJzVmOWVhMCcsXG4gIEthcnRZdXNlOiAnN2ZmZjAwJyxcbiAgS29jVGF0ZTogJ2QyNjkxZScsXG4gIGNTTzogJ2ZmN2Y1MCcsXG4gIGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcbiAgY1Nuc2lsazogJ2ZmZjhkYycsXG4gIGNyaW1zb246ICdkYzE0M2MnLFxuICBjeWFuOiAnZmZmZicsXG4gIHhYZTogJzhiJyxcbiAgeGN5YW46ICc4YjhiJyxcbiAgeGdUTW5QZDogJ2I4ODYwYicsXG4gIHhXYXk6ICdhOWE5YTknLFxuICB4Z1lGOiAnNjQwMCcsXG4gIHhnWXk6ICdhOWE5YTknLFxuICB4a2hha2k6ICdiZGI3NmInLFxuICB4bWFnRnRhOiAnOGIwMDhiJyxcbiAgeFRpdmVnWUY6ICc1NTZiMmYnLFxuICB4U2FuZ2U6ICdmZjhjMDAnLFxuICB4U2NFZDogJzk5MzJjYycsXG4gIHhZZDogJzhiMDAwMCcsXG4gIHhzT21vbjogJ2U5OTY3YScsXG4gIHhzSGdZRjogJzhmYmM4ZicsXG4gIHhVWGU6ICc0ODNkOGInLFxuICB4VVdheTogJzJmNGY0ZicsXG4gIHhVZ1l5OiAnMmY0ZjRmJyxcbiAgeFFlOiAnY2VkMScsXG4gIHh2aVRldDogJzk0MDBkMycsXG4gIGRBcHBSazogJ2ZmMTQ5MycsXG4gIGRBcHNreVhlOiAnYmZmZicsXG4gIGRpbVdheTogJzY5Njk2OScsXG4gIGRpbWdZeTogJzY5Njk2OScsXG4gIGRvZGdlclhlOiAnMWU5MGZmJyxcbiAgZmlZYnJpY2s6ICdiMjIyMjInLFxuICBmbFNPd0V0ZTogJ2ZmZmFmMCcsXG4gIGZvWXN0V0FuOiAnMjI4YjIyJyxcbiAgZnVLc2lhOiAnZmYwMGZmJyxcbiAgZ2FSc2JTbzogJ2RjZGNkYycsXG4gIGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG4gIGdUZDogJ2ZmZDcwMCcsXG4gIGdUTW5QZDogJ2RhYTUyMCcsXG4gIFdheTogJzgwODA4MCcsXG4gIGdZRjogJzgwMDAnLFxuICBnWUZMdzogJ2FkZmYyZicsXG4gIGdZeTogJzgwODA4MCcsXG4gIGhvbmV5TXc6ICdmMGZmZjAnLFxuICBob3RwUms6ICdmZjY5YjQnLFxuICBSZGlhbllkOiAnY2Q1YzVjJyxcbiAgUmRpZ286ICc0YjAwODInLFxuICBpdlN5OiAnZmZmZmYwJyxcbiAga2hha2k6ICdmMGU2OGMnLFxuICBsYXZGTXI6ICdlNmU2ZmEnLFxuICBsYXZGTXJYc2g6ICdmZmYwZjUnLFxuICBsYXduZ1lGOiAnN2NmYzAwJyxcbiAgTm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG4gIFpYZTogJ2FkZDhlNicsXG4gIFpjU086ICdmMDgwODAnLFxuICBaY3lhbjogJ2UwZmZmZicsXG4gIFpnVE1uUGRMdzogJ2ZhZmFkMicsXG4gIFpXYXk6ICdkM2QzZDMnLFxuICBaZ1lGOiAnOTBlZTkwJyxcbiAgWmdZeTogJ2QzZDNkMycsXG4gIFpwUms6ICdmZmI2YzEnLFxuICBac09tb246ICdmZmEwN2EnLFxuICBac0hnWUY6ICcyMGIyYWEnLFxuICBac2t5WGU6ICc4N2NlZmEnLFxuICBaVVdheTogJzc3ODg5OScsXG4gIFpVZ1l5OiAnNzc4ODk5JyxcbiAgWnN0QWxYZTogJ2IwYzRkZScsXG4gIFpMdzogJ2ZmZmZlMCcsXG4gIGxpbWU6ICdmZjAwJyxcbiAgbGltZWdZRjogJzMyY2QzMicsXG4gIGxSRjogJ2ZhZjBlNicsXG4gIG1hZ0Z0YTogJ2ZmMDBmZicsXG4gIG1hUG9uOiAnODAwMDAwJyxcbiAgVmFxdWFtYXJSZTogJzY2Y2RhYScsXG4gIFZYZTogJ2NkJyxcbiAgVlNjRWQ6ICdiYTU1ZDMnLFxuICBWcHVycE46ICc5MzcwZGInLFxuICBWc0hnWUY6ICczY2IzNzEnLFxuICBWVVhlOiAnN2I2OGVlJyxcbiAgVnNwclJnZ1lGOiAnZmE5YScsXG4gIFZRZTogJzQ4ZDFjYycsXG4gIFZ2aVRldFlkOiAnYzcxNTg1JyxcbiAgbWlkbmlnaHRYZTogJzE5MTk3MCcsXG4gIG1SdGNZYW06ICdmNWZmZmEnLFxuICBtaXN0eVBzZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc1I6ICdmZmU0YjUnLFxuICBuYXZham93RXRlOiAnZmZkZWFkJyxcbiAgbmF2eTogJzgwJyxcbiAgVGRsYWNlOiAnZmRmNWU2JyxcbiAgVGl2ZTogJzgwODAwMCcsXG4gIFRpdmVkQmI6ICc2YjhlMjMnLFxuICBTYW5nZTogJ2ZmYTUwMCcsXG4gIFNhbmdlWWQ6ICdmZjQ1MDAnLFxuICBTY0VkOiAnZGE3MGQ2JyxcbiAgcE9lZ1RNblBkOiAnZWVlOGFhJyxcbiAgcE9lZ1lGOiAnOThmYjk4JyxcbiAgcE9lUWU6ICdhZmVlZWUnLFxuICBwT2V2aVRldFlkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd0VwOiAnZmZlZmQ1JyxcbiAgcEhLcHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwUms6ICdmZmMwY2InLFxuICBwbHVtOiAnZGRhMGRkJyxcbiAgcG93TXJYZTogJ2IwZTBlNicsXG4gIHB1cnBOOiAnODAwMDgwJyxcbiAgWWJlY2NhcHVycE46ICc2NjMzOTknLFxuICBZZDogJ2ZmMDAwMCcsXG4gIFBzeWJyb3duOiAnYmM4ZjhmJyxcbiAgUHlPWGU6ICc0MTY5ZTEnLFxuICBzYWRkTmJQd246ICc4YjQ1MTMnLFxuICBzT21vbjogJ2ZhODA3MicsXG4gIHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG4gIHNIZ1lGOiAnMmU4YjU3JyxcbiAgc0hzaGVsbDogJ2ZmZjVlZScsXG4gIHNpRm5hOiAnYTA1MjJkJyxcbiAgc2lsdmVyOiAnYzBjMGMwJyxcbiAgc2t5WGU6ICc4N2NlZWInLFxuICBVWGU6ICc2YTVhY2QnLFxuICBVV2F5OiAnNzA4MDkwJyxcbiAgVWdZeTogJzcwODA5MCcsXG4gIHNub3c6ICdmZmZhZmEnLFxuICBzcHJSZ2dZRjogJ2ZmN2YnLFxuICBzdEFsWGU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZU86ICc4MDgwJyxcbiAgdEVzdE46ICdkOGJmZDgnLFxuICB0b21hdG86ICdmZjYzNDcnLFxuICBRZTogJzQwZTBkMCcsXG4gIHZpVGV0OiAnZWU4MmVlJyxcbiAgSkh0OiAnZjVkZWIzJyxcbiAgd0V0ZTogJ2ZmZmZmZicsXG4gIHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG4gIEx3OiAnZmZmZjAwJyxcbiAgTHdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuICBjb25zdCB1bnBhY2tlZCA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMkMSk7XG4gIGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwJDIpO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcCQyW2tdKTtcbiAgICB9XG4gICAgayA9IHBhcnNlSW50KG5hbWVzJDFbb2tdLCAxNik7XG4gICAgdW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG4gIH1cbiAgcmV0dXJuIHVucGFja2VkO1xufVxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuICBjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCByLCBnLCBiO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bN10gIT09IHIpIHtcbiAgICBjb25zdCB2ID0gK21bN107XG4gICAgYSA9IG1bOF0gPyBwMmIodikgOiBsaW0odiAqIDI1NSwgMCwgMjU1KTtcbiAgfVxuICByID0gK21bMV07XG4gIGcgPSArbVszXTtcbiAgYiA9ICttWzVdO1xuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XG4gIGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGxpbShnLCAwLCAyNTUpKTtcbiAgYiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogbGltKGIsIDAsIDI1NSkpO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG4gIHJldHVybiB2ICYmIChcbiAgICB2LmEgPCAyNTVcbiAgICAgID8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuICAgICAgOiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuICApO1xufVxuY29uc3QgdG8gPSB2ID0+IHYgPD0gMC4wMDMxMzA4ID8gdiAqIDEyLjkyIDogTWF0aC5wb3codiwgMS4wIC8gMi40KSAqIDEuMDU1IC0gMC4wNTU7XG5jb25zdCBmcm9tID0gdiA9PiB2IDw9IDAuMDQwNDUgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdygodiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUkMShyZ2IxLCByZ2IyLCB0KSB7XG4gIGNvbnN0IHIgPSBmcm9tKGIybihyZ2IxLnIpKTtcbiAgY29uc3QgZyA9IGZyb20oYjJuKHJnYjEuZykpO1xuICBjb25zdCBiID0gZnJvbShiMm4ocmdiMS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogbjJiKHRvKHIgKyB0ICogKGZyb20oYjJuKHJnYjIucikpIC0gcikpKSxcbiAgICBnOiBuMmIodG8oZyArIHQgKiAoZnJvbShiMm4ocmdiMi5nKSkgLSBnKSkpLFxuICAgIGI6IG4yYih0byhiICsgdCAqIChmcm9tKGIybihyZ2IyLmIpKSAtIGIpKSksXG4gICAgYTogcmdiMS5hICsgdCAqIChyZ2IyLmEgLSByZ2IxLmEpXG4gIH07XG59XG5mdW5jdGlvbiBtb2RIU0wodiwgaSwgcmF0aW8pIHtcbiAgaWYgKHYpIHtcbiAgICBsZXQgdG1wID0gcmdiMmhzbCh2KTtcbiAgICB0bXBbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0bXBbaV0gKyB0bXBbaV0gKiByYXRpbywgaSA9PT0gMCA/IDM2MCA6IDEpKTtcbiAgICB0bXAgPSBoc2wycmdiKHRtcCk7XG4gICAgdi5yID0gdG1wWzBdO1xuICAgIHYuZyA9IHRtcFsxXTtcbiAgICB2LmIgPSB0bXBbMl07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lKHYsIHByb3RvKSB7XG4gIHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xufVxuZnVuY3Rpb24gZnJvbU9iamVjdChpbnB1dCkge1xuICB2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcbiAgICAgIHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAzKSB7XG4gICAgICAgIHYuYSA9IG4yYihpbnB1dFszXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHYgPSBjbG9uZShpbnB1dCwge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9KTtcbiAgICB2LmEgPSBuMmIodi5hKTtcbiAgfVxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyc2Uoc3RyKSB7XG4gIGlmIChzdHIuY2hhckF0KDApID09PSAncicpIHtcbiAgICByZXR1cm4gcmdiUGFyc2Uoc3RyKTtcbiAgfVxuICByZXR1cm4gaHVlUGFyc2Uoc3RyKTtcbn1cbmNsYXNzIENvbG9yIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIGxldCB2O1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdiA9IGZyb21PYmplY3QoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSBoZXhQYXJzZShpbnB1dCkgfHwgbmFtZVBhcnNlKGlucHV0KSB8fCBmdW5jdGlvblBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdGhpcy5fcmdiID0gdjtcbiAgICB0aGlzLl92YWxpZCA9ICEhdjtcbiAgfVxuICBnZXQgdmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICB9XG4gIGdldCByZ2IoKSB7XG4gICAgdmFyIHYgPSBjbG9uZSh0aGlzLl9yZ2IpO1xuICAgIGlmICh2KSB7XG4gICAgICB2LmEgPSBiMm4odi5hKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgc2V0IHJnYihvYmopIHtcbiAgICB0aGlzLl9yZ2IgPSBmcm9tT2JqZWN0KG9iaik7XG4gIH1cbiAgcmdiU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IHJnYlN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhleFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoZXhTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoc2xTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaHNsU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgbWl4KGNvbG9yLCB3ZWlnaHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbnN0IGMxID0gdGhpcy5yZ2I7XG4gICAgICBjb25zdCBjMiA9IGNvbG9yLnJnYjtcbiAgICAgIGxldCB3MjtcbiAgICAgIGNvbnN0IHAgPSB3ZWlnaHQgPT09IHcyID8gMC41IDogd2VpZ2h0O1xuICAgICAgY29uc3QgdyA9IDIgKiBwIC0gMTtcbiAgICAgIGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcbiAgICAgIGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgdzIgPSAxIC0gdzE7XG4gICAgICBjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcbiAgICAgIGMxLmcgPSAweEZGICYgdzEgKiBjMS5nICsgdzIgKiBjMi5nICsgMC41O1xuICAgICAgYzEuYiA9IDB4RkYgJiB3MSAqIGMxLmIgKyB3MiAqIGMyLmIgKyAwLjU7XG4gICAgICBjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcbiAgICAgIHRoaXMucmdiID0gYzE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludGVycG9sYXRlKGNvbG9yLCB0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBpbnRlcnBvbGF0ZSQxKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBpbmRleF9lc20odmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmRleF9lc20odmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgfVxuICBzZXQoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQodGhpcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICB9XG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBvdmVycmlkZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChvdmVycmlkZXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NvcGVPYmplY3QsIHtcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG52YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gX2dldFBhcmVudE5vZGUoZG9tTm9kZSkge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuICBsZXQgdmFsdWVJblBpeGVscztcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG4gICAgaWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgdmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWVJblBpeGVscztcbn1cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudCkgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5mdW5jdGlvbiBnZXRTdHlsZShlbCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXMsIHN0eWxlLCBzdWZmaXgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHN1ZmZpeCA9IHN1ZmZpeCA/ICctJyArIHN1ZmZpeCA6ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1tpXTtcbiAgICByZXN1bHRbcG9zXSA9IHBhcnNlRmxvYXQoc3R5bGVzW3N0eWxlICsgJy0nICsgcG9zICsgc3VmZml4XSkgfHwgMDtcbiAgfVxuICByZXN1bHQud2lkdGggPSByZXN1bHQubGVmdCArIHJlc3VsdC5yaWdodDtcbiAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC50b3AgKyByZXN1bHQuYm90dG9tO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHgsIHksIHRhcmdldCkgPT4gKHggPiAwIHx8IHkgPiAwKSAmJiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oZSwgY2FudmFzKSB7XG4gIGNvbnN0IHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gIGNvbnN0IHNvdXJjZSA9IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZTtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlO1xuICBsZXQgYm94ID0gZmFsc2U7XG4gIGxldCB4LCB5O1xuICBpZiAodXNlT2Zmc2V0UG9zKG9mZnNldFgsIG9mZnNldFksIGUudGFyZ2V0KSkge1xuICAgIHggPSBvZmZzZXRYO1xuICAgIHkgPSBvZmZzZXRZO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IHNvdXJjZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIHkgPSBzb3VyY2UuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIGJveCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHt4LCB5LCBib3h9O1xufVxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihldnQsIGNoYXJ0KSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldnQpIHtcbiAgICByZXR1cm4gZXZ0O1xuICB9XG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpO1xuICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgbGV0IG1heFdpZHRoLCBtYXhIZWlnaHQ7XG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuY29uc3Qgcm91bmQxID0gdiA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gcmV0aW5hU2NhbGUoY2hhcnQsIGZvcmNlUmF0aW8sIGZvcmNlU3R5bGUpIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG4gIGNoYXJ0LmhlaWdodCA9IGRldmljZUhlaWdodCAvIHBpeGVsUmF0aW87XG4gIGNoYXJ0LndpZHRoID0gZGV2aWNlV2lkdGggLyBwaXhlbFJhdGlvO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5mdW5jdGlvbiBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9sb25nZXN0VGV4dChjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGksIGosIGpsZW4sIHRoaW5nLCBuZXN0ZWRUaGluZztcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBpc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdHgucmVzdG9yZSgpO1xuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCkge1xuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB4LCB5KSB7XG4gIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIG51bGwpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgdykge1xuICBsZXQgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzLCB3aWR0aDtcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XG4gIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIGRlZmF1bHQ6XG4gICAgaWYgKHcpIHtcbiAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICBjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICBjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3QnOlxuICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAncmVjdFJvdCc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdjcm9zcyc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdzdGFyJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdsaW5lJzpcbiAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdkYXNoJzpcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICBicmVhaztcbiAgfVxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKHBvaW50LCBhcmVhLCBtYXJnaW4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTtcbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5mdW5jdGlvbiBjbGlwQXJlYShjdHgsIGFyZWEpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4KSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXAsIG1vZGUpIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gX2JlemllckN1cnZlVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gcmVuZGVyVGV4dChjdHgsIHRleHQsIHgsIHksIGZvbnQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGksIGxpbmU7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuICAgIHkgKz0gZm9udC5saW5lSGVpZ2h0O1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgLUhBTEZfUEksIFBJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyA9IFsnJ10sIHJvb3RTY29wZXMgPSBzY29wZXMsIGZhbGxiYWNrLCBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF0pIHtcbiAgaWYgKCFkZWZpbmVkKGZhbGxiYWNrKSkge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiByb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCByb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0KHByb3h5LCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhwcm94eSwgZGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfSkge1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4LCBuYW1lKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3AsIHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbmZ1bmN0aW9uIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCByZXNvbHZlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cbiAgY29uc3QgdmFsdWUgPSByZXNvbHZlKCk7XG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGxldCB2YWx1ZSA9IF9wcm94eVtwcm9wXTtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgfVxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfc3RhY2t9ID0gdGFyZ2V0O1xuICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIGRldGVjdGVkOiAnICsgQXJyYXkuZnJvbShfc3RhY2spLmpvaW4oJy0+JykgKyAnLT4nICsgcHJvcCk7XG4gIH1cbiAgX3N0YWNrLmFkZChwcm9wKTtcbiAgdmFsdWUgPSB2YWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBjcmVhdGVTdWJSZXNvbHZlcihfcHJveHkuX3Njb3BlcywgX3Byb3h5LCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBpc0luZGV4YWJsZSkge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgaWYgKGRlZmluZWQoX2NvbnRleHQuaW5kZXgpICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhmYWxsYmFjaywgcHJvcCwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5jb25zdCBnZXRTY29wZSA9IChrZXksIHBhcmVudCkgPT4ga2V5ID09PSB0cnVlID8gcGFyZW50XG4gIDogdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyByZXNvbHZlT2JqZWN0S2V5KHBhcmVudCwga2V5KSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGFkZFNjb3BlcyhzZXQsIHBhcmVudFNjb3Blcywga2V5LCBwYXJlbnRGYWxsYmFjaywgdmFsdWUpIHtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50U2NvcGVzKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZShrZXksIHBhcmVudCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBzZXQuYWRkKHNjb3BlKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHNjb3BlLl9mYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIGRlZmluZWQocGFyZW50RmFsbGJhY2spICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IHByb3ApIHtcbiAgICBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBmYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZVJlc29sdmVyKEFycmF5LmZyb20oc2V0KSwgWycnXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssXG4gICAgKCkgPT4gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSkge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHByb3h5KSB7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlKHJlYWRLZXkocHJlZml4LCBwcm9wKSwgc2NvcGVzKTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5LCBzY29wZXMpIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5mdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50cywgaSkgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuZnVuY3Rpb24gc3BsaW5lQ3VydmUoZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuICBjb25zdCBmYSA9IHQgKiBzMDE7XG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSykge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSyA9IEFycmF5KHBvaW50c0xlbik7XG4gIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHBvaW50cywgb3B0aW9ucywgYXJlYSwgbG9vcCwgaW5kZXhBeGlzKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgY29udHJvbFBvaW50cztcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cblxuY29uc3QgYXRFZGdlID0gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0LCBzLCBwKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodCwgcywgcCkgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuY29uc3QgZWZmZWN0cyA9IHtcbiAgbGluZWFyOiB0ID0+IHQsXG4gIGVhc2VJblF1YWQ6IHQgPT4gdCAqIHQsXG4gIGVhc2VPdXRRdWFkOiB0ID0+IC10ICogKHQgLSAyKSxcbiAgZWFzZUluT3V0UXVhZDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdFxuICAgIDogLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKSxcbiAgZWFzZUluQ3ViaWM6IHQgPT4gdCAqIHQgKiB0LFxuICBlYXNlT3V0Q3ViaWM6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCArIDEsXG4gIGVhc2VJbk91dEN1YmljOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKSxcbiAgZWFzZUluUXVhcnQ6IHQgPT4gdCAqIHQgKiB0ICogdCxcbiAgZWFzZU91dFF1YXJ0OiB0ID0+IC0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcbiAgZWFzZUluT3V0UXVhcnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdFxuICAgIDogLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpLFxuICBlYXNlSW5RdWludDogdCA9PiB0ICogdCAqIHQgKiB0ICogdCxcbiAgZWFzZU91dFF1aW50OiB0ID0+ICh0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG4gIGVhc2VJbk91dFF1aW50OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblNpbmU6IHQgPT4gLU1hdGguY29zKHQgKiBIQUxGX1BJKSArIDEsXG4gIGVhc2VPdXRTaW5lOiB0ID0+IE1hdGguc2luKHQgKiBIQUxGX1BJKSxcbiAgZWFzZUluT3V0U2luZTogdCA9PiAtMC41ICogKE1hdGguY29zKFBJICogdCkgLSAxKSxcbiAgZWFzZUluRXhwbzogdCA9PiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSxcbiAgZWFzZU91dEV4cG86IHQgPT4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEsXG4gIGVhc2VJbk91dEV4cG86IHQgPT4gYXRFZGdlKHQpID8gdCA6IHQgPCAwLjVcbiAgICA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpXG4gICAgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuICBlYXNlSW5DaXJjOiB0ID0+ICh0ID49IDEpID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcbiAgZWFzZU91dENpcmM6IHQgPT4gTWF0aC5zcXJ0KDEgLSAodCAtPSAxKSAqIHQpLFxuICBlYXNlSW5PdXRDaXJjOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKVxuICAgIDogMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpLFxuICBlYXNlSW5FbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG4gIGVhc2VPdXRFbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljT3V0KHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlSW5PdXRFbGFzdGljKHQpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuICBlYXNlSW5CYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfSxcbiAgZWFzZU91dEJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH0sXG4gIGVhc2VJbk91dEJhY2sodCkge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuICBlYXNlSW5Cb3VuY2U6IHQgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG4gIGVhc2VPdXRCb3VuY2UodCkge1xuICAgIGNvbnN0IG0gPSA3LjU2MjU7XG4gICAgY29uc3QgZCA9IDIuNzU7XG4gICAgaWYgKHQgPCAoMSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8ICgyIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8ICgyLjUgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XG4gICAgfVxuICAgIHJldHVybiBtICogKHQgLT0gKDIuNjI1IC8gZCkpICogdCArIDAuOTg0Mzc1O1xuICB9LFxuICBlYXNlSW5PdXRCb3VuY2U6IHQgPT4gKHQgPCAwLjUpXG4gICAgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjVcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxufTtcblxuZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5mdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuXG5jb25zdCBpbnRsQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cblxuY29uc3QgTElORV9IRUlHSFQgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcbmNvbnN0IEZPTlRfU1RZTEUgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvKTtcbmZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZSwgc2l6ZSkge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gIGNhc2UgJ3B4JzpcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNhc2UgJyUnOlxuICAgIHZhbHVlIC89IDEwMDtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuY29uc3QgbnVtYmVyT3JaZXJvID0gdiA9PiArdiB8fCAwO1xuZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0b1RSQkwodmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cbmZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cbmZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZSkge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpO1xuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gdG9Gb250KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQ7XG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9ICcnO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHMsIGNvbnRleHQsIGluZGV4LCBpbmZvKSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXgsIGdyYWNlLCBiZWdpbkF0WmVybykge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWUsIGFkZCkgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0LCBjb250ZXh0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbnZhciBoZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuZWFzaW5nRWZmZWN0czogZWZmZWN0cyxcbmlzUGF0dGVybk9yR3JhZGllbnQ6IGlzUGF0dGVybk9yR3JhZGllbnQsXG5jb2xvcjogY29sb3IsXG5nZXRIb3ZlckNvbG9yOiBnZXRIb3ZlckNvbG9yLFxubm9vcDogbm9vcCxcbnVpZDogdWlkLFxuaXNOdWxsT3JVbmRlZjogaXNOdWxsT3JVbmRlZixcbmlzQXJyYXk6IGlzQXJyYXksXG5pc09iamVjdDogaXNPYmplY3QsXG5pc0Zpbml0ZTogaXNOdW1iZXJGaW5pdGUsXG5maW5pdGVPckRlZmF1bHQ6IGZpbml0ZU9yRGVmYXVsdCxcbnZhbHVlT3JEZWZhdWx0OiB2YWx1ZU9yRGVmYXVsdCxcbnRvUGVyY2VudGFnZTogdG9QZXJjZW50YWdlLFxudG9EaW1lbnNpb246IHRvRGltZW5zaW9uLFxuY2FsbGJhY2s6IGNhbGxiYWNrLFxuZWFjaDogZWFjaCxcbl9lbGVtZW50c0VxdWFsOiBfZWxlbWVudHNFcXVhbCxcbmNsb25lOiBjbG9uZSQxLFxuX21lcmdlcjogX21lcmdlcixcbm1lcmdlOiBtZXJnZSxcbm1lcmdlSWY6IG1lcmdlSWYsXG5fbWVyZ2VySWY6IF9tZXJnZXJJZixcbl9kZXByZWNhdGVkOiBfZGVwcmVjYXRlZCxcbnJlc29sdmVPYmplY3RLZXk6IHJlc29sdmVPYmplY3RLZXksXG5fc3BsaXRLZXk6IF9zcGxpdEtleSxcbl9jYXBpdGFsaXplOiBfY2FwaXRhbGl6ZSxcbmRlZmluZWQ6IGRlZmluZWQsXG5pc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuc2V0c0VxdWFsOiBzZXRzRXF1YWwsXG5faXNDbGlja0V2ZW50OiBfaXNDbGlja0V2ZW50LFxudG9Gb250U3RyaW5nOiB0b0ZvbnRTdHJpbmcsXG5fbWVhc3VyZVRleHQ6IF9tZWFzdXJlVGV4dCxcbl9sb25nZXN0VGV4dDogX2xvbmdlc3RUZXh0LFxuX2FsaWduUGl4ZWw6IF9hbGlnblBpeGVsLFxuY2xlYXJDYW52YXM6IGNsZWFyQ2FudmFzLFxuZHJhd1BvaW50OiBkcmF3UG9pbnQsXG5kcmF3UG9pbnRMZWdlbmQ6IGRyYXdQb2ludExlZ2VuZCxcbl9pc1BvaW50SW5BcmVhOiBfaXNQb2ludEluQXJlYSxcbmNsaXBBcmVhOiBjbGlwQXJlYSxcbnVuY2xpcEFyZWE6IHVuY2xpcEFyZWEsXG5fc3RlcHBlZExpbmVUbzogX3N0ZXBwZWRMaW5lVG8sXG5fYmV6aWVyQ3VydmVUbzogX2JlemllckN1cnZlVG8sXG5yZW5kZXJUZXh0OiByZW5kZXJUZXh0LFxuYWRkUm91bmRlZFJlY3RQYXRoOiBhZGRSb3VuZGVkUmVjdFBhdGgsXG5fbG9va3VwOiBfbG9va3VwLFxuX2xvb2t1cEJ5S2V5OiBfbG9va3VwQnlLZXksXG5fcmxvb2t1cEJ5S2V5OiBfcmxvb2t1cEJ5S2V5LFxuX2ZpbHRlckJldHdlZW46IF9maWx0ZXJCZXR3ZWVuLFxubGlzdGVuQXJyYXlFdmVudHM6IGxpc3RlbkFycmF5RXZlbnRzLFxudW5saXN0ZW5BcnJheUV2ZW50czogdW5saXN0ZW5BcnJheUV2ZW50cyxcbl9hcnJheVVuaXF1ZTogX2FycmF5VW5pcXVlLFxuX2NyZWF0ZVJlc29sdmVyOiBfY3JlYXRlUmVzb2x2ZXIsXG5fYXR0YWNoQ29udGV4dDogX2F0dGFjaENvbnRleHQsXG5fZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyxcbl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZTogX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLFxuc3BsaW5lQ3VydmU6IHNwbGluZUN1cnZlLFxuc3BsaW5lQ3VydmVNb25vdG9uZTogc3BsaW5lQ3VydmVNb25vdG9uZSxcbl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyxcbl9pc0RvbVN1cHBvcnRlZDogX2lzRG9tU3VwcG9ydGVkLFxuX2dldFBhcmVudE5vZGU6IF9nZXRQYXJlbnROb2RlLFxuZ2V0U3R5bGU6IGdldFN0eWxlLFxuZ2V0UmVsYXRpdmVQb3NpdGlvbjogZ2V0UmVsYXRpdmVQb3NpdGlvbixcbmdldE1heGltdW1TaXplOiBnZXRNYXhpbXVtU2l6ZSxcbnJldGluYVNjYWxlOiByZXRpbmFTY2FsZSxcbnN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnM6IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG5yZWFkVXNlZFNpemU6IHJlYWRVc2VkU2l6ZSxcbmZvbnRTdHJpbmc6IGZvbnRTdHJpbmcsXG5yZXF1ZXN0QW5pbUZyYW1lOiByZXF1ZXN0QW5pbUZyYW1lLFxudGhyb3R0bGVkOiB0aHJvdHRsZWQsXG5kZWJvdW5jZTogZGVib3VuY2UsXG5fdG9MZWZ0UmlnaHRDZW50ZXI6IF90b0xlZnRSaWdodENlbnRlcixcbl9hbGlnblN0YXJ0RW5kOiBfYWxpZ25TdGFydEVuZCxcbl90ZXh0WDogX3RleHRYLFxuX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHM6IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLFxuX3NjYWxlUmFuZ2VzQ2hhbmdlZDogX3NjYWxlUmFuZ2VzQ2hhbmdlZCxcbl9wb2ludEluTGluZTogX3BvaW50SW5MaW5lLFxuX3N0ZXBwZWRJbnRlcnBvbGF0aW9uOiBfc3RlcHBlZEludGVycG9sYXRpb24sXG5fYmV6aWVySW50ZXJwb2xhdGlvbjogX2JlemllckludGVycG9sYXRpb24sXG5mb3JtYXROdW1iZXI6IGZvcm1hdE51bWJlcixcbnRvTGluZUhlaWdodDogdG9MaW5lSGVpZ2h0LFxuX3JlYWRWYWx1ZVRvUHJvcHM6IF9yZWFkVmFsdWVUb1Byb3BzLFxudG9UUkJMOiB0b1RSQkwsXG50b1RSQkxDb3JuZXJzOiB0b1RSQkxDb3JuZXJzLFxudG9QYWRkaW5nOiB0b1BhZGRpbmcsXG50b0ZvbnQ6IHRvRm9udCxcbnJlc29sdmU6IHJlc29sdmUsXG5fYWRkR3JhY2U6IF9hZGRHcmFjZSxcbmNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXG5QSTogUEksXG5UQVU6IFRBVSxcblBJVEFVOiBQSVRBVSxcbklORklOSVRZOiBJTkZJTklUWSxcblJBRF9QRVJfREVHOiBSQURfUEVSX0RFRyxcbkhBTEZfUEk6IEhBTEZfUEksXG5RVUFSVEVSX1BJOiBRVUFSVEVSX1BJLFxuVFdPX1RISVJEU19QSTogVFdPX1RISVJEU19QSSxcbmxvZzEwOiBsb2cxMCxcbnNpZ246IHNpZ24sXG5uaWNlTnVtOiBuaWNlTnVtLFxuX2ZhY3Rvcml6ZTogX2ZhY3Rvcml6ZSxcbmlzTnVtYmVyOiBpc051bWJlcixcbmFsbW9zdEVxdWFsczogYWxtb3N0RXF1YWxzLFxuYWxtb3N0V2hvbGU6IGFsbW9zdFdob2xlLFxuX3NldE1pbkFuZE1heEJ5S2V5OiBfc2V0TWluQW5kTWF4QnlLZXksXG50b1JhZGlhbnM6IHRvUmFkaWFucyxcbnRvRGVncmVlczogdG9EZWdyZWVzLFxuX2RlY2ltYWxQbGFjZXM6IF9kZWNpbWFsUGxhY2VzLFxuZ2V0QW5nbGVGcm9tUG9pbnQ6IGdldEFuZ2xlRnJvbVBvaW50LFxuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzOiBkaXN0YW5jZUJldHdlZW5Qb2ludHMsXG5fYW5nbGVEaWZmOiBfYW5nbGVEaWZmLFxuX25vcm1hbGl6ZUFuZ2xlOiBfbm9ybWFsaXplQW5nbGUsXG5fYW5nbGVCZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuX2xpbWl0VmFsdWU6IF9saW1pdFZhbHVlLFxuX2ludDE2UmFuZ2U6IF9pbnQxNlJhbmdlLFxuX2lzQmV0d2VlbjogX2lzQmV0d2VlbixcbmdldFJ0bEFkYXB0ZXI6IGdldFJ0bEFkYXB0ZXIsXG5vdmVycmlkZVRleHREaXJlY3Rpb246IG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbnJlc3RvcmVUZXh0RGlyZWN0aW9uOiByZXN0b3JlVGV4dERpcmVjdGlvbixcbl9ib3VuZFNlZ21lbnQ6IF9ib3VuZFNlZ21lbnQsXG5fYm91bmRTZWdtZW50czogX2JvdW5kU2VnbWVudHMsXG5fY29tcHV0ZVNlZ21lbnRzOiBfY29tcHV0ZVNlZ21lbnRzXG59KTtcblxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5mdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHBvaW50SW5BcmVhID0gISFpbmNsdWRlSW52aXNpYmxlIHx8IGNoYXJ0LmlzUG9pbnRJbkFyZWEoY2VudGVyKTtcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG52YXIgSW50ZXJhY3Rpb24gPSB7XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcbiAgbW9kZXM6IHtcbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG4gICAgbmVhcmVzdChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGJveCA9IGJveGVzW2ldO1xuICAgICh7cG9zaXRpb246IHBvcywgb3B0aW9uczoge3N0YWNrLCBzdGFja1dlaWdodCA9IDF9fSA9IGJveCk7XG4gICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGJveCxcbiAgICAgIHBvcyxcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgIHN0YWNrOiBzdGFjayAmJiAocG9zICsgc3RhY2spLFxuICAgICAgc3RhY2tXZWlnaHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcbiAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gIGNvbnN0IHt2Qm94TWF4V2lkdGgsIGhCb3hNYXhIZWlnaHR9ID0gcGFyYW1zO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgbGF5b3V0LndpZHRoID0gZmFjdG9yID8gZmFjdG9yICogdkJveE1heFdpZHRoIDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGhCb3hNYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xuICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gIHVwZGF0ZVBvcygncmlnaHQnKTtcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuICByZXR1cm4gaG9yaXpvbnRhbFxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxuICAgIDogbWFyZ2luRm9yUG9zaXRpb25zKFsndG9wJywgJ2JvdHRvbSddKTtcbn1cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcbiAgICBib3gudXBkYXRlKFxuICAgICAgbGF5b3V0LndpZHRoIHx8IGNoYXJ0QXJlYS53LFxuICAgICAgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcbiAgICApO1xuICAgIGNvbnN0IHtzYW1lLCBvdGhlcn0gPSB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcyk7XG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcbiAgICBpZiAoIWJveC5mdWxsU2l6ZSkge1xuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cbmRlZmF1bHRzLnNldCgnbGF5b3V0Jywge1xuICBhdXRvUGFkZGluZzogdHJ1ZSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9XG59KTtcbnZhciBsYXlvdXRzID0ge1xuICBhZGRCb3goY2hhcnQsIGl0ZW0pIHtcbiAgICBpZiAoIWNoYXJ0LmJveGVzKSB7XG4gICAgICBjaGFydC5ib3hlcyA9IFtdO1xuICAgIH1cbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcbiAgcmVtb3ZlQm94KGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSxcbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKGNoYXJ0Lm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgLSBwYWRkaW5nLmhlaWdodCwgMCk7XG4gICAgY29uc3QgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XG4gICAgY29uc3QgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB2aXNpYmxlVmVydGljYWxCb3hDb3VudCA9IHZlcnRpY2FsQm94ZXMucmVkdWNlKCh0b3RhbCwgd3JhcCkgPT5cbiAgICAgIHdyYXAuYm94Lm9wdGlvbnMgJiYgd3JhcC5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSA/IHRvdGFsIDogdG90YWwgKyAxLCAwKSB8fCAxO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG4gICAgZml0Qm94ZXMoYm94ZXMuZnVsbFNpemUsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICB9XG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5yaWdodEFuZEJvdHRvbSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5jbGFzcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gIH1cbn1cblxuY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICB9XG59XG5cbmNvbnN0IEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJIZWlnaHQpKSB7XG4gICAgaWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cbmNvbnN0IGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hhcnQuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCwgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIFtldmVudCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gIH0pO1xuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxudmFyIHBsYXRmb3JtcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbl9kZXRlY3RQbGF0Zm9ybTogX2RldGVjdFBsYXRmb3JtLFxuQmFzZVBsYXRmb3JtOiBCYXNlUGxhdGZvcm0sXG5CYXNpY1BsYXRmb3JtOiBCYXNpY1BsYXRmb3JtLFxuRG9tUGxhdGZvcm06IERvbVBsYXRmb3JtXG59KTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBjb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICBkZWxheTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogMTAwMCxcbiAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgZm46IHVuZGVmaW5lZCxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICBsb29wOiB1bmRlZmluZWQsXG4gIHRvOiB1bmRlZmluZWQsXG4gIHR5cGU6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG59KTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgfSxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG59KTtcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBmbjogdiA9PiB2IHwgMFxuICAgICAgfSxcbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTtcbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcbmNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIG1ldGEuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgfVxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcbiAgICBpZiAoc3RhY2tDaGFuZ2VkIHx8IG9sZFN0YWNrZWQgIT09IG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBsZXQgc29ydGVkID0gc3RhcnQgPT09IDAgJiYgY291bnQgPT09IGRhdGEubGVuZ3RoID8gdHJ1ZSA6IG1ldGEuX3NvcnRlZDtcbiAgICBsZXQgcHJldiA9IHN0YXJ0ID4gMCAmJiBtZXRhLl9wYXJzZWRbc3RhcnQgLSAxXTtcbiAgICBsZXQgaSwgY3VyLCBwYXJzZWQ7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG4gICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXVxuICAgIH07XG4gICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7bW9kZX0pO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgIGlmIChzdGFjayAmJiB2YWx1ZXMpIHtcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHZhbHVlID0gYXBwbHlTdGFjayhzdGFjaywgcGFyc2VkVmFsdWUsIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpO1xuICAgIH1cbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIHZhbHVlKTtcbiAgfVxuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgX3BhcnNlZCA9IG1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IGlsZW4gPSBfcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBvdGhlclNjYWxlID0gdGhpcy5fZ2V0T3RoZXJTY2FsZShzY2FsZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBjb25zdCB7bWluOiBvdGhlck1pbiwgbWF4OiBvdGhlck1heH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgIGxldCBpLCBwYXJzZWQ7XG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc051bWJlckZpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge31cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuICAgIGlmIChtZXRhLmRhdGFzZXQpIHtcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuICBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldFxuICAgICAgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSlcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dCA9IGVsZW1lbnQuJGNvbnRleHQgfHxcbiAgICAgICAgKGVsZW1lbnQuJGNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIGVsZW1lbnQpKTtcbiAgICAgIGNvbnRleHQucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgY29udGV4dC5yYXcgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YUluZGV4ID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzLiRjb250ZXh0IHx8XG4gICAgICAgICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlRGF0YXNldENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKTtcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoY2xvbmVJZk5vdFNoYXJlZCh2YWx1ZXMsIHNoYXJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuICBpbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gIH1cbiAgX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpIHtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zID0gdGhpcy5fc2hhcmVkT3B0aW9ucztcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHx8IChzaGFyZWRPcHRpb25zICE9PSBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyk7XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgcmV0dXJuIHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc307XG4gIH1cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xuICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIHRydWUpO1xuICB9XG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge31cbiAgX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgfVxuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG4gIF9vbkRhdGFQdXNoKCkge1xuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnRdKTtcbiAgfVxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgc3RhcnQsIGNvdW50XSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKG5ld0NvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgc3RhcnQsIG5ld0NvdW50XSk7XG4gICAgfVxuICB9XG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbkRhdGFzZXRDb250cm9sbGVyLmRlZmF1bHRzID0ge307XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cbiAgZ2V0UHJvcHMocHJvcHMsIGZpbmFsKSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5FbGVtZW50LmRlZmF1bHRzID0ge307XG5FbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcbiAgfSxcbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTtcbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSk7XG4gICAgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1KSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxudmFyIFRpY2tzID0ge2Zvcm1hdHRlcnN9O1xuXG5kZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICBkaXNwbGF5OiB0cnVlLFxuICBvZmZzZXQ6IGZhbHNlLFxuICByZXZlcnNlOiBmYWxzZSxcbiAgYmVnaW5BdFplcm86IGZhbHNlLFxuICBib3VuZHM6ICd0aWNrcycsXG4gIGdyYWNlOiAwLFxuICBncmlkOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgZHJhd0JvcmRlcjogdHJ1ZSxcbiAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcbiAgICBib3JkZXJXaWR0aDogMVxuICB9LFxuICB0aXRsZToge1xuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIHRleHQ6ICcnLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogNCxcbiAgICAgIGJvdHRvbTogNFxuICAgIH1cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgbWlycm9yOiBmYWxzZSxcbiAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgdGV4dFN0cm9rZUNvbG9yOiAnJyxcbiAgICBwYWRkaW5nOiAzLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgYXV0b1NraXA6IHRydWUsXG4gICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICBtaW5vcjoge30sXG4gICAgbWFqb3I6IHt9LFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBjcm9zc0FsaWduOiAnbmVhcicsXG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gIH1cbn0pO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdib3JkZXJDb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnLFxufSk7XG5cbmZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cbiAgbmV4dCA9IHN0YXJ0O1xuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02O1xuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZTogJ3NjYWxlJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY2ZnLmlkO1xuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN0eCA9IGNmZy5jdHg7XG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gMDtcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1pbik7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIHJldHVybiByYXc7XG4gIH1cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQge191c2VyTWluLCBfdXNlck1heCwgX3N1Z2dlc3RlZE1pbiwgX3N1Z2dlc3RlZE1heH0gPSB0aGlzO1xuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgIG1pbkRlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWluKSxcbiAgICAgIG1heERlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWF4KVxuICAgIH07XG4gIH1cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHRcbiAgICAgIDogdGhpcy5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTtcbiAgICB0aGlzLmFmdGVyRml0KCk7XG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsYmFjayh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IGxhYmVsW2pdO1xuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9ufSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhbGlnbmVkTGluZVZhbHVlID0gX2FsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBsZXQgYmFja2Ryb3A7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcbiAgICAgICAgbGV0IHRvcCA9IHkgKyB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSB4IC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgIGJhY2tkcm9wLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgYWxpZ24gPSAnaW5uZXInO1xuICAgIH1cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGdyaWQuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmJvcmRlckNvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgaWYgKGl0ZW0uYmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGl0ZW0uYmFja2Ryb3AuY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpdGVtLmJhY2tkcm9wLmxlZnQsIGl0ZW0uYmFja2Ryb3AudG9wLCBpdGVtLmJhY2tkcm9wLndpZHRoLCBpdGVtLmJhY2tkcm9wLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBsZXQgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBneiArIDEsXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuXG5jbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG5cbmNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgfVxuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XG5cbmNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5Jykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICByZXR1cm4gc2NhbGVPcHRpb25zLmF4aXMgfHwgYXhpc0Zyb21Qb3NpdGlvbihzY2FsZU9wdGlvbnMucG9zaXRpb24pIHx8IGlkLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdElEcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgZmlyc3RJRHNbYXhpc10gPSBmaXJzdElEc1theGlzXSB8fCBpZDtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgZmlyc3RJRHNbYXhpc10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNjYWxlcztcbn1cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuICBpbml0T3B0aW9ucyhjb25maWcpO1xuICByZXR1cm4gY29uZmlnO1xufVxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5jbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjIHx8IGlzRnVuY3Rpb24odmFsdWVba2V5XSksIGZhbHNlKTtcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjMuOS4xXCI7XG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuY2xhc3MgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG4gICAgY2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG4gICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICB9XG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuICBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICB9XG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xuICAgIGNvbnN0IHtjYW52YXMsIGN0eH0gPSB0aGlzO1xuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdkZXN0cm95Jyk7XG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZGV0YWNoZWQ7XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICByZXBsYXksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgIH07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkIHx8IHJlcGxheSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbn1cbmNvbnN0IGludmFsaWRhdGVQbHVnaW5zID0gKCkgPT4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbmNvbnN0IGVudW1lcmFibGUgPSB0cnVlO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhcnQsIHtcbiAgZGVmYXVsdHM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBkZWZhdWx0c1xuICB9LFxuICBpbnN0YW5jZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBpbnN0YW5jZXNcbiAgfSxcbiAgb3ZlcnJpZGVzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogb3ZlcnJpZGVzXG4gIH0sXG4gIHJlZ2lzdHJ5OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogcmVnaXN0cnlcbiAgfSxcbiAgdmVyc2lvbjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHZlcnNpb25cbiAgfSxcbiAgZ2V0Q2hhcnQ6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBnZXRDaGFydFxuICB9LFxuICByZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5jbGFzcyBEYXRlQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG4gIGluaXQoY2hhcnRPcHRpb25zKSB7fVxuICBmb3JtYXRzKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHBhcnNlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBmb3JtYXQodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBhZGQodGltZXN0YW1wLCBhbW91bnQsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBkaWZmKGEsIGIsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBzdGFydE9mKHRpbWVzdGFtcCwgdW5pdCwgd2Vla2RheSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGVuZE9mKHRpbWVzdGFtcCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcbnZhciBfYWRhcHRlcnMgPSB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlclxufTtcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5jbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCB7aVNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSlcbiAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtZXRhIG9mIG1ldGFzZXRzKSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTtcbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XG4gICAgfVxuICAgIGlmIChiYXNlID09PSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShhY3R1YWxCYXNlKSkge1xuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcbiAgICAgIGJhc2UgKz0gaGFsZkdyaWQ7XG4gICAgICBzaXplIC09IGhhbGZHcmlkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICBjb25zdCBzY2FsZSA9IHJ1bGVyLnNjYWxlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XG4gICAgbGV0IGNlbnRlciwgc2l6ZTtcbiAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG4gICAgICAgID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG4gICAgICBoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcbiAgICAgIGNlbnRlcixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgaWxlbiA9IHJlY3RzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuQmFyQ29udHJvbGxlci5pZCA9ICdiYXInO1xuQmFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcbiAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgZ3JvdXBlZDogdHJ1ZSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgIH1cbiAgfVxufTtcbkJhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbWV0YS5sYWJlbCxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuQnViYmxlQ29udHJvbGxlci5pZCA9ICdidWJibGUnO1xuQnViYmxlQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgIH1cbiAgfVxufTtcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge31cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgIH0sXG4gIH0sXG4gIGN1dG91dDogJzUwJScsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6ICdyJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgbGV0IGRhdGFMYWJlbCA9IHRvb2x0aXBJdGVtLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFMYWJlbCkpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgKz0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhTGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBkYXRhOiBwb2ludHMgPSBbXSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuTGluZUNvbnRyb2xsZXIuaWQgPSAnbGluZSc7XG5MaW5lQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbn07XG5MaW5lQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICB9LFxuICB9XG59O1xuXG5jbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuUG9sYXJBcmVhQ29udHJvbGxlci5pZCA9ICdwb2xhckFyZWEnO1xuUG9sYXJBcmVhQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgfSxcbiAgfSxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHN0YXJ0QW5nbGU6IDAsXG59O1xuUG9sYXJBcmVhQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jaGFydC5kYXRhLmxhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gKyAnOiAnICsgY29udGV4dC5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcbn1cblBpZUNvbnRyb2xsZXIuaWQgPSAncGllJztcblBpZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGN1dG91dDogMCxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJSdcbn07XG5cbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuUmFkYXJDb250cm9sbGVyLmlkID0gJ3JhZGFyJztcblJhZGFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBlbGVtZW50czoge1xuICAgIGxpbmU6IHtcbiAgICAgIGZpbGw6ICdzdGFydCdcbiAgICB9XG4gIH0sXG59O1xuUmFkYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGE6IHBvaW50cyA9IFtdfSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgc2hvd0xpbmUpIHtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gcmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcblNjYXR0ZXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiBmYWxzZSxcbiAgZmlsbDogZmFsc2Vcbn07XG5TY2F0dGVyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kZTogJ3BvaW50J1xuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoaXRlbSkge1xuICAgICAgICAgIHJldHVybiAnKCcgKyBpdGVtLmxhYmVsICsgJywgJyArIGl0ZW0uZm9ybWF0dGVkVmFsdWUgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbnRyb2xsZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQmFyQ29udHJvbGxlcjogQmFyQ29udHJvbGxlcixcbkJ1YmJsZUNvbnRyb2xsZXI6IEJ1YmJsZUNvbnRyb2xsZXIsXG5Eb3VnaG51dENvbnRyb2xsZXI6IERvdWdobnV0Q29udHJvbGxlcixcbkxpbmVDb250cm9sbGVyOiBMaW5lQ29udHJvbGxlcixcblBvbGFyQXJlYUNvbnRyb2xsZXI6IFBvbGFyQXJlYUNvbnRyb2xsZXIsXG5QaWVDb250cm9sbGVyOiBQaWVDb250cm9sbGVyLFxuUmFkYXJDb250cm9sbGVyOiBSYWRhckNvbnRyb2xsZXIsXG5TY2F0dGVyQ29udHJvbGxlcjogU2NhdHRlckNvbnRyb2xsZXJcbn0pO1xuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXN9ID0gZWxlbWVudDtcbiAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMkMShhcmMsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgYW5nbGVEZWx0YSkge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cbmZ1bmN0aW9uIHJUaGV0YVRvWFkociwgdGhldGEsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZCwgY2lyY3VsYXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzcGFjaW5nKSB7XG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuICAgIGNvbnN0IG91dGVyRW5kWCA9IE1hdGguY29zKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgc3RhcnRBbmdsZSArIFRBVSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSAlIFRBVTtcbiAgICAgIGlmIChjaXJjdW1mZXJlbmNlICUgVEFVID09PSAwKSB7XG4gICAgICAgIGVuZEFuZ2xlICs9IFRBVTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCBmdWxsQ2lyY2xlc30gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gZWxlbWVudC5pbm5lclJhZGl1cyArIHBpeGVsTWFyZ2luO1xuICBsZXQgaTtcbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSArIFRBVSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpIHtcbiAgY29uc3Qge29wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGV9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG4gIGlmIChlbGVtZW50LmZ1bGxDaXJjbGVzKSB7XG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LnN0cm9rZSgpO1xufVxuY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShjaGFydFgsIGNoYXJ0WSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSB0aGlzLm9wdGlvbnMuc3BhY2luZyAvIDI7XG4gICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZScsXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyAyO1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgcmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCk7XG4gICAgICBpZiAodGhpcy5jaXJjdW1mZXJlbmNlID49IFBJKSB7XG4gICAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgZW5kQW5nbGUgPSBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5BcmNFbGVtZW50LmlkID0gJ2FyYyc7XG5BcmNFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gIGJvcmRlckpvaW5TdHlsZTogdW5kZWZpbmVkLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBvZmZzZXQ6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIGFuZ2xlOiB1bmRlZmluZWQsXG4gIGNpcmN1bGFyOiB0cnVlLFxufTtcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xufTtcblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cbiAgcmV0dXJuIGxpbmVUbztcbn1cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcHJldiA9IHBvaW50O1xuICB9XG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuICByZXR1cm4gISFsb29wO1xufVxuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5MaW5lRWxlbWVudC5pZCA9ICdsaW5lJztcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gIGZpbGw6IGZhbHNlLFxuICBzcGFuR2FwczogZmFsc2UsXG4gIHN0ZXBwZWQ6IGZhbHNlLFxuICB0ZW5zaW9uOiAwLFxufTtcbkxpbmVFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuTGluZUVsZW1lbnQuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbn07XG5cbmZ1bmN0aW9uIGluUmFuZ2UkMShlbCwgcG9zLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgc2l6ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuICBkcmF3KGN0eCwgYXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cblBvaW50RWxlbWVudC5pZCA9ICdwb2ludCc7XG5Qb2ludEVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgcmFkaXVzOiAzLFxuICByb3RhdGlvbjogMFxufTtcblBvaW50RWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSBiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5CYXJFbGVtZW50LmlkID0gJ2Jhcic7XG5CYXJFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxufTtcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5MaW5lRWxlbWVudDogTGluZUVsZW1lbnQsXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcbkJhckVsZW1lbnQ6IEJhckVsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXRhLmNvbnRyb2xsZXIuc3VwcG9ydHNEZWNpbWF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIF9zaG91bGRBcHBseUZpbGwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuICBsZXQgdGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsKTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cbmZ1bmN0aW9uIGRlY29kZVRhcmdldEluZGV4KGZpcnN0Q2gsIGluZGV4LCB0YXJnZXQsIGNvdW50KSB7XG4gIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XG4gICAgdGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSkge1xuICBsZXQgcGl4ZWwgPSBudWxsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHBpeGVsID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS50b3A7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5mdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcbiAgbGV0IHZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgdmFsdWUgPSBmaWxsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuXG5mdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG5cbmNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cbiAgcGF0aFNlZ21lbnQoY3R4LCBib3VuZHMsIG9wdHMpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgYm91bmRzID0gYm91bmRzIHx8IHtzdGFydDogMCwgZW5kOiBUQVV9O1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBib3VuZHMuZW5kLCBib3VuZHMuc3RhcnQsIHRydWUpO1xuICAgIHJldHVybiAhb3B0cy5ib3VuZHM7XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUocGl4ZWwpKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG4gIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2xpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXN9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlfSA9IGNmZztcbiAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuICBjdHguc2F2ZSgpO1xuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5fSk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC5maXJzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICBjb25zdCB7dG9wLCBib3R0b219ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbnZhciBpbmRleCA9IHtcbiAgaWQ6ICdmaWxsZXInLFxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG4gICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcbmNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge2NvbG9yOiBmb250Q29sb3IsIHBhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94SGVpZ2h0ICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICBjb25zdCB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSA9IHRpdGxlUGFkZGluZy50b3AgKyBoYWxmRm9udFNpemU7XG4gICAgbGV0IHk7XG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmhlaWdodCksIDApO1xuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG4gIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgbGggPSB0aGlzLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2hvdmVyZWRJdGVtO1xuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGxiYWNrKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgaWYgKCh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnbW91c2VvdXQnKSAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgaWQ6ICdsZWdlbmQnLFxuICBfZWxlbWVudDogTGVnZW5kLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gIGlkOiAndGl0bGUnLFxuICBfZWxlbWVudDogVGl0bGUsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gIGxldCB3aWR0aCA9IDA7XG4gIGxldCBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZSgoY291bnQsIGJvZHlJdGVtKSA9PiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICBjb21iaW5lZEJvZHlMZW5ndGggKz0gdG9vbHRpcC5iZWZvcmVCb2R5Lmxlbmd0aCArIHRvb2x0aXAuYWZ0ZXJCb2R5Lmxlbmd0aDtcbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyAoYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nKSA6IDA7XG4gIGVhY2goYm9keSwgKGJvZHlJdGVtKSA9PiB7XG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuICB9KTtcbiAgd2lkdGhQYWRkaW5nID0gMDtcbiAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICBpZiAoeEFsaWduID09PSAnbGVmdCcgJiYgeCArIHdpZHRoICsgY2FyZXQgPiBjaGFydC53aWR0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xuICB9XG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cbiAgcmV0dXJuIHhBbGlnbjtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuICByZXR1cm4ge1xuICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgIHlBbGlnblxuICB9O1xufVxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2Uge1xuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydCB8fCBjb25maWcuX2NoYXJ0O1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5iZWZvcmVMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhzY29wZWQuYWZ0ZXJMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goc2NvcGVkLmxhYmVsQ29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goc2NvcGVkLmxhYmVsUG9pbnRTdHlsZS5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbFRleHRDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0aGlzLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gIH1cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgxID0gcHRYO1xuICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG4gICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nO1xuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWCh0aGlzLCAnbGVmdCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICBjb25zdCBjb2xvclkgPSBwdC55ICsgeU9mZlNldDtcbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsXG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKSArIGJveFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBjb2xvclkgKyBib3hIZWlnaHQgLyAyO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoKSkgOiAobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9ycy5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3JzLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGggLSBib3hQYWRkaW5nKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIGJveFBhZGRpbmcgLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvcnMuYm9yZGVyUmFkaXVzKTtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7XG4gIH1cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgaWYgKGFuaW1YIHx8IGFuaW1ZKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgdGhpcy5fYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCB0aGlzLl9zaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FyZXRYID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF93aWxsUmVuZGVyKCkge1xuICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblRvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIGJlZm9yZVRpdGxlOiBub29wLFxuICAgICAgdGl0bGUodG9vbHRpcEl0ZW1zKSB7XG4gICAgICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0sXG4gICAgICBhZnRlclRpdGxlOiBub29wLFxuICAgICAgYmVmb3JlQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUxhYmVsOiBub29wLFxuICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJzogJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgICAgbGFiZWwgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcbiAgICAgIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgICAgIH0sXG4gICAgICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWZ0ZXJMYWJlbDogbm9vcCxcbiAgICAgIGFmdGVyQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgICAgIGZvb3Rlcjogbm9vcCxcbiAgICAgIGFmdGVyRm9vdGVyOiBub29wXG4gICAgfVxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG5cbnZhciBwbHVnaW5zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuRGVjaW1hdGlvbjogcGx1Z2luX2RlY2ltYXRpb24sXG5GaWxsZXI6IGluZGV4LFxuTGVnZW5kOiBwbHVnaW5fbGVnZW5kLFxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcblRpdGxlOiBwbHVnaW5fdGl0bGUsXG5Ub29sdGlwOiBwbHVnaW5fdG9vbHRpcFxufSk7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5jbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuQ2F0ZWdvcnlTY2FsZS5pZCA9ICdjYXRlZ29yeSc7XG5DYXRlZ29yeVNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBDYXRlZ29yeVNjYWxlLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcn0pO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cbmNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICtyYXc7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IDE7XG4gICAgICBpZiAobWF4ID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG1pbiA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhtYXggKiAwLjA1KTtcbiAgICAgIH1cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG5cbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBtYXggOiAxO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG5MaW5lYXJTY2FsZS5pZCA9ICdsaW5lYXInO1xuTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcbiAgY29uc3QgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgbGV0IHRpY2tWYWwgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcbiAgbGV0IGV4cCA9IE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgZG8ge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICAgICsrc2lnbmlmaWNhbmQ7XG4gICAgaWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSAxO1xuICAgICAgKytleHA7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICByZXR1cm4gdGlja3M7XG59XG5jbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBjb25zdCBleHAgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodikpICsgbSk7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChleHAobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihleHAobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcbiAgICAgIHNldE1heChleHAobWluLCArMSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmIG1pbiA9PT0gZXhwKHRoaXMubWluLCAwKSkge1xuICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuTG9nYXJpdGhtaWNTY2FsZS5pZCA9ICdsb2dhcml0aG1pYyc7XG5Mb2dhcml0aG1pY1NjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBleHRyYSA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDI7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gb3B0cy5wb2ludExhYmVscy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gICAgY29uc3Qgc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG4gICAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gICAgaXRlbXMucHVzaCh7XG4gICAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICAgIHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICBsZWZ0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgICBib3R0b206IHkgKyBzaXplLmhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cbiAgcmV0dXJuICdyaWdodCc7XG59XG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ24sIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHNBdEluZGV4O1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzQXRJbmRleC5ib3JkZXJSYWRpdXMpO1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG4gICAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCkge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG4gIGlmICgoIWNpcmN1bGFyICYmICFsYWJlbENvdW50KSB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2gpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldDtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnN0cm9rZSgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMik7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEkgKyBhZGRpdGlvbmFsQW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZH0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgIH1cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4IC0gMSkpO1xuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG4gICAgICAgIGlmICghbGluZVdpZHRoIHx8ICFjb2xvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7fVxuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7fVxufVxuUmFkaWFsTGluZWFyU2NhbGUuaWQgPSAncmFkaWFsTGluZWFyJztcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICBkaXNwbGF5OiB0cnVlLFxuICBhbmltYXRlOiB0cnVlLFxuICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG4gIGFuZ2xlTGluZXM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgfSxcbiAgZ3JpZDoge1xuICAgIGNpcmN1bGFyOiBmYWxzZVxuICB9LFxuICBzdGFydEFuZ2xlOiAwLFxuICB0aWNrczoge1xuICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfSxcbiAgcG9pbnRMYWJlbHM6IHtcbiAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgZm9udDoge1xuICAgICAgc2l6ZTogMTBcbiAgICB9LFxuICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICB9XG59O1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdFJvdXRlcyA9IHtcbiAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxuICAndGlja3MuY29sb3InOiAnY29sb3InXG59O1xuUmFkaWFsTGluZWFyU2NhbGUuZGVzY3JpcHRvcnMgPSB7XG4gIGFuZ2xlTGluZXM6IHtcbiAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICB9XG59O1xuXG5jb25zdCBJTlRFUlZBTFMgPSB7XG4gIG1pbGxpc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxLCBzdGVwczogMTAwMH0sXG4gIHNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMTAwMCwgc3RlcHM6IDYwfSxcbiAgbWludXRlOiB7Y29tbW9uOiB0cnVlLCBzaXplOiA2MDAwMCwgc3RlcHM6IDYwfSxcbiAgaG91cjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMzYwMDAwMCwgc3RlcHM6IDI0fSxcbiAgZGF5OiB7Y29tbW9uOiB0cnVlLCBzaXplOiA4NjQwMDAwMCwgc3RlcHM6IDMwfSxcbiAgd2Vlazoge2NvbW1vbjogZmFsc2UsIHNpemU6IDYwNDgwMDAwMCwgc3RlcHM6IDR9LFxuICBtb250aDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMi42MjhlOSwgc3RlcHM6IDEyfSxcbiAgcXVhcnRlcjoge2NvbW1vbjogZmFsc2UsIHNpemU6IDcuODg0ZTksIHN0ZXBzOiA0fSxcbiAgeWVhcjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMy4xNTRlMTB9XG59O1xuY29uc3QgVU5JVFMgPSAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcbiAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKCFpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBwYXJzZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGFkYXB0ZXIucGFyc2UodmFsdWUsIHBhcnNlcilcbiAgICAgIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cbiAgcmV0dXJuICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG4gIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuICAgIGNvbnN0IHVuaXQgPSBVTklUU1tpXTtcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcbiAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcykge1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICBjb25zdCB7bG8sIGhpfSA9IF9sb29rdXAodGltZXN0YW1wcywgdGltZSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgdGlja3NbdGltZXN0YW1wXSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcbiAgY29uc3QgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgbWFqb3IsIGluZGV4O1xuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIG1hcFt2YWx1ZV0gPSBpO1xuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5jbGFzcyBUaW1lU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIHRoaXMuX21ham9yVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KHNjYWxlT3B0cywgb3B0cykge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgX2FkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcykge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgIHJldHVybiBmb3JtYXR0ZXIgPyBjYWxsYmFjayhmb3JtYXR0ZXIsIFtsYWJlbCwgaW5kZXgsIHRpY2tzXSwgdGhpcykgOiBsYWJlbDtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuVGltZVNjYWxlLmlkID0gJ3RpbWUnO1xuVGltZVNjYWxlLmRlZmF1bHRzID0ge1xuICBib3VuZHM6ICdkYXRhJyxcbiAgYWRhcHRlcnM6IHt9LFxuICB0aW1lOiB7XG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB1bml0OiBmYWxzZSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgaXNvV2Vla2RheTogZmFsc2UsXG4gICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6ICdhdXRvJyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblRpbWVTZXJpZXNTY2FsZS5pZCA9ICd0aW1lc2VyaWVzJztcblRpbWVTZXJpZXNTY2FsZS5kZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbkNoYXJ0LnJlZ2lzdGVyKGNvbnRyb2xsZXJzLCBzY2FsZXMsIGVsZW1lbnRzLCBwbHVnaW5zKTtcbkNoYXJ0LmhlbHBlcnMgPSB7Li4uaGVscGVyc307XG5DaGFydC5fYWRhcHRlcnMgPSBfYWRhcHRlcnM7XG5DaGFydC5BbmltYXRpb24gPSBBbmltYXRpb247XG5DaGFydC5BbmltYXRpb25zID0gQW5pbWF0aW9ucztcbkNoYXJ0LmFuaW1hdG9yID0gYW5pbWF0b3I7XG5DaGFydC5jb250cm9sbGVycyA9IHJlZ2lzdHJ5LmNvbnRyb2xsZXJzLml0ZW1zO1xuQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIgPSBEYXRhc2V0Q29udHJvbGxlcjtcbkNoYXJ0LkVsZW1lbnQgPSBFbGVtZW50O1xuQ2hhcnQuZWxlbWVudHMgPSBlbGVtZW50cztcbkNoYXJ0LkludGVyYWN0aW9uID0gSW50ZXJhY3Rpb247XG5DaGFydC5sYXlvdXRzID0gbGF5b3V0cztcbkNoYXJ0LnBsYXRmb3JtcyA9IHBsYXRmb3JtcztcbkNoYXJ0LlNjYWxlID0gU2NhbGU7XG5DaGFydC5UaWNrcyA9IFRpY2tzO1xuT2JqZWN0LmFzc2lnbihDaGFydCwgY29udHJvbGxlcnMsIHNjYWxlcywgZWxlbWVudHMsIHBsdWdpbnMsIHBsYXRmb3Jtcyk7XG5DaGFydC5DaGFydCA9IENoYXJ0O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5DaGFydCA9IENoYXJ0O1xufVxuXG5yZXR1cm4gQ2hhcnQ7XG5cbn0pKTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uJykuaGVscGVycztcbiIsICIvKiFcbiAqIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgdjIuMi4wXG4gKiBodHRwczovL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMubmV0bGlmeS5hcHBcbiAqIChjKSAyMDE3LTIwMjIgY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2NoYXJ0LmpzL2hlbHBlcnMnKSwgcmVxdWlyZSgnY2hhcnQuanMnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnY2hhcnQuanMvaGVscGVycycsICdjaGFydC5qcyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ2hhcnREYXRhTGFiZWxzID0gZmFjdG9yeShnbG9iYWwuQ2hhcnQuaGVscGVycywgZ2xvYmFsLkNoYXJ0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGhlbHBlcnMsIGNoYXJ0X2pzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIC8vIGRldmljZVBpeGVsUmF0aW8gaXMgdW5kZWZpbmVkIG9uIElFMTBcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAyMDQxODAvODgzNzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzg1XG4gICAgdmFyIHNjcmVlbiA9IHdpbmRvdy5zY3JlZW47XG4gICAgaWYgKHNjcmVlbikge1xuICAgICAgcmV0dXJuIChzY3JlZW4uZGV2aWNlWERQSSB8fCAxKSAvIChzY3JlZW4ubG9naWNhbFhEUEkgfHwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59KCkpO1xuXG52YXIgdXRpbHMgPSB7XG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLnRvVGV4dExpbmVzXG4gIHRvVGV4dExpbmVzOiBmdW5jdGlvbihpbnB1dHMpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgaW5wdXQ7XG5cbiAgICBpbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzKTtcbiAgICB3aGlsZSAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgaW5wdXQgPSBpbnB1dHMucG9wKCk7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBsaW5lcy51bnNoaWZ0LmFwcGx5KGxpbmVzLCBpbnB1dC5zcGxpdCgnXFxuJykpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBpbnB1dHMucHVzaC5hcHBseShpbnB1dHMsIGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWhlbHBlcnMuaXNOdWxsT3JVbmRlZihpbnB1dHMpKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQoJycgKyBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9LFxuXG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLmNhbnZhcy50ZXh0U2l6ZVxuICAvLyBAdG9kbyBjYWNoZSBjYWxscyBvZiBtZWFzdXJlVGV4dCBpZiBmb250IGRvZXNuJ3QgY2hhbmdlPyFcbiAgdGV4dFNpemU6IGZ1bmN0aW9uKGN0eCwgbGluZXMsIGZvbnQpIHtcbiAgICB2YXIgaXRlbXMgPSBbXS5jb25jYXQobGluZXMpO1xuICAgIHZhciBpbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBwcmV2ID0gY3R4LmZvbnQ7XG4gICAgdmFyIHdpZHRoID0gMDtcbiAgICB2YXIgaTtcblxuICAgIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KGN0eC5tZWFzdXJlVGV4dChpdGVtc1tpXSkud2lkdGgsIHdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZm9udCA9IHByZXY7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBpbGVuICogZm9udC5saW5lSGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB2YWx1ZSBib3VuZGVkIGJ5IG1pbiBhbmQgbWF4LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gbWF4KG1pbiwgbWluKHZhbHVlLCBtYXgpKS5cbiAgICogQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLmJvdW5kXG4gICAqIGh0dHBzOi8vZG9jLnF0LmlvL3F0LTUvcXRnbG9iYWwuaHRtbCNxQm91bmRcbiAgICovXG4gIGJvdW5kOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcGFpciBbdmFsdWUsIHN0YXRlXSB3aGVyZSBzdGF0ZSBpczpcbiAgICogKiAtMTogdmFsdWUgaXMgb25seSBpbiBhMCAocmVtb3ZlZClcbiAgICogKiAgMTogdmFsdWUgaXMgb25seSBpbiBhMSAoYWRkZWQpXG4gICAqL1xuICBhcnJheURpZmY6IGZ1bmN0aW9uKGEwLCBhMSkge1xuICAgIHZhciBwcmV2ID0gYTAuc2xpY2UoKTtcbiAgICB2YXIgdXBkYXRlcyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCB2O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGExLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdiA9IGExW2ldO1xuICAgICAgaiA9IHByZXYuaW5kZXhPZih2KTtcblxuICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChbdiwgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldi5zcGxpY2UoaiwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHByZXYubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB1cGRhdGVzLnB1c2goW3ByZXZbaV0sIC0xXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzcwXG4gICAqL1xuICByYXN0ZXJpemU6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2ICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcmllbnQocG9pbnQsIG9yaWdpbikge1xuICB2YXIgeDAgPSBvcmlnaW4ueDtcbiAgdmFyIHkwID0gb3JpZ2luLnk7XG5cbiAgaWYgKHgwID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt4OiAwLCB5OiAtMX07XG4gIH1cbiAgaWYgKHkwID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt4OiAxLCB5OiAwfTtcbiAgfVxuXG4gIHZhciBkeCA9IHBvaW50LnggLSB4MDtcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHkwO1xuICB2YXIgbG4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIHJldHVybiB7XG4gICAgeDogbG4gPyBkeCAvIGxuIDogMCxcbiAgICB5OiBsbiA/IGR5IC8gbG4gOiAtMVxuICB9O1xufVxuXG5mdW5jdGlvbiBhbGlnbmVkKHgsIHksIHZ4LCB2eSwgYWxpZ24pIHtcbiAgc3dpdGNoIChhbGlnbikge1xuICBjYXNlICdjZW50ZXInOlxuICAgIHZ4ID0gdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICdib3R0b20nOlxuICAgIHZ4ID0gMDtcbiAgICB2eSA9IDE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JpZ2h0JzpcbiAgICB2eCA9IDE7XG4gICAgdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICdsZWZ0JzpcbiAgICB2eCA9IC0xO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAndG9wJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAtMTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3RhcnQnOlxuICAgIHZ4ID0gLXZ4O1xuICAgIHZ5ID0gLXZ5O1xuICAgIGJyZWFrO1xuICBjYXNlICdlbmQnOlxuICAgIC8vIGtlZXAgbmF0dXJhbCBvcmllbnRhdGlvblxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIC8vIGNsb2Nrd2lzZSByb3RhdGlvbiAoaW4gZGVncmVlKVxuICAgIGFsaWduICo9IChNYXRoLlBJIC8gMTgwKTtcbiAgICB2eCA9IE1hdGguY29zKGFsaWduKTtcbiAgICB2eSA9IE1hdGguc2luKGFsaWduKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHZ4OiB2eCxcbiAgICB2eTogdnlcbiAgfTtcbn1cblxuLy8gTGluZSBjbGlwcGluZyAoQ29oZW5cdTIwMTNTdXRoZXJsYW5kIGFsZ29yaXRobSlcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuXHUyMDEzU3V0aGVybGFuZF9hbGdvcml0aG1cblxudmFyIFJfSU5TSURFID0gMDtcbnZhciBSX0xFRlQgPSAxO1xudmFyIFJfUklHSFQgPSAyO1xudmFyIFJfQk9UVE9NID0gNDtcbnZhciBSX1RPUCA9IDg7XG5cbmZ1bmN0aW9uIHJlZ2lvbih4LCB5LCByZWN0KSB7XG4gIHZhciByZXMgPSBSX0lOU0lERTtcblxuICBpZiAoeCA8IHJlY3QubGVmdCkge1xuICAgIHJlcyB8PSBSX0xFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IHJlY3QucmlnaHQpIHtcbiAgICByZXMgfD0gUl9SSUdIVDtcbiAgfVxuICBpZiAoeSA8IHJlY3QudG9wKSB7XG4gICAgcmVzIHw9IFJfVE9QO1xuICB9IGVsc2UgaWYgKHkgPiByZWN0LmJvdHRvbSkge1xuICAgIHJlcyB8PSBSX0JPVFRPTTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNsaXBwZWQoc2VnbWVudCwgYXJlYSkge1xuICB2YXIgeDAgPSBzZWdtZW50LngwO1xuICB2YXIgeTAgPSBzZWdtZW50LnkwO1xuICB2YXIgeDEgPSBzZWdtZW50LngxO1xuICB2YXIgeTEgPSBzZWdtZW50LnkxO1xuICB2YXIgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgdmFyIHIxID0gcmVnaW9uKHgxLCB5MSwgYXJlYSk7XG4gIHZhciByLCB4LCB5O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIShyMCB8IHIxKSB8fCAocjAgJiByMSkpIHtcbiAgICAgIC8vIGJvdGggcG9pbnRzIGluc2lkZSBvciBvbiB0aGUgc2FtZSBzaWRlOiBubyBjbGlwcGluZ1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYXQgbGVhc3Qgb25lIHBvaW50IGlzIG91dHNpZGVcbiAgICByID0gcjAgfHwgcjE7XG5cbiAgICBpZiAociAmIFJfVE9QKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS50b3AgLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS50b3A7XG4gICAgfSBlbHNlIGlmIChyICYgUl9CT1RUT00pIHtcbiAgICAgIHggPSB4MCArICh4MSAtIHgwKSAqIChhcmVhLmJvdHRvbSAtIHkwKSAvICh5MSAtIHkwKTtcbiAgICAgIHkgPSBhcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX1JJR0hUKSB7XG4gICAgICB5ID0geTAgKyAoeTEgLSB5MCkgKiAoYXJlYS5yaWdodCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICAgIHggPSBhcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAociAmIFJfTEVGVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEubGVmdCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICAgIHggPSBhcmVhLmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHIgPT09IHIwKSB7XG4gICAgICB4MCA9IHg7XG4gICAgICB5MCA9IHk7XG4gICAgICByMCA9IHJlZ2lvbih4MCwgeTAsIGFyZWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MSA9IHg7XG4gICAgICB5MSA9IHk7XG4gICAgICByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDA6IHgwLFxuICAgIHgxOiB4MSxcbiAgICB5MDogeTAsXG4gICAgeTE6IHkxXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGUkMShyYW5nZSwgY29uZmlnKSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuYW5jaG9yO1xuICB2YXIgc2VnbWVudCA9IHJhbmdlO1xuICB2YXIgeCwgeTtcblxuICBpZiAoY29uZmlnLmNsYW1wKSB7XG4gICAgc2VnbWVudCA9IGNsaXBwZWQoc2VnbWVudCwgY29uZmlnLmFyZWEpO1xuICB9XG5cbiAgaWYgKGFuY2hvciA9PT0gJ3N0YXJ0Jykge1xuICAgIHggPSBzZWdtZW50LngwO1xuICAgIHkgPSBzZWdtZW50LnkwO1xuICB9IGVsc2UgaWYgKGFuY2hvciA9PT0gJ2VuZCcpIHtcbiAgICB4ID0gc2VnbWVudC54MTtcbiAgICB5ID0gc2VnbWVudC55MTtcbiAgfSBlbHNlIHtcbiAgICB4ID0gKHNlZ21lbnQueDAgKyBzZWdtZW50LngxKSAvIDI7XG4gICAgeSA9IChzZWdtZW50LnkwICsgc2VnbWVudC55MSkgLyAyO1xuICB9XG5cbiAgcmV0dXJuIGFsaWduZWQoeCwgeSwgcmFuZ2UudngsIHJhbmdlLnZ5LCBjb25maWcuYWxpZ24pO1xufVxuXG52YXIgcG9zaXRpb25lcnMgPSB7XG4gIGFyYzogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciBhbmdsZSA9IChlbC5zdGFydEFuZ2xlICsgZWwuZW5kQW5nbGUpIC8gMjtcbiAgICB2YXIgdnggPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHZ5ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciByMCA9IGVsLmlubmVyUmFkaXVzO1xuICAgIHZhciByMSA9IGVsLm91dGVyUmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCArIHZ4ICogcjAsXG4gICAgICB5MDogZWwueSArIHZ5ICogcjAsXG4gICAgICB4MTogZWwueCArIHZ4ICogcjEsXG4gICAgICB5MTogZWwueSArIHZ5ICogcjEsXG4gICAgICB2eDogdngsXG4gICAgICB2eTogdnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIHBvaW50OiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuICAgIHZhciByeCA9IHYueCAqIGVsLm9wdGlvbnMucmFkaXVzO1xuICAgIHZhciByeSA9IHYueSAqIGVsLm9wdGlvbnMucmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCAtIHJ4LFxuICAgICAgeTA6IGVsLnkgLSByeSxcbiAgICAgIHgxOiBlbC54ICsgcngsXG4gICAgICB5MTogZWwueSArIHJ5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGJhcjogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgeCA9IGVsLng7XG4gICAgdmFyIHkgPSBlbC55O1xuICAgIHZhciBzeCA9IDA7XG4gICAgdmFyIHN5ID0gMDtcblxuICAgIGlmIChlbC5ob3Jpem9udGFsKSB7XG4gICAgICB4ID0gTWF0aC5taW4oZWwueCwgZWwuYmFzZSk7XG4gICAgICBzeCA9IE1hdGguYWJzKGVsLmJhc2UgLSBlbC54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IE1hdGgubWluKGVsLnksIGVsLmJhc2UpO1xuICAgICAgc3kgPSBNYXRoLmFicyhlbC5iYXNlIC0gZWwueSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogeCxcbiAgICAgIHkwOiB5ICsgc3ksXG4gICAgICB4MTogeCArIHN4LFxuICAgICAgeTE6IHksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG5cbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcbiAgICAgIHgwOiBlbC54LFxuICAgICAgeTA6IGVsLnksXG4gICAgICB4MTogZWwueCArIChlbC53aWR0aCB8fCAwKSxcbiAgICAgIHkxOiBlbC55ICsgKGVsLmhlaWdodCB8fCAwKSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfVxufTtcblxudmFyIHJhc3Rlcml6ZSA9IHV0aWxzLnJhc3Rlcml6ZTtcblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhtb2RlbCkge1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aCB8fCAwO1xuICB2YXIgcGFkZGluZyA9IG1vZGVsLnBhZGRpbmc7XG4gIHZhciB0aCA9IG1vZGVsLnNpemUuaGVpZ2h0O1xuICB2YXIgdHcgPSBtb2RlbC5zaXplLndpZHRoO1xuICB2YXIgdHggPSAtdHcgLyAyO1xuICB2YXIgdHkgPSAtdGggLyAyO1xuXG4gIHJldHVybiB7XG4gICAgZnJhbWU6IHtcbiAgICAgIHg6IHR4IC0gcGFkZGluZy5sZWZ0IC0gYm9yZGVyV2lkdGgsXG4gICAgICB5OiB0eSAtIHBhZGRpbmcudG9wIC0gYm9yZGVyV2lkdGgsXG4gICAgICB3OiB0dyArIHBhZGRpbmcud2lkdGggKyBib3JkZXJXaWR0aCAqIDIsXG4gICAgICBoOiB0aCArIHBhZGRpbmcuaGVpZ2h0ICsgYm9yZGVyV2lkdGggKiAyXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICB4OiB0eCxcbiAgICAgIHk6IHR5LFxuICAgICAgdzogdHcsXG4gICAgICBoOiB0aFxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGVPcmlnaW4oZWwsIGNvbnRleHQpIHtcbiAgdmFyIHNjYWxlID0gY29udGV4dC5jaGFydC5nZXREYXRhc2V0TWV0YShjb250ZXh0LmRhdGFzZXRJbmRleCkudlNjYWxlO1xuXG4gIGlmICghc2NhbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzY2FsZS54Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgc2NhbGUueUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHt4OiBzY2FsZS54Q2VudGVyLCB5OiBzY2FsZS55Q2VudGVyfTtcbiAgfVxuXG4gIHZhciBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICByZXR1cm4gZWwuaG9yaXpvbnRhbCA/XG4gICAge3g6IHBpeGVsLCB5OiBudWxsfSA6XG4gICAge3g6IG51bGwsIHk6IHBpeGVsfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lcihlbCkge1xuICBpZiAoZWwgaW5zdGFuY2VvZiBjaGFydF9qcy5BcmNFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLmFyYztcbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBjaGFydF9qcy5Qb2ludEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMucG9pbnQ7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgY2hhcnRfanMuQmFyRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5iYXI7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9uZXJzLmZhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBkcmF3Um91bmRlZFJlY3QoY3R4LCB4LCB5LCB3LCBoLCByYWRpdXMpIHtcbiAgdmFyIEhBTEZfUEkgPSBNYXRoLlBJIC8gMjtcblxuICBpZiAocmFkaXVzKSB7XG4gICAgdmFyIHIgPSBNYXRoLm1pbihyYWRpdXMsIGggLyAyLCB3IC8gMik7XG4gICAgdmFyIGxlZnQgPSB4ICsgcjtcbiAgICB2YXIgdG9wID0geSArIHI7XG4gICAgdmFyIHJpZ2h0ID0geCArIHcgLSByO1xuICAgIHZhciBib3R0b20gPSB5ICsgaCAtIHI7XG5cbiAgICBjdHgubW92ZVRvKHgsIHRvcCk7XG4gICAgaWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgLUhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XG4gICAgICBjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIEhBTEZfUEksIE1hdGguUEkpO1xuICAgIH0gZWxzZSBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBjdHgubW92ZVRvKGxlZnQsIHkpO1xuICAgICAgY3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgSEFMRl9QSSwgTWF0aC5QSSArIEhBTEZfUEkpO1xuICAgIH0gZWxzZSBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIDApO1xuICAgICAgY3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIE1hdGguUEkpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3RnJhbWUoY3R4LCByZWN0LCBtb2RlbCkge1xuICB2YXIgYmdDb2xvciA9IG1vZGVsLmJhY2tncm91bmRDb2xvcjtcbiAgdmFyIGJvcmRlckNvbG9yID0gbW9kZWwuYm9yZGVyQ29sb3I7XG4gIHZhciBib3JkZXJXaWR0aCA9IG1vZGVsLmJvcmRlcldpZHRoO1xuXG4gIGlmICghYmdDb2xvciAmJiAoIWJvcmRlckNvbG9yIHx8ICFib3JkZXJXaWR0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgZHJhd1JvdW5kZWRSZWN0KFxuICAgIGN0eCxcbiAgICByYXN0ZXJpemUocmVjdC54KSArIGJvcmRlcldpZHRoIC8gMixcbiAgICByYXN0ZXJpemUocmVjdC55KSArIGJvcmRlcldpZHRoIC8gMixcbiAgICByYXN0ZXJpemUocmVjdC53KSAtIGJvcmRlcldpZHRoLFxuICAgIHJhc3Rlcml6ZShyZWN0LmgpIC0gYm9yZGVyV2lkdGgsXG4gICAgbW9kZWwuYm9yZGVyUmFkaXVzKTtcblxuICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgaWYgKGJnQ29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICB9XG5cbiAgaWYgKGJvcmRlckNvbG9yICYmIGJvcmRlcldpZHRoKSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRleHRHZW9tZXRyeShyZWN0LCBhbGlnbiwgZm9udCkge1xuICB2YXIgaCA9IGZvbnQubGluZUhlaWdodDtcbiAgdmFyIHcgPSByZWN0Lnc7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueSArIGggLyAyO1xuXG4gIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4ICs9IHcgLyAyO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJyB8fCBhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gdztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaDogaCxcbiAgICB3OiB3LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3VGV4dExpbmUoY3R4LCB0ZXh0LCBjZmcpIHtcbiAgdmFyIHNoYWRvdyA9IGN0eC5zaGFkb3dCbHVyO1xuICB2YXIgc3Ryb2tlZCA9IGNmZy5zdHJva2VkO1xuICB2YXIgeCA9IHJhc3Rlcml6ZShjZmcueCk7XG4gIHZhciB5ID0gcmFzdGVyaXplKGNmZy55KTtcbiAgdmFyIHcgPSByYXN0ZXJpemUoY2ZnLncpO1xuXG4gIGlmIChzdHJva2VkKSB7XG4gICAgY3R4LnN0cm9rZVRleHQodGV4dCwgeCwgeSwgdyk7XG4gIH1cblxuICBpZiAoY2ZnLmZpbGxlZCkge1xuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xuICAgICAgLy8gUHJldmVudCBkcmF3aW5nIHNoYWRvdyBvbiBib3RoIHRoZSB0ZXh0IHN0cm9rZSBhbmQgZmlsbCwgc29cbiAgICAgIC8vIGlmIHRoZSB0ZXh0IGlzIHN0cm9rZWQsIHJlbW92ZSB0aGUgc2hhZG93IGZvciB0aGUgdGV4dCBmaWxsLlxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5LCB3KTtcblxuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3c7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0KGN0eCwgbGluZXMsIHJlY3QsIG1vZGVsKSB7XG4gIHZhciBhbGlnbiA9IG1vZGVsLnRleHRBbGlnbjtcbiAgdmFyIGNvbG9yID0gbW9kZWwuY29sb3I7XG4gIHZhciBmaWxsZWQgPSAhIWNvbG9yO1xuICB2YXIgZm9udCA9IG1vZGVsLmZvbnQ7XG4gIHZhciBpbGVuID0gbGluZXMubGVuZ3RoO1xuICB2YXIgc3Ryb2tlQ29sb3IgPSBtb2RlbC50ZXh0U3Ryb2tlQ29sb3I7XG4gIHZhciBzdHJva2VXaWR0aCA9IG1vZGVsLnRleHRTdHJva2VXaWR0aDtcbiAgdmFyIHN0cm9rZWQgPSBzdHJva2VDb2xvciAmJiBzdHJva2VXaWR0aDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFpbGVuIHx8ICghZmlsbGVkICYmICFzdHJva2VkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFkanVzdCBjb29yZGluYXRlcyBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudCBhbmQgbGluZSBoZWlnaHRcbiAgcmVjdCA9IHRleHRHZW9tZXRyeShyZWN0LCBhbGlnbiwgZm9udCk7XG5cbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgY3R4LnRleHRBbGlnbiA9IGFsaWduO1xuICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gIGN0eC5zaGFkb3dCbHVyID0gbW9kZWwudGV4dFNoYWRvd0JsdXI7XG4gIGN0eC5zaGFkb3dDb2xvciA9IG1vZGVsLnRleHRTaGFkb3dDb2xvcjtcblxuICBpZiAoZmlsbGVkKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICB9XG4gIGlmIChzdHJva2VkKSB7XG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZHJhd1RleHRMaW5lKGN0eCwgbGluZXNbaV0sIHtcbiAgICAgIHN0cm9rZWQ6IHN0cm9rZWQsXG4gICAgICBmaWxsZWQ6IGZpbGxlZCxcbiAgICAgIHc6IHJlY3QudyxcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSArIHJlY3QuaCAqIGlcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgTGFiZWwgPSBmdW5jdGlvbihjb25maWcsIGN0eCwgZWwsIGluZGV4KSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgbWUuX2NvbmZpZyA9IGNvbmZpZztcbiAgbWUuX2luZGV4ID0gaW5kZXg7XG4gIG1lLl9tb2RlbCA9IG51bGw7XG4gIG1lLl9yZWN0cyA9IG51bGw7XG4gIG1lLl9jdHggPSBjdHg7XG4gIG1lLl9lbCA9IGVsO1xufTtcblxuaGVscGVycy5tZXJnZShMYWJlbC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW9kZWxpemU6IGZ1bmN0aW9uKGRpc3BsYXksIGxpbmVzLCBjb25maWcsIGNvbnRleHQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IG1lLl9pbmRleDtcbiAgICB2YXIgZm9udCA9IGhlbHBlcnMudG9Gb250KGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmZvbnQsIHt9XSwgY29udGV4dCwgaW5kZXgpKTtcbiAgICB2YXIgY29sb3IgPSBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5jb2xvciwgY2hhcnRfanMuZGVmYXVsdHMuY29sb3JdLCBjb250ZXh0LCBpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWxpZ246IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmFsaWduLCAnY2VudGVyJ10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGFuY2hvcjogaGVscGVycy5yZXNvbHZlKFtjb25maWcuYW5jaG9yLCAnY2VudGVyJ10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGFyZWE6IGNvbnRleHQuY2hhcnQuY2hhcnRBcmVhLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5iYWNrZ3JvdW5kQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJDb2xvcjogaGVscGVycy5yZXNvbHZlKFtjb25maWcuYm9yZGVyQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJSYWRpdXM6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmJvcmRlclJhZGl1cywgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlcldpZHRoOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5ib3JkZXJXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNsYW1wOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5jbGFtcCwgZmFsc2VdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjbGlwOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5jbGlwLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGRpc3BsYXk6IGRpc3BsYXksXG4gICAgICBmb250OiBmb250LFxuICAgICAgbGluZXM6IGxpbmVzLFxuICAgICAgb2Zmc2V0OiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5vZmZzZXQsIDRdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBvcGFjaXR5OiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5vcGFjaXR5LCAxXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgb3JpZ2luOiBnZXRTY2FsZU9yaWdpbihtZS5fZWwsIGNvbnRleHQpLFxuICAgICAgcGFkZGluZzogaGVscGVycy50b1BhZGRpbmcoaGVscGVycy5yZXNvbHZlKFtjb25maWcucGFkZGluZywgNF0sIGNvbnRleHQsIGluZGV4KSksXG4gICAgICBwb3NpdGlvbmVyOiBnZXRQb3NpdGlvbmVyKG1lLl9lbCksXG4gICAgICByb3RhdGlvbjogaGVscGVycy5yZXNvbHZlKFtjb25maWcucm90YXRpb24sIDBdLCBjb250ZXh0LCBpbmRleCkgKiAoTWF0aC5QSSAvIDE4MCksXG4gICAgICBzaXplOiB1dGlscy50ZXh0U2l6ZShtZS5fY3R4LCBsaW5lcywgZm9udCksXG4gICAgICB0ZXh0QWxpZ246IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnRleHRBbGlnbiwgJ3N0YXJ0J10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTaGFkb3dCbHVyOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Qmx1ciwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTaGFkb3dDb2xvcjogaGVscGVycy5yZXNvbHZlKFtjb25maWcudGV4dFNoYWRvd0NvbG9yLCBjb2xvcl0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTdHJva2VDb2xvcjogaGVscGVycy5yZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZUNvbG9yLCBjb2xvcl0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogaGVscGVycy5yZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZVdpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtb2RlbCA9IG51bGw7XG4gICAgdmFyIHJlY3RzID0gbnVsbDtcbiAgICB2YXIgaW5kZXggPSBtZS5faW5kZXg7XG4gICAgdmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XG4gICAgdmFyIHZhbHVlLCBsYWJlbCwgbGluZXM7XG5cbiAgICAvLyBXZSBmaXJzdCByZXNvbHZlIHRoZSBkaXNwbGF5IG9wdGlvbiAoc2VwYXJhdGVseSkgdG8gYXZvaWQgY29tcHV0aW5nXG4gICAgLy8gb3RoZXIgb3B0aW9ucyBpbiBjYXNlIHRoZSBsYWJlbCBpcyBoaWRkZW4gKGkuZS4gZGlzcGxheTogZmFsc2UpLlxuICAgIHZhciBkaXNwbGF5ID0gaGVscGVycy5yZXNvbHZlKFtjb25maWcuZGlzcGxheSwgdHJ1ZV0sIGNvbnRleHQsIGluZGV4KTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICB2YWx1ZSA9IGNvbnRleHQuZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGxhYmVsID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChoZWxwZXJzLmNhbGxiYWNrKGNvbmZpZy5mb3JtYXR0ZXIsIFt2YWx1ZSwgY29udGV4dF0pLCB2YWx1ZSk7XG4gICAgICBsaW5lcyA9IGhlbHBlcnMuaXNOdWxsT3JVbmRlZihsYWJlbCkgPyBbXSA6IHV0aWxzLnRvVGV4dExpbmVzKGxhYmVsKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCkge1xuICAgICAgICBtb2RlbCA9IG1lLl9tb2RlbGl6ZShkaXNwbGF5LCBsaW5lcywgY29uZmlnLCBjb250ZXh0KTtcbiAgICAgICAgcmVjdHMgPSBib3VuZGluZ1JlY3RzKG1vZGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZS5fbW9kZWwgPSBtb2RlbDtcbiAgICBtZS5fcmVjdHMgPSByZWN0cztcbiAgfSxcblxuICBnZW9tZXRyeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY3RzID8gdGhpcy5fcmVjdHMuZnJhbWUgOiB7fTtcbiAgfSxcblxuICByb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsID8gdGhpcy5fbW9kZWwucm90YXRpb24gOiAwO1xuICB9LFxuXG4gIHZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5vcGFjaXR5O1xuICB9LFxuXG4gIG1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oY2hhcnQsIGNlbnRlcikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcbiAgICB2YXIgbW9kZWwgPSBtZS5fbW9kZWw7XG4gICAgdmFyIHJlY3RzID0gbWUuX3JlY3RzO1xuICAgIHZhciBhcmVhO1xuXG4gICAgaWYgKCF0aGlzLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAobW9kZWwuY2xpcCkge1xuICAgICAgYXJlYSA9IG1vZGVsLmFyZWE7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgucmVjdChcbiAgICAgICAgYXJlYS5sZWZ0LFxuICAgICAgICBhcmVhLnRvcCxcbiAgICAgICAgYXJlYS5yaWdodCAtIGFyZWEubGVmdCxcbiAgICAgICAgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgIH1cblxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHV0aWxzLmJvdW5kKDAsIG1vZGVsLm9wYWNpdHksIDEpO1xuICAgIGN0eC50cmFuc2xhdGUocmFzdGVyaXplKGNlbnRlci54KSwgcmFzdGVyaXplKGNlbnRlci55KSk7XG4gICAgY3R4LnJvdGF0ZShtb2RlbC5yb3RhdGlvbik7XG5cbiAgICBkcmF3RnJhbWUoY3R4LCByZWN0cy5mcmFtZSwgbW9kZWwpO1xuICAgIGRyYXdUZXh0KGN0eCwgbW9kZWwubGluZXMsIHJlY3RzLnRleHQsIG1vZGVsKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn0pO1xuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcy9uby1udW1iZXItbWluc2FmZWludGVnZXJcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1tYXhzYWZlaW50ZWdlclxuXG5mdW5jdGlvbiByb3RhdGVkKHBvaW50LCBjZW50ZXIsIGFuZ2xlKSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHZhciBjeCA9IGNlbnRlci54O1xuICB2YXIgY3kgPSBjZW50ZXIueTtcblxuICByZXR1cm4ge1xuICAgIHg6IGN4ICsgY29zICogKHBvaW50LnggLSBjeCkgLSBzaW4gKiAocG9pbnQueSAtIGN5KSxcbiAgICB5OiBjeSArIHNpbiAqIChwb2ludC54IC0gY3gpICsgY29zICogKHBvaW50LnkgLSBjeSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdGVkKHBvaW50cywgYXhpcykge1xuICB2YXIgbWluID0gTUFYX0lOVEVHRVI7XG4gIHZhciBtYXggPSBNSU5fSU5URUdFUjtcbiAgdmFyIG9yaWdpbiA9IGF4aXMub3JpZ2luO1xuICB2YXIgaSwgcHQsIHZ4LCB2eSwgZHA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHB0ID0gcG9pbnRzW2ldO1xuICAgIHZ4ID0gcHQueCAtIG9yaWdpbi54O1xuICAgIHZ5ID0gcHQueSAtIG9yaWdpbi55O1xuICAgIGRwID0gYXhpcy52eCAqIHZ4ICsgYXhpcy52eSAqIHZ5O1xuICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZHApO1xuICAgIG1heCA9IE1hdGgubWF4KG1heCwgZHApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b0F4aXMocDAsIHAxKSB7XG4gIHZhciB2eCA9IHAxLnggLSBwMC54O1xuICB2YXIgdnkgPSBwMS55IC0gcDAueTtcbiAgdmFyIGxuID0gTWF0aC5zcXJ0KHZ4ICogdnggKyB2eSAqIHZ5KTtcblxuICByZXR1cm4ge1xuICAgIHZ4OiAocDEueCAtIHAwLngpIC8gbG4sXG4gICAgdnk6IChwMS55IC0gcDAueSkgLyBsbixcbiAgICBvcmlnaW46IHAwLFxuICAgIGxuOiBsblxuICB9O1xufVxuXG52YXIgSGl0Qm94ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JvdGF0aW9uID0gMDtcbiAgdGhpcy5fcmVjdCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgdzogMCxcbiAgICBoOiAwXG4gIH07XG59O1xuXG5oZWxwZXJzLm1lcmdlKEhpdEJveC5wcm90b3R5cGUsIHtcbiAgY2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHRoaXMuX3JlY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHIueCArIHIudyAvIDIsXG4gICAgICB5OiByLnkgKyByLmggLyAyXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNlbnRlciwgcmVjdCwgcm90YXRpb24pIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuX3JlY3QgPSB7XG4gICAgICB4OiByZWN0LnggKyBjZW50ZXIueCxcbiAgICAgIHk6IHJlY3QueSArIGNlbnRlci55LFxuICAgICAgdzogcmVjdC53LFxuICAgICAgaDogcmVjdC5oXG4gICAgfTtcbiAgfSxcblxuICBjb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtYXJnaW4gPSAxO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG5cbiAgICBwb2ludCA9IHJvdGF0ZWQocG9pbnQsIG1lLmNlbnRlcigpLCAtbWUuX3JvdGF0aW9uKTtcblxuICAgIHJldHVybiAhKHBvaW50LnggPCByZWN0LnggLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnkgPCByZWN0LnkgLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnggPiByZWN0LnggKyByZWN0LncgKyBtYXJnaW4gKiAyXG4gICAgICB8fCBwb2ludC55ID4gcmVjdC55ICsgcmVjdC5oICsgbWFyZ2luICogMik7XG4gIH0sXG5cbiAgLy8gU2VwYXJhdGluZyBBeGlzIFRoZW9yZW1cbiAgLy8gaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICB2YXIgcjAgPSB0aGlzLl9wb2ludHMoKTtcbiAgICB2YXIgcjEgPSBvdGhlci5fcG9pbnRzKCk7XG4gICAgdmFyIGF4ZXMgPSBbXG4gICAgICB0b0F4aXMocjBbMF0sIHIwWzFdKSxcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbM10pXG4gICAgXTtcbiAgICB2YXIgaSwgcHIwLCBwcjE7XG5cbiAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IG90aGVyLl9yb3RhdGlvbikge1xuICAgICAgLy8gT25seSBzZXBhcmF0ZSB3aXRoIHIxIGF4aXMgaWYgdGhlIHJvdGF0aW9uIGlzIGRpZmZlcmVudCxcbiAgICAgIC8vIGVsc2UgaXQncyBlbm91Z2ggdG8gc2VwYXJhdGUgcjAgYW5kIHIxIHdpdGggcjAgYXhpcyBvbmx5IVxuICAgICAgYXhlcy5wdXNoKFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzFdKSxcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVszXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHByMCA9IHByb2plY3RlZChyMCwgYXhlc1tpXSk7XG4gICAgICBwcjEgPSBwcm9qZWN0ZWQocjEsIGF4ZXNbaV0pO1xuXG4gICAgICBpZiAocHIwLm1heCA8IHByMS5taW4gfHwgcHIxLm1heCA8IHByMC5taW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BvaW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVjdCA9IG1lLl9yZWN0O1xuICAgIHZhciBhbmdsZSA9IG1lLl9yb3RhdGlvbjtcbiAgICB2YXIgY2VudGVyID0gbWUuY2VudGVyKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LnggKyByZWN0LncsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0Lmh9LCBjZW50ZXIsIGFuZ2xlKVxuICAgIF07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb29yZGluYXRlcyhlbCwgbW9kZWwsIGdlb21ldHJ5KSB7XG4gIHZhciBwb2ludCA9IG1vZGVsLnBvc2l0aW9uZXIoZWwsIG1vZGVsKTtcbiAgdmFyIHZ4ID0gcG9pbnQudng7XG4gIHZhciB2eSA9IHBvaW50LnZ5O1xuXG4gIGlmICghdnggJiYgIXZ5KSB7XG4gICAgLy8gaWYgYWxpZ25lZCBjZW50ZXIsIHdlIGRvbid0IHdhbnQgdG8gb2Zmc2V0IHRoZSBjZW50ZXIgcG9pbnRcbiAgICByZXR1cm4ge3g6IHBvaW50LngsIHk6IHBvaW50Lnl9O1xuICB9XG5cbiAgdmFyIHcgPSBnZW9tZXRyeS53O1xuICB2YXIgaCA9IGdlb21ldHJ5Lmg7XG5cbiAgLy8gdGFrZSBpbiBhY2NvdW50IHRoZSBsYWJlbCByb3RhdGlvblxuICB2YXIgcm90YXRpb24gPSBtb2RlbC5yb3RhdGlvbjtcbiAgdmFyIGR4ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpO1xuICB2YXIgZHkgPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSk7XG5cbiAgLy8gc2NhbGUgdGhlIHVuaXQgdmVjdG9yICh2eCwgdnkpIHRvIGdldCBhdCBsZWFzdCBkeCBvciBkeSBlcXVhbCB0b1xuICAvLyB3IG9yIGggcmVzcGVjdGl2ZWx5IChlbHNlIHdlIHdvdWxkIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlXG4gIC8vIGVsbGlwc2UgaW5zY3JpYmVkIGluIHRoZSBib3VuZGluZyByZWN0KVxuICB2YXIgdnMgPSAxIC8gTWF0aC5tYXgoTWF0aC5hYnModngpLCBNYXRoLmFicyh2eSkpO1xuICBkeCAqPSB2eCAqIHZzO1xuICBkeSAqPSB2eSAqIHZzO1xuXG4gIC8vIGZpbmFsbHksIGluY2x1ZGUgdGhlIGV4cGxpY2l0IG9mZnNldFxuICBkeCArPSBtb2RlbC5vZmZzZXQgKiB2eDtcbiAgZHkgKz0gbW9kZWwub2Zmc2V0ICogdnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludC54ICsgZHgsXG4gICAgeTogcG9pbnQueSArIGR5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGUobGFiZWxzLCBjb2xsaWRlcikge1xuICB2YXIgaSwgaiwgczAsIHMxO1xuXG4gIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2YgdGhlXG4gIC8vIGxpc3QgaGF2ZSBhbiBoaWdoZXIgd2VpZ2h0L3ByaW9yaXR5IGFuZCB0aHVzIHNob3VsZCBiZSBsZXNzIGltcGFjdGVkXG4gIC8vIGJ5IHRoZSBvdmVybGFwcGluZyBzdHJhdGVneS5cblxuICBmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBzMCA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG4gICAgZm9yIChqID0gaSAtIDE7IGogPj0gMCAmJiBzMC5fdmlzaWJsZTsgLS1qKSB7XG4gICAgICBzMSA9IGxhYmVsc1tqXS4kbGF5b3V0O1xuXG4gICAgICBpZiAoczEuX3Zpc2libGUgJiYgczAuX2JveC5pbnRlcnNlY3RzKHMxLl9ib3gpKSB7XG4gICAgICAgIGNvbGxpZGVyKHMwLCBzMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZShsYWJlbHMpIHtcbiAgdmFyIGksIGlsZW4sIGxhYmVsLCBzdGF0ZSwgZ2VvbWV0cnksIGNlbnRlciwgcHJveHk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYWJlbHMgZm9yIG92ZXJsYXAgZGV0ZWN0aW9uXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICAvLyBDaGFydC5qcyAzIHJlbW92ZWQgZWwuX21vZGVsIGluIGZhdm9yIG9mIGdldFByb3BzKCksIG1ha2luZyBoYXJkZXIgdG9cbiAgICAgIC8vIGFic3RyYWN0IHJlYWRpbmcgdmFsdWVzIGluIHBvc2l0aW9uZXJzLiBBbHNvLCB1c2luZyBzdHJpbmcgYXJyYXlzIHRvXG4gICAgICAvLyByZWFkIHZhbHVlcyAoaS5lLiB2YXIge2EsYixjfSA9IGVsLmdldFByb3BzKFtcImFcIixcImJcIixcImNcIl0pKSB3b3VsZCBtYWtlXG4gICAgICAvLyBwb3NpdGlvbmVycyBpbmVmZmljaWVudCBpbiB0aGUgbm9ybWFsIGNhc2UgKGkuZS4gbm90IHRoZSBmaW5hbCB2YWx1ZXMpXG4gICAgICAvLyBhbmQgdGhlIGNvZGUgYSBiaXQgdWdseSwgc28gbGV0J3MgdXNlIGEgUHJveHkgaW5zdGVhZC5cbiAgICAgIHByb3h5ID0gbmV3IFByb3h5KGxhYmVsLl9lbCwge2dldDogKGVsLCBwKSA9PiBlbC5nZXRQcm9wcyhbcF0sIHRydWUpW3BdfSk7XG5cbiAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcbiAgICAgIGNlbnRlciA9IGNvb3JkaW5hdGVzKHByb3h5LCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvIGhpZGUgb3ZlcmxhcHBpbmcgbGFiZWxzXG4gIHJldHVybiBjb2xsaWRlKGxhYmVscywgZnVuY3Rpb24oczAsIHMxKSB7XG4gICAgdmFyIGgwID0gczAuX2hpZGFibGU7XG4gICAgdmFyIGgxID0gczEuX2hpZGFibGU7XG5cbiAgICBpZiAoKGgwICYmIGgxKSB8fCBoMSkge1xuICAgICAgczEuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGgwKSB7XG4gICAgICBzMC5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXlvdXQgPSB7XG4gIHByZXBhcmU6IGZ1bmN0aW9uKGRhdGFzZXRzKSB7XG4gICAgdmFyIGxhYmVscyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBsYWJlbDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhc2V0c1tpXS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgbGFiZWwgPSBkYXRhc2V0c1tpXVtqXTtcbiAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICBsYWJlbC4kbGF5b3V0ID0ge1xuICAgICAgICAgIF9ib3g6IG5ldyBIaXRCb3goKSxcbiAgICAgICAgICBfaGlkYWJsZTogZmFsc2UsXG4gICAgICAgICAgX3Zpc2libGU6IHRydWUsXG4gICAgICAgICAgX3NldDogaSxcbiAgICAgICAgICBfaWR4OiBsYWJlbC5faW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIE5ldyBgemAgb3B0aW9uOiBsYWJlbHMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3blxuICAgIC8vIG9mIHRvcCBvZiB0aGUgb25lcyB3aXRoIGEgbG93ZXIgaW5kZXguIExvd2VzdCB6LWluZGV4IGxhYmVsc1xuICAgIC8vIGFyZSBhbHNvIGRpc2NhcmRlZCBmaXJzdCB3aGVuIGhpZGluZyBvdmVybGFwcGluZyBsYWJlbHMuXG4gICAgbGFiZWxzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIHNhID0gYS4kbGF5b3V0O1xuICAgICAgdmFyIHNiID0gYi4kbGF5b3V0O1xuXG4gICAgICByZXR1cm4gc2EuX2lkeCA9PT0gc2IuX2lkeFxuICAgICAgICA/IHNiLl9zZXQgLSBzYS5fc2V0XG4gICAgICAgIDogc2IuX2lkeCAtIHNhLl9pZHg7XG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZShsYWJlbHMpO1xuXG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGxhYmVscykge1xuICAgIHZhciBkaXJ0eSA9IGZhbHNlO1xuICAgIHZhciBpLCBpbGVuLCBsYWJlbCwgbW9kZWwsIHN0YXRlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgbW9kZWwgPSBsYWJlbC5tb2RlbCgpO1xuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuICAgICAgc3RhdGUuX2hpZGFibGUgPSBtb2RlbCAmJiBtb2RlbC5kaXNwbGF5ID09PSAnYXV0byc7XG4gICAgICBzdGF0ZS5fdmlzaWJsZSA9IGxhYmVsLnZpc2libGUoKTtcbiAgICAgIGRpcnR5IHw9IHN0YXRlLl9oaWRhYmxlO1xuICAgIH1cblxuICAgIGlmIChkaXJ0eSkge1xuICAgICAgY29tcHV0ZShsYWJlbHMpO1xuICAgIH1cbiAgfSxcblxuICBsb29rdXA6IGZ1bmN0aW9uKGxhYmVscywgcG9pbnQpIHtcbiAgICB2YXIgaSwgc3RhdGU7XG5cbiAgICAvLyBJTVBPUlRBTlQgSXRlcmF0ZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBzaW5jZSBpdGVtcyBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIGxpc3QgaGF2ZSBhbiBoaWdoZXIgei1pbmRleCwgdGh1cyBzaG91bGQgYmUgcGlja2VkIGZpcnN0LlxuXG4gICAgZm9yIChpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdGF0ZSA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG4gICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuX3Zpc2libGUgJiYgc3RhdGUuX2JveC5jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbihjaGFydCwgbGFiZWxzKSB7XG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBzdGF0ZSwgZ2VvbWV0cnksIGNlbnRlcjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcblxuICAgICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcbiAgICAgICAgY2VudGVyID0gY29vcmRpbmF0ZXMobGFiZWwuX2VsLCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xuICAgICAgICBsYWJlbC5kcmF3KGNoYXJ0LCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGZvcm1hdHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChoZWxwZXJzLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGFiZWwgPSB2YWx1ZTtcbiAgdmFyIGtleXMsIGtsZW4sIGs7XG4gIGlmIChoZWxwZXJzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGlmICghaGVscGVycy5pc051bGxPclVuZGVmKHZhbHVlLmxhYmVsKSkge1xuICAgICAgbGFiZWwgPSB2YWx1ZS5sYWJlbDtcbiAgICB9IGVsc2UgaWYgKCFoZWxwZXJzLmlzTnVsbE9yVW5kZWYodmFsdWUucikpIHtcbiAgICAgIGxhYmVsID0gdmFsdWUucjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwgPSAnJztcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICBmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgICAgbGFiZWwgKz0gKGsgIT09IDAgPyAnLCAnIDogJycpICsga2V5c1trXSArICc6ICcgKyB2YWx1ZVtrZXlzW2tdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJycgKyBsYWJlbDtcbn07XG5cbi8qKlxuICogSU1QT1JUQU5UOiBtYWtlIHN1cmUgdG8gYWxzbyB1cGRhdGUgdGVzdHMgYW5kIFR5cGVTY3JpcHQgZGVmaW5pdGlvblxuICogZmlsZXMgKGAvdGVzdC9zcGVjcy9kZWZhdWx0cy5zcGVjLmpzYCBhbmQgYC90eXBlcy9vcHRpb25zLmQudHNgKVxuICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBhbmNob3I6ICdjZW50ZXInLFxuICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gIGJvcmRlckNvbG9yOiBudWxsLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBjbGFtcDogZmFsc2UsXG4gIGNsaXA6IGZhbHNlLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBkaXNwbGF5OiB0cnVlLFxuICBmb250OiB7XG4gICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgbGluZUhlaWdodDogMS4yLFxuICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgIHdlaWdodDogbnVsbFxuICB9LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgbGFiZWxzOiB1bmRlZmluZWQsXG4gIGxpc3RlbmVyczoge30sXG4gIG9mZnNldDogNCxcbiAgb3BhY2l0eTogMSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogNCxcbiAgICByaWdodDogNCxcbiAgICBib3R0b206IDQsXG4gICAgbGVmdDogNFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICB0ZXh0U3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICB0ZXh0U2hhZG93Qmx1cjogMCxcbiAgdGV4dFNoYWRvd0NvbG9yOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE3NlxuICovXG5cbnZhciBFWFBBTkRPX0tFWSA9ICckZGF0YWxhYmVscyc7XG52YXIgREVGQVVMVF9LRVkgPSAnJGRlZmF1bHQnO1xuXG5mdW5jdGlvbiBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucykge1xuICB2YXIgb3ZlcnJpZGUgPSBkYXRhc2V0LmRhdGFsYWJlbHM7XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIGNvbmZpZ3MgPSBbXTtcbiAgdmFyIGxhYmVscywga2V5cztcblxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgb3ZlcnJpZGUgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBoZWxwZXJzLm1lcmdlKHt9LCBbb3B0aW9ucywgb3ZlcnJpZGVdKTtcbiAgbGFiZWxzID0gb3B0aW9ucy5sYWJlbHMgfHwge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhsYWJlbHMpO1xuICBkZWxldGUgb3B0aW9ucy5sYWJlbHM7XG5cbiAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGxhYmVsc1trZXldKSB7XG4gICAgICAgIGNvbmZpZ3MucHVzaChoZWxwZXJzLm1lcmdlKHt9LCBbXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBsYWJlbHNba2V5XSxcbiAgICAgICAgICB7X2tleToga2V5fVxuICAgICAgICBdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBsYWJlbCBpZiBubyBcIm5hbWVkXCIgbGFiZWwgZGVmaW5lZC5cbiAgICBjb25maWdzLnB1c2gob3B0aW9ucyk7XG4gIH1cblxuICAvLyBsaXN0ZW5lcnM6IHs8ZXZlbnQtdHlwZT46IHs8bGFiZWwta2V5PjogPGZuPn19XG4gIGxpc3RlbmVycyA9IGNvbmZpZ3MucmVkdWNlKGZ1bmN0aW9uKHRhcmdldCwgY29uZmlnKSB7XG4gICAgaGVscGVycy5lYWNoKGNvbmZpZy5saXN0ZW5lcnMgfHwge30sIGZ1bmN0aW9uKGZuLCBldmVudCkge1xuICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICB0YXJnZXRbZXZlbnRdW2NvbmZpZy5fa2V5IHx8IERFRkFVTFRfS0VZXSA9IGZuO1xuICAgIH0pO1xuXG4gICAgZGVsZXRlIGNvbmZpZy5saXN0ZW5lcnM7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7XG4gICAgbGFiZWxzOiBjb25maWdzLFxuICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycywgbGFiZWwsIGV2ZW50KSB7XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBsYWJlbC4kY29udGV4dDtcbiAgdmFyIGdyb3VwcyA9IGxhYmVsLiRncm91cHM7XG4gIHZhciBjYWxsYmFjaztcblxuICBpZiAoIWxpc3RlbmVyc1tncm91cHMuX3NldF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWxsYmFjayA9IGxpc3RlbmVyc1tncm91cHMuX3NldF1bZ3JvdXBzLl9rZXldO1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGhlbHBlcnMuY2FsbGJhY2soY2FsbGJhY2ssIFtjb250ZXh0LCBldmVudF0pID09PSB0cnVlKSB7XG4gICAgLy8gVXNlcnMgYXJlIGFsbG93ZWQgdG8gdHdlYWsgdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5qZWN0aW5nIHZhbHVlcyB0aGF0IGNhbiBiZVxuICAgIC8vIHVzZWQgaW4gc2NyaXB0YWJsZSBvcHRpb25zIHRvIGRpc3BsYXkgbGFiZWxzIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZXZlbnQgKGUuZy4gaGlnaGxpZ2h0IGFuIGhvdmVyZWQgbGFiZWwpLiBUaGF0J3Mgd2h5IHdlIHVwZGF0ZSB0aGUgbGFiZWwgd2l0aFxuICAgIC8vIHRoZSBvdXRwdXQgY29udGV4dCBhbmQgc2NoZWR1bGUgYSBuZXcgY2hhcnQgcmVuZGVyIGJ5IHNldHRpbmcgaXQgZGlydHkuXG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9kaXJ0eSA9IHRydWU7XG4gICAgbGFiZWwudXBkYXRlKGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwsIGV2ZW50KSB7XG4gIHZhciBlbnRlciwgbGVhdmU7XG5cbiAgaWYgKCFwcmV2aW91cyAmJiAhbGFiZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgZW50ZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFsYWJlbCkge1xuICAgIGxlYXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwcmV2aW91cyAhPT0gbGFiZWwpIHtcbiAgICBsZWF2ZSA9IGVudGVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsZWF2ZSkge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycy5sZWF2ZSwgcHJldmlvdXMsIGV2ZW50KTtcbiAgfVxuICBpZiAoZW50ZXIpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMuZW50ZXIsIGxhYmVsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpIHtcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gIHZhciBsaXN0ZW5lcnMgPSBleHBhbmRvLl9saXN0ZW5lcnM7XG4gIHZhciBwcmV2aW91cywgbGFiZWw7XG5cbiAgaWYgKCFsaXN0ZW5lcnMuZW50ZXIgJiYgIWxpc3RlbmVycy5sZWF2ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIGxhYmVsID0gbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChldmVudC50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJldmlvdXMgPSBleHBhbmRvLl9ob3ZlcmVkO1xuICBleHBhbmRvLl9ob3ZlcmVkID0gbGFiZWw7XG4gIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KSB7XG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICB2YXIgaGFuZGxlcnMgPSBleHBhbmRvLl9saXN0ZW5lcnMuY2xpY2s7XG4gIHZhciBsYWJlbCA9IGhhbmRsZXJzICYmIGxheW91dC5sb29rdXAoZXhwYW5kby5fbGFiZWxzLCBldmVudCk7XG4gIGlmIChsYWJlbCkge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGhhbmRsZXJzLCBsYWJlbCwgZXZlbnQpO1xuICB9XG59XG5cbnZhciBwbHVnaW4gPSB7XG4gIGlkOiAnZGF0YWxhYmVscycsXG5cbiAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuXG4gIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldID0ge1xuICAgICAgX2FjdGl2ZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgZXhwYW5kby5fbGlzdGVuZWQgPSBmYWxzZTtcbiAgICBleHBhbmRvLl9saXN0ZW5lcnMgPSB7fTsgICAgIC8vIHs8ZXZlbnQtdHlwZT46IHs8ZGF0YXNldC1pbmRleD46IHs8bGFiZWwta2V5PjogPGZuPn19fVxuICAgIGV4cGFuZG8uX2RhdGFzZXRzID0gW107ICAgICAgLy8gcGVyIGRhdGFzZXQgbGFiZWxzOiBbTGFiZWxbXV1cbiAgICBleHBhbmRvLl9sYWJlbHMgPSBbXTsgICAgICAgIC8vIGxheW91dGVkIGxhYmVsczogTGFiZWxbXVxuICB9LFxuXG4gIGFmdGVyRGF0YXNldFVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YXNldEluZGV4ID0gYXJncy5pbmRleDtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICB2YXIgbGFiZWxzID0gZXhwYW5kby5fZGF0YXNldHNbZGF0YXNldEluZGV4XSA9IFtdO1xuICAgIHZhciB2aXNpYmxlID0gY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpO1xuICAgIHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIHZhciBjb25maWcgPSBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucyk7XG4gICAgdmFyIGVsZW1lbnRzID0gYXJncy5tZXRhLmRhdGEgfHwgW107XG4gICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcbiAgICB2YXIgaSwgaiwgaWxlbiwgamxlbiwgY2ZnLCBrZXksIGVsLCBsYWJlbDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBlbCA9IGVsZW1lbnRzW2ldO1xuICAgICAgZWxbRVhQQU5ET19LRVldID0gW107XG5cbiAgICAgIGlmICh2aXNpYmxlICYmIGVsICYmIGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFlbC5za2lwKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBjb25maWcubGFiZWxzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIGNmZyA9IGNvbmZpZy5sYWJlbHNbal07XG4gICAgICAgICAga2V5ID0gY2ZnLl9rZXk7XG5cbiAgICAgICAgICBsYWJlbCA9IG5ldyBMYWJlbChjZmcsIGN0eCwgZWwsIGkpO1xuICAgICAgICAgIGxhYmVsLiRncm91cHMgPSB7XG4gICAgICAgICAgICBfc2V0OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICBfa2V5OiBrZXkgfHwgREVGQVVMVF9LRVlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxhYmVsLiRjb250ZXh0ID0ge1xuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcbiAgICAgICAgICAgIGRhdGFJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuICAgICAgICAgIGVsW0VYUEFORE9fS0VZXS5wdXNoKGxhYmVsKTtcbiAgICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgLy8gU3RvcmUgbGlzdGVuZXJzIGF0IHRoZSBjaGFydCBsZXZlbCBhbmQgcGVyIGV2ZW50IHR5cGUgdG8gb3B0aW1pemVcbiAgICAvLyBjYXNlcyB3aGVyZSBubyBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gICAgaGVscGVycy5tZXJnZShleHBhbmRvLl9saXN0ZW5lcnMsIGNvbmZpZy5saXN0ZW5lcnMsIHtcbiAgICAgIG1lcmdlcjogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHRhcmdldFtldmVudF0gPSB0YXJnZXRbZXZlbnRdIHx8IHt9O1xuICAgICAgICB0YXJnZXRbZXZlbnRdW2FyZ3MuaW5kZXhdID0gc291cmNlW2V2ZW50XTtcbiAgICAgICAgZXhwYW5kby5fbGlzdGVuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzID0gbGF5b3V0LnByZXBhcmUoY2hhcnRbRVhQQU5ET19LRVldLl9kYXRhc2V0cyk7XG4gIH0sXG5cbiAgLy8gRHJhdyBsYWJlbHMgb24gdG9wIG9mIGFsbCBkYXRhc2V0IGVsZW1lbnRzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzI5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzMyXG4gIGFmdGVyRGF0YXNldHNEcmF3OiBmdW5jdGlvbihjaGFydCkge1xuICAgIGxheW91dC5kcmF3KGNoYXJ0LCBjaGFydFtFWFBBTkRPX0tFWV0uX2xhYmVscyk7XG4gIH0sXG5cbiAgYmVmb3JlRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIgcmVnaXN0ZXJlZCBmb3IgdGhpcyBjaGFydCwgYGxpc3RlbmVkYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIG1lYW5pbmcgd2UgY2FuIGltbWVkaWF0ZWx5IGlnbm9yZSB0aGUgaW5jb21pbmcgZXZlbnQgYW5kIGF2b2lkIHVzZWxlc3MgZXh0cmFcbiAgICAvLyBjb21wdXRhdGlvbiBmb3IgdXNlcnMgd2hvIGRvbid0IGltcGxlbWVudCBsYWJlbCBpbnRlcmFjdGlvbnMuXG4gICAgaWYgKGNoYXJ0W0VYUEFORE9fS0VZXS5fbGlzdGVuZWQpIHtcbiAgICAgIHZhciBldmVudCA9IGFyZ3MuZXZlbnQ7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICAgIGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICAgIGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCkge1xuICAgIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICAgIHZhciBwcmV2aW91cyA9IGV4cGFuZG8uX2FjdGl2ZXM7XG4gICAgdmFyIGFjdGl2ZXMgPSBleHBhbmRvLl9hY3RpdmVzID0gY2hhcnQuZ2V0QWN0aXZlRWxlbWVudHMoKTtcbiAgICB2YXIgdXBkYXRlcyA9IHV0aWxzLmFycmF5RGlmZihwcmV2aW91cywgYWN0aXZlcyk7XG4gICAgdmFyIGksIGlsZW4sIGosIGpsZW4sIHVwZGF0ZSwgbGFiZWwsIGxhYmVscztcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB1cGRhdGVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1tpXTtcbiAgICAgIGlmICh1cGRhdGVbMV0pIHtcbiAgICAgICAgbGFiZWxzID0gdXBkYXRlWzBdLmVsZW1lbnRbRVhQQU5ET19LRVldIHx8IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWxzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIGxhYmVsID0gbGFiZWxzW2pdO1xuICAgICAgICAgIGxhYmVsLiRjb250ZXh0LmFjdGl2ZSA9ICh1cGRhdGVbMV0gPT09IDEpO1xuICAgICAgICAgIGxhYmVsLnVwZGF0ZShsYWJlbC4kY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhwYW5kby5fZGlydHkgfHwgdXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGxheW91dC51cGRhdGUoZXhwYW5kby5fbGFiZWxzKTtcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBleHBhbmRvLl9kaXJ0eTtcbiAgfVxufTtcblxucmV0dXJuIHBsdWdpbjtcblxufSkpO1xuIiwgIi8vIFdlIGltcG9ydCB0aGUgQ1NTIHdoaWNoIGlzIGV4dHJhY3RlZCB0byBpdHMgb3duIGZpbGUgYnkgZXNidWlsZC5cbi8vIFJlbW92ZSB0aGlzIGxpbmUgaWYgeW91IGFkZCBhIHlvdXIgb3duIENTUyBidWlsZCBwaXBlbGluZSAoZS5nIHBvc3Rjc3MpLlxuaW1wb3J0IFwiLi4vY3NzL2FwcC5jc3NcIjtcblxuaW1wb3J0IFwiLi9Cb2FyZENvbnRyb2xlLmpzXCI7XG5cbmltcG9ydCBcInRvbS1zZWxlY3RcIjtcbmltcG9ydCB7IGFkZFJvdywgaGF2ZUxpbmVOb3RTYXZlZCB9IGZyb20gXCIuL3RvbV9zZWxlY3Rfc2Fpc2llX3BhZ2UuanNcIjtcbmltcG9ydCBUb21TZWxlY3QgZnJvbSBcInRvbS1zZWxlY3RcIjtcbmltcG9ydCB7IGRlc2FjdGl2YXRlQWxsaW5wdXRzLCBzaG93VGFzayB9IGZyb20gXCIuL3Nob3dpbmdfdGFzay5qc1wiO1xuaW1wb3J0IHtsb2FkRm9ybX0gZnJvbSBcIi4vbmV3X3Rhc2suanNcIjtcbmltcG9ydCB7Y2hhbmdlRmF2aWNvbkJ5VGhlbWV9IGZyb20gXCIuL2Zhdmljb24uanNcIjtcblxuLy9pbXBvcnQgXCIuL3RhYmxlX3NhaXNpZV90ZW1wX2NvbnRyb2xlLmpzXCJcblxuLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXG5cbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXG4vL1xuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XG4vL1xuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxuLy9cbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcbi8vXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcbi8vXG5cbnJlcXVpcmUoXCJib290c3RyYXAtaWNvbnMvZm9udC9ib290c3RyYXAtaWNvbnMuY3NzXCIpO1xucmVxdWlyZShcIm1hdGVyaWFsLWljb25zL2ljb25mb250L21hdGVyaWFsLWljb25zLmNzc1wiKTtcblxuLy8gaW1wb3J0ICdib290c3RyYXAtaWNvbnMvZm9udC9ib290c3RyYXAtaWNvbnMuY3NzJztcbi8vIGltcG9ydCAnbWF0ZXJpYWwtaWNvbnMvaWNvbmZvbnQvbWF0ZXJpYWwtaWNvbnMuY3NzJztcblxuLy8gSW5jbHVkZSBwaG9lbml4X2h0bWwgdG8gaGFuZGxlIG1ldGhvZD1QVVQvREVMRVRFIGluIGZvcm1zIGFuZCBidXR0b25zLlxuaW1wb3J0IFwicGhvZW5peF9odG1sXCI7XG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwicGhvZW5peFwiO1xuaW1wb3J0IHsgTGl2ZVNvY2tldCB9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiO1xuaW1wb3J0IHsgU29ydGFibGUsIFBsdWdpbnMgfSBmcm9tIFwiQHNob3BpZnkvZHJhZ2dhYmxlXCI7XG5pbXBvcnQgdG9wYmFyIGZyb20gXCIuLi92ZW5kb3IvdG9wYmFyXCI7XG5pbXBvcnQge1xuICBEb3VnaE51dENoYXJ0LFxuICBIb3Jpem9udGFsQmFyQ2hhcnQsXG4gIFN0YWNrZWRCYXJDaGFydCxcbiAgTGluZUNoYXJ0LFxuICBTdXJ2ZXlDaGFydCxcbn0gZnJvbSBcIi4vY2hhcnQuanNcIjtcbmltcG9ydCBjaGFydCBmcm9tIFwiY2hhcnQuanMvZGlzdC9jaGFydFwiO1xuXG4vKlxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgLy8gVlx1MDBFOXJpZmllciBzaSBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGV4aXN0ZW50IHN1ciBsYSBwYWdlXG4gIGNvbnN0IHRhYmxlQm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWNvcmQtdGFibGUtYm9keScpO1xuICBjb25zdCBhZGRSb3dMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFJvd0ljb24nKTtcbiAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkYXRhLWNvbnRhaW5lcicpO1xuXG4gIC8vIFZcdTAwRTlyaWZpZXIgc2kgbGVzIFx1MDBFOWxcdTAwRTltZW50cyBuXHUwMEU5Y2Vzc2FpcmVzIGV4aXN0ZW50XG4gIGlmICh0YWJsZUJvZHkgJiYgYWRkUm93TGluayAmJiBkYXRhQ29udGFpbmVyKSB7XG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsZXMgZG9ublx1MDBFOWVzIHVuaXF1ZW1lbnQgc2kgbGVzIFx1MDBFOWxcdTAwRTltZW50cyBleGlzdGVudFxuICAgIGNvbnN0IHVzZXJJZCA9IGRhdGFDb250YWluZXIuZGF0YXNldC51c2VySWQ7XG4gICAgLy9jb25zb2xlLmxvZyh1c2VySWQpXG4gICAgY29uc3QgZGF0ZSA9IGRhdGFDb250YWluZXIuZGF0YXNldC50b2RheTtcbiAgICAvL2NvbnNvbGUubG9nKGRhdGUpXG4gICAgY29uc3QgdXNlcm5hbWUgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudXNlcm5hbWU7XG4gICAgLy9jb25zb2xlLmxvZyh1c2VybmFtZSlcbiAgICAvL2NvbnNvbGUubG9nKGRhdGFDb250YWluZXIuZGF0YXNldC5wcm9qZWN0cylcbiAgICBjb25zdCBwcm9qZWN0cyA9IEpTT04ucGFyc2UoZGF0YUNvbnRhaW5lci5kYXRhc2V0LnByb2plY3RzKTtcbiAgICAvL2NvbnNvbGUubG9nKHByb2plY3RzKVxuXG4gICAgLy8gQWpvdXRlciB1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgdW5pcXVlbWVudCBzaSBsJ2ljXHUwMEY0bmUgZCdham91dCBkZSBsaWduZSBleGlzdGVcbiAgICBhZGRSb3dMaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICBsaW5lTm90U2F2ZWQgPSBoYXZlTGluZU5vdFNhdmVkKHRhYmxlQm9keSk7XG4gICAgICBjb25zb2xlLmxvZyhsaW5lTm90U2F2ZWQpO1xuICAgICAgaWYgKCFsaW5lTm90U2F2ZWQpIHtcbiAgICAgICAgYWRkUm93KHRhYmxlQm9keSwgVG9tU2VsZWN0LCB1c2VySWQsIGRhdGUsIHVzZXJuYW1lLCBwcm9qZWN0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICB2YXIgYWRkUm93SWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGRSb3dJY29uIGknKTtcbiAgICAgICAgY29uc29sZS5sb2coYWRkUm93SWNvbik7XG4gICAgICAgIGFkZFJvd0xpbmsuY2xhc3NMaXN0LmFkZCgnbm9uLWNsaXF1YWJsZScpO1xuICAgICAgICBhZGRSb3dJY29uLnN0eWxlLmN1cnNvciA9ICdub3QtYWxsb3dlZCc7XG5cbiAgICAgIH1cblxuXG4gICAgfSk7XG4gIH1cblxuXG5cbn0pO1xuKi9cbmNvbnN0IEhvb2tzID0ge307XG5cbi8vIEhvb2tzLkRvdWdoTnV0Q2hhcnQgPSB7XG4vLyAgIG1vdW50ZWQoKSB7XG4vLyAgICAgY29uc3QgeyBsYWJlbHNfdGFza3NfYnlfY29udHJpYnV0b3JzLCB2YWx1ZXNfdGFza3NfYnlfY29udHJpYnV0b3JzIH0gPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpXG4vLyAgICAgdGhpcy5jaGFydCA9IG5ldyBEb3VnaE51dENoYXJ0KHRoaXMuZWwsIGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnMpXG4vLyAgIH1cbi8vIH1cblxuLy9ob29rcyBwb3VyIGdlcmVyIGxlcyBzYWlzaWUgZGUgdGVtcHNcbi8vbmIgOiB1dGlsaXNlciBwYXIgbGEgcGFnZSBzYWlzaWVfaW5kZXguaHRtbCAsIHNhaXNpZV9kZXRhaWxzLmh0bWxcblxuSG9va3Muc2Fpc2llQWN0aW9uID0ge1xuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IHRhYmxlQm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVjb3JkLXRhYmxlLWJvZHlcIik7XG4gICAgY29uc3QgYWRkUm93TGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRkUm93SWNvblwiKTtcbiAgICBjb25zdCBkYXRhQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkYXRhLWNvbnRhaW5lclwiKTtcbiAgICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgblx1MDBFOWNlc3NhaXJlcyBleGlzdGVudFxuICAgIGlmICh0YWJsZUJvZHkgJiYgYWRkUm93TGluayAmJiBkYXRhQ29udGFpbmVyKSB7XG4gICAgICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyBkb25uXHUwMEU5ZXMgdW5pcXVlbWVudCBzaSBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGV4aXN0ZW50XG4gICAgICBjb25zdCB1c2VySWQgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudXNlcklkO1xuICAgICAgLy9jb25zb2xlLmxvZyh1c2VySWQpXG4gICAgICBjb25zdCBkYXRlID0gZGF0YUNvbnRhaW5lci5kYXRhc2V0LnRvZGF5O1xuICAgICAgLy9jb25zb2xlLmxvZyhkYXRlKVxuICAgICAgY29uc3QgdXNlcm5hbWUgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudXNlcm5hbWU7XG4gICAgICAvL2NvbnNvbGUubG9nKHVzZXJuYW1lKVxuICAgICAgLy9jb25zb2xlLmxvZyhkYXRhQ29udGFpbmVyLmRhdGFzZXQucHJvamVjdHMpXG4gICAgICBjb25zdCBwcm9qZWN0cyA9IEpTT04ucGFyc2UoZGF0YUNvbnRhaW5lci5kYXRhc2V0LnByb2plY3RzKTtcbiAgICAgIC8vY29uc29sZS5sb2cocHJvamVjdHMpXG5cbiAgICAgIC8vIEFqb3V0ZXIgdW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIHVuaXF1ZW1lbnQgc2kgbCdpY1x1MDBGNG5lIGQnYWpvdXQgZGUgbGlnbmUgZXhpc3RlXG4gICAgICBhZGRSb3dMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxpbmVOb3RTYXZlZCA9IGhhdmVMaW5lTm90U2F2ZWQodGFibGVCb2R5KTtcbiAgICAgICAgY29uc29sZS5sb2cobGluZU5vdFNhdmVkKTtcbiAgICAgICAgaWYgKCFsaW5lTm90U2F2ZWQpIHtcbiAgICAgICAgICBhZGRSb3codGFibGVCb2R5LCBUb21TZWxlY3QsIHVzZXJJZCwgZGF0ZSwgdXNlcm5hbWUsIHByb2plY3RzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWRkUm93SWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYWRkUm93SWNvbiBpXCIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGFkZFJvd0ljb24pO1xuICAgICAgICAgIGFkZFJvd0xpbmsuY2xhc3NMaXN0LmFkZChcIm5vbi1jbGlxdWFibGVcIik7XG4gICAgICAgICAgYWRkUm93SWNvbi5zdHlsZS5jdXJzb3IgPSBcIm5vdC1hbGxvd2VkXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vIEhvb2tzOiBEeW5hbWljIGNoYW5nZW1lbnQgRmF2aWNvblxuSG9va3MuZHluYW1pY0Zhdmljb24gPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgY2hhbmdlRmF2aWNvbkJ5VGhlbWUoKVxuICB9XG59XG5cbi8vaG9va3M6IGdlc3Rpb24gZGUgbCdhZmZpY2hhZ2UgZGUgbGEgZGV0YWlscyBwYWdlc1xuXG5Ib29rcy5zaG93VGFzayA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICBkZXNhY3RpdmF0ZUFsbGlucHV0cygpO1xuICAgIGNvbnN0IHByb2ZpbGUgPSB0aGlzLmVsLmRhdGFzZXQucHJvZmlsZTtcbiAgICBjb25zb2xlLmxvZyhwcm9maWxlKTtcbiAgICBzaG93VGFzayhwcm9maWxlKTtcbiAgfSxcbiAgdXBkYXRlZCgpIHtcbiAgICBkZXNhY3RpdmF0ZUFsbGlucHV0cygpO1xuICB9XG59O1xuXG5cbkhvb2tzLm5ld1Rhc2sgPSB7XG4gIHVwZGF0ZWQoKSB7XG4gICAgbG9hZEZvcm0oKTtcbiAgfVxufVxuXG5cblxuXG5cblxuLyogaG9va3MgcGhvZW5peCBwb3VyIGxlcyBjaGFuZ2VtZW50IGNvdWxldXIgZGVzIGxpZ25lcyBzdXJ2b2xcdTAwRTlcbm1ldHRyZSBjZXR0ZSBob29rcyBlbiBhdHRyaWJ1dCBkdSBiYWxpc2UgPHRhYmxlPjwvdGFibGU+IHNpIGxlIHRhYmxlIGEgYmVzb2luIGRlIGNldHRlIGZvbmN0aW9uYWxpdFx1MDBFOVxuTkIgOiBhIG1ldHRyZSB1bmlxdWVtZW50IHN1ciB1bmUgZWxlbWVudCBodG1sIHRhYmxlXG5cbiovXG5cbkhvb2tzLnRhYmxlSG92ZXIgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLmVsOyAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxhIHRhYmxlIFx1MDBFMCBwYXJ0aXIgZGUgdGhpcy5lbFxuXG4gICAgdGFibGUucXVlcnlTZWxlY3RvckFsbChcInRib2R5IHRyXCIpLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRDb2xvciA9IFwiXCI7XG5cbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgICAgY3VycmVudENvbG9yID0gcm93LnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgcm93LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzYwYjBmMFwiO1xuICAgICAgfSk7XG5cbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgICAgICByb3cuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG59O1xuXG5Ib29rcy5DdXN0b21TYW1wbGVTZWxlY3QgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJDdXN0b21TYW1wbGVTZWxlY3QgaG9vayBpbml0aWFsaXplZFwiKTtcblxuICAgIC8vIFJcdTAwRTljdXBcdTAwRTlyZXIgbCdcdTAwRTlsXHUwMEU5bWVudCBzZWxlY3RcbiAgICB2YXIgc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlTZWxlY3RcIik7XG5cbiAgICAvLyBBc3N1cmV6LXZvdXMgcXVlIGwnXHUwMEU5bFx1MDBFOW1lbnQgc2VsZWN0IGVzdCByZW5kdSBkYW5zIGxlIERPTVxuICAgIGlmIChzZWxlY3RFbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgZm91bmQ6XCIsIHNlbGVjdEVsZW1lbnQpO1xuXG4gICAgICAvLyBJbml0aWFsaXNleiBUb21TZWxlY3QgYXZlYyBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdCBzJ2lsIG4nZXhpc3RlIHBhcyBkXHUwMEU5alx1MDBFMCBkJ2luc3RhbmNlXG4gICAgICBpZiAoIXNlbGVjdEVsZW1lbnQudG9tc2VsZWN0KSB7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0ID0gbmV3IFRvbVNlbGVjdChzZWxlY3RFbGVtZW50LCB7XG4gICAgICAgICAgLy8gQ29uZmlndXJhdGlvbnMgZGUgVG9tU2VsZWN0IGljaVxuICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgc29ydEZpZWxkOiB7XG4gICAgICAgICAgICBmaWVsZDogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXNjXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVG9tU2VsZWN0IG9wdGlvbnM6XCIsIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU2VsZWN0IGVsZW1lbnQgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkN1c3RvbVNhbXBsZVNlbGVjdCBob29rIHVwZGF0ZWRcIik7XG5cbiAgICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGwnXHUwMEU5bFx1MDBFOW1lbnQgc2VsZWN0XG4gICAgdmFyIHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15U2VsZWN0XCIpO1xuXG4gICAgLy8gVlx1MDBFOXJpZmlleiBzaSB1bmUgaW5zdGFuY2UgZGUgVG9tU2VsZWN0IGVzdCBhdHRhY2hcdTAwRTllIFx1MDBFMCBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxuICAgIGlmIChzZWxlY3RFbGVtZW50ICYmIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgZm91bmQ6XCIsIHNlbGVjdEVsZW1lbnQpO1xuXG4gICAgICAvLyBTdXBwcmltZXogdG91dGVzIGxlcyBvcHRpb25zIGFjdHVlbGxlcyBkZSBUb21TZWxlY3RcbiAgICAgIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0LmNsZWFyT3B0aW9ucygpO1xuXG4gICAgICAvLyBBam91dGV6IGRlIG5vdXZlbGxlcyBvcHRpb25zIFx1MDBFMCBUb21TZWxlY3QgXHUwMEUwIHBhcnRpciBkZSBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxuICAgICAgdmFyIHNlbGVjdE9wdGlvbnMgPSBzZWxlY3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJvcHRpb25cIik7XG4gICAgICBzZWxlY3RPcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBzZWxlY3RFbGVtZW50LnRvbXNlbGVjdC5hZGRPcHRpb24oe1xuICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgICAgdGV4dDogb3B0aW9uLnRleHRDb250ZW50LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3R1YWxpc2V6IGxlIFRvbVNlbGVjdCBwb3VyIHJlZmxcdTAwRTl0ZXIgbGVzIG1vZGlmaWNhdGlvbnNcbiAgICAgIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0LnJlZnJlc2hPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZWxlY3QgZWxlbWVudCBvciBUb21TZWxlY3QgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgfSxcbn07XG5cbkhvb2tzLkNzdkV4cG9ydEhvb2sgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5oYW5kbGVFeHBvcnRDbGljayA9IHRoaXMuaGFuZGxlRXhwb3J0Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUV4cG9ydENsaWNrKTtcbiAgfSxcbiAgZGVzdHJveWVkKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlRXhwb3J0Q2xpY2spO1xuICB9LFxuXG4gIGhhbmRsZUV4cG9ydENsaWNrKGV2ZW50KSB7XG4gICAgbGV0IGNzdkRhdGEgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtY3N2XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiYXZhbnQgOlwiLCBjc3ZEYXRhKTtcbiAgICBjc3ZEYXRhID0gY3N2RGF0YS5yZXBsYWNlKC9cXFxcclxcXFxuL2csIFwiXFxuXCIpO1xuICAgIC8vbGV0IHRlc3QgPSBcIk5hbWUsQWdlLENpdHlcXG5Kb2huLDMwLE5ldyBZb3JrXFxuSmFuZSwyNSxTYW4gRnJhbmNpc2NvXFxuQm9iLDM1LENoaWNhZ29cIjtcbiAgICBjb25zb2xlLmxvZyhcImFwcmVzIDpcIiwgY3N2RGF0YSk7XG4gICAgLy8gQ3JcdTAwRTllciB1biBvYmpldCBCbG9iIFx1MDBFMCBwYXJ0aXIgZGUgbGEgY2hhXHUwMEVFbmUgQ1NWXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiBcInRleHQvY3N2O2NoYXJzZXQ9dXRmLTg7XCIgfSk7XG5cbiAgICAvLyBDclx1MDBFOWVyIHVuIFx1MDBFOWxcdTAwRTltZW50IDxhPiBwb3VyIHRcdTAwRTlsXHUwMEU5Y2hhcmdlciBsZSBmaWNoaWVyIENTVlxuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBsaW5rLmRvd25sb2FkID0gXCJleGVtcGxlLmNzdlwiO1xuXG4gICAgLy8gQWpvdXRlciBsJ1x1MDBFOWxcdTAwRTltZW50IDxhPiBcdTAwRTAgbGEgcGFnZVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG5cbiAgICAvLyBTaW11bGVyIHVuIGNsaWMgc3VyIGxlIGxpZW4gcG91ciBkXHUwMEU5Y2xlbmNoZXIgbGUgdFx1MDBFOWxcdTAwRTljaGFyZ2VtZW50XG4gICAgbGluay5jbGljaygpO1xuXG4gICAgLy8gU3VwcHJpbWVyIGwnXHUwMEU5bFx1MDBFOW1lbnQgPGE+IGFwclx1MDBFOHMgbGUgdFx1MDBFOWxcdTAwRTljaGFyZ2VtZW50XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcblxuICAgIC8vIC4uLiBBdXRyZXMgYWN0aW9ucyBcdTAwRTAgZWZmZWN0dWVyIGF2ZWMgY3N2RGF0YSAuLi5cbiAgfSxcbn07XG5cbkhvb2tzLkhvcml6b250YWxCYXJDaGFydCA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCB7IGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnMgfSA9XG4gICAgICBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xuICAgIHRoaXMuY2hhcnQgPSBuZXcgSG9yaXpvbnRhbEJhckNoYXJ0KFxuICAgICAgdGhpcy5lbCxcbiAgICAgIGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsXG4gICAgICB2YWx1ZXNfdGFza3NfYnlfY29udHJpYnV0b3JzXG4gICAgKTtcbiAgfSxcbn07XG5cbkhvb2tzLlN0YWNrZWRCYXJDaGFydCA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCxcbiAgICAgIHZhbHVlc19ibG9ja2luZ190YXNrc19ieV9tb250aCxcbiAgICAgIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCxcbiAgICAgIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLFxuICAgICAgdmFsdWVzX3Rhc2tzX2FjaGlldmVkX2J5X21vbnRoLFxuICAgIH0gPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xuICAgIHRoaXMuY2hhcnQgPSBuZXcgU3RhY2tlZEJhckNoYXJ0KFxuICAgICAgdGhpcy5lbCxcbiAgICAgIHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLFxuICAgICAgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLFxuICAgICAgdmFsdWVzX3Rhc2tzX2luX3Byb2dyZXNzX2J5X21vbnRoLFxuICAgICAgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsXG4gICAgICB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGhcbiAgICApO1xuICB9LFxufTtcblxuSG9va3MuU3VydmV5Q2hhcnQgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJpcyBtb3VudGVkXCIpO1xuXG4gICAgY29uc3QgeyB2YWx1ZXMgfSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSk7XG5cbiAgICB0aGlzLm15Y2hhcnQgPSBuZXcgU3VydmV5Q2hhcnQodGhpcy5lbCwgdmFsdWVzKTtcbiAgfSxcbn07XG5cbi8vIEhvb2tzLkxpbmVDaGFydCA9IHtcbi8vICAgbW91bnRlZCgpIHtcbi8vICAgICBjb25zdCB7IHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLCB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aCB9ID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnREYXRhKVxuLy8gICAgIHRoaXMuY2hhcnQgPSBuZXcgTGluZUNoYXJ0KHRoaXMuZWwsIHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLCB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aClcbi8vICAgfVxuLy8gfVxuXG5Ib29rcy5Cb2FyZCA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmluaXREcmFnZ2FibGVzKCk7XG4gIH0sXG5cbiAgdXBkYXRlZCgpIHtcbiAgICB0aGlzLnNvcnRhYmxlQ2FyZC5kZXN0cm95KCk7XG4gICAgdGhpcy5zb3J0YWJsZVN0YWdlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmluaXREcmFnZ2FibGVzKCk7XG4gIH0sXG5cbiAgaW5pdERyYWdnYWJsZXMoKSB7XG4gICAgdGhpcy5zb3J0YWJsZUNhcmQgPSBuZXcgU29ydGFibGUoXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnN0YWdlX19jYXJkc1wiKSxcbiAgICAgIHtcbiAgICAgICAgZHJhZ2dhYmxlOiBcIi5jYXJkXCIsXG4gICAgICAgIG1pcnJvcjoge1xuICAgICAgICAgIGNvbnN0cmFpbkRpbWVuc2lvbnM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHN3YXBBbmltYXRpb246IHtcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBcImVhc2UtaW4tb3V0XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHBsdWdpbnM6IFtQbHVnaW5zLlN3YXBBbmltYXRpb25dLFxuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLnNvcnRhYmxlQ2FyZC5vbihcInNvcnRhYmxlOnN0b3BcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBldmVudC5kYXRhLmRyYWdFdmVudC5kYXRhLnNvdXJjZTtcbiAgICAgIGNvbnN0IGNhcmRJZCA9IHBhcnNlSW50KHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcmQtaWRcIikpO1xuICAgICAgY29uc3QgbmV3U3RhZ2VJZCA9IHBhcnNlSW50KFxuICAgICAgICBldmVudC5kYXRhLm5ld0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0YWdlLWlkXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSBwYXJzZUludChldmVudC5kYXRhLm5ld0luZGV4KTtcbiAgICAgIGNvbnN0IGNhcmRQYXlsb2FkID0ge1xuICAgICAgICBjYXJkOiB7XG4gICAgICAgICAgaWQ6IGNhcmRJZCxcbiAgICAgICAgICBzdGFnZV9pZDogbmV3U3RhZ2VJZCxcbiAgICAgICAgICBwb3NpdGlvbjogbmV3SW5kZXgsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy5wdXNoRXZlbnQoXCJ1cGRhdGVfY2FyZFwiLCBjYXJkUGF5bG9hZCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNvcnRhYmxlU3RhZ2UgPSBuZXcgU29ydGFibGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ib2FyZFwiKSwge1xuICAgICAgZHJhZ2dhYmxlOiBcIi5zdGFnZVwiLFxuICAgICAgaGFuZGxlOiBcIi5kcmFnZ2FibGUtaGFuZGxlXCIsXG4gICAgICBtaXJyb3I6IHtcbiAgICAgICAgY29uc3RyYWluRGltZW5zaW9uczogdHJ1ZSxcbiAgICAgICAgeUF4aXM6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuc29ydGFibGVTdGFnZS5vbihcInNvcnRhYmxlOnN0b3BcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBldmVudC5kYXRhLmRyYWdFdmVudC5kYXRhLnNvdXJjZTtcbiAgICAgIGNvbnN0IHN0YWdlSWQgPSBwYXJzZUludChzb3VyY2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdGFnZS1pZFwiKSk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHBhcnNlSW50KGV2ZW50LmRhdGEubmV3SW5kZXgpO1xuICAgICAgY29uc3Qgc3RhZ2VQYXlsb2FkID0ge1xuICAgICAgICBzdGFnZToge1xuICAgICAgICAgIGlkOiBzdGFnZUlkLFxuICAgICAgICAgIHBvc2l0aW9uOiBuZXdJbmRleCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLnB1c2hFdmVudChcInVwZGF0ZV9zdGFnZVwiLCBzdGFnZVBheWxvYWQpO1xuICAgIH0pO1xuICB9LFxufTtcblxuSG9va3MuQW5pbWF0ZUFsZXJ0ID0ge1xuICBtb3VudGVkKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwidGFmaWRpdHJhIGFsZXJ0XCIpXG4gICAgdGhpcy5oYW5kbGVFdmVudChcIkFuaW1hdGVBbGVydFwiLCAoe30pID0+IHRoaXMucmVzZXRfb3BhY2l0eSgpKTtcbiAgfSxcbiAgdXBkYXRlZCgpIHt9LFxuICByZXNldF9vcGFjaXR5KCkge1xuICAgIHZhciBhbGVydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYWxlcnRfYW5pbVwiKTtcbiAgICBhbGVydC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBhbGVydC5zdHlsZS5vcGFjaXR5ID0gMDsgKi9cbiAgICAgIGFsZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LCAyMDAwKTtcbiAgfSxcbiAgYW5pbV9vbmxvYWQoKSB7XG4gICAgdmFyIGFsZXJ0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWxlcnRcIik7XG4gICAgLy8gIGNvbnNvbGUubG9nKGFsZXJ0cyk7XG5cbiAgICBhbGVydHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIGl0ZW0ub25sb2FkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgYWxlcnRzW2ldLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgYWxlcnRzW2ldLm9ubG9hZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWxlcnRzW2ldLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfVxuICB9LFxufTtcblxuSG9va3MuYmx1ckhvb2sgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJ0YWZpZGl0cmEgYmx1ckhvb2tcIilcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiYmx1ckJvZHlcIiwgKHsgcGFyYW0xLCBwYXJhbTIgfSkgPT5cbiAgICAgIC8vIGNvbnNvbGUubG9nKHBhcmFtMSlcbiAgICAgIHRoaXMuYmx1ckJvZHkoKVxuICAgICk7XG4gIH0sXG4gIGJsdXJCb2R5KCkge1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgcmVxdWVzdF9mb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0aGVfcmVxdWVzdF9mb3JtXCIpO1xuICAgIC8vIGNvbnNvbGUubG9nKHJlcXVlc3RfZm9ybSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhib2R5KTtcbiAgICBib2R5LnN0eWxlLm9wYWNpdHkgPSAwLjU7XG5cbiAgICAvLyB2YXIgbW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm1vZGFsLWNvbnRhaW5lclwiKTtcbiAgICAvLyBjb25zb2xlLmxvZyhtb2RhbCk7XG4gICAgLy8gbW9kYWwuc3R5bGUuZmlsdGVyID0gXCJibHVyKDFweClcIjtcbiAgICByZXF1ZXN0X2Zvcm0uc3R5bGUub3BhY2l0eSA9IDE7XG4gIH0sXG59O1xuXG5Ib29rcy5NZXNzYWdlQm9keSA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICB2YXIgbWVzc2FnZUJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21lc3NhZ2VCb2R5XCIpO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQoXG4gICAgICBcInVwZGF0ZVNjcm9sbFwiLFxuICAgICAgKHt9KSA9PlxuICAgICAgICAobWVzc2FnZUJvZHkuc2Nyb2xsVG9wID1cbiAgICAgICAgICBtZXNzYWdlQm9keS5zY3JvbGxIZWlnaHQgLSBtZXNzYWdlQm9keS5jbGllbnRIZWlnaHQpXG4gICAgKTtcbiAgfSxcbn07XG5cbi8vIEdldCB1cmwgbG9jYXRpb25cbkhvb2tzLnVybFByb2Nlc3MgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgbGV0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21haW5cIik7XG5cbiAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICAvLyBUZXJuYXJ5IGZ1bmN0aW9uXG4gICAgdXJsLmluY2x1ZGVzKFwiL2xvZ3NcIilcbiAgICAgID8gbWFpbi5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyXCIpXG4gICAgICA6IG1haW4uY2xhc3NMaXN0LmFkZChcImNvbnRhaW5lclwiKTtcbiAgfSxcbn07XG5cbkhvb2tzLlNwaW5UZXN0ID0ge1xuICBtb3VudGVkKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwidGFmaWRpdHJhIGhvb2tcIilcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiU3BpblRlc3RcIiwgKHt9KSA9PiB0aGlzLnNwaW5faWNvbigpKTtcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiU3BpbkNvbW1lbnRcIiwgKHt9KSA9PiB0aGlzLnNwaW5fY29tbWVudF9pY29uKCkpO1xuICB9LFxuICBzcGluX2ljb24oKSB7XG4gICAgdmFyIHNwaW5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ub3RpZl9fbG9hZFwiKTtcbiAgICAvLyBjb25zb2xlLmxvZyhzcGluKTtcbiAgICAvLyBzcGlucy5jbGFzc0xpc3QuYWRkKCdyb3RhdGVfX2ljb24nKTtcbiAgICAvLyBjb25zb2xlLmxvZyhzcGluKTtcbiAgICAvLyB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe3NwaW5zLmNsYXNzTGlzdC5yZW1vdmUoJ3JvdGF0ZV9faWNvbicpO30sIDUwMCk7XG4gICAgLy8gY29uc29sZS5sb2coJ25vdGlmJylcbiAgICBzcGlucy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoXCJuZXdfX3JvdGF0ZV9faWNvblwiKTtcbiAgICB9KTtcblxuICAgIHNwaW5zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwibmV3X19yb3RhdGVfX2ljb25cIik7XG4gICAgICB9LCA1MDApO1xuICAgIH0pO1xuICB9LFxuICBzcGluX2NvbW1lbnRfaWNvbigpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnY29tbWVudCcpXG4gICAgdmFyIGNsb2NrX2NvbW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsb2NrX2NvbW1lbnRcIik7XG4gICAgLy8gY29uc29sZS5sb2coY2xvY2tfY29tbWVudCk7XG4gICAgY2xvY2tfY29tbWVudC5jbGFzc0xpc3QuYWRkKFwicm90YXRlX19pY29uXCIpO1xuICAgIC8vIGNvbnNvbGUubG9nKGNsb2NrX2NvbW1lbnQpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsb2NrX2NvbW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcInJvdGF0ZV9faWNvblwiKTtcbiAgICB9LCA1MDApO1xuICAgIC8vIGNvbnNvbGUubG9nKGNsb2NrX2NvbW1lbnQpO1xuICB9LFxufTtcblxubGV0IG5hdlRvZ2dsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2X190b2dnbGVcIik7XG5sZXQgbmF2V3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2X193cmFwcGVyXCIpO1xubmF2VG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gIGlmIChuYXZXcmFwcGVyLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIm1lbnVcIik7XG4gICAgbmF2V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICB9IGVsc2Uge1xuICAgIG5hdldyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJjbG9zZSBtZW51XCIpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gIH1cbn0pO1xuLy8gUlx1MDBFOWN1cFx1MDBFOXJleiBsJ1x1MDBFOWxcdTAwRTltZW50IHBhciBzb24gSURcbnZhciBjb3B5cmlnaHRJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb3B5cmlnaHRfX2ljb25cIik7XG5cbi8vIFZcdTAwRTlyaWZpZXogc2kgbCdcdTAwRTlsXHUwMEU5bWVudCBhIFx1MDBFOXRcdTAwRTkgdHJvdXZcdTAwRTkgYXZhbnQgZGUgbGUgbW9kaWZpZXJcbmlmIChjb3B5cmlnaHRJY29uKSB7XG4gIGNvcHlyaWdodEljb24uaW5uZXJIVE1MID0gXCJjb3B5cmlnaHQgUEhJRElBIC8gUHJvamVjdCBtb25pdG9yaW5nIC0yMDI0XCI7XG59XG5jb25zdCBtZW51QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tZW51LWJ0blwiKTtcbmxldCBtZW51T3BlbiA9IGZhbHNlO1xubWVudUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICBpZiAoIW1lbnVPcGVuKSB7XG4gICAgbWVudUJ0bi5jbGFzc0xpc3QuYWRkKFwib3BlblwiKTtcbiAgICBtZW51T3BlbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbWVudUJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcbiAgICBtZW51T3BlbiA9IGZhbHNlO1xuICB9XG59KTtcblxudmFyIGFsZXJ0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWxlcnRcIik7XG5cbmFsZXJ0cy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDE7XG4gIGl0ZW0ub25sb2FkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDA7XG4gIH0sIDIwMDApO1xufSk7XG5cbmxldCBjc3JmVG9rZW4gPSBkb2N1bWVudFxuICAucXVlcnlTZWxlY3RvcihcIm1ldGFbbmFtZT0nY3NyZi10b2tlbiddXCIpXG4gIC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpO1xubGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwge1xuICBwYXJhbXM6IHsgX2NzcmZfdG9rZW46IGNzcmZUb2tlbiB9LFxuICBob29rczogSG9va3MsXG59KTtcblxubGV0IHRvcEJhclNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbnRvcGJhci5jb25maWcoeyBiYXJDb2xvcnM6IHsgMDogXCIjMjlkXCIgfSwgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAuMylcIiB9KTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIChpbmZvKSA9PiB0b3BiYXIuc2hvdygpKTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIChpbmZvKSA9PiB0b3BiYXIuaGlkZSgpKTtcblxuLy8gY29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxubGl2ZVNvY2tldC5jb25uZWN0KCk7XG5cbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XG4iLCAiLypcbmZpY2hpZXIgSlMgcG91ciBsYSBnZW5lcmVyYXRpb24gZXQgc2F1dmdhcmRlIGRlIGxpZ25lIGRlIHNhaXNpZVxucmVxdWlyZWQgVG9tU2VsZWN0XG5hIHZvaXIgYXVzc2kgVGFza0NvbnRyb2xsZXIudGFza19ieV9wcm9qZWN0ICAvL2FwaSBkZSByZWN1cGVyYXRpb24gZGVzIHRhY2hlcyBldCBpbmZvIGNsaWVudCBwYXIgcHJvamV0XG5TYWlzaWVDb250cm9sbGVyLmNyZWF0ZSAgLy9hcGkgZGUgc2F1dmdhcmRlIGQndW5lIGxpZ25lXG5hdXRob3IgIDogbG9pY1JhdmVsbzA1QGdtYWlsLmNvbVxuKi9cblxuXG5cblxuXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSBcInRvbS1zZWxlY3RcIjtcblxuXG5cblxuLy8gRm9uY3Rpb24gcG91ciBzYXV2ZWdhcmRlciB1bmUgbGlnbmVcbmZ1bmN0aW9uIHNhdmVSb3coaWNvbikge1xuICAgIGNvbnN0IHJvdyA9IGljb24uY2xvc2VzdCgndHInKTtcbiAgICBjb25zdCBpbnB1dHMgPSByb3cucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCcpOyAvLyBnZXQgYWxsIGlucHV0cyBcbiAgICBjb25zdCByb3dEYXRhID0ge307IC8vbGVzIHZhbGV1ciBkZSBjaGFxdWUgaW5wdXRcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIHJvd0RhdGFbaW5wdXQubmFtZV0gPSBpbnB1dC52YWx1ZTtcbiAgICB9KTtcbiAgICAvLyBWb3VzIHBvdXZleiBtYWludGVuYW50IHNvdW1ldHRyZSBjZXR0ZSBsaWduZSBkZSBkb25uXHUwMEU5ZXMgXHUwMEUwIHZvdHJlIGJhY2tlbmQgb3UgZWZmZWN0dWVyIGQnYXV0cmVzIGFjdGlvbnNcbiAgICBjb25zb2xlLmxvZyhcIkRvbm5cdTAwRTllcyBcdTAwRTAgc2F1dmVnYXJkZXI6XCIsIHJvd0RhdGEpO1xuXG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsZSBqZXRvbiBDU1JGIGRlcHVpcyB1biBjaGFtcCBjYWNoXHUwMEU5IGRhbnMgbGUgZm9ybXVsYWlyZVxuICAgIGNvbnN0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcblxuICAgIC8vIEVudm9pIGRlcyBkb25uXHUwMEU5ZXMgYXUgYmFja2VuZCBhdmVjIGxlIGpldG9uIENTUkZcbiAgICBmZXRjaCgnL3NhdmVfc2Fpc2llJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdYLUNTUkYtVG9rZW4nOiBjc3JmVG9rZW4gIC8vIEluY2x1cmUgbGUgamV0b24gQ1NSRiBkYW5zIGxlcyBlbi10XHUwMEVBdGVzIGRlIGxhIHJlcXVcdTAwRUF0ZVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyb3dEYXRhKVxuICAgIH0pXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIHJlc3BvbnNlIDogXCIsIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyZXVyIGxvcnMgZGUgbGEgc2F1dmVnYXJkZSBkZXMgZG9ublx1MDBFOWVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIC8vIFRyYWl0ZW1lbnQgZGUgbGEgclx1MDBFOXBvbnNlIGR1IGJhY2tlbmRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjXHUwMEU4czonLCBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpOyAvLyBvdSB0b3V0ZSBhdXRyZSBhY3Rpb24gcXVlIHZvdXMgdm91bGV6IGVmZmVjdHVlciBlbiBjYXMgZGUgc3VjY1x1MDBFOHNcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VycmV1ciA6JywgZXJyb3IpO1xuICAgICAgICAgICAgYWxlcnQoJ1VuZSBlcnJldXIgZXN0IHN1cnZlbnVlIGxvcnMgZGUgbGEgc2F1dmVnYXJkZS4gVmV1aWxsZXogdlx1MDBFOXJpZmllciBxdWUgdG91cyBsZXMgY2hhbXBzIHNvbnQgYmllbiByZW1wbGlzIGV0IGF1IGJvbiBmb3JtYXQnKTtcbiAgICAgICAgfSk7XG59XG4vLyBGb25jdGlvbiBwb3VyIHN1cHByaW1lciB1bmUgbGlnbmVcbmZ1bmN0aW9uIHJlbW92ZVJvdyhpY29uKSB7XG4gICAgaWNvbi5jbG9zZXN0KCd0cicpLnJlbW92ZSgpO1xufVxuXG4vLyBmb25jdGlvbiBkZSB2YWxpZGF0aW9uIGR1IGNoYW1wIGRlY2ltYWwgZGUgbCdpbnB1dFxuZnVuY3Rpb24gaXNEZWNpbWFsVmFsaWQoaW5wdXRWYWx1ZSkge1xuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSBsYSB2YWxldXIgc2Fpc2llIGVzdCB1biBub21icmUgZFx1MDBFOWNpbWFsIHZhbGlkZSBlbnRyZSAwIGV0IDIwXG4gICAgY29uc3QgbnVtZXJpY1ZhbHVlID0gcGFyc2VGbG9hdChpbnB1dFZhbHVlKTtcbiAgICByZXR1cm4gIWlzTmFOKG51bWVyaWNWYWx1ZSkgJiYgbnVtZXJpY1ZhbHVlID49IDAgJiYgbnVtZXJpY1ZhbHVlIDw9IDIwIDtcbn1cblxuXG5mdW5jdGlvbiBpc0xhYmVsVmFsaWQoaW5wdXRWYWx1ZSkge1xuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSBsYSB2YWxldXIgc2Fpc2llIG4nZXN0IHBhcyB2aWRlIGV0IG5lIGRcdTAwRTlwYXNzZSBwYXMgMjU1IGNhcmFjdFx1MDBFOHJlc1xuICAgIHJldHVybiBpbnB1dFZhbHVlLnRyaW0oKSAhPT0gJycgJiYgaW5wdXRWYWx1ZS5sZW5ndGggPD0gMjU1O1xufVxuXG5mdW5jdGlvbiBpc1Byb2plY3RJZFZhbGlkKHZhbHVlKSB7XG4gICAgLy8gVlx1MDBFOXJpZmllIHNpIGxhIHZhbGV1ciBkdSBjaGFtcCBkZSBzXHUwMEU5bGVjdGlvbiBkZSBwcm9qZXQgbidlc3QgcGFzIHZpZGVcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSAnJztcbn1cblxuZnVuY3Rpb24gaXNUYXNrVmFsaWQoc2VsZWN0ZWRUYXNrKSB7XG4gICAgLy8gVlx1MDBFOXJpZmllIHNpIHVuZSB0XHUwMEUyY2hlIGVzdCBzXHUwMEU5bGVjdGlvbm5cdTAwRTllXG4gICAgcmV0dXJuIHNlbGVjdGVkVGFzayAhPT0gJyc7XG59XG5cblxuLy8gZWNvdXRldXIgZCdldmVuZW1lbnQgZHUgY2hhbXAgZGVjaW1hbFxuXG5mdW5jdGlvbiBoYW5kbGVEZWNpbWFsSW5wdXQoZXZlbnQpIHtcbiAgIC8vIGNvbnN0IHN0cmluZ0Zvcm1hdCA9IHRoaXMudmFsdWU7XG5cbiAgICAvLyBTdXBwcmltZXIgbGVzIHNpZ25lcyAnKycgZXQgJy0nIGRlIGxhIHZhbGV1ciBzYWlzaWVcbiAgICBpZiAodGhpcy52YWx1ZS5pbmNsdWRlcygnKycpIHx8IHRoaXMudmFsdWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMudmFsdWUucmVwbGFjZSgvWystXS9nLCAnJyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG4gICBcbiAgICAvLyBWYWxpZGVyIGxhIHZhbGV1ciBzYWlzaWUgZXQgY2hhbmdlciBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgZW4gY29uc1x1MDBFOXF1ZW5jZVxuICAgIGlmICghaXNEZWNpbWFsVmFsaWQodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnOyAvLyBDaGFuZ2VtZW50IGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBlbiByb3VnZSBlbiBjYXMgZCdlcnJldXJcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWXHUwMEU5cmlmaWVyIGxhIGxvbmd1ZXVyIGRlIGxhIHBhcnRpZSBkXHUwMEU5Y2ltYWxlXG4gICAgICAgIGNvbnN0IGRlY2ltYWxMZW5ndGggPSAodGhpcy52YWx1ZS5zcGxpdCgnLicpWzFdIHx8ICcnKS5sZW5ndGg7XG4gICAgICAgIGNvbnNvbGUubG9nKGRlY2ltYWxMZW5ndGgpO1xuICAgICAgICBpZiAoZGVjaW1hbExlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhbGV1ciA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWxldXI7IC8vIExpbWl0ZXIgXHUwMEUwIGRldXggY2hpZmZyZXMgYXByXHUwMEU4cyBsYSB2aXJndWxlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHlsZS5ib3JkZXJDb2xvciA9ICdncmVlbic7IC8vIFJcdTAwRTlpbml0aWFsaXNhdGlvbiBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgXHUwMEUwIHNhIHZhbGV1ciBwYXIgZFx1MDBFOWZhdXRcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiBoYW5kbGVMYWJlbElucHV0KGV2ZW50KSB7XG4gICAgaWYgKCFpc0xhYmVsVmFsaWQodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnOyAvLyBDaGFuZ2VtZW50IGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBlbiByb3VnZSBlbiBjYXMgZCdlcnJldXJcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0eWxlLmJvcmRlckNvbG9yID0gJ2dyZWVuJzsgLy8gUlx1MDBFOWluaXRpYWxpc2F0aW9uIGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBcdTAwRTAgc2EgdmFsZXVyIHBhciBkXHUwMEU5ZmF1dFxuICAgIH1cbn1cblxuXG5cbi8vZ2VzdGlvbiBkJ2V2ZW5lbWVudCBkdSBsYSBsaXN0ZSBkZXJvdWxhbnRlIGRlcyBwcm9qZXRcbmZ1bmN0aW9uIGhhbmRsZVByb2plY3RTZWxlY3RDaGFuZ2UoZXZlbnQgLCB0YXNrX3RvbV9zZWxlY3QpIHtcbiAgICBjb25zdCBwcm9qZWN0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9qZWN0X2lkJyk7XG4gICAgY29uc3QgdHNDb250cm9sRWxlbWVudCA9IHByb2plY3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cy1jb250cm9sJyk7XG4gICAgY29uc3Qgc2VsZWN0ZWRQcm9qZWN0SWQgPSBldmVudC50YXJnZXQudmFsdWU7XG5cbiAgICBpZiAoIWlzUHJvamVjdElkVmFsaWQoc2VsZWN0ZWRQcm9qZWN0SWQpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibWFrYXRvIGFtaW4gcmVkXCIpO1xuICAgICAgICB0c0NvbnRyb2xFbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJ3JlZCc7IC8vIENoYW5nZW1lbnQgZGUgbGEgY291bGV1ciBkZSBsYSBib3JkdXJlIGVuIHJvdWdlIGVuIGNhcyBkJ2VycmV1clxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibWFrYXRvIGFtaW4gZ3JlZW5cIik7XG4gICAgICAgIHRzQ29udHJvbEVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSAnZ3JlZW4nOyAvLyBSXHUwMEU5aW5pdGlhbGlzYXRpb24gZGUgbGEgY291bGV1ciBkZSBsYSBib3JkdXJlIFx1MDBFMCBzYSB2YWxldXIgcGFyIGRcdTAwRTlmYXV0XG4gICAgfVxuXG4gICAgLy8gTWlzZSBcdTAwRTAgam91ciBkZSBsYSBsaXN0ZSBkXHUwMEU5cm91bGFudGUgZGVzIHRcdTAwRTJjaGVzIGVuIGZvbmN0aW9uIGR1IHByb2pldCBzXHUwMEU5bGVjdGlvbm5cdTAwRTlcbiAgICB1cGRhdGVUYXNrT3B0aW9ucyhzZWxlY3RlZFByb2plY3RJZCwgdGFza190b21fc2VsZWN0KTtcbn1cblxuXG5cblxuLypcbmVjb3V0ZXVyIGQnZXZlbmVtZW50IHN1ciBsYSBsaXN0ZSBkZXJvdWxhbnRlIGRlIHByb2pldFxuKi9cbmZ1bmN0aW9uIGhhbmRsZVRhc2tTZWxlY3RDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCB0YXNrRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YXNrJyk7XG4gICAgY29uc3QgdHNDb250cm9sRWxlbWVudCA9IHRhc2tFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cy1jb250cm9sJyk7XG4gICAgY29uc3Qgc2VsZWN0ZWRUYXNrID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuXG4gICAgaWYgKCFpc1Rhc2tWYWxpZChzZWxlY3RlZFRhc2spKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTGEgdFx1MDBFMmNoZSBzXHUwMEU5bGVjdGlvbm5cdTAwRTllIGVzdCBpbnZhbGlkZVwiKTtcbiAgICAgICAgdHNDb250cm9sRWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnOyAvLyBDaGFuZ2VtZW50IGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBlbiByb3VnZSBlbiBjYXMgZCdlcnJldXJcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxhIHRcdTAwRTJjaGUgc1x1MDBFOWxlY3Rpb25uXHUwMEU5ZSBlc3QgdmFsaWRlXCIpO1xuICAgICAgICB0c0NvbnRyb2xFbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJ2dyZWVuJzsgLy8gUlx1MDBFOWluaXRpYWxpc2F0aW9uIGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBcdTAwRTAgc2EgdmFsZXVyIHBhciBkXHUwMEU5ZmF1dFxuICAgIH1cbn1cblxuXG5cblxuXG4vKiBmb25jdGlvbiBxdWkgYWpvdXQgbGVzIGNvdWxldXIgcGFyIGRlZmF1dCByb3VnZSBzdXIgbGVzIGNoYW1wIHB1aXNxdWUgbGVzIGNoYW1wIHNvbnQgdG91cyB2aWRlIGxvcnMgZGUgbGEgZ2VuZXJhdGlvbiBkJ3VuZSBub3V2ZWxsZSBsaWduZSBcbk5CIDogYXBwZWxlciBjZXR0ZSAgZm9uY3Rpb24ganVzdGUgYXByZXMgYXZvaXIgY3JlZXIgbGVzIGluc3RhbmNlIGRlIHRvbVNlbGVjdCBzdXIgbGVzIGxpc3RlIGRlcm91bGFudGUgPT4gaWwgeSBhIGRlcyBkaXYgZ2VuZXJlciBqdXN0ZSBhcHJlcyBhdm9pciBtaXMgdW5lIGluc3RhbmNlIGRlIHRvbVNlbGVjdCBzdXIgdW5lIGxpc3RlIGRlcm91bGFudGUgKC50cy1jb250cm9sKVxuKi9cblxuZnVuY3Rpb24gYXBwbHlGaWVsZFZhbGlkYXRpb25zKHRhYmxlQm9keSkge1xuXG4gICAgY29uc3QgdGFza0VsZW1lbnQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcignLnRhc2snKTtcbiAgICBjb25zdCB0c0NvbnRyb2xFbGVtZW50MSA9IHRhc2tFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cy1jb250cm9sJyk7XG4gICAgdHNDb250cm9sRWxlbWVudDEuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJztcblxuICAgIGNvbnN0IHByb2plY3RFbGVtZW50ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJy5wcm9qZWN0X2lkJyk7XG4gICAgY29uc3QgdHNDb250cm9sRWxlbWVudCA9IHByb2plY3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cy1jb250cm9sJyk7XG4gICAgdHNDb250cm9sRWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnO1xuXG4gICAgY29uc3QgbGFiZWxJbnB1dCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIGlucHV0W25hbWU9XCJsYWJlbHNcIl0nKTtcbiAgICAvLyBham91dCBkZSBsYSBjb3VsZXVyIGludGlhbCBcbiAgICBsYWJlbElucHV0LnN0eWxlLmJvcmRlckNvbG9yID0gJ3JlZCc7XG4gICBcbn1cblxuZnVuY3Rpb24gbGluZVZhbGlkYXRpb24odGFibGVCb2R5KSB7XG4gICAgY29uc3QgbGFiZWxJbnB1dCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIGlucHV0W25hbWU9XCJsYWJlbHNcIl0nKTtcbiAgICBjb25zdCB0YXNrU2VsZWN0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgc2VsZWN0W25hbWU9XCJ0YXNrXCJdJyk7XG4gICAgY29uc3QgcHJvamVjdFNlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwicHJvamVjdF9pZFwiXScpO1xuICAgIGNvbnN0IGRlY2ltYWxJbnB1dCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIGlucHV0W25hbWU9XCJob3Vyc1wiXScpO1xuXG4gICAgLy8gVmFsaWRhdGlvbiBkdSBjaGFtcCBkZSBsaWJlbGxcdTAwRTlcbiAgICBjb25zdCBpc0xhYmVsVmFsaWRSZXN1bHQgPSBpc0xhYmVsVmFsaWQobGFiZWxJbnB1dC52YWx1ZSk7XG5cbiAgICAvLyBWYWxpZGF0aW9uIGR1IGNoYW1wIGRlIHNcdTAwRTlsZWN0aW9uIGRlIHRcdTAwRTJjaGVcbiAgICBjb25zdCBpc1Rhc2tWYWxpZFJlc3VsdCA9IGlzVGFza1ZhbGlkKHRhc2tTZWxlY3QudmFsdWUpO1xuXG4gICAgLy8gVmFsaWRhdGlvbiBkdSBjaGFtcCBkZSBzXHUwMEU5bGVjdGlvbiBkZSBwcm9qZXRcbiAgICBjb25zdCBpc1Byb2plY3RJZFZhbGlkUmVzdWx0ID0gaXNQcm9qZWN0SWRWYWxpZChwcm9qZWN0U2VsZWN0LnZhbHVlKTtcblxuICAgIC8vIFZhbGlkYXRpb24gZHUgY2hhbXAgZFx1MDBFOWNpbWFsXG4gICAgY29uc3QgaXNEZWNpbWFsVmFsaWRSZXN1bHQgPSBpc0RlY2ltYWxWYWxpZChkZWNpbWFsSW5wdXQudmFsdWUpO1xuXG4gICAgLy8gU2kgdG91dGVzIGxlcyB2YWxpZGF0aW9ucyBzb250IHZhbGlkZXMsIHJldG91cm5leiB0cnVlLCBzaW5vbiByZXRvdXJuZXogZmFsc2VcbiAgICByZXR1cm4gaXNMYWJlbFZhbGlkUmVzdWx0ICYmIGlzVGFza1ZhbGlkUmVzdWx0ICYmIGlzUHJvamVjdElkVmFsaWRSZXN1bHQgJiYgaXNEZWNpbWFsVmFsaWRSZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXZlTGluZU5vdFNhdmVkKHRhYmxlQm9keSkge1xuICAgIGNvbnN0IG5ld1Rhc2tTZWxlY3QgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBzZWxlY3RbbmFtZT1cInRhc2tcIl0nKTtcbiAgICBpZiAobmV3VGFza1NlbGVjdCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG59XG5cblxuXG5cbi8vZm9uY3Rpb24gZGUgZ1x1MDBFOW5cdTAwRTlyYXRpb24gZHluYW1pcXVlIGRlcyBsaWduZSBkZSBzYWlzaWVcbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3codGFibGVCb2R5LCBUb21TZWxlY3QsIHVzZXJJZCwgZGF0ZSwgdXNlcm5hbWUsIHByb2plY3RzKSB7XG4gICAgLy9sZXMgZWxlbWVudCBkZSBsaWduZXMgXG4gICAgY29uc3QgbmV3Um93ID0gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJ1c2VyX2lkXCIgdmFsdWU9XCIke3VzZXJJZH1cIj5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImRhdGVcIj48aW5wdXQgdHlwZT1cImRhdGVcIiBuYW1lPVwiZGF0ZVwiIHZhbHVlPVwiJHtkYXRlfVwiPjwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJ1c2VyXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInVzZXJcIiB2YWx1ZT1cIiR7dXNlcm5hbWV9XCIgcmVhZG9ubHk+PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInByb2plY3RfaWRcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IG5hbWU9XCJwcm9qZWN0X2lkXCIgaWQ9XCJ0b21fc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5TXHUwMEU5bGVjdGlvbm5lciB1biBwcm9qZXQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgJHtwcm9qZWN0cy5tYXAocHJvamVjdCA9PiBgPG9wdGlvbiB2YWx1ZT1cIiR7cHJvamVjdC5pZH1cIj4ke3Byb2plY3QudGl0bGV9PC9vcHRpb24+YCkuam9pbignJyl9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiY2xpZW50XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImNsaWVudF9uYW1lXCIgdmFsdWU9XCJcIiByZWFkb25seT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJ0YXNrXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBuYW1lPVwidGFza1wiIGlkPVwidGFza3Nfc2VsZWN0XCIgcGxhY2Vob2xkZXI9XCJTXHUwMEU5bGVjdGlvbmVyIHVuZSB0XHUwMEUyY2hlXCI+PC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwibGFiZWxzXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhYmVsc1wiIHBsYWNlaG9sZGVyPVwiTGliZWxsXHUwMEU5XCI+PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRlbXBzXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBpZD1cImRlY2ltYWxfaW5wdXRcIiBuYW1lPVwiaG91cnNcIiBzdGVwPVwiMC4xXCIgdmFsdWU9XCIwLjBcIj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJhY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgPGkgdGl0bGU9XCJTYXV2ZWdhcmRlclwiIGNsYXNzPVwiYmkgYmktc2F2ZVwiIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyO1wiPjwvaT5cbiAgICAgICAgICAgICAgICA8aSB0aXRsZT1cIlN1cHByaW1lclwiIGlkPVwic3VwcHJcIiBjbGFzcz1cImJpIGJpLXRyYXNoXCIgc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXI7XCIgPjwvaT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgYDtcbiBcbiAgICB0YWJsZUJvZHkuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBuZXdSb3cpO1xuICBcblxuXG4gICAgLy9ham91dCB0b21TZWxlY3QgYSBsYSBsaXN0ZSBkZXJvdWxhbnRlIGRlcyBwcm9qZXRcbiAgICBjb25zdCBuZXdQcm9qZWN0U2VsZWN0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgc2VsZWN0W25hbWU9XCJwcm9qZWN0X2lkXCJdJyk7XG5cbiAgICBuZXcgVG9tU2VsZWN0KG5ld1Byb2plY3RTZWxlY3QsIHtcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBkZSBUb21TZWxlY3RcbiAgICAgICAgc2VhcmNoYWJsZTogdHJ1ZSxcbiAgICAgICAgc29ydEZpZWxkOiB7XG4gICAgICAgICAgICBmaWVsZDogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXNjXCJcbiAgICAgICAgfSAsXG4gICAgICAgIHJlbmRlcjoge1xuICAgICAgICAgICAgbm9fcmVzdWx0czogZnVuY3Rpb24gKGRhdGEsIGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIm5vLXJlc3VsdHNcIj5SXHUwMEU5c3VsdGF0IG5vbiB0cm91dmVyIHBvdXIgIFwiJyArIGVzY2FwZShkYXRhLmlucHV0KSArICdcIjwvZGl2Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vY3JlYXRpb24gZCd1biBpbnN0YW5jZSBkZSB0b21TZWxlY3QgYXZlYyBsYSBsaXN0ZSBkZXJvdWxhbnRlIGRlcyB0YWNoZXMgZGFucyBsYSBsaWduZSBub3V2ZWxsZW1lbnQgZ2VucmVyXG4gICAgY29uc3QgbmV3VGFza1NlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwidGFza1wiXScpO1xuICAgIG5ld1Rhc2tTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlVGFza1NlbGVjdENoYW5nZSk7XG4gICAgLy9jb25zb2xlLmxvZyhuZXdUYXNrU2VsZWN0KVxuICAgIHRhc2tfdG9tX3NlbGVjdCA9IG5ldyBUb21TZWxlY3QobmV3VGFza1NlbGVjdCwge1xuICAgICAgICAvLyBDb25maWd1cmF0aW9uIGRlIFRvbVNlbGVjdFxuICAgICAgICBzZWFyY2hhYmxlOiB0cnVlLFxuICAgICAgICBzb3J0RmllbGQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBcInRleHRcIixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJhc2NcIlxuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgIG5vX3Jlc3VsdHM6IGZ1bmN0aW9uIChkYXRhLCBlc2NhcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJuby1yZXN1bHRzXCI+Ulx1MDBFOXN1bHRhdCBub24gdHJvdXZlciBwb3VyICBcIicgKyBlc2NhcGUoZGF0YS5pbnB1dCkgKyAnXCI8L2Rpdj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgIFxuICAgIH0pO1xuXG5cbiAgICAvL2FwcGVsZSBkZSBsYSBmb25jdGlvbiBxdWkgYWpvdXRlIGxlcyBzdHlsZSBkZSBjb3VsZXVyIHBhcmRlZmF1dCBkZXMgY2hhbXAganVzdGUgYXByZXMgYXZvaXIgY3JlZXIgbGVzIGluc3RhbmNlIGRlIHRvbVNlbGVjdFxuICAgIGFwcGx5RmllbGRWYWxpZGF0aW9ucyh0YWJsZUJvZHkpXG5cbiAgICAvL2V4dHJhY3QgbGUgcHJvamV0IHNlbGVjdGlvbmVyIHBvdXIgcmVjdXBlcmVyIGxlcyB0YWNoZSBjb3JyZXNwb25kYW50XG4gICAgY29uc3QgcHJvamVjdFNlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtuYW1lPVwicHJvamVjdF9pZFwiXScpO1xuICAgIC8vIEFqb3V0IGQndW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIFx1MDBFMCBwcm9qZWN0U2VsZWN0IGF2ZWMgdW5lIGZvbmN0aW9uIGRlIHJhcHBlbFxuICAgIHByb2plY3RTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEFwcGVsIGRlIGhhbmRsZVByb2plY3RTZWxlY3RDaGFuZ2UgYXZlYyBsJ29iamV0IGV2ZW50IGV0IHRhc2tfdG9tX3NlbGVjdFxuICAgICAgICBoYW5kbGVQcm9qZWN0U2VsZWN0Q2hhbmdlKGV2ZW50LCB0YXNrX3RvbV9zZWxlY3QpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBam91dCBkJ3VuIFx1MDBFOWNvdXRldXIgZCdcdTAwRTl2XHUwMEU5bmVtZW50cyBzdXIgbCdlbnRyXHUwMEU5ZSBkXHUwMEU5Y2ltYWxlIHBvdXIgbGEgdmFsaWRhdGlvbiBlbiBkaXJlY3RcbiAgICBjb25zdCBkZWNpbWFsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwiaG91cnNcIl0nKTtcbiAgICBkZWNpbWFsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBoYW5kbGVEZWNpbWFsSW5wdXQpO1xuXG4gICAgXG4gICAgY29uc3QgbGFiZWxJbnB1dCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIGlucHV0W25hbWU9XCJsYWJlbHNcIl0nKTtcbiAgICAvLyBBam91dCBkJ3VuIFx1MDBFOWNvdXRldXIgZCdcdTAwRTl2XHUwMEU5bmVtZW50cyBzdXIgbGUgY2hhbXAgZGUgdGV4dGUgcG91ciBsYSB2YWxpZGF0aW9uIGVuIGRpcmVjdFxuICAgIGxhYmVsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBoYW5kbGVMYWJlbElucHV0KTtcblxuICAgIC8vIEFqb3V0ZXogbGVzIFx1MDBFOWNvdXRldXJzIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgYXV4IGljXHUwMEY0bmVzIHNhdXZlZ2FyZGVyIGV0IHN1cHByaW1lciBkZSBsYSBub3V2ZWxsZSBsaWduZVxuICAgIGNvbnN0IG5ld1NhdmVJY29uID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJy5iaS1zYXZlJyk7XG4gICAgbmV3U2F2ZUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFZcdTAwRTlyaWZpZXogbGEgdmFsaWRpdFx1MDBFOSBkZXMgY2hhbXBzIGRlIGxhIGRlcm5pXHUwMEU4cmUgbGlnbmVcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGxpbmVWYWxpZGF0aW9uKHRhYmxlQm9keSk7XG5cbiAgICAgICAgLy8gU2kgdG91cyBsZXMgY2hhbXBzIHNvbnQgdmFsaWRlcywgYXBwZWxleiBsYSBmb25jdGlvbiBzYXZlUm93XG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICBzYXZlUm93KG5ld1NhdmVJY29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbm9uLCBhZmZpY2hleiB1biBtZXNzYWdlIGQnZXJyZXVyIG91IGVmZmVjdHVleiB1bmUgYXV0cmUgYWN0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTGVzIGNoYW1wcyBuZSBzb250IHBhcyB2YWxpZGVzLiBWZXVpbGxleiB2XHUwMEU5cmlmaWVyIHZvcyBzYWlzaWVzLicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBzdXBwcmVzc2lvbiBkZXMgbGlnbmVzIGdlbnJlclxuICAgIGNvbnN0IG5ld1JlbW92ZUljb24gPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcignI3N1cHByJyk7XG4gICAgY29uc29sZS5sb2cobmV3UmVtb3ZlSWNvbilcbiAgICBuZXdSZW1vdmVJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVSb3cobmV3UmVtb3ZlSWNvbik7XG4gICAgICAgIHJlc2V0QWRkUm93SWNvbigpO1xuICAgIH0pO1xuXG5cblxuXG4gICAgXG4gICBcblxuXG5cbn1cbi8vZm9uY3Rpb24gZGUgbWlzZSBcdTAwRTAgam91ciBkZSBsYSBsaXN0ZSBkXHUwMEU5cm91bGFudGUgZGVzIHRcdTAwRTJjaGVzIHBhciBwcm9qZXQgc1x1MDBFOWxlY3Rpb25uXHUwMEU5XG4vL2FwcGVsIFx1MDBFMCB1bmUgQVBJIGRhbnMgVGFza0NvbnRyb2xsZXIudGFza19ieV9wcm9qZWN0ID0+IHJldG91cm5lIGxlcyB0XHUwMEUyY2hlcyBldCBsZXMgZFx1MDBFOXRhaWxzIGR1IGNsaWVudCByYXR0YWNoXHUwMEU5IGF1IHByb2pldCBzXHUwMEU5bGVjdGlvbm5cdTAwRTlcbmZ1bmN0aW9uIHVwZGF0ZVRhc2tPcHRpb25zKHNlbGVjdGVkUHJvamVjdElkLCB0YXNrVG9tU2VsZWN0KSB7XG4gICAgLy8gVm90cmUgbG9naXF1ZSBwb3VyIG1ldHRyZSBcdTAwRTAgam91ciBsZXMgb3B0aW9ucyBkdSBtZW51IGRcdTAwRTlyb3VsYW50IGRlcyB0XHUwMEUyY2hlcyBpY2lcbiAgICAvL2NvbnNvbGUubG9nKCdQcm9qZXQgc1x1MDBFOWxlY3Rpb25uXHUwMEU5OicsIHNlbGVjdGVkUHJvamVjdElkKTtcblxuICAgIC8vIEVmZmVjdHVlciB1bmUgcmVxdVx1MDBFQXRlIEFKQVggdmVycyB2b3RyZSBlbmRwb2ludCBiYWNrZW5kIHBvdXIgclx1MDBFOWN1cFx1MDBFOXJlciBsZXMgdFx1MDBFMmNoZXMgYXNzb2NpXHUwMEU5ZXMgYXUgcHJvamV0IHNcdTAwRTlsZWN0aW9ublx1MDBFOVxuICAgIGZldGNoKGAvdGFza3MvJHtzZWxlY3RlZFByb2plY3RJZH1gKVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VycmV1ciBsb3JzIGRlIGxhIHJcdTAwRTljdXBcdTAwRTlyYXRpb24gZGVzIHRcdTAwRTJjaGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIC8vIE1ldHRyZSBcdTAwRTAgam91ciBsYSBsaXN0ZSBkXHUwMEU5cm91bGFudGUgZGVzIHRcdTAwRTJjaGVzIGF2ZWMgbGVzIGRvbm5cdTAwRTllcyByXHUwMEU5Y3VwXHUwMEU5clx1MDBFOWVzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICAgICAgY29uc3QgdGFza3MgPSBkYXRhLnRhc2tzO1xuICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5jbGVhcigpO1xuICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5jbGVhck9wdGlvbnMoKTsgLy8gRWZmYWNlciBsZXMgb3B0aW9ucyBwclx1MDBFOWNcdTAwRTlkZW50ZXNcbiAgICAgICAgICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5hZGRPcHRpb24oeyB2YWx1ZTogdGFzay5pZCwgdGV4dDogdGFzay50aXRsZSB9KTsgIC8vYWpvdXQgZGVzIG5vdXZlbGxlcyBvcHRpb24gYSBsJ2luc3RhbmNlIGR1IHRvbVNlbGVjdCBwYXNzZXIgZW4gcGFyYW1ldHJlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUcmFpdGVtZW50IGRlcyBkXHUwMEU5dGFpbHMgY2xpZW50c1xuICAgICAgICAgICAgY29uc3QgY2xpZW50RGV0YWlscyA9IGRhdGEuY2xpZW50X2RldGFpbHM7XG4gICAgICAgICAgICAvLyBFeGVtcGxlIGQndXRpbGlzYXRpb24gZGVzIGRcdTAwRTl0YWlscyBkdSBjbGllbnRcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdOb20gZHUgY2xpZW50OicsIGNsaWVudERldGFpbHMuY2xpZW50c19uYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudE5hbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCJjbGllbnRfbmFtZVwiXScpO1xuICAgICAgICAgICAgY2xpZW50TmFtZUlucHV0LnZhbHVlID0gY2xpZW50RGV0YWlscy5jbGllbnRzX25hbWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnROYW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiY2xpZW50X25hbWVcIl0nKTtcbiAgICAgICAgICAgIGNsaWVudE5hbWVJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5jbGVhcigpO1xuICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5jbGVhck9wdGlvbnMoKTsgLy8gRWZmYWNlciBsZXMgb3B0aW9ucyBwclx1MDBFOWNcdTAwRTlkZW50ZXNcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRhc2tUb21TZWxlY3QpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyZXVyIDonLCBlcnJvcik7XG4gICAgICAgIH0pO1xufVxuXG5cbi8vcmVzZXQgYWRkIHJvdyBpY29uIFxuZnVuY3Rpb24gcmVzZXRBZGRSb3dJY29uKCkge1xuICAgIHZhciBhZGRSb3dMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFJvd0ljb24nKTsgXG4gICAgdmFyIGFkZFJvd0ljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYWRkUm93SWNvbiBpJyk7XG4gICAgYWRkUm93TGluay5jbGFzc0xpc3QucmVtb3ZlKCdub24tY2xpcXVhYmxlJyk7XG4gICAgYWRkUm93SWNvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG59XG5cblxuIiwgInZhciBhdXRob3JpemVkSW5wdXRzID0ge1xuICBBZG1pbjogW1xuICAgIFwidGFza190aXRsZVwiLFxuICAgIFwidGFza19kZXNjcmlwdGlvblwiLFxuICAgIFwicGFyZW50X3Rhc2tcIixcbiAgICBcImFzc2lnbmVkX3BlcnNvblwiLFxuICAgIFwiZHVlX2RhdGVcIixcbiAgICBcInN0YXJ0X2RhdGVcIixcbiAgICBcIm9yaWdpbmFsX2VzdGltYXRlXCIsXG4gICAgXCJwcm9ncmVzc1wiLFxuICAgIFwic2F2ZVwiLFxuICAgIFwiY3Vycl91c2VyXCIsXG4gICAgXCJwcm9faWRcIixcbiAgICBcInN0YXR1c19pZFwiLFxuICAgIFwicHJpb3JpdHlfaWRcIixcbiAgICBcInRhc2tfZGVhZGxpbmVcIlxuICBdLFxuICBBdHRyaWJ1dGV1cjogW1xuICAgIFwidGFza190aXRsZVwiLFxuICAgIFwidGFza19kZXNjcmlwdGlvblwiLFxuICAgIFwicGFyZW50X3Rhc2tcIixcbiAgICBcImFzc2lnbmVkX3BlcnNvblwiLFxuICAgIFwiZHVlX2RhdGVcIixcbiAgICBcInN0YXJ0X2RhdGVcIixcbiAgICBcIm9yaWdpbmFsX2VzdGltYXRlXCIsXG4gICAgXCJwcm9ncmVzc1wiLFxuICAgIFwic2F2ZVwiLFxuICAgIFwiY3Vycl91c2VyXCIsXG4gICAgXCJwcm9faWRcIixcbiAgICBcInN0YXR1c19pZFwiLFxuICAgIFwicHJpb3JpdHlfaWRcIixcbiAgICBcInRhc2tfZGVhZGxpbmVcIlxuICBdLFxuICBDb250cmlidXRldXI6IFtcbiAgICBcInRhc2tfdGl0bGVcIixcbiAgICBcInRhc2tfZGVzY3JpcHRpb25cIixcbiAgICBcInByb2dyZXNzXCIsXG4gICAgXCJzYXZlXCIsXG4gICAgIFwiY3Vycl91c2VyXCIsXG4gICAgXCJwcm9faWRcIixcbiAgICBcInN0YXR1c19pZFwiLFxuICAgIFwicHJpb3JpdHlfaWRcIixcbiAgICBcInRhc2tfZGVhZGxpbmVcIlxuICBdLFxuICAvLyBBam91dGV6IGQnYXV0cmVzIHByb2ZpbHMgZXQgbGV1cnMgbGlzdGVzIGQnaW5wdXRzIGF1dG9yaXNcdTAwRTlzIHNpIG5cdTAwRTljZXNzYWlyZVxufTtcblxuZnVuY3Rpb24gdG9nZ2xlSW5wdXRzKHByb2ZpbGUpIHtcbiAgLy8gU1x1MDBFOWxlY3Rpb25uZXogdG91cyBsZXMgY2hhbXBzIGRlIGZvcm11bGFpcmVcbiAgY29uc3QgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0XCIpO1xuICBjb25zdCBwcm9maWxlSW5wdXRzID0gYXV0aG9yaXplZElucHV0c1twcm9maWxlXTtcbiAvLyBjb25zb2xlLmxvZyhwcm9maWxlSW5wdXRzLCBwcm9maWxlKTtcbiAgLy8gUGFyY291cmV6IGNoYXF1ZSBjaGFtcCBkZSBmb3JtdWxhaXJlXG4gIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIC8vIFZcdTAwRTlyaWZpZXogc2kgbGUgY2hhbXAgZmFpdCBwYXJ0aWUgZGVzIGlucHV0cyBhdXRvcmlzXHUwMEU5cyBwb3VyIGxlIHByb2ZpbFxuXG4gICAgaWYgKHByb2ZpbGVJbnB1dHMgJiYgcHJvZmlsZUlucHV0cy5pbmNsdWRlcyhpbnB1dC5uYW1lKSApIHtcbiAgICAgIC8vIEFjdGl2ZXIgbGUgY2hhbXAgc2kgYXV0b3Jpc1x1MDBFOSBwb3VyIGNlIHByb2ZpbFxuICAgICAvLyBjb25zb2xlLmxvZyhpbnB1dC5pZCk7XG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRFx1MDBFOXNhY3RpdmVyIGxlIGNoYW1wIHMnaWwgbidlc3QgcGFzIGF1dG9yaXNcdTAwRTkgcG91ciBjZSBwcm9maWxcbiAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0ZpcnN0RGF0ZUJlZm9yZVNlY29uZERhdGUoZGF0ZTEsIGRhdGUyKSB7XG4gIC8vIENvbnZlcnRpciBsZXMgZGF0ZXMgZW4gb2JqZXRzIERhdGVcbiAgdmFyIGZpcnN0RGF0ZSA9IG5ldyBEYXRlKGRhdGUxKTtcbiAgdmFyIHNlY29uZERhdGUgPSBuZXcgRGF0ZShkYXRlMik7XG5cbiAgLy8gQ29tcGFyZXIgbGVzIGRhdGVzXG4gIHJldHVybiBmaXJzdERhdGUgPCBzZWNvbmREYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzYWN0aXZhdGVBbGxpbnB1dHMoKSB7XG4gIC8vIFNcdTAwRTlsZWN0aW9uIGRlIGxhIGRpdiBwcmluY2lwYWxlXG4gIHZhciBtYWluRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93aW5nX3Rhc2tcIik7XG5cbiAgLy8gU1x1MDBFOWxlY3Rpb24gZGUgdG91cyBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGRlIGZvcm11bGFpcmUgZGFucyBsYSBkaXYgcHJpbmNpcGFsZVxuICB2YXIgaW5wdXRzID0gbWFpbkRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIik7XG4gIFxuICAvLyBQYXJjb3VyaXIgdG91cyBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGRlIGZvcm11bGFpcmUgZXQgYWN0aXZlciBsZXMgY2hhbXBzXG4gIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVDbGlja09uTW9kaWZCdG4ocHJvZmlsZSkge1xuICB2YXIgc2F2ZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F2ZVwiKTtcbiAgdmFyIGNhbmNlbEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FuY2VsXCIpO1xuICB2YXIgbW9kaWZCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1vZGlmeVwiKTtcbiAgLy8gdmFyIHRhc2tfaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhc2tfdGl0bGVcIik7XG4gIHNhdmVCdG4uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gIHNhdmVCdG4uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gIGNhbmNlbEJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgY2FuY2VsQnRuLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICBtb2RpZkJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJjb250ZW50c1wiO1xuICBtb2RpZkJ0bi5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgdG9nZ2xlSW5wdXRzKHByb2ZpbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPbkNhbmNlbEJ0bigpIHtcbiAgdmFyIHNhdmVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNhdmVcIik7XG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbmNlbFwiKTtcbiAgdmFyIG1vZGlmQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RpZnlcIik7XG5cbiAgc2F2ZUJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJjb250ZW50c1wiO1xuICBzYXZlQnRuLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICBjYW5jZWxCdG4uc3R5bGUuZGlzcGxheSA9IFwiY29udGVudHNcIjtcbiAgY2FuY2VsQnRuLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICBtb2RpZkJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgbW9kaWZCdG4uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gIGRlc2FjdGl2YXRlQWxsaW5wdXRzKCk7XG59XG5cbi8vIEZvbmN0aW9uIHBvdXIgdmFsaWRlciBsYSBzYWlzaWUgZGFucyBsZSBjaGFtcCBcInByb2dyZXNzXCJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3Jlc3NJbnB1dCh2YWx1ZSkge1xuICAvLyBWXHUwMEU5cmlmaWUgc2kgbGEgdmFsZXVyIGVzdCB1biBub21icmVcbiAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAvLyBWXHUwMEU5cmlmaWUgc2kgbGEgdmFsZXVyIGVzdCBjb21wcmlzZSBlbnRyZSAwIGV0IDEwMFxuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEwMCkge1xuICAgICAgLy8gTGEgdmFsZXVyIGVzdCB2YWxpZGVcbiAgICAgLy8gY29uc29sZS5sb2coXCJMYSB2YWxldXIgZXN0IHZhbGlkZSA6XCIsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMYSB2YWxldXIgZXN0IGVuIGRlaG9ycyBkZSBsYSBwbGFnZSBhdXRvcmlzXHUwMEU5ZVxuICAgICAgLy9jb25zb2xlLmxvZyhcIkxhIHZhbGV1ciBkb2l0IFx1MDBFQXRyZSBjb21wcmlzZSBlbnRyZSAwIGV0IDEwMFwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTGEgdmFsZXVyIG4nZXN0IHBhcyB1biBub21icmVcbiAgICAvL2NvbnNvbGUubG9nKFwiTGEgdmFsZXVyIGRvaXQgXHUwMEVBdHJlIHVuIG5vbWJyZVwiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gIHZhbGlkYXRlRGF0ZUlucHV0cygpIHtcbiAgICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgaW5wdXQgZGVzIGNoYW1wcyBkZSBkYXRlXG4gICAgdmFyIHN0YXJ0RGF0ZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0X2RhdGUnKTtcbiAgICB2YXIgZHVlRGF0ZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R1ZV9kYXRlJyk7XG5cbiAgICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyB2YWxldXJzIGRlcyBjaGFtcHMgZGUgZGF0ZVxuICAgIHZhciBzdGFydERhdGVWYWx1ZSA9IHN0YXJ0RGF0ZUlucHV0LnZhbHVlO1xuICAgIHZhciBkdWVEYXRlVmFsdWUgPSBkdWVEYXRlSW5wdXQudmFsdWU7XG5cbiAgICAvLyBSXHUwMEU5aW5pdGlhbGlzZXIgbGVzIG1lc3NhZ2VzIGQnZXJyZXVyIGRhbnMgbGVzIGxhYmVsc1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydF9kYXRlX2Vycm9yJykudGV4dENvbnRlbnQgPSBcIkxhIGRhdGUgZCdcdTAwRTljaFx1MDBFOWFuY2UgbmUgcGV1dCBwYXMgXHUwMEVBdHJlIGFudFx1MDBFOXJpZXVyZSBcdTAwRTAgbGEgZGF0ZSBkZSBkXHUwMEU5YnV0XCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0X2RhdGVfZXJyb3InKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHVlX2RhdGVfZXJyb3InKS50ZXh0Q29udGVudCA9IFwiTGEgZGF0ZSBkJ1x1MDBFOWNoXHUwMEU5YW5jZSBuZSBwZXV0IHBhcyBcdTAwRUF0cmUgYW50XHUwMEU5cmlldXJlIFx1MDBFMCBsYSBkYXRlIGRlIGRcdTAwRTlidXRcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHVlX2RhdGVfZXJyb3InKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblxuICAgIC8vIFZcdTAwRTlyaWZpZXIgc2kgbGVzIGNoYW1wcyBkZSBkYXRlIHNvbnQgdmlkZXNcbiAgICBpZiAoIXN0YXJ0RGF0ZVZhbHVlKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydF9kYXRlX2Vycm9yJykudGV4dENvbnRlbnQgPSBcIlZldWlsbGV6IGVudHJlciB1bmUgZGF0ZSBkZSBkXHUwMEU5YnV0XCI7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydF9kYXRlX2Vycm9yJykuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWR1ZURhdGVWYWx1ZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHVlX2RhdGVfZXJyb3InKS50ZXh0Q29udGVudCA9IFwiVmV1aWxsZXogZW50cmVyIHVuZSBkYXRlIGQnXHUwMEU5Y2hcdTAwRTlhbmNlXCI7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkdWVfZGF0ZV9lcnJvcicpLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVlx1MDBFOXJpZmllciBzaSBsZXMgZGF0ZXMgc29udCBhdSBib24gZm9ybWF0XG4gICAgaWYgKGlzTmFOKERhdGUucGFyc2Uoc3RhcnREYXRlVmFsdWUpKSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRfZGF0ZV9lcnJvcicpLnRleHRDb250ZW50ID0gXCJGb3JtYXQgZGUgZGF0ZSBpbnZhbGlkZVwiO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRfZGF0ZV9lcnJvcicpLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKERhdGUucGFyc2UoZHVlRGF0ZVZhbHVlKSkpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R1ZV9kYXRlX2Vycm9yJykudGV4dENvbnRlbnQgPSBcIkZvcm1hdCBkZSBkYXRlIGludmFsaWRlXCI7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkdWVfZGF0ZV9lcnJvcicpLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVlx1MDBFOXJpZmllciBzaSBsYSBkYXRlIGQnXHUwMEU5Y2hcdTAwRTlhbmNlIGVzdCBhbnRcdTAwRTlyaWV1cmUgXHUwMEUwIGxhIGRhdGUgZGUgZFx1MDBFOWJ1dFxuICAgIGlmIChpc0ZpcnN0RGF0ZUJlZm9yZVNlY29uZERhdGUoZHVlRGF0ZVZhbHVlLCBzdGFydERhdGVWYWx1ZSkpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R1ZV9kYXRlX2Vycm9yJykudGV4dENvbnRlbnQgPSBcIkxhIGRhdGUgZCdcdTAwRTljaFx1MDBFOWFuY2UgbmUgcGV1dCBwYXMgXHUwMEVBdHJlIGFudFx1MDBFOXJpZXVyZSBcdTAwRTAgbGEgZGF0ZSBkZSBkXHUwMEU5YnV0XCI7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkdWVfZGF0ZV9lcnJvcicpLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERlY2ltYWxWYWwodmFsdWUpIHtcbiAgdmFyIG51bVZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IG51bVZhbHVlLnRvRml4ZWQoMik7XG4gIHJldHVybiBmb3JtYXR0ZWRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFc3RpbWF0aW9uSW5wdXQodmFsdWUpIHtcbiAgIHZhciBudW1WYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgLy8gVlx1MDBFOXJpZmllciBzaSBsYSB2YWxldXIgZXN0IHVuIG5vbWJyZVxuICAgIGlmIChpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgICAvLyBjb25zb2xlLmxvZyhcIkxhIHZhbGV1ciBlbnRyXHUwMEU5ZSBuJ2VzdCBwYXMgdW4gbm9tYnJlIHZhbGlkZS5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxhIHZhbGV1ciBlc3Qgblx1MDBFOWdhdGl2ZVxuICAgIGlmIChudW1WYWx1ZSA8IDApIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxhIHZhbGV1ciBuZSBwZXV0IHBhcyBcdTAwRUF0cmUgblx1MDBFOWdhdGl2ZS5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXROdW1iZXJJbnB1dCh2YWx1ZSkge1xuICAvLyBSZW1wbGFjZXogdG91dGVzIGxlcyBjYXJhY3RcdTAwRThyZXMgbm9uIG51bVx1MDBFOXJpcXVlcyBwYXIgdW5lIGNoYVx1MDBFRW5lIHZpZGVcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcRC9nLCBcIlwiKTtcbn1cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzSW5wdXQoZXZlbnQpIHtcbiAgZm9ybWF0ZWRfdmFsdWUgPSBmb3JtYXROdW1iZXJJbnB1dCh0aGlzLnZhbHVlKTtcbiAgaXNfdmFsaWQgPSB2YWxpZGF0ZVByb2dyZXNzSW5wdXQodGhpcy52YWx1ZSk7XG4gIC8vY29uc29sZS5sb2codGhpcy52YWx1ZSwgZm9ybWF0ZWRfdmFsdWUsIGlzX3ZhbGlkKTtcbiAgaWYgKGlzX3ZhbGlkKSB7XG4gICAgdGhpcy52YWx1ZSA9IGZvcm1hdGVkX3ZhbHVlO1xuICB9IGVsc2UgdGhpcy52YWx1ZSA9IFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAgaGFuZGxlRGF0ZUlucHV0Q2hhbmdlKGV2ZW50KSB7XG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsJ1x1MDBFOWxcdTAwRTltZW50IGlucHV0IHF1aSBhIGRcdTAwRTljbGVuY2hcdTAwRTkgbCdcdTAwRTl2XHUwMEU5bmVtZW50XG4gICAgdmFyIGlucHV0ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zb2xlLmxvZyhcIm1ha2F0b1wiKTtcbiAgICAvLyBWYWxpZGVyIGxhIHZhbGV1ciBzYWlzaWUgZGFucyBsZSBjaGFtcCBkZSBkYXRlXG4gICBjb25zb2xlLmxvZyh2YWxpZGF0ZURhdGVJbnB1dHMoKSk7XG5cbiAgICAvLyBWb3VzIHBvdXZleiBham91dGVyIGQnYXV0cmVzIGFjdGlvbnMgZW4gZm9uY3Rpb24gZGUgbGEgdmFsaWRhdGlvbiBpY2lcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gIGhhbmRsZUVzdGltYXRpb25JbnB1dChldmVudCkge1xuIGxldCBmaWx0cmVkdmFsID0gIHRoaXMudmFsdWUucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gIGNvbnNvbGUubG9nKGZpbHRyZWR2YWwpO1xuICB2YWwgPSBwYXJzZUZsb2F0KGZpbHRyZWR2YWwpO1xuICBjb25zb2xlLmxvZyhpc05hTih2YWwpLCB2YWwsIGZpbHRyZWR2YWwpO1xuICBpZiAoIWlzTmFOKHZhbCkgfHwgdmFsPjApIHtcbiAgICBjb25zb2xlLmxvZyhmaWx0cmVkdmFsKTtcbiAgICAvL3RoaXMudmFsdWUgPSBmaWx0cmVkdmFsO1xuICAgICAgIGxldCBkZWNpbWFsTGVuZ3RoID0gKGZpbHRyZWR2YWwuc3BsaXQoJy4nKVsxXSB8fCAnJykubGVuZ3RoO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGRlY2ltYWxMZW5ndGgpO1xuICAgICAgICBpZiAoZGVjaW1hbExlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhbGV1ciA9IHBhcnNlRmxvYXQoZmlsdHJlZHZhbCkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWxldXI7IC8vIExpbWl0ZXIgXHUwMEUwIGRldXggY2hpZmZyZXMgYXByXHUwMEU4cyBsYSB2aXJndWxlXG4gICAgICAgIH1cbiAgfVxuICBlbHNlXG4gICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gXG59XG5cblxuZnVuY3Rpb24gbG9hZEJ1dHRvbkFjdGlvbihwcm9maWxlKSB7XG4gIHZhciBtb2RpZkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibW9kaWZ5XCIpO1xuICBtb2RpZkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgIGhhbmRsZUNsaWNrT25Nb2RpZkJ0bihwcm9maWxlKTtcbiAgfSk7XG5cbiAgdmFyIGNhbmNlbEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FuY2VsXCIpO1xuICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBoYW5kbGVDbGlja09uQ2FuY2VsQnRuKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkQWxsSW5wdXRzRXZlbnQoKSB7XG4gIHZhciBwcm9ncmVzc0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9ncmVzc1wiKTtcbiAgcHJvZ3Jlc3NJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgaGFuZGxlUHJvZ3Jlc3NJbnB1dCk7XG4gIC8vIFNcdTAwRTlsZWN0aW9ubmVyIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgaW5wdXQgZGVzIGNoYW1wcyBkZSBkYXRlXG4gIHZhciBzdGFydERhdGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydF9kYXRlJyk7XG4gIHZhciBkdWVEYXRlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHVlX2RhdGUnKTtcblxuICAgICBcbiAgdmFyIGVzdGltYXRpb25JbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXN0aW1hdGlvbl92YWxcIik7XG4gIGNvbnNvbGUubG9nKGVzdGltYXRpb25JbnB1dCk7XG4gIGVzdGltYXRpb25JbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgaGFuZGxlRXN0aW1hdGlvbklucHV0KTtcbiAgXG4gIC8vIEFqb3V0ZXIgdW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIHBvdXIgc3VydmVpbGxlciBsZXMgbW9kaWZpY2F0aW9ucyBkYW5zIGxlIGNoYW1wIGRlIGRhdGUgZGUgZFx1MDBFOWJ1dFxuICBzdGFydERhdGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVEYXRlSW5wdXRDaGFuZ2UpO1xuXG4gIC8vIEFqb3V0ZXIgdW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIHBvdXIgc3VydmVpbGxlciBsZXMgbW9kaWZpY2F0aW9ucyBkYW5zIGxlIGNoYW1wIGRlIGRhdGUgZCdcdTAwRTljaFx1MDBFOWFuY2VcbiAgZHVlRGF0ZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZURhdGVJbnB1dENoYW5nZSk7XG4gXG59XG5cblxuZnVuY3Rpb24gZmlsdGVySW5wdXQoaW5wdXQpIHtcbiAgICAvLyBSZW1wbGFjZSB0b3V0IGNlIHF1aSBuJ2VzdCBuaSB1biBjaGlmZnJlIG5pIHVuIHBvaW50IHBhciB1bmUgY2hhXHUwMEVFbmUgdmlkZVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXEQvZywgXCJcIik7XG59XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93VGFzayhwcm9maWxlKSB7XG4gIHZhciBzYXZlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXZlXCIpO1xuICBzYXZlQnRuLnN0eWxlLmRpc3BsYXkgPSBcImNvbnRlbnRzXCI7XG4gIGxvYWRCdXR0b25BY3Rpb24ocHJvZmlsZSk7XG5cbiAgbG9hZEFsbElucHV0c0V2ZW50KCk7XG59XG4iLCAiaW1wb3J0IFwidG9tLXNlbGVjdFwiO1xuaW1wb3J0IHsgaGFuZGxlRGF0ZUlucHV0Q2hhbmdlICwgaGFuZGxlRXN0aW1hdGlvbklucHV0fSBmcm9tIFwiLi9zaG93aW5nX3Rhc2tcIlxuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gXCJ0b20tc2VsZWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gbG9hZEZvcm0oKXtcbiAgICBsZXQgY29udHJpYnV0b3JTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRyaWJ1dG9yU2VsZWN0XCIpO1xuICAgIGNvbnNvbGUubG9nKGNvbnRyaWJ1dG9yU2VsZWN0KTtcbiAgICBsZXQgdG9tID0gbmV3IFRvbVNlbGVjdChjb250cmlidXRvclNlbGVjdCx7XG4gICAgICAgIHBlcnNpc3Q6IGZhbHNlLFxuICAgICAgICBjcmVhdGVPbkJsdXI6IHRydWUsXG4gICAgICAgIHBsdWdpbnM6IFsncmVtb3ZlX2J1dHRvbiddXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2codG9tKTtcbiAgICB2YXIgc3RhcnREYXRlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRfZGF0ZScpO1xuICAgIHZhciBkdWVEYXRlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHVlX2RhdGUnKTtcbiAgICB2YXIgZXN0aW1hdGlvbklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlc3RpbWF0aW9uX3ZhbFwiKTtcbiAgICB2YXIgdGl0bGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVfaVwiKTtcbiAgICB2YXIgZGVzY3JpSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlc2NyaXB0aW9uXCIpO1xuICAgIC8vZXZlbmVtZW50IHN1ciBsJ2VzdGltYXRpb25cbiAgICBlc3RpbWF0aW9uSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGhhbmRsZUVzdGltYXRpb25JbnB1dCk7XG4gICAgLy8gQWpvdXRlciB1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgcG91ciBzdXJ2ZWlsbGVyIGxlcyBtb2RpZmljYXRpb25zIGRhbnMgbGUgY2hhbXAgZGUgZGF0ZSBkZSBkXHUwMEU5YnV0XG4gICAgc3RhcnREYXRlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlRGF0ZUlucHV0Q2hhbmdlKTtcbiAgICAvLyBBam91dGVyIHVuIFx1MDBFOWNvdXRldXIgZCdcdTAwRTl2XHUwMEU5bmVtZW50cyBwb3VyIHN1cnZlaWxsZXIgbGVzIG1vZGlmaWNhdGlvbnMgZGFucyBsZSBjaGFtcCBkZSBkYXRlIGQnXHUwMEU5Y2hcdTAwRTlhbmNlXG4gICAgZHVlRGF0ZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZURhdGVJbnB1dENoYW5nZSk7XG4gICAgLy9ham91dGVyIHVuIGVjb3V0ZXVyIHN1ciBsJ2lucHV0IHRpdGxlXG4gICAgdGl0bGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHZhbGlkYXRlVGl0bGUpO1xuICAgIC8vYWpvdXRlciB1bmUgZWNvdXRldXIgc3VyIGwnaW5wdXQgZGVzY3JpcHRpb25cbiAgICBkZXNjcmlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHZhbGlkYXRlRGVzY3JpcHRpb24pO1xuXG4gICAgXG5cblxuXG5cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaXRsZSgpIHtcbiAgICBsZXQgdGl0bGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVfaVwiKTtcbiAgICBsZXQgZXJyb3JMYWJlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVfZXJyb3JcIik7XG4gICAgbGV0IHRpdGxlVmFsID0gdGl0bGVJbnB1dC52YWx1ZTtcbiAgICBpZiAoaXNGaWVsZEVtcHR5KHRpdGxlVmFsKSkge1xuICAgICAgICBlcnJvckxhYmVsLnRleHRDb250ZW50ID0gXCJDZXR0ZSBjaGFtcHMgbmUgcGV1dCBwYXMgZXRyZSB2aWRlIVwiO1xuICAgICAgICBlcnJvckxhYmVsLnN0eWxlLnZpc2liaWxpdHk9XCJcIjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzTGVuZ3RoVmFsaWQodGl0bGVWYWwsIDI1NSkpIHtcbiAgICAgICAgZXJyb3JMYWJlbC50ZXh0Q29udGVudCA9IFwidmFsZXVyIHRyb3AgbG9uZ1wiO1xuICAgICAgICBlcnJvckxhYmVsLnN0eWxlLnZpc2liaWxpdHk9XCJcIjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXJyb3JMYWJlbC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIGVycm9yTGFiZWwuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAgICAgXG4gICAgXG4gICAgICAgIFxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURlc2NyaXB0aW9uKCkge1xuICAgIGxldCBkZXNjcmlJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVzY3JpcHRpb25cIik7XG4gICAgbGV0IGVycm9yTGFiZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlc2NyaXB0aW9uX2Vycm9yXCIpO1xuICAgIGxldCBkZXNjcmlWYWwgPSBkZXNjcmlJbnB1dC52YWx1ZTtcbiAgICBpZiAoaXNGaWVsZEVtcHR5KGRlc2NyaVZhbCkpIHtcbiAgICAgICAgZXJyb3JMYWJlbC50ZXh0Q29udGVudCA9IFwiQ2V0dGUgY2hhbXBzIG5lIHBldXQgcGFzIGV0cmUgdmlkZSFcIjtcbiAgICAgICAgZXJyb3JMYWJlbC5zdHlsZS52aXNpYmlsaXR5PVwiXCI7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0xlbmd0aFZhbGlkKGRlc2NyaVZhbCwgMzAwKSkge1xuICAgICAgICBlcnJvckxhYmVsLnRleHRDb250ZW50ID0gXCJ2YWxldXIgdHJvcCBsb25nXCI7XG4gICAgICAgIGVycm9yTGFiZWwuc3R5bGUudmlzaWJpbGl0eT1cIlwiO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0ZpZWxkRW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpID09PSAnJztcbn1cblxuZnVuY3Rpb24gaXNMZW5ndGhWYWxpZCh2YWx1ZSAsIG1heExlbmd0aCkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gbWF4TGVuZ3RoO1xufSIsICJcbi8vIEphdmFTY3JpcHQgdG8gY2hhbmdlIGZhdmljb24gZHluYW1pY2FsbHlcbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VGYXZpY29uQnlUaGVtZSgpIHtcbiAgICBjb25zdCBpc0RhcmtNb2RlID0gd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzO1xuICAgIGNvbnN0IGlzTGlnaHRNb2RlID0gd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpJykubWF0Y2hlcztcbiAgICBjb25zdCBmYXZpY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPSdpY29uJ11cIik7XG5cbiAgICBpZiAoaXNEYXJrTW9kZSkge1xuICAgICAgICBmYXZpY29uLmhyZWYgPSAnaHR0cHM6Ly90ZXN0Lm1vbml0b3JpbmcucGhpZGlhLmZyL2ltYWdlcy9wcm9maWxlcy9NZ2JpLXByb2ZpbGUtbGlnaHQucG5nJztcbiAgICAgICAgY29uc29sZS5sb2coXCJUaGUgdGhlbWUgaXMgRGFyayBhbmQgaXQnc1wiLCBpc0RhcmtNb2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhdmljb24uaHJlZiA9ICdodHRwczovL3Rlc3QubW9uaXRvcmluZy5waGlkaWEuZnIvaW1hZ2VzL3Byb2ZpbGVzL01nYmktcHJvZmlsZS5wbmcnO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSB0aGVtZSBpcyBMaWdodCBhbmQgaXQnc1wiLCBpc0xpZ2h0TW9kZSlcbiAgICB9XG59XG5cbi8vIENhbGwgdGhlIGZ1bmN0aW9uIHdoZW4gdGhlIHBhZ2UgbG9hZHNcbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBjaGFuZ2VGYXZpY29uQnlUaGVtZSgpO1xufVxuXG4vLyBMaXN0ZW4gZm9yIHRoZW1lIGNoYW5nZXMgYW5kIHVwZGF0ZSB0aGUgZmF2aWNvbiBhY2NvcmRpbmdseVxud2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgY2hhbmdlRmF2aWNvbkJ5VGhlbWUoKTtcbn0pOyIsICJcInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgUG9seWZpbGxFdmVudCA9IGV2ZW50Q29uc3RydWN0b3IoKTtcblxuICBmdW5jdGlvbiBldmVudENvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG4gICAgLy8gSUU8PTkgU3VwcG9ydFxuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7YnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZH07XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9XG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICByZXR1cm4gQ3VzdG9tRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEhpZGRlbklucHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgIGlucHV0Lm5hbWUgPSBuYW1lO1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZWxlbWVudCwgdGFyZ2V0TW9kaWZpZXJLZXkpIHtcbiAgICB2YXIgdG8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIiksXG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfbWV0aG9kXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpLFxuICAgICAgICBjc3JmID0gYnVpbGRIaWRkZW5JbnB1dChcIl9jc3JmX3Rva2VuXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jc3JmXCIpKSxcbiAgICAgICAgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcblxuICAgIGlmICh0YXJnZXQpIGZvcm0udGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGVsc2UgaWYgKHRhcmdldE1vZGlmaWVyS2V5KSBmb3JtLnRhcmdldCA9IFwiX2JsYW5rXCI7XG5cbiAgICBmb3JtLmFwcGVuZENoaWxkKGNzcmYpO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQobWV0aG9kKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgIGZvcm0uc3VibWl0KCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSkge1xuICAgICAgICBoYW5kbGVDbGljayhlbGVtZW50LCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGZhbHNlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29uZmlybVwiKTtcbiAgICBpZihtZXNzYWdlICYmICF3aW5kb3cuY29uZmlybShtZXNzYWdlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufSkoKTtcbiIsICIvLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGxldCBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKXtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBsZXQgY2xvc3VyZSA9IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsdWUgfVxuICAgIHJldHVybiBjbG9zdXJlXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGxcbmV4cG9ydCBjb25zdCBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbFxuZXhwb3J0IGNvbnN0IGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IHRoaXNcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZTTiA9IFwiMi4wLjBcIlxuZXhwb3J0IGNvbnN0IFNPQ0tFVF9TVEFURVMgPSB7Y29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzfVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuZXhwb3J0IGNvbnN0IENIQU5ORUxfU1RBVEVTID0ge1xuICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gIGVycm9yZWQ6IFwiZXJyb3JlZFwiLFxuICBqb2luZWQ6IFwiam9pbmVkXCIsXG4gIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICBsZWF2aW5nOiBcImxlYXZpbmdcIixcbn1cbmV4cG9ydCBjb25zdCBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgY2xvc2U6IFwicGh4X2Nsb3NlXCIsXG4gIGVycm9yOiBcInBoeF9lcnJvclwiLFxuICBqb2luOiBcInBoeF9qb2luXCIsXG4gIHJlcGx5OiBcInBoeF9yZXBseVwiLFxuICBsZWF2ZTogXCJwaHhfbGVhdmVcIlxufVxuXG5leHBvcnQgY29uc3QgVFJBTlNQT1JUUyA9IHtcbiAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgd2Vic29ja2V0OiBcIndlYnNvY2tldFwiXG59XG5leHBvcnQgY29uc3QgWEhSX1NUQVRFUyA9IHtcbiAgY29tcGxldGU6IDRcbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBgXCJwaHhfam9pblwiYFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpe1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uICgpeyByZXR1cm4ge30gfVxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnJlY0hvb2tzID0gW11cbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAqL1xuICByZXNlbmQodGltZW91dCl7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIHNlbmQoKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKFwidGltZW91dFwiKSl7IHJldHVybiB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKCksXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3RhdHVzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChzdGF0dXMpKXtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7c3RhdHVzLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXQoKXtcbiAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9IG51bGxcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbFxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1hdGNoUmVjZWl2ZSh7c3RhdHVzLCByZXNwb25zZSwgX3JlZn0pe1xuICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKGggPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKGggPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFJlZkV2ZW50KCl7XG4gICAgaWYoIXRoaXMucmVmRXZlbnQpeyByZXR1cm4gfVxuICAgIHRoaXMuY2hhbm5lbC5vZmYodGhpcy5yZWZFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy50aW1lb3V0VGltZXIpeyB0aGlzLmNhbmNlbFRpbWVvdXQoKSB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpXG5cbiAgICB0aGlzLmNoYW5uZWwub24odGhpcy5yZWZFdmVudCwgcGF5bG9hZCA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMubWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJ0aW1lb3V0XCIsIHt9KVxuICAgIH0sIHRoaXMudGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzUmVjZWl2ZWQoc3RhdHVzKXtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKXtcbiAgICB0aGlzLmNoYW5uZWwudHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7c3RhdHVzLCByZXNwb25zZX0pXG4gIH1cbn1cbiIsICIvKipcbiAqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybVxuICogY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH0pXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVyQ2FsY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpe1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gICAgdGhpcy50aW1lciA9IG51bGxcbiAgICB0aGlzLnRyaWVzID0gMFxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAqL1xuICBzY2hlZHVsZVRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMVxuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKVxuICB9XG59XG4iLCAiaW1wb3J0IHtjbG9zdXJlfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UUyxcbiAgQ0hBTk5FTF9TVEFURVMsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBQdXNoIGZyb20gXCIuL3B1c2hcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBwYXJhbXNcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKHRvcGljLCBwYXJhbXMsIHNvY2tldCl7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgIHRoaXMudG9waWMgPSB0b3BpY1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMgfHwge30pXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLmJpbmRpbmdzID0gW11cbiAgICB0aGlzLmJpbmRpbmdSZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dFxuICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlXG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcyA9IFtdXG5cbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5pc0Vycm9yZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0pXG4gICAgKVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2gocHVzaEV2ZW50ID0+IHB1c2hFdmVudC5zZW5kKCkpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub25DbG9zZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIGlmKHRoaXMuaXNKb2luaW5nKCkpeyB0aGlzLmpvaW5QdXNoLnJlc2V0KCkgfVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYHRpbWVvdXQgJHt0aGlzLnRvcGljfSAoJHt0aGlzLmpvaW5SZWYoKX0pYCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGhpcy50aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMucmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMucmVqb2luKClcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGNsb3NlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBlcnJvcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmVycm9yLCByZWFzb24gPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbiByZXR1cm5zIGEgcmVmIGNvdW50ZXIsIHdoaWNoIGNhbiBiZSB1c2VkIGxhdGVyIHRvXG4gICAqIHVuc3Vic2NyaWJlIHRoZSBleGFjdCBldmVudCBsaXN0ZW5lclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjb25zdCByZWYyID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX290aGVyX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqIC8vIFNpbmNlIHVuc3Vic2NyaXB0aW9uLCBkb19zdHVmZiB3b24ndCBmaXJlLFxuICAgKiAvLyB3aGlsZSBkb19vdGhlcl9zdHVmZiB3aWxsIGtlZXAgZmlyaW5nIG9uIHRoZSBcImV2ZW50XCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMuYmluZGluZ1JlZisrXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKHtldmVudCwgcmVmLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBvZmYgb2YgY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogVXNlIHRoZSByZWYgcmV0dXJuZWQgZnJvbSBhIGNoYW5uZWwub24oKSB0byB1bnN1YnNjcmliZSBvbmVcbiAgICogaGFuZGxlciwgb3IgcGFzcyBub3RoaW5nIGZvciB0aGUgcmVmIHRvIHVuc3Vic2NyaWJlIGFsbFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgZG9fc3R1ZmYgaGFuZGxlclxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIGFsbCBoYW5kbGVycyBmcm9tIGV2ZW50XG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvZmYoZXZlbnQsIHJlZil7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5QdXNoKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKSB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBgZXZlbnRgIHRvIHBob2VuaXggd2l0aCB0aGUgcGF5bG9hZCBgcGF5bG9hZGAuXG4gICAqIFBob2VuaXggcmVjZWl2ZXMgdGhpcyBpbiB0aGUgYGhhbmRsZV9pbihldmVudCwgcGF5bG9hZCwgc29ja2V0KWBcbiAgICogZnVuY3Rpb24uIGlmIHBob2VuaXggcmVwbGllcyBvciBpdCB0aW1lcyBvdXQgKGRlZmF1bHQgMTAwMDBtcyksXG4gICAqIHRoZW4gb3B0aW9uYWxseSB0aGUgcmVwbHkgY2FuIGJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLnB1c2goXCJldmVudFwiKVxuICAgKiAgIC5yZWNlaXZlKFwib2tcIiwgcGF5bG9hZCA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggcmVwbGllZDpcIiwgcGF5bG9hZCkpXG4gICAqICAgLnJlY2VpdmUoXCJlcnJvclwiLCBlcnIgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IGVycm9yZWRcIiwgZXJyKSlcbiAgICogICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gY29uc29sZS5sb2coXCJ0aW1lZCBvdXQgcHVzaGluZ1wiKSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF1cbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBwdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIGlmKCF0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5qb2luKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYClcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBmdW5jdGlvbiAoKXsgcmV0dXJuIHBheWxvYWQgfSwgdGltZW91dClcbiAgICBpZih0aGlzLmNhblB1c2goKSl7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBwdXNoRXZlbnRcbiAgfVxuXG4gIC8qKiBMZWF2ZXMgdGhlIGNoYW5uZWxcbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kXG4gICAqIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXJcbiAgICpcbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBgcmVjZWl2ZWBcbiAgICogaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgbGVhdmUodGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgdGhpcy5qb2luUHVzaC5jYW5jZWxUaW1lb3V0KClcblxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgbGV0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIFwibGVhdmVcIilcbiAgICB9XG4gICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGltZW91dClcbiAgICBsZWF2ZVB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgIGlmKCF0aGlzLmNhblB1c2goKSl7IGxlYXZlUHVzaC50cmlnZ2VyKFwib2tcIiwge30pIH1cblxuICAgIHJldHVybiBsZWF2ZVB1c2hcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICpcbiAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZ1xuICAgKiBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpeyByZXR1cm4gcGF5bG9hZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpe1xuICAgIGlmKHRoaXMudG9waWMgIT09IHRvcGljKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmKGpvaW5SZWYgJiYgam9pblJlZiAhPT0gdGhpcy5qb2luUmVmKCkpe1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgXCJkcm9wcGluZyBvdXRkYXRlZCBtZXNzYWdlXCIsIHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWZ9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqb2luUmVmKCl7IHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5pc0xlYXZpbmcoKSl7IHJldHVybiB9XG4gICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZil7XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5vbk1lc3NhZ2UoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZilcbiAgICBpZihwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCl7IHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKSB9XG5cbiAgICBsZXQgZXZlbnRCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKGJpbmQgPT4gYmluZC5ldmVudCA9PT0gZXZlbnQpXG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKyl7XG4gICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV1cbiAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGx5RXZlbnROYW1lKHJlZil7IHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQ2xvc2VkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNFcnJvcmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luaW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTGVhdmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZyB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBYSFJfU1RBVEVTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqYXgge1xuXG4gIHN0YXRpYyByZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgaWYoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCkgLy8gSUU4LCBJRTlcbiAgICAgIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpIC8vIElFNyssIEZpcmVmb3gsIENocm9tZSwgT3BlcmEsIFNhZmFyaVxuICAgICAgdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpXG4gICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZSlcbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gSUU5IHRoYXQgcmVxdWlyZXMgYW4gYXR0YWNoZWQgb25wcm9ncmVzcyBoYW5kbGVyXG4gICAgcmVxLm9ucHJvZ3Jlc3MgPSAoKSA9PiB7IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gIH1cblxuICBzdGF0aWMgeGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCwgdHJ1ZSlcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBhY2NlcHQpXG4gICAgcmVxLm9uZXJyb3IgPSAoKSA9PiB7IGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpIH1cbiAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spe1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICB9XG5cbiAgc3RhdGljIHBhcnNlSlNPTihyZXNwKXtcbiAgICBpZighcmVzcCB8fCByZXNwID09PSBcIlwiKXsgcmV0dXJuIG51bGwgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApXG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSl7XG4gICAgbGV0IHF1ZXJ5U3RyID0gW11cbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpeyBjb250aW51ZSB9XG4gICAgICBsZXQgcGFyYW1LZXkgPSBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9WyR7a2V5fV1gIDoga2V5XG4gICAgICBsZXQgcGFyYW1WYWwgPSBvYmpba2V5XVxuICAgICAgaWYodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKXtcbiAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocGFyYW1LZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWwpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIilcbiAgfVxuXG4gIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpe1xuICAgIGlmKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKXsgcmV0dXJuIHVybCB9XG5cbiAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCJcbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb25nUG9sbCB7XG5cbiAgY29uc3RydWN0b3IoZW5kUG9pbnQpe1xuICAgIHRoaXMuZW5kUG9pbnQgPSBudWxsXG4gICAgdGhpcy50b2tlbiA9IG51bGxcbiAgICB0aGlzLnNraXBIZWFydGJlYXQgPSB0cnVlXG4gICAgdGhpcy5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG5cbiAgICB0aGlzLnBvbGwoKVxuICB9XG5cbiAgbm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpe1xuICAgIHJldHVybiAoZW5kUG9pbnRcbiAgICAgIC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpXG4gICAgICAucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKVxcL1wiICsgVFJBTlNQT1JUUy53ZWJzb2NrZXQpLCBcIiQxL1wiICsgVFJBTlNQT1JUUy5sb25ncG9sbCkpXG4gIH1cblxuICBlbmRwb2ludFVSTCgpe1xuICAgIHJldHVybiBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLnBvbGxFbmRwb2ludCwge3Rva2VuOiB0aGlzLnRva2VufSlcbiAgfVxuXG4gIGNsb3NlQW5kUmV0cnkoKXtcbiAgICB0aGlzLmNsb3NlKClcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgfVxuXG4gIG9udGltZW91dCgpe1xuICAgIHRoaXMub25lcnJvcihcInRpbWVvdXRcIilcbiAgICB0aGlzLmNsb3NlQW5kUmV0cnkoKVxuICB9XG5cbiAgcG9sbCgpe1xuICAgIGlmKCEodGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4gfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcpKXsgcmV0dXJuIH1cblxuICAgIEFqYXgucmVxdWVzdChcIkdFVFwiLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBudWxsLCB0aGlzLnRpbWVvdXQsIHRoaXMub250aW1lb3V0LmJpbmQodGhpcyksIChyZXNwKSA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0J3Mgb3duIG1hY3JvdGFzay5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSlcbiAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oKVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKClcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgNTAwOlxuICAgICAgICAgIHRoaXMub25lcnJvcigpXG4gICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KClcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBwb2xsIHN0YXR1cyAke3N0YXR1c31gKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZW5kKGJvZHkpe1xuICAgIEFqYXgucmVxdWVzdChcIlBPU1RcIiwgdGhpcy5lbmRwb2ludFVSTCgpLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgYm9keSwgdGhpcy50aW1lb3V0LCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzLCBcInRpbWVvdXRcIiksIChyZXNwKSA9PiB7XG4gICAgICBpZighcmVzcCB8fCByZXNwLnN0YXR1cyAhPT0gMjAwKXtcbiAgICAgICAgdGhpcy5vbmVycm9yKHJlc3AgJiYgcmVzcC5zdGF0dXMpXG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlKF9jb2RlLCBfcmVhc29uKXtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZFxuICAgIHRoaXMub25jbG9zZSgpXG4gIH1cbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQcmVzZW5jZVxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMsXG4gKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogXCJzdGF0ZVwiLCBkaWZmOiBcImRpZmZcIn19YFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzZW5jZSB7XG5cbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXZlbnRzID0gb3B0cy5ldmVudHMgfHwge3N0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwifVxuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5qb2luUmVmID0gbnVsbFxuICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgb25Kb2luOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25TeW5jOiBmdW5jdGlvbiAoKXsgfVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuc3RhdGUsIG5ld1N0YXRlID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICAgIG9uU3luYygpXG4gICAgfSlcblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuZGlmZiwgZGlmZiA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpe1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW4oY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjayB9XG5cbiAgb25MZWF2ZShjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjayB9XG5cbiAgb25TeW5jKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2sgfVxuXG4gIGxpc3QoYnkpeyByZXR1cm4gUHJlc2VuY2UubGlzdCh0aGlzLnN0YXRlLCBieSkgfVxuXG4gIGluUGVuZGluZ1N5bmNTdGF0ZSgpe1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8ICh0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvLyBsb3dlci1sZXZlbCBwdWJsaWMgc3RhdGljIEFQSVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXJcbiAgICogd2l0aCB0aGUgY2xpZW50J3Mgc3RhdGUuIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuXG4gICAqIGJlIHByb3ZpZGVkIHRvIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5jbG9uZShjdXJyZW50U3RhdGUpXG4gICAgbGV0IGpvaW5zID0ge31cbiAgICBsZXQgbGVhdmVzID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgaWYoIW5ld1N0YXRlW2tleV0pe1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm1hcChuZXdTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgbmV3UmVmcyA9IG5ld1ByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1clJlZnMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBjdXJSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGxldCBsZWZ0TWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gbmV3UmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBpZihqb2luZWRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgICAgICBqb2luc1trZXldLm1ldGFzID0gam9pbmVkTWV0YXNcbiAgICAgICAgfVxuICAgICAgICBpZihsZWZ0TWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGVhdmVzW2tleV0gPSB0aGlzLmNsb25lKGN1cnJlbnRQcmVzZW5jZSlcbiAgICAgICAgICBsZWF2ZXNba2V5XS5tZXRhcyA9IGxlZnRNZXRhc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7am9pbnM6IGpvaW5zLCBsZWF2ZXM6IGxlYXZlc30sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlXG4gICAqIGV2ZW50cyBmcm9tIHRoZSBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgXG4gICAqIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyXG4gICAqIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGEgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHtqb2lucywgbGVhdmVzfSA9IHRoaXMuY2xvbmUoZGlmZilcbiAgICBpZighb25Kb2luKXsgb25Kb2luID0gZnVuY3Rpb24gKCl7IH0gfVxuICAgIGlmKCFvbkxlYXZlKXsgb25MZWF2ZSA9IGZ1bmN0aW9uICgpeyB9IH1cblxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lKG5ld1ByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1ck1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGpvaW5lZFJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgc3RhdGVba2V5XS5tZXRhcy51bnNoaWZ0KC4uLmN1ck1ldGFzKVxuICAgICAgfVxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSlcbiAgICB9KVxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoIWN1cnJlbnRQcmVzZW5jZSl7IHJldHVybiB9XG4gICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgIGN1cnJlbnRQcmVzZW5jZS5tZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIocCA9PiB7XG4gICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMFxuICAgICAgfSlcbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5sZW5ndGggPT09IDApe1xuICAgICAgICBkZWxldGUgc3RhdGVba2V5XVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJlc2VuY2VzLCB3aXRoIHNlbGVjdGVkIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VuY2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNob29zZXJcbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIGxpc3QocHJlc2VuY2VzLCBjaG9vc2VyKXtcbiAgICBpZighY2hvb3Nlcil7IGNob29zZXIgPSBmdW5jdGlvbiAoa2V5LCBwcmVzKXsgcmV0dXJuIHByZXMgfSB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgcmV0dXJuIGNob29zZXIoa2V5LCBwcmVzZW5jZSlcbiAgICB9KVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIHN0YXRpYyBtYXAob2JqLCBmdW5jKXtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoa2V5ID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICBzdGF0aWMgY2xvbmUob2JqKXsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxufVxuIiwgIi8qIFRoZSBkZWZhdWx0IHNlcmlhbGl6ZXIgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBtZXNzYWdlcyAqL1xuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQge1xuICBIRUFERVJfTEVOR1RIOiAxLFxuICBNRVRBX0xFTkdUSDogNCxcbiAgS0lORFM6IHtwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyfSxcblxuICBlbmNvZGUobXNnLCBjYWxsYmFjayl7XG4gICAgaWYobXNnLnBheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeUVuY29kZShtc2cpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF5bG9hZCA9IFttc2cuam9pbl9yZWYsIG1zZy5yZWYsIG1zZy50b3BpYywgbXNnLmV2ZW50LCBtc2cucGF5bG9hZF1cbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKXtcbiAgICBpZihyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZClcbiAgICAgIHJldHVybiBjYWxsYmFjayh7am9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGJpbmFyeUVuY29kZShtZXNzYWdlKXtcbiAgICBsZXQge2pvaW5fcmVmLCByZWYsIGV2ZW50LCB0b3BpYywgcGF5bG9hZH0gPSBtZXNzYWdlXG4gICAgbGV0IG1ldGFMZW5ndGggPSB0aGlzLk1FVEFfTEVOR1RIICsgam9pbl9yZWYubGVuZ3RoICsgcmVmLmxlbmd0aCArIHRvcGljLmxlbmd0aCArIGV2ZW50Lmxlbmd0aFxuICAgIGxldCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aClcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIpXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCkgLy8ga2luZFxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5fcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCByZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBldmVudC5sZW5ndGgpXG4gICAgQXJyYXkuZnJvbShqb2luX3JlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20ocmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbSh0b3BpYywgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20oZXZlbnQsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyXG4gIH0sXG5cbiAgYmluYXJ5RGVjb2RlKGJ1ZmZlcil7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGxldCBraW5kID0gdmlldy5nZXRVaW50OCgwKVxuICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDogcmV0dXJuIHRoaXMuZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMucmVwbHk6IHJldHVybiB0aGlzLmRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5icm9hZGNhc3Q6IHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIIC0gMSAvLyBwdXNoZXMgaGF2ZSBubyByZWZcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH0sXG5cbiAgZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCg0KVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgcmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgcmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIGxldCBwYXlsb2FkID0ge3N0YXR1czogZXZlbnQsIHJlc3BvbnNlOiBkYXRhfVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogcmVmLCB0b3BpYzogdG9waWMsIGV2ZW50OiBDSEFOTkVMX0VWRU5UUy5yZXBseSwgcGF5bG9hZDogcGF5bG9hZH1cbiAgfSxcblxuICBkZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiB7am9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIHBoeFdpbmRvdyxcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIERFRkFVTFRfVElNRU9VVCxcbiAgREVGQVVMVF9WU04sXG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIFdTX0NMT1NFX05PUk1BTFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9zdXJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5pbXBvcnQgQ2hhbm5lbCBmcm9tIFwiLi9jaGFubmVsXCJcbmltcG9ydCBMb25nUG9sbCBmcm9tIFwiLi9sb25ncG9sbFwiXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tIFwiLi9zZXJpYWxpemVyXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKiBJbml0aWFsaXplcyB0aGUgU29ja2V0ICpcbiAqXG4gKiBGb3IgSUU4IHN1cHBvcnQgdXNlIGFuIEVTNS1zaGltIChodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9zb2NrZXRcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudHJhbnNwb3J0XSAtIFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQgb3IgUGhvZW5peC5Mb25nUG9sbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBXZWJTb2NrZXQgd2l0aCBhdXRvbWF0aWMgTG9uZ1BvbGwgZmFsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5lbmNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OIGVuY29kZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZGVjb2RlXSAtIFRoZSBmdW5jdGlvbiB0byBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gSlNPTjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04ucGFyc2UocGF5bG9hZCkpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dF0gLSBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gKlxuICogRGVmYXVsdHMgYERFRkFVTFRfVElNRU9VVGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWFydGJlYXRJbnRlcnZhbE1zXSAtIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZWNvbm5lY3RBZnRlck1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjXG4gKiByZWpvaW4gaW50ZXJ2YWwgZm9yIGluZGl2aWR1YWwgY2hhbm5lbHMuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5sb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbihraW5kLCBtc2csIGRhdGEpIHtcbiAqICAgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMubG9uZ3BvbGxlclRpbWVvdXRdIC0gVGhlIG1heGltdW0gdGltZW91dCBvZiBhIGxvbmcgcG9sbCBBSkFYIHJlcXVlc3QuXG4gKlxuICogRGVmYXVsdHMgdG8gMjBzIChkb3VibGUgdGhlIHNlcnZlciBsb25nIHBvbGwgdGltZXIpLlxuICpcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluYXJ5VHlwZV0gLSBUaGUgYmluYXJ5IHR5cGUgdG8gdXNlIGZvciBiaW5hcnkgV2ViU29ja2V0IGZyYW1lcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBcImFycmF5YnVmZmVyXCJcbiAqXG4gKiBAcGFyYW0ge3Zzbn0gW29wdHMudnNuXSAtIFRoZSBzZXJpYWxpemVyJ3MgcHJvdG9jb2wgdmVyc2lvbiB0byBzZW5kIG9uIGNvbm5lY3QuXG4gKlxuICogRGVmYXVsdHMgdG8gREVGQVVMVF9WU04uXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29ja2V0IHtcbiAgY29uc3RydWN0b3IoZW5kUG9pbnQsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtvcGVuOiBbXSwgY2xvc2U6IFtdLCBlcnJvcjogW10sIG1lc3NhZ2U6IFtdfVxuICAgIHRoaXMuY2hhbm5lbHMgPSBbXVxuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5yZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVFxuICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbFxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDBcbiAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gU2VyaWFsaXplci5lbmNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuZGVmYXVsdERlY29kZXIgPSBTZXJpYWxpemVyLmRlY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiXG4gICAgdGhpcy5jb25uZWN0Q2xvY2sgPSAxXG4gICAgaWYodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfVxuICAgIGxldCBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgIGlmKHBoeFdpbmRvdyAmJiBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSB0aGlzLmNvbm5lY3RDbG9ja1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBfZSA9PiB7XG4gICAgICAgIGlmKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKXtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzMDAwMFxuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWpvaW5BZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVqb2luQWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVjb25uZWN0QWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IG51bGxcbiAgICB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0ID0gb3B0cy5sb25ncG9sbGVyVGltZW91dCB8fCAyMDAwMFxuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YFxuICAgIHRoaXMudnNuID0gb3B0cy52c24gfHwgREVGQVVMVF9WU05cbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5jb25uZWN0KCkpXG4gICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuZCByZXBsYWNlcyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdUcmFuc3BvcnQgLSBUaGUgbmV3IHRyYW5zcG9ydCBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICAgKlxuICAgKi9cbiAgcmVwbGFjZVRyYW5zcG9ydChuZXdUcmFuc3BvcnQpe1xuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgdGhpcy50cmFuc3BvcnQgPSBuZXdUcmFuc3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzb2NrZXQgcHJvdG9jb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHByb3RvY29sKCl7IHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLykgPyBcIndzc1wiIDogXCJ3c1wiIH1cblxuICAvKipcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmVkIHNvY2tldCB1cmxcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuZFBvaW50VVJMKCl7XG4gICAgbGV0IHVyaSA9IEFqYXguYXBwZW5kUGFyYW1zKFxuICAgICAgQWpheC5hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgdGhpcy5wYXJhbXMoKSksIHt2c246IHRoaXMudnNufSlcbiAgICBpZih1cmkuY2hhckF0KDApICE9PSBcIi9cIil7IHJldHVybiB1cmkgfVxuICAgIGlmKHVyaS5jaGFyQXQoMSkgPT09IFwiL1wiKXsgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06JHt1cml9YCB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfTovLyR7bG9jYXRpb24uaG9zdH0ke3VyaX1gXG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldFxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzIGZvciB2YWxpZCBzdGF0dXMgY29kZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHNvY2tldCBpcyBkaXNjb25uZWN0ZWQuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gY29kZSAtIEEgc3RhdHVzIGNvZGUgZm9yIGRpc2Nvbm5lY3Rpb24gKE9wdGlvbmFsKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIEEgdGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgcmVhc29uIHRvIGRpc2Nvbm5lY3QuIChPcHRpb25hbClcbiAgICovXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2ssIGNvZGUsIHJlYXNvbil7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWVcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB0aGlzLnRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbXMgdG8gc2VuZCB3aGVuIGNvbm5lY3RpbmcsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogdXNlclRva2VufWBcbiAgICpcbiAgICogUGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkOyBwYXNzIHRoZW0gaW4gdGhlIFNvY2tldCBjb25zdHJ1Y3RvciBpbnN0ZWFkOlxuICAgKiBgbmV3IFNvY2tldChcIi9zb2NrZXRcIiwge3BhcmFtczoge3VzZXJfaWQ6IHVzZXJUb2tlbn19KWAuXG4gICAqL1xuICBjb25uZWN0KHBhcmFtcyl7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNvbm5PcGVuKCl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zKytcbiAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy5yZXNldEhlYXJ0YmVhdCgpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBoZWFydGJlYXRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpeyB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImhlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uXCIpIH1cbiAgICAgIHRoaXMuYWJub3JtYWxDbG9zZShcImhlYXJ0YmVhdCB0aW1lb3V0XCIpXG4gICAgfVxuICB9XG5cbiAgcmVzZXRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICBpZighdGhpcy5jb25uKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZSgoKSA9PiB7XG4gICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICBpZihjb2RlKXsgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiB8fCBcIlwiKSB9IGVsc2UgeyB0aGlzLmNvbm4uY2xvc2UoKSB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZCgoKSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgb25Db25uQ2xvc2UoZXZlbnQpe1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIGlmKCF0aGlzLmNsb3NlV2FzQ2xlYW4gJiYgY2xvc2VDb2RlICE9PSAxMDAwKXtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKGV2ZW50KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Db25uRXJyb3IoZXJyb3Ipe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGVycm9yKVxuICAgIGxldCB0cmFuc3BvcnRCZWZvcmUgPSB0aGlzLnRyYW5zcG9ydFxuICAgIGxldCBlc3RhYmxpc2hlZEJlZm9yZSA9IHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uc1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgdHJhbnNwb3J0QmVmb3JlLCBlc3RhYmxpc2hlZEJlZm9yZSlcbiAgICB9KVxuICAgIGlmKHRyYW5zcG9ydEJlZm9yZSA9PT0gdGhpcy50cmFuc3BvcnQgfHwgZXN0YWJsaXNoZWRCZWZvcmUgPiAwKXtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyQ2hhbkVycm9yKCl7XG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgaWYoIShjaGFubmVsLmlzRXJyb3JlZCgpIHx8IGNoYW5uZWwuaXNMZWF2aW5nKCkgfHwgY2hhbm5lbC5pc0Nsb3NlZCgpKSl7XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25uZWN0aW9uU3RhdGUoKXtcbiAgICBzd2l0Y2godGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKXtcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOiByZXR1cm4gXCJjb25uZWN0aW5nXCJcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOiByZXR1cm4gXCJvcGVuXCJcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOiByZXR1cm4gXCJjbG9zaW5nXCJcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcImNsb3NlZFwiXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IFwib3BlblwiIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtDaGFubmVsfVxuICAgKi9cbiAgcmVtb3ZlKGNoYW5uZWwpe1xuICAgIHRoaXMub2ZmKGNoYW5uZWwuc3RhdGVDaGFuZ2VSZWZzKVxuICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihjID0+IGMuam9pblJlZigpICE9PSBjaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgIHJlZ2lzdHJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7cmVmc30gLSBsaXN0IG9mIHJlZnMgcmV0dXJuZWQgYnkgY2FsbHMgdG9cbiAgICogICAgICAgICAgICAgICAgIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgXG4gICAqL1xuICBvZmYocmVmcyl7XG4gICAgZm9yKGxldCBrZXkgaW4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyl7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0uZmlsdGVyKChbcmVmXSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVmcy5pbmRleE9mKHJlZikgPT09IC0xXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBuZXcgY2hhbm5lbCBmb3IgdGhlIGdpdmVuIHRvcGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhblBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtDaGFubmVsfVxuICAgKi9cbiAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KXtcbiAgICBsZXQgY2hhbiA9IG5ldyBDaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zLCB0aGlzKVxuICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKVxuICAgIHJldHVybiBjaGFuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIHB1c2goZGF0YSl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBkYXRhXG4gICAgICB0aGlzLmxvZyhcInB1c2hcIiwgYCR7dG9waWN9ICR7ZXZlbnR9ICgke2pvaW5fcmVmfSwgJHtyZWZ9KWAsIHBheWxvYWQpXG4gICAgfVxuXG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaCgoKSA9PiB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBtYWtlUmVmKCl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMVxuICAgIGlmKG5ld1JlZiA9PT0gdGhpcy5yZWYpeyB0aGlzLnJlZiA9IDAgfSBlbHNlIHsgdGhpcy5yZWYgPSBuZXdSZWYgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIHNlbmRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgJiYgIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnB1c2goe3RvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZn0pXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oZWFydGJlYXRUaW1lb3V0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIGFibm9ybWFsQ2xvc2UocmVhc29uKXtcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7IHRoaXMuY29ubi5jbG9zZShXU19DTE9TRV9OT1JNQUwsIHJlYXNvbikgfVxuICB9XG5cbiAgZmx1c2hTZW5kQnVmZmVyKCl7XG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSl7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCBtc2cgPT4ge1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gbXNnXG4gICAgICBpZihyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwicmVjZWl2ZVwiLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCBcIlwifSAke3RvcGljfSAke2V2ZW50fSAke3JlZiAmJiBcIihcIiArIHJlZiArIFwiKVwiIHx8IFwiXCJ9YCwgcGF5bG9hZClcblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXVxuICAgICAgICBpZighY2hhbm5lbC5pc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5fcmVmKSl7IGNvbnRpbnVlIH1cbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXVxuICAgICAgICBjYWxsYmFjayhtc2cpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGxlYXZlT3BlblRvcGljKHRvcGljKXtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLmlzSm9pbmVkKCkgfHwgYy5pc0pvaW5pbmcoKSkpXG4gICAgaWYoZHVwQ2hhbm5lbCl7XG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgfVxufVxuIiwgIlxuZXhwb3J0IGNvbnN0IENPTlNFQ1VUSVZFX1JFTE9BRFMgPSBcImNvbnNlY3V0aXZlLXJlbG9hZHNcIlxuZXhwb3J0IGNvbnN0IE1BWF9SRUxPQURTID0gMTBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01JTiA9IDEwMDBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01BWCA9IDMwMDBcbmV4cG9ydCBjb25zdCBGQUlMU0FGRV9KSVRURVIgPSAzMDAwMFxuZXhwb3J0IGNvbnN0IFBIWF9FVkVOVF9DTEFTU0VTID0gW1xuICBcInBoeC1jbGljay1sb2FkaW5nXCIsIFwicGh4LWNoYW5nZS1sb2FkaW5nXCIsIFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIsXG4gIFwicGh4LWtleWRvd24tbG9hZGluZ1wiLCBcInBoeC1rZXl1cC1sb2FkaW5nXCIsIFwicGh4LWJsdXItbG9hZGluZ1wiLCBcInBoeC1mb2N1cy1sb2FkaW5nXCJcbl1cbmV4cG9ydCBjb25zdCBQSFhfQ09NUE9ORU5UID0gXCJkYXRhLXBoeC1jb21wb25lbnRcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0xJTksgPSBcImRhdGEtcGh4LWxpbmtcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19TVEFUSUMgPSBcInRyYWNrLXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX0xJTktfU1RBVEUgPSBcImRhdGEtcGh4LWxpbmstc3RhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUYgPSBcImRhdGEtcGh4LXJlZlwiXG5leHBvcnQgY29uc3QgUEhYX1JFRl9TUkMgPSBcImRhdGEtcGh4LXJlZi1zcmNcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19VUExPQURTID0gXCJ0cmFjay11cGxvYWRzXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBMT0FEX1JFRiA9IFwiZGF0YS1waHgtdXBsb2FkLXJlZlwiXG5leHBvcnQgY29uc3QgUEhYX1BSRUZMSUdIVEVEX1JFRlMgPSBcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9ET05FX1JFRlMgPSBcImRhdGEtcGh4LWRvbmUtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0RST1BfVEFSR0VUID0gXCJkcm9wLXRhcmdldFwiXG5leHBvcnQgY29uc3QgUEhYX0FDVElWRV9FTlRSWV9SRUZTID0gXCJkYXRhLXBoeC1hY3RpdmUtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfRklMRV9VUERBVEVEID0gXCJwaHg6bGl2ZS1maWxlOnVwZGF0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TS0lQID0gXCJkYXRhLXBoeC1za2lwXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJVTkUgPSBcImRhdGEtcGh4LXBydW5lXCJcbmV4cG9ydCBjb25zdCBQSFhfUEFHRV9MT0FESU5HID0gXCJwYWdlLWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9DT05ORUNURURfQ0xBU1MgPSBcInBoeC1jb25uZWN0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNDT05ORUNURURfQ0xBU1MgPSBcInBoeC1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfTk9fRkVFREJBQ0tfQ0xBU1MgPSBcInBoeC1uby1mZWVkYmFja1wiXG5leHBvcnQgY29uc3QgUEhYX0VSUk9SX0NMQVNTID0gXCJwaHgtZXJyb3JcIlxuZXhwb3J0IGNvbnN0IFBIWF9QQVJFTlRfSUQgPSBcImRhdGEtcGh4LXBhcmVudC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX01BSU4gPSBcImRhdGEtcGh4LW1haW5cIlxuZXhwb3J0IGNvbnN0IFBIWF9ST09UX0lEID0gXCJkYXRhLXBoeC1yb290LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJJR0dFUl9BQ1RJT04gPSBcInRyaWdnZXItYWN0aW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfRkVFREJBQ0tfRk9SID0gXCJmZWVkYmFjay1mb3JcIlxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfRk9DVVNFRCA9IFwicGh4LWhhcy1mb2N1c2VkXCJcbmV4cG9ydCBjb25zdCBGT0NVU0FCTEVfSU5QVVRTID0gW1widGV4dFwiLCBcInRleHRhcmVhXCIsIFwibnVtYmVyXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJjb2xvclwiLCBcInJhbmdlXCJdXG5leHBvcnQgY29uc3QgQ0hFQ0tBQkxFX0lOUFVUUyA9IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl1cbmV4cG9ydCBjb25zdCBQSFhfSEFTX1NVQk1JVFRFRCA9IFwicGh4LWhhcy1zdWJtaXR0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TRVNTSU9OID0gXCJkYXRhLXBoeC1zZXNzaW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfVklFV19TRUxFQ1RPUiA9IGBbJHtQSFhfU0VTU0lPTn1dYFxuZXhwb3J0IGNvbnN0IFBIWF9TVElDS1kgPSBcImRhdGEtcGh4LXN0aWNreVwiXG5leHBvcnQgY29uc3QgUEhYX1NUQVRJQyA9IFwiZGF0YS1waHgtc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRUQgPSBcImRhdGEtcGh4LWRpc2FibGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIID0gXCJkaXNhYmxlLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9IT09LID0gXCJob29rXCJcbmV4cG9ydCBjb25zdCBQSFhfREVCT1VOQ0UgPSBcImRlYm91bmNlXCJcbmV4cG9ydCBjb25zdCBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBEQVRFID0gXCJ1cGRhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9LRVkgPSBcImtleVwiXG5leHBvcnQgY29uc3QgUEhYX1BSSVZBVEUgPSBcInBoeFByaXZhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiXG5leHBvcnQgY29uc3QgUEhYX0xWX0RFQlVHID0gXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9QUk9GSUxFID0gXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiXG5leHBvcnQgY29uc3QgUEhYX1BST0dSRVNTID0gXCJwcm9ncmVzc1wiXG5leHBvcnQgY29uc3QgTE9BREVSX1RJTUVPVVQgPSAxXG5leHBvcnQgY29uc3QgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCA9IDIwMFxuZXhwb3J0IGNvbnN0IEJJTkRJTkdfUFJFRklYID0gXCJwaHgtXCJcbmV4cG9ydCBjb25zdCBQVVNIX1RJTUVPVVQgPSAzMDAwMFxuZXhwb3J0IGNvbnN0IExJTktfSEVBREVSID0gXCJ4LXJlcXVlc3RlZC13aXRoXCJcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9VUkxfSEVBREVSID0gXCJ4LXJlc3BvbnNlLXVybFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfVFJJR0dFUiA9IFwiZGVib3VuY2UtdHJpZ2dlclwiXG5leHBvcnQgY29uc3QgVEhST1RUTEVEID0gXCJ0aHJvdHRsZWRcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1BSRVZfS0VZID0gXCJkZWJvdW5jZS1wcmV2LWtleVwiXG5leHBvcnQgY29uc3QgREVGQVVMVFMgPSB7XG4gIGRlYm91bmNlOiAzMDAsXG4gIHRocm90dGxlOiAzMDBcbn1cblxuLy8gUmVuZGVyZWRcbmV4cG9ydCBjb25zdCBEWU5BTUlDUyA9IFwiZFwiXG5leHBvcnQgY29uc3QgU1RBVElDID0gXCJzXCJcbmV4cG9ydCBjb25zdCBDT01QT05FTlRTID0gXCJjXCJcbmV4cG9ydCBjb25zdCBFVkVOVFMgPSBcImVcIlxuZXhwb3J0IGNvbnN0IFJFUExZID0gXCJyXCJcbmV4cG9ydCBjb25zdCBUSVRMRSA9IFwidFwiXG5leHBvcnQgY29uc3QgVEVNUExBVEVTID0gXCJwXCJcbiIsICJpbXBvcnQge1xuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudHJ5VXBsb2FkZXIge1xuICBjb25zdHJ1Y3RvcihlbnRyeSwgY2h1bmtTaXplLCBsaXZlU29ja2V0KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG4gICAgdGhpcy5lbnRyeSA9IGVudHJ5XG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemVcbiAgICB0aGlzLmNodW5rVGltZXIgPSBudWxsXG4gICAgdGhpcy51cGxvYWRDaGFubmVsID0gbGl2ZVNvY2tldC5jaGFubmVsKGBsdnU6JHtlbnRyeS5yZWZ9YCwge3Rva2VuOiBlbnRyeS5tZXRhZGF0YSgpfSlcbiAgfVxuXG4gIGVycm9yKHJlYXNvbil7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2h1bmtUaW1lcilcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKVxuICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKVxuICB9XG5cbiAgdXBsb2FkKCl7XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwuam9pbigpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIF9kYXRhID0+IHRoaXMucmVhZE5leHRDaHVuaygpKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCByZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLm9mZnNldCA+PSB0aGlzLmVudHJ5LmZpbGUuc2l6ZSB9XG5cbiAgcmVhZE5leHRDaHVuaygpe1xuICAgIGxldCByZWFkZXIgPSBuZXcgd2luZG93LkZpbGVSZWFkZXIoKVxuICAgIGxldCBibG9iID0gdGhpcy5lbnRyeS5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmNodW5rU2l6ZSArIHRoaXMub2Zmc2V0KVxuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgaWYoZS50YXJnZXQuZXJyb3IgPT09IG51bGwpe1xuICAgICAgICB0aGlzLm9mZnNldCArPSBlLnRhcmdldC5yZXN1bHQuYnl0ZUxlbmd0aFxuICAgICAgICB0aGlzLnB1c2hDaHVuayhlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9nRXJyb3IoXCJSZWFkIGVycm9yOiBcIiArIGUudGFyZ2V0LmVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgfVxuXG4gIHB1c2hDaHVuayhjaHVuayl7XG4gICAgaWYoIXRoaXMudXBsb2FkQ2hhbm5lbC5pc0pvaW5lZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnVwbG9hZENoYW5uZWwucHVzaChcImNodW5rXCIsIGNodW5rKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3MoKHRoaXMub2Zmc2V0IC8gdGhpcy5lbnRyeS5maWxlLnNpemUpICogMTAwKVxuICAgICAgICBpZighdGhpcy5pc0RvbmUoKSl7XG4gICAgICAgICAgdGhpcy5jaHVua1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSwgdGhpcy5saXZlU29ja2V0LmdldExhdGVuY3lTaW0oKSB8fCAwKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX1ZJRVdfU0VMRUNUT1Jcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEVudHJ5VXBsb2FkZXIgZnJvbSBcIi4vZW50cnlfdXBsb2FkZXJcIlxuXG5leHBvcnQgbGV0IGxvZ0Vycm9yID0gKG1zZywgb2JqKSA9PiBjb25zb2xlLmVycm9yICYmIGNvbnNvbGUuZXJyb3IobXNnLCBvYmopXG5cbmV4cG9ydCBsZXQgaXNDaWQgPSAoY2lkKSA9PiB7XG4gIGxldCB0eXBlID0gdHlwZW9mKGNpZClcbiAgcmV0dXJuIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgL14oMHxbMS05XVxcZCopJC8udGVzdChjaWQpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0RHVwbGljYXRlSWRzKCl7XG4gIGxldCBpZHMgPSBuZXcgU2V0KClcbiAgbGV0IGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIipbaWRdXCIpXG4gIGZvcihsZXQgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICBpZihpZHMuaGFzKGVsZW1zW2ldLmlkKSl7XG4gICAgICBjb25zb2xlLmVycm9yKGBNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6ICR7ZWxlbXNbaV0uaWR9LiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLmApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkcy5hZGQoZWxlbXNbaV0uaWQpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBsZXQgZGVidWcgPSAodmlldywga2luZCwgbXNnLCBvYmopID0+IHtcbiAgaWYodmlldy5saXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpe1xuICAgIGNvbnNvbGUubG9nKGAke3ZpZXcuaWR9ICR7a2luZH06ICR7bXNnfSAtIGAsIG9iailcbiAgfVxufVxuXG4vLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGxldCBjbG9zdXJlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogZnVuY3Rpb24gKCl7IHJldHVybiB2YWwgfVxuXG5leHBvcnQgbGV0IGNsb25lID0gKG9iaikgPT4geyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG5cbmV4cG9ydCBsZXQgY2xvc2VzdFBoeEJpbmRpbmcgPSAoZWwsIGJpbmRpbmcsIGJvcmRlckVsKSA9PiB7XG4gIGRvIHtcbiAgICBpZihlbC5tYXRjaGVzKGBbJHtiaW5kaW5nfV1gKSl7IHJldHVybiBlbCB9XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGVcbiAgfSB3aGlsZShlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiAhKChib3JkZXJFbCAmJiBib3JkZXJFbC5pc1NhbWVOb2RlKGVsKSkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgbGV0IGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSlcbn1cblxuZXhwb3J0IGxldCBpc0VxdWFsT2JqID0gKG9iajEsIG9iajIpID0+IEpTT04uc3RyaW5naWZ5KG9iajEpID09PSBKU09OLnN0cmluZ2lmeShvYmoyKVxuXG5leHBvcnQgbGV0IGlzRW1wdHkgPSAob2JqKSA9PiB7XG4gIGZvcihsZXQgeCBpbiBvYmopeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgbGV0IG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpXG5cbmV4cG9ydCBsZXQgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24gKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpe1xuICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLmNodW5rX3NpemUsIGxpdmVTb2NrZXQpXG4gICAgZW50cnlVcGxvYWRlci51cGxvYWQoKVxuICB9KVxufVxuIiwgImxldCBCcm93c2VyID0ge1xuICBjYW5QdXNoU3RhdGUoKXsgcmV0dXJuICh0eXBlb2YgKGhpc3RvcnkucHVzaFN0YXRlKSAhPT0gXCJ1bmRlZmluZWRcIikgfSxcblxuICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKVxuICB9LFxuXG4gIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpe1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpXG4gICAgcmV0dXJuIG5ld1ZhbFxuICB9LFxuXG4gIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSlcbiAgfSxcblxuICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0sXG5cbiAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKXtcbiAgICBpZih0aGlzLmNhblB1c2hTdGF0ZSgpKXtcbiAgICAgIGlmKHRvICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZil7XG4gICAgICAgIGlmKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpe1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHJlZGlyZWN0aW5nIHN0b3JlIHRoZSBjdXJyZW50IHNjcm9sbFkgZm9yIHRoZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUuXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge31cbiAgICAgICAgICBjdXJyZW50U3RhdGUuc2Nyb2xsID0gbWV0YS5zY3JvbGxcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG1ldGEuc2Nyb2xsIC8vIE9ubHkgc3RvcmUgdGhlIHNjcm9sbCBpbiB0aGUgcmVkaXJlY3QgY2FzZS5cbiAgICAgICAgaGlzdG9yeVtraW5kICsgXCJTdGF0ZVwiXShtZXRhLCBcIlwiLCB0byB8fCBudWxsKSAvLyBJRSB3aWxsIGNvZXJjZSB1bmRlZmluZWQgdG8gc3RyaW5nXG4gICAgICAgIGxldCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaClcblxuICAgICAgICBpZihoYXNoRWwpe1xuICAgICAgICAgIGhhc2hFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH0gZWxzZSBpZihtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVkaXJlY3QodG8pXG4gICAgfVxuICB9LFxuXG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSl7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX1gXG4gIH0sXG5cbiAgZ2V0Q29va2llKG5hbWUpe1xuICAgIHJldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKGAoPzooPzpefC4qO1xccyopJHtuYW1lfVxccypcXD1cXHMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpXG4gIH0sXG5cbiAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKXtcbiAgICBpZihmbGFzaCl7IEJyb3dzZXIuc2V0Q29va2llKFwiX19waG9lbml4X2ZsYXNoX19cIiwgZmxhc2ggKyBcIjsgbWF4LWFnZT02MDAwMDsgcGF0aD0vXCIpIH1cbiAgICB3aW5kb3cubG9jYXRpb24gPSB0b1VSTFxuICB9LFxuXG4gIGxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KXsgcmV0dXJuIGAke25hbWVzcGFjZX0tJHtzdWJrZXl9YCB9LFxuXG4gIGdldEhhc2hUYXJnZXRFbChtYXliZUhhc2gpe1xuICAgIGxldCBoYXNoID0gbWF5YmVIYXNoLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpXG4gICAgaWYoaGFzaCA9PT0gXCJcIil7IHJldHVybiB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGFbbmFtZT1cIiR7aGFzaH1cIl1gKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJcbiIsICJpbXBvcnQge1xuICBDSEVDS0FCTEVfSU5QVVRTLFxuICBERUJPVU5DRV9QUkVWX0tFWSxcbiAgREVCT1VOQ0VfVFJJR0dFUixcbiAgRk9DVVNBQkxFX0lOUFVUUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0VWRU5UX0NMQVNTRVMsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9NQUlOLFxuICBQSFhfTk9fRkVFREJBQ0tfQ0xBU1MsXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUklWQVRFLFxuICBQSFhfUkVGLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9TVElDS1ksXG4gIFRIUk9UVExFRFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmxldCBET00gPSB7XG4gIGJ5SWQoaWQpeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGxvZ0Vycm9yKGBubyBpZCBmb3VuZCBmb3IgJHtpZH1gKSB9LFxuXG4gIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpe1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgIGlmKGVsLmNsYXNzTGlzdC5sZW5ndGggPT09IDApeyBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKSB9XG4gIH0sXG5cbiAgYWxsKG5vZGUsIHF1ZXJ5LCBjYWxsYmFjayl7XG4gICAgaWYoIW5vZGUpeyByZXR1cm4gW10gfVxuICAgIGxldCBhcnJheSA9IEFycmF5LmZyb20obm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBhcnJheS5mb3JFYWNoKGNhbGxiYWNrKSA6IGFycmF5XG4gIH0sXG5cbiAgY2hpbGROb2RlTGVuZ3RoKGh0bWwpe1xuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudFxuICB9LFxuXG4gIGlzVXBsb2FkSW5wdXQoZWwpeyByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbCB9LFxuXG4gIGZpbmRVcGxvYWRJbnB1dHMobm9kZSl7IHJldHVybiB0aGlzLmFsbChub2RlLCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dYCkgfSxcblxuICBmaW5kQ29tcG9uZW50Tm9kZUxpc3Qobm9kZSwgY2lkKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdYCksIG5vZGUpXG4gIH0sXG5cbiAgaXNQaHhEZXN0cm95ZWQobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuaWQgJiYgRE9NLnByaXZhdGUobm9kZSwgXCJkZXN0cm95ZWRcIikgPyB0cnVlIDogZmFsc2VcbiAgfSxcblxuICBtYXJrUGh4Q2hpbGREZXN0cm95ZWQoZWwpe1xuICAgIGlmKHRoaXMuaXNQaHhDaGlsZChlbCkpeyBlbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIFwiXCIpIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiZGVzdHJveWVkXCIsIHRydWUpXG4gIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCBwYXJlbnRJZCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0aGlzLmZpbmRQaHhDaGlsZHJlbih0ZW1wbGF0ZS5jb250ZW50LCBwYXJlbnRJZClcbiAgfSxcblxuICBpc0lnbm9yZWQoZWwsIHBoeFVwZGF0ZSl7XG4gICAgcmV0dXJuIChlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpID09PSBcImlnbm9yZVwiXG4gIH0sXG5cbiAgaXNQaHhVcGRhdGUoZWwsIHBoeFVwZGF0ZSwgdXBkYXRlVHlwZXMpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgdXBkYXRlVHlwZXMuaW5kZXhPZihlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkgPj0gMFxuICB9LFxuXG4gIGZpbmRQaHhTdGlja3koZWwpeyByZXR1cm4gdGhpcy5hbGwoZWwsIGBbJHtQSFhfU1RJQ0tZfV1gKSB9LFxuXG4gIGZpbmRQaHhDaGlsZHJlbihlbCwgcGFyZW50SWQpe1xuICAgIHJldHVybiB0aGlzLmFsbChlbCwgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9WyR7UEhYX1BBUkVOVF9JRH09XCIke3BhcmVudElkfVwiXWApXG4gIH0sXG5cbiAgZmluZFBhcmVudENJRHMobm9kZSwgY2lkcyl7XG4gICAgbGV0IGluaXRpYWwgPSBuZXcgU2V0KGNpZHMpXG4gICAgcmV0dXJuIGNpZHMucmVkdWNlKChhY2MsIGNpZCkgPT4ge1xuICAgICAgbGV0IHNlbGVjdG9yID0gYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdIFske1BIWF9DT01QT05FTlR9XWBcblxuICAgICAgdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgc2VsZWN0b3IpLCBub2RlKVxuICAgICAgICAubWFwKGVsID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSkpXG4gICAgICAgIC5mb3JFYWNoKGNoaWxkQ0lEID0+IGFjYy5kZWxldGUoY2hpbGRDSUQpKVxuXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgaW5pdGlhbClcbiAgfSxcblxuICBmaWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcobm9kZXMsIHBhcmVudCl7XG4gICAgaWYocGFyZW50LnF1ZXJ5U2VsZWN0b3IoUEhYX1ZJRVdfU0VMRUNUT1IpKXtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoZWwgPT4gdGhpcy53aXRoaW5TYW1lTGl2ZVZpZXcoZWwsIHBhcmVudCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfSxcblxuICB3aXRoaW5TYW1lTGl2ZVZpZXcobm9kZSwgcGFyZW50KXtcbiAgICB3aGlsZShub2RlID0gbm9kZS5wYXJlbnROb2RlKXtcbiAgICAgIGlmKG5vZGUuaXNTYW1lTm9kZShwYXJlbnQpKXsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYobm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJpdmF0ZShlbCwga2V5KXsgcmV0dXJuIGVsW1BIWF9QUklWQVRFXSAmJiBlbFtQSFhfUFJJVkFURV1ba2V5XSB9LFxuXG4gIGRlbGV0ZVByaXZhdGUoZWwsIGtleSl7IGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgKGVsW1BIWF9QUklWQVRFXVtrZXldKSB9LFxuXG4gIHB1dFByaXZhdGUoZWwsIGtleSwgdmFsdWUpe1xuICAgIGlmKCFlbFtQSFhfUFJJVkFURV0peyBlbFtQSFhfUFJJVkFURV0gPSB7fSB9XG4gICAgZWxbUEhYX1BSSVZBVEVdW2tleV0gPSB2YWx1ZVxuICB9LFxuXG4gIHVwZGF0ZVByaXZhdGUoZWwsIGtleSwgZGVmYXVsdFZhbCwgdXBkYXRlRnVuYyl7XG4gICAgbGV0IGV4aXN0aW5nID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpXG4gICAgaWYoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhkZWZhdWx0VmFsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZXhpc3RpbmcpKVxuICAgIH1cbiAgfSxcblxuICBjb3B5UHJpdmF0ZXModGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtQSFhfUFJJVkFURV0pe1xuICAgICAgdGFyZ2V0W1BIWF9QUklWQVRFXSA9IHNvdXJjZVtQSFhfUFJJVkFURV1cbiAgICB9XG4gIH0sXG5cbiAgcHV0VGl0bGUoc3RyKXtcbiAgICBsZXQgdGl0bGVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0aXRsZVwiKVxuICAgIGxldCB7cHJlZml4LCBzdWZmaXh9ID0gdGl0bGVFbC5kYXRhc2V0XG4gICAgZG9jdW1lbnQudGl0bGUgPSBgJHtwcmVmaXggfHwgXCJcIn0ke3N0cn0ke3N1ZmZpeCB8fCBcIlwifWBcbiAgfSxcblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKXtcbiAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpXG4gICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKVxuICAgIGlmKGRlYm91bmNlID09PSBcIlwiKXsgZGVib3VuY2UgPSBkZWZhdWx0RGVib3VuY2UgfVxuICAgIGlmKHRocm90dGxlID09PSBcIlwiKXsgdGhyb3R0bGUgPSBkZWZhdWx0VGhyb3R0bGUgfVxuICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlXG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgbnVsbDogcmV0dXJuIGNhbGxiYWNrKClcblxuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImRlYm91bmNlLWJsdXJcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IGNhbGxiYWNrKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpXG4gICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKVxuICAgICAgICBpZihpc05hTih0aW1lb3V0KSl7IHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKSB9XG4gICAgICAgIGlmKHRocm90dGxlKXtcbiAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlXG4gICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIpe1xuICAgICAgICAgICAgbGV0IHByZXZLZXkgPSB0aGlzLnByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSwgZXZlbnQua2V5KVxuICAgICAgICAgICAgbmV3S2V5RG93biA9IHByZXZLZXkgIT09IGV2ZW50LmtleVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFuZXdLZXlEb3duICYmIHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHRydWUpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSwgdGltZW91dClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSwgdGltZW91dClcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtXG4gICAgICAgIGlmKGZvcm0gJiYgdGhpcy5vbmNlKGZvcm0sIFwiYmluZC1kZWJvdW5jZVwiKSl7XG4gICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsICgpID0+IHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oKG5ldyBGb3JtRGF0YShmb3JtKSkuZW50cmllcygpLCAoW25hbWVdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYClcbiAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUilcbiAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSlcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmlnZ2VyQ3ljbGUoZWwsIGtleSwgY3VycmVudEN5Y2xlKXtcbiAgICBsZXQgW2N5Y2xlLCB0cmlnZ2VyXSA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKCFjdXJyZW50Q3ljbGUpeyBjdXJyZW50Q3ljbGUgPSBjeWNsZSB9XG4gICAgaWYoY3VycmVudEN5Y2xlID09PSBjeWNsZSl7XG4gICAgICB0aGlzLmluY0N5Y2xlKGVsLCBrZXkpXG4gICAgICB0cmlnZ2VyKClcbiAgICB9XG4gIH0sXG5cbiAgb25jZShlbCwga2V5KXtcbiAgICBpZih0aGlzLnByaXZhdGUoZWwsIGtleSkgPT09IHRydWUpeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB0cnVlKVxuICAgIHJldHVybiB0cnVlXG4gIH0sXG5cbiAgaW5jQ3ljbGUoZWwsIGtleSwgdHJpZ2dlciA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdXG4gICAgY3VycmVudEN5Y2xlKytcbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pXG4gICAgcmV0dXJuIGN1cnJlbnRDeWNsZVxuICB9LFxuXG4gIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcil7XG4gICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0ZvcilcbiAgICAvLyBUT0RPOiBSZW1vdmUgaWQgbG9va3VwIGFmdGVyIHdlIHVwZGF0ZSBQaG9lbml4IHRvIHVzZSBpbnB1dF9uYW1lIGluc3RlYWQgb2YgaW5wdXRfaWRcbiAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKVxuICAgIGlmKCFpbnB1dCl7IHJldHVybiB9XG5cbiAgICBpZighKHRoaXMucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKSB8fCB0aGlzLnByaXZhdGUoaW5wdXQuZm9ybSwgUEhYX0hBU19TVUJNSVRURUQpKSl7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKFBIWF9OT19GRUVEQkFDS19DTEFTUylcbiAgICB9XG4gIH0sXG5cbiAgc2hvd0Vycm9yKGlucHV0RWwsIHBoeEZlZWRiYWNrRm9yKXtcbiAgICBpZihpbnB1dEVsLmlkIHx8IGlucHV0RWwubmFtZSl7XG4gICAgICB0aGlzLmFsbChpbnB1dEVsLmZvcm0sIGBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwuaWR9XCJdLCBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwubmFtZX1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhlbCwgUEhYX05PX0ZFRURCQUNLX0NMQVNTKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgaXNQaHhDaGlsZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRClcbiAgfSxcblxuICBpc1BoeFN0aWNreShub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NUSUNLWSkgIT09IG51bGxcbiAgfSxcblxuICBmaXJzdFBoeENoaWxkKGVsKXtcbiAgICByZXR1cm4gdGhpcy5pc1BoeENoaWxkKGVsKSA/IGVsIDogdGhpcy5hbGwoZWwsIGBbJHtQSFhfUEFSRU5UX0lEfV1gKVswXVxuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBldmVudFN0cmluZywgZGV0YWlsID0ge30pe1xuICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFN0cmluZywge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogZGV0YWlsfSlcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBjbG9uZU5vZGUobm9kZSwgaHRtbCl7XG4gICAgaWYodHlwZW9mIChodG1sKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXhjbHVkZSA9IG9wdHMuZXhjbHVkZSB8fCBbXVxuICAgIGxldCBpc0lnbm9yZWQgPSBvcHRzLmlzSWdub3JlZFxuICAgIGxldCBzb3VyY2VBdHRycyA9IHNvdXJjZS5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gc291cmNlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSBzb3VyY2VBdHRyc1tpXS5uYW1lXG4gICAgICBpZihleGNsdWRlLmluZGV4T2YobmFtZSkgPCAwKXsgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKSB9XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGlzSWdub3JlZCl7XG4gICAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSl7XG4gICAgLy8gc2tpcCBzZWxlY3RzIGJlY2F1c2UgRkYgd2lsbCByZXNldCBoaWdobGlnaHRlZCBpbmRleCBmb3IgYW55IHNldEF0dHJpYnV0ZVxuICAgIGlmKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKXsgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHtleGNlcHQ6IFtcInZhbHVlXCJdfSkgfVxuICAgIGlmKHNvdXJjZS5yZWFkT25seSl7XG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpXG4gICAgfVxuICB9LFxuXG4gIGhhc1NlbGVjdGlvblJhbmdlKGVsKXtcbiAgICByZXR1cm4gZWwuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgKGVsLnR5cGUgPT09IFwidGV4dFwiIHx8IGVsLnR5cGUgPT09IFwidGV4dGFyZWFcIilcbiAgfSxcblxuICByZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCl7XG4gICAgaWYoIURPTS5pc1RleHR1YWxJbnB1dChmb2N1c2VkKSl7IHJldHVybiB9XG4gICAgbGV0IHdhc0ZvY3VzZWQgPSBmb2N1c2VkLm1hdGNoZXMoXCI6Zm9jdXNcIilcbiAgICBpZihmb2N1c2VkLnJlYWRPbmx5KXsgZm9jdXNlZC5ibHVyKCkgfVxuICAgIGlmKCF3YXNGb2N1c2VkKXsgZm9jdXNlZC5mb2N1cygpIH1cbiAgICBpZih0aGlzLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpKXtcbiAgICAgIGZvY3VzZWQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZClcbiAgICB9XG4gIH0sXG5cbiAgaXNGb3JtSW5wdXQoZWwpeyByZXR1cm4gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLnRlc3QoZWwudGFnTmFtZSkgJiYgZWwudHlwZSAhPT0gXCJidXR0b25cIiB9LFxuXG4gIHN5bmNBdHRyc1RvUHJvcHMoZWwpe1xuICAgIGlmKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+PSAwKXtcbiAgICAgIGVsLmNoZWNrZWQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpICE9PSBudWxsXG4gICAgfVxuICB9LFxuXG4gIGlzVGV4dHVhbElucHV0KGVsKXsgcmV0dXJuIEZPQ1VTQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwIH0sXG5cbiAgaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFRyaWdnZXJFeHRlcm5hbCkgIT09IG51bGxcbiAgfSxcblxuICBzeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKXtcbiAgICBsZXQgcmVmID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfUkVGKVxuICAgIGlmKHJlZiA9PT0gbnVsbCl7IHJldHVybiB0cnVlIH1cbiAgICBsZXQgcmVmU3JjID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfUkVGX1NSQylcblxuICAgIGlmKERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpIHx8IGZyb21FbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpICE9PSBudWxsKXtcbiAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpeyBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KSB9XG4gICAgICBET00ucHV0UHJpdmF0ZShmcm9tRWwsIFBIWF9SRUYsIHRvRWwpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgICBmcm9tRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgJiYgdG9FbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgIH0pXG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCByZWYpXG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShQSFhfUkVGX1NSQywgcmVmU3JjKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW5DaGlsZE5vZGVzKGNvbnRhaW5lciwgcGh4VXBkYXRlKXtcbiAgICBpZihET00uaXNQaHhVcGRhdGUoY29udGFpbmVyLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgIGxldCB0b1JlbW92ZSA9IFtdXG4gICAgICBjb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgIGlmKCFjaGlsZE5vZGUuaWQpe1xuICAgICAgICAgIC8vIFNraXAgd2FybmluZyBpZiBpdCdzIGFuIGVtcHR5IHRleHQgbm9kZSAoZS5nLiBhIG5ldy1saW5lKVxuICAgICAgICAgIGxldCBpc0VtcHR5VGV4dE5vZGUgPSBjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSBcIlwiXG4gICAgICAgICAgaWYoIWlzRW1wdHlUZXh0Tm9kZSl7XG4gICAgICAgICAgICBsb2dFcnJvcihcIm9ubHkgSFRNTCBlbGVtZW50IHRhZ3Mgd2l0aCBhbiBpZCBhcmUgYWxsb3dlZCBpbnNpZGUgY29udGFpbmVycyB3aXRoIHBoeC11cGRhdGUuXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBgcmVtb3ZpbmcgaWxsZWdhbCBub2RlOiBcIiR7KGNoaWxkTm9kZS5vdXRlckhUTUwgfHwgY2hpbGROb2RlLm5vZGVWYWx1ZSkudHJpbSgpfVwiXFxuXFxuYClcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9SZW1vdmUucHVzaChjaGlsZE5vZGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGNoaWxkTm9kZSA9PiBjaGlsZE5vZGUucmVtb3ZlKCkpXG4gICAgfVxuICB9LFxuXG4gIHJlcGxhY2VSb290Q29udGFpbmVyKGNvbnRhaW5lciwgdGFnTmFtZSwgYXR0cnMpe1xuICAgIGxldCByZXRhaW5lZEF0dHJzID0gbmV3IFNldChbXCJpZFwiLCBQSFhfU0VTU0lPTiwgUEhYX1NUQVRJQywgUEhYX01BSU4sIFBIWF9ST09UX0lEXSlcbiAgICBpZihjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpe1xuICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuYXR0cmlidXRlcylcbiAgICAgICAgLmZpbHRlcihhdHRyID0+ICFyZXRhaW5lZEF0dHJzLmhhcyhhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpKVxuXG4gICAgICBPYmplY3Qua2V5cyhhdHRycylcbiAgICAgICAgLmZpbHRlcihuYW1lID0+ICFyZXRhaW5lZEF0dHJzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaChhdHRyID0+IGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKVxuXG4gICAgICByZXR1cm4gY29udGFpbmVyXG5cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGF0dHIgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpXG4gICAgICByZXRhaW5lZEF0dHJzLmZvckVhY2goYXR0ciA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cikpKVxuICAgICAgbmV3Q29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRhaW5lci5pbm5lckhUTUxcbiAgICAgIGNvbnRhaW5lci5yZXBsYWNlV2l0aChuZXdDb250YWluZXIpXG4gICAgICByZXR1cm4gbmV3Q29udGFpbmVyXG4gICAgfVxuICB9LFxuXG4gIGdldFN0aWNreShlbCwgbmFtZSwgZGVmYXVsdFZhbCl7XG4gICAgbGV0IG9wID0gKERPTS5wcml2YXRlKGVsLCBcInN0aWNreVwiKSB8fCBbXSkuZmluZCgoW2V4aXN0aW5nTmFtZSwgXSkgPT4gbmFtZSA9PT0gZXhpc3RpbmdOYW1lKVxuICAgIGlmKG9wKXtcbiAgICAgIGxldCBbX25hbWUsIF9vcCwgc3Rhc2hlZFJlc3VsdF0gPSBvcFxuICAgICAgcmV0dXJuIHN0YXNoZWRSZXN1bHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGVvZihkZWZhdWx0VmFsKSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbCgpIDogZGVmYXVsdFZhbFxuICAgIH1cbiAgfSxcblxuICBkZWxldGVTdGlja3koZWwsIG5hbWUpe1xuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICByZXR1cm4gb3BzLmZpbHRlcigoW2V4aXN0aW5nTmFtZSwgX10pID0+IGV4aXN0aW5nTmFtZSAhPT0gbmFtZSlcbiAgICB9KVxuICB9LFxuXG4gIHB1dFN0aWNreShlbCwgbmFtZSwgb3Ape1xuICAgIGxldCBzdGFzaGVkUmVzdWx0ID0gb3AoZWwpXG4gICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgb3BzID0+IHtcbiAgICAgIGxldCBleGlzdGluZ0luZGV4ID0gb3BzLmZpbmRJbmRleCgoW2V4aXN0aW5nTmFtZSwgXSkgPT4gbmFtZSA9PT0gZXhpc3RpbmdOYW1lKVxuICAgICAgaWYoZXhpc3RpbmdJbmRleCA+PSAwKXtcbiAgICAgICAgb3BzW2V4aXN0aW5nSW5kZXhdID0gW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BzLnB1c2goW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHNcbiAgICB9KVxuICB9LFxuXG4gIGFwcGx5U3RpY2t5T3BlcmF0aW9ucyhlbCl7XG4gICAgbGV0IG9wcyA9IERPTS5wcml2YXRlKGVsLCBcInN0aWNreVwiKVxuICAgIGlmKCFvcHMpeyByZXR1cm4gfVxuXG4gICAgb3BzLmZvckVhY2goKFtuYW1lLCBvcCwgX3N0YXNoZWRdKSA9PiB0aGlzLnB1dFN0aWNreShlbCwgbmFtZSwgb3ApKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERPTVxuIiwgImltcG9ydCB7XG4gIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyxcbiAgUEhYX0xJVkVfRklMRV9VUERBVEVELFxuICBQSFhfUFJFRkxJR0hURURfUkVGU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjaGFubmVsVXBsb2FkZXIsXG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXBsb2FkRW50cnkge1xuICBzdGF0aWMgaXNBY3RpdmUoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgaXNOZXcgPSBmaWxlLl9waHhSZWYgPT09IHVuZGVmaW5lZFxuICAgIGxldCBhY3RpdmVSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGxldCBpc0FjdGl2ZSA9IGFjdGl2ZVJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBmaWxlLnNpemUgPiAwICYmIChpc05ldyB8fCBpc0FjdGl2ZSlcbiAgfVxuXG4gIHN0YXRpYyBpc1ByZWZsaWdodGVkKGZpbGVFbCwgZmlsZSl7XG4gICAgbGV0IHByZWZsaWdodGVkUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGxldCBpc1ByZWZsaWdodGVkID0gcHJlZmxpZ2h0ZWRSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDBcbiAgICByZXR1cm4gaXNQcmVmbGlnaHRlZCAmJiB0aGlzLmlzQWN0aXZlKGZpbGVFbCwgZmlsZSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGZpbGVFbCwgZmlsZSwgdmlldyl7XG4gICAgdGhpcy5yZWYgPSBMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKVxuICAgIHRoaXMuZmlsZUVsID0gZmlsZUVsXG4gICAgdGhpcy5maWxlID0gZmlsZVxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLm1ldGEgPSBudWxsXG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZVxuICAgIHRoaXMuX2lzRG9uZSA9IGZhbHNlXG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwXG4gICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IC0xXG4gICAgdGhpcy5fb25Eb25lID0gZnVuY3Rpb24gKCl7IH1cbiAgICB0aGlzLl9vbkVsVXBkYXRlZCA9IHRoaXMub25FbFVwZGF0ZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgfVxuXG4gIG1ldGFkYXRhKCl7IHJldHVybiB0aGlzLm1ldGEgfVxuXG4gIHByb2dyZXNzKHByb2dyZXNzKXtcbiAgICB0aGlzLl9wcm9ncmVzcyA9IE1hdGguZmxvb3IocHJvZ3Jlc3MpXG4gICAgaWYodGhpcy5fcHJvZ3Jlc3MgPiB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50KXtcbiAgICAgIGlmKHRoaXMuX3Byb2dyZXNzID49IDEwMCl7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMTAwXG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAxMDBcbiAgICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZVxuICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIDEwMCwgKCkgPT4ge1xuICAgICAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKVxuICAgICAgICAgIHRoaXMuX29uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gdGhpcy5fcHJvZ3Jlc3NcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB0aGlzLl9wcm9ncmVzcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYW5jZWwoKXtcbiAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWVcbiAgICB0aGlzLl9pc0RvbmUgPSB0cnVlXG4gICAgdGhpcy5fb25Eb25lKClcbiAgfVxuXG4gIGlzRG9uZSgpeyByZXR1cm4gdGhpcy5faXNEb25lIH1cblxuICBlcnJvcihyZWFzb24gPSBcImZhaWxlZFwiKXtcbiAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHtlcnJvcjogcmVhc29ufSlcbiAgICBMaXZlVXBsb2FkZXIuY2xlYXJGaWxlcyh0aGlzLmZpbGVFbClcbiAgfVxuXG4gIC8vcHJpdmF0ZVxuXG4gIG9uRG9uZShjYWxsYmFjayl7XG4gICAgdGhpcy5fb25Eb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5maWxlRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIG9uRWxVcGRhdGVkKCl7XG4gICAgbGV0IGFjdGl2ZVJlZnMgPSB0aGlzLmZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIilcbiAgICBpZihhY3RpdmVSZWZzLmluZGV4T2YodGhpcy5yZWYpID09PSAtMSl7IHRoaXMuY2FuY2VsKCkgfVxuICB9XG5cbiAgdG9QcmVmbGlnaHRQYXlsb2FkKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RfbW9kaWZpZWQ6IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lOiB0aGlzLmZpbGUubmFtZSxcbiAgICAgIHNpemU6IHRoaXMuZmlsZS5zaXplLFxuICAgICAgdHlwZTogdGhpcy5maWxlLnR5cGUsXG4gICAgICByZWY6IHRoaXMucmVmXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkZXIodXBsb2FkZXJzKXtcbiAgICBpZih0aGlzLm1ldGEudXBsb2FkZXIpe1xuICAgICAgbGV0IGNhbGxiYWNrID0gdXBsb2FkZXJzW3RoaXMubWV0YS51cGxvYWRlcl0gfHwgbG9nRXJyb3IoYG5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yICR7dGhpcy5tZXRhLnVwbG9hZGVyfWApXG4gICAgICByZXR1cm4ge25hbWU6IHRoaXMubWV0YS51cGxvYWRlciwgY2FsbGJhY2s6IGNhbGxiYWNrfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge25hbWU6IFwiY2hhbm5lbFwiLCBjYWxsYmFjazogY2hhbm5lbFVwbG9hZGVyfVxuICAgIH1cbiAgfVxuXG4gIHppcFBvc3RGbGlnaHQocmVzcCl7XG4gICAgdGhpcy5tZXRhID0gcmVzcC5lbnRyaWVzW3RoaXMucmVmXVxuICAgIGlmKCF0aGlzLm1ldGEpeyBsb2dFcnJvcihgbm8gcHJlZmxpZ2h0IHVwbG9hZCByZXNwb25zZSByZXR1cm5lZCB3aXRoIHJlZiAke3RoaXMucmVmfWAsIHtpbnB1dDogdGhpcy5maWxlRWwsIHJlc3BvbnNlOiByZXNwfSkgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0RPTkVfUkVGUyxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IFVwbG9hZEVudHJ5IGZyb20gXCIuL3VwbG9hZF9lbnRyeVwiXG5cbmxldCBsaXZlVXBsb2FkZXJGaWxlUmVmID0gMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXZlVXBsb2FkZXIge1xuICBzdGF0aWMgZ2VuRmlsZVJlZihmaWxlKXtcbiAgICBsZXQgcmVmID0gZmlsZS5fcGh4UmVmXG4gICAgaWYocmVmICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHJlZlxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlLl9waHhSZWYgPSAobGl2ZVVwbG9hZGVyRmlsZVJlZisrKS50b1N0cmluZygpXG4gICAgICByZXR1cm4gZmlsZS5fcGh4UmVmXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldEVudHJ5RGF0YVVSTChpbnB1dEVsLCByZWYsIGNhbGxiYWNrKXtcbiAgICBsZXQgZmlsZSA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmaWxlID0+IHRoaXMuZ2VuRmlsZVJlZihmaWxlKSA9PT0gcmVmKVxuICAgIGNhbGxiYWNrKFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSkpXG4gIH1cblxuICBzdGF0aWMgaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKXtcbiAgICBsZXQgYWN0aXZlID0gMFxuICAgIERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCkuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpZihpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpICE9PSBpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX0RPTkVfUkVGUykpe1xuICAgICAgICBhY3RpdmUrK1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGFjdGl2ZSA+IDBcbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemVVcGxvYWRzKGlucHV0RWwpe1xuICAgIGxldCBmaWxlcyA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbClcbiAgICBsZXQgZmlsZURhdGEgPSB7fVxuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSB7cGF0aDogaW5wdXRFbC5uYW1lfVxuICAgICAgbGV0IHVwbG9hZFJlZiA9IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXSA9IGZpbGVEYXRhW3VwbG9hZFJlZl0gfHwgW11cbiAgICAgIGVudHJ5LnJlZiA9IHRoaXMuZ2VuRmlsZVJlZihmaWxlKVxuICAgICAgZW50cnkubmFtZSA9IGZpbGUubmFtZSB8fCBlbnRyeS5yZWZcbiAgICAgIGVudHJ5LnR5cGUgPSBmaWxlLnR5cGVcbiAgICAgIGVudHJ5LnNpemUgPSBmaWxlLnNpemVcbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0ucHVzaChlbnRyeSlcbiAgICB9KVxuICAgIHJldHVybiBmaWxlRGF0YVxuICB9XG5cbiAgc3RhdGljIGNsZWFyRmlsZXMoaW5wdXRFbCl7XG4gICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdKVxuICB9XG5cbiAgc3RhdGljIHVudHJhY2tGaWxlKGlucHV0RWwsIGZpbGUpe1xuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgRE9NLnByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiKS5maWx0ZXIoZiA9PiAhT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgfVxuXG4gIHN0YXRpYyB0cmFja0ZpbGVzKGlucHV0RWwsIGZpbGVzKXtcbiAgICBpZihpbnB1dEVsLmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpICE9PSBudWxsKXtcbiAgICAgIGxldCBuZXdGaWxlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+ICF0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoZiA9PiBPYmplY3QuaXMoZiwgZmlsZSkpKVxuICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmNvbmNhdChuZXdGaWxlcykpXG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIGZpbGVzKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlSW5wdXRzKGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGVsID0+IGVsLmZpbGVzICYmIHRoaXMuYWN0aXZlRmlsZXMoZWwpLmxlbmd0aCA+IDApXG4gIH1cblxuICBzdGF0aWMgYWN0aXZlRmlsZXMoaW5wdXQpe1xuICAgIHJldHVybiAoRE9NLnByaXZhdGUoaW5wdXQsIFwiZmlsZXNcIikgfHwgW10pLmZpbHRlcihmID0+IFVwbG9hZEVudHJ5LmlzQWN0aXZlKGlucHV0LCBmKSlcbiAgfVxuXG4gIHN0YXRpYyBpbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpe1xuICAgIGxldCBmaWxlSW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcihpbnB1dCA9PiB0aGlzLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpLmxlbmd0aCA+IDApXG4gIH1cblxuICBzdGF0aWMgZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCl7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXQpLmZpbHRlcihmID0+ICFVcGxvYWRFbnRyeS5pc1ByZWZsaWdodGVkKGlucHV0LCBmKSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGlucHV0RWwsIHZpZXcsIG9uQ29tcGxldGUpe1xuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlXG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICBBcnJheS5mcm9tKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdKVxuICAgICAgICAubWFwKGZpbGUgPT4gbmV3IFVwbG9hZEVudHJ5KGlucHV0RWwsIGZpbGUsIHZpZXcpKVxuXG4gICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9IHRoaXMuX2VudHJpZXMubGVuZ3RoXG4gIH1cblxuICBlbnRyaWVzKCl7IHJldHVybiB0aGlzLl9lbnRyaWVzIH1cblxuICBpbml0QWRhcHRlclVwbG9hZChyZXNwLCBvbkVycm9yLCBsaXZlU29ja2V0KXtcbiAgICB0aGlzLl9lbnRyaWVzID1cbiAgICAgIHRoaXMuX2VudHJpZXMubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgZW50cnkuemlwUG9zdEZsaWdodChyZXNwKVxuICAgICAgICBlbnRyeS5vbkRvbmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLVxuICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBlbnRyeVxuICAgICAgfSlcblxuICAgIGxldCBncm91cGVkRW50cmllcyA9IHRoaXMuX2VudHJpZXMucmVkdWNlKChhY2MsIGVudHJ5KSA9PiB7XG4gICAgICBsZXQge25hbWUsIGNhbGxiYWNrfSA9IGVudHJ5LnVwbG9hZGVyKGxpdmVTb2NrZXQudXBsb2FkZXJzKVxuICAgICAgYWNjW25hbWVdID0gYWNjW25hbWVdIHx8IHtjYWxsYmFjazogY2FsbGJhY2ssIGVudHJpZXM6IFtdfVxuICAgICAgYWNjW25hbWVdLmVudHJpZXMucHVzaChlbnRyeSlcbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcblxuICAgIGZvcihsZXQgbmFtZSBpbiBncm91cGVkRW50cmllcyl7XG4gICAgICBsZXQge2NhbGxiYWNrLCBlbnRyaWVzfSA9IGdyb3VwZWRFbnRyaWVzW25hbWVdXG4gICAgICBjYWxsYmFjayhlbnRyaWVzLCBvbkVycm9yLCByZXNwLCBsaXZlU29ja2V0KVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyxcbiAgUEhYX0xJVkVfRklMRV9VUERBVEVELFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbiAgUEhYX1VQTE9BRF9SRUZcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcblxubGV0IEhvb2tzID0ge1xuICBMaXZlRmlsZVVwbG9hZDoge1xuICAgIGFjdGl2ZVJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykgfSxcblxuICAgIHByZWZsaWdodGVkUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpIH0sXG5cbiAgICBtb3VudGVkKCl7IHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpIH0sXG5cbiAgICB1cGRhdGVkKCl7XG4gICAgICBsZXQgbmV3UHJlZmxpZ2h0cyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKClcbiAgICAgIGlmKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpe1xuICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0c1xuICAgICAgICBpZihuZXdQcmVmbGlnaHRzID09PSBcIlwiKXtcbiAgICAgICAgICB0aGlzLl9fdmlldy5jYW5jZWxTdWJtaXQodGhpcy5lbC5mb3JtKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuYWN0aXZlUmVmcygpID09PSBcIlwiKXsgdGhpcy5lbC52YWx1ZSA9IG51bGwgfVxuICAgICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChQSFhfTElWRV9GSUxFX1VQREFURUQpKVxuICAgIH1cbiAgfSxcblxuICBMaXZlSW1nUHJldmlldzoge1xuICAgIG1vdW50ZWQoKXtcbiAgICAgIHRoaXMucmVmID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1lbnRyeS1yZWZcIilcbiAgICAgIHRoaXMuaW5wdXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSlcbiAgICAgIExpdmVVcGxvYWRlci5nZXRFbnRyeURhdGFVUkwodGhpcy5pbnB1dEVsLCB0aGlzLnJlZiwgdXJsID0+IHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmxcbiAgICAgICAgdGhpcy5lbC5zcmMgPSB1cmxcbiAgICAgIH0pXG4gICAgfSxcbiAgICBkZXN0cm95ZWQoKXtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy51cmwpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvb2tzXG4iLCAiaW1wb3J0IHtcbiAgbWF5YmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTVBvc3RNb3JwaFJlc3RvcmVyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyQmVmb3JlLCBjb250YWluZXJBZnRlciwgdXBkYXRlVHlwZSl7XG4gICAgbGV0IGlkc0JlZm9yZSA9IG5ldyBTZXQoKVxuICAgIGxldCBpZHNBZnRlciA9IG5ldyBTZXQoWy4uLmNvbnRhaW5lckFmdGVyLmNoaWxkcmVuXS5tYXAoY2hpbGQgPT4gY2hpbGQuaWQpKVxuXG4gICAgbGV0IGVsZW1lbnRzVG9Nb2RpZnkgPSBbXVxuXG4gICAgQXJyYXkuZnJvbShjb250YWluZXJCZWZvcmUuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYoY2hpbGQuaWQpeyAvLyBhbGwgb2Ygb3VyIGNoaWxkcmVuIHNob3VsZCBiZSBlbGVtZW50cyB3aXRoIGlkc1xuICAgICAgICBpZHNCZWZvcmUuYWRkKGNoaWxkLmlkKVxuICAgICAgICBpZihpZHNBZnRlci5oYXMoY2hpbGQuaWQpKXtcbiAgICAgICAgICBsZXQgcHJldmlvdXNFbGVtZW50SWQgPSBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWRcbiAgICAgICAgICBlbGVtZW50c1RvTW9kaWZ5LnB1c2goe2VsZW1lbnRJZDogY2hpbGQuaWQsIHByZXZpb3VzRWxlbWVudElkOiBwcmV2aW91c0VsZW1lbnRJZH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5jb250YWluZXJJZCA9IGNvbnRhaW5lckFmdGVyLmlkXG4gICAgdGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZVxuICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeSA9IGVsZW1lbnRzVG9Nb2RpZnlcbiAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZCA9IFsuLi5pZHNBZnRlcl0uZmlsdGVyKGlkID0+ICFpZHNCZWZvcmUuaGFzKGlkKSlcbiAgfVxuXG4gIC8vIFdlIGRvIHRoZSBmb2xsb3dpbmcgdG8gb3B0aW1pemUgYXBwZW5kL3ByZXBlbmQgb3BlcmF0aW9uczpcbiAgLy8gICAxKSBUcmFjayBpZHMgb2YgbW9kaWZpZWQgZWxlbWVudHMgJiBvZiBuZXcgZWxlbWVudHNcbiAgLy8gICAyKSBBbGwgdGhlIG1vZGlmaWVkIGVsZW1lbnRzIGFyZSBwdXQgYmFjayBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgRE9NIHRyZWVcbiAgLy8gICAgICBieSBzdG9yaW5nIHRoZSBpZCBvZiB0aGVpciBwcmV2aW91cyBzaWJsaW5nXG4gIC8vICAgMykgTmV3IGVsZW1lbnRzIGFyZSBnb2luZyB0byBiZSBwdXQgaW4gdGhlIHJpZ2h0IHBsYWNlIGJ5IG1vcnBoZG9tIGR1cmluZyBhcHBlbmQuXG4gIC8vICAgICAgRm9yIHByZXBlbmQsIHdlIG1vdmUgdGhlbSB0byB0aGUgZmlyc3QgcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lclxuICBwZXJmb3JtKCl7XG4gICAgbGV0IGNvbnRhaW5lciA9IERPTS5ieUlkKHRoaXMuY29udGFpbmVySWQpXG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5LmZvckVhY2goZWxlbWVudFRvTW9kaWZ5ID0+IHtcbiAgICAgIGlmKGVsZW1lbnRUb01vZGlmeS5wcmV2aW91c0VsZW1lbnRJZCl7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5wcmV2aW91c0VsZW1lbnRJZCksIHByZXZpb3VzRWxlbSA9PiB7XG4gICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LmVsZW1lbnRJZCksIGVsZW0gPT4ge1xuICAgICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZy5pZCA9PSBwcmV2aW91c0VsZW0uaWRcbiAgICAgICAgICAgIGlmKCFpc0luUmlnaHRQbGFjZSl7XG4gICAgICAgICAgICAgIHByZXZpb3VzRWxlbS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBlbGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBjb250YWluZXJcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LmVsZW1lbnRJZCksIGVsZW0gPT4ge1xuICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyA9PSBudWxsXG4gICAgICAgICAgaWYoIWlzSW5SaWdodFBsYWNlKXtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZih0aGlzLnVwZGF0ZVR5cGUgPT0gXCJwcmVwZW5kXCIpe1xuICAgICAgdGhpcy5lbGVtZW50SWRzVG9BZGQucmV2ZXJzZSgpLmZvckVhY2goZWxlbUlkID0+IHtcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbUlkKSwgZWxlbSA9PiBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG4iLCAidmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuZnVuY3Rpb24gbW9ycGhBdHRycyhmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgdmFyIHRvTm9kZUF0dHJzID0gdG9Ob2RlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGF0dHI7XG4gICAgdmFyIGF0dHJOYW1lO1xuICAgIHZhciBhdHRyTmFtZXNwYWNlVVJJO1xuICAgIHZhciBhdHRyVmFsdWU7XG4gICAgdmFyIGZyb21WYWx1ZTtcblxuICAgIC8vIGRvY3VtZW50LWZyYWdtZW50cyBkb250IGhhdmUgYXR0cmlidXRlcyBzbyBsZXRzIG5vdCBkbyBhbnl0aGluZ1xuICAgIGlmICh0b05vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgZnJvbU5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudFxuICAgIGZvciAodmFyIGkgPSB0b05vZGVBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhdHRyID0gdG9Ob2RlQXR0cnNbaV07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG4gICAgICAgIGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnByZWZpeCA9PT0gJ3htbG5zJyl7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lOyAvLyBJdCdzIG5vdCBhbGxvd2VkIHRvIHNldCBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgWE1MTlMgbmFtZXNwYWNlIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgYHhtbG5zYCBwcmVmaXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGF0dHJpYnV0ZXMgZm91bmQgb24gdGhlIG9yaWdpbmFsIERPTSBlbGVtZW50IHRoYXRcbiAgICAvLyB3ZXJlbid0IGZvdW5kIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICB2YXIgZnJvbU5vZGVBdHRycyA9IGZyb21Ob2RlLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBkID0gZnJvbU5vZGVBdHRycy5sZW5ndGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBhdHRyID0gZnJvbU5vZGVBdHRyc1tkXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcblxuICAgICAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciByYW5nZTsgLy8gQ3JlYXRlIGEgcmFuZ2Ugb2JqZWN0IGZvciBlZmZpY2VudGx5IHJlbmRlcmluZyBzdHJpbmdzIHRvIGVsZW1lbnRzLlxudmFyIE5TX1hIVE1MID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGRvY3VtZW50O1xudmFyIEhBU19URU1QTEFURV9TVVBQT1JUID0gISFkb2MgJiYgJ2NvbnRlbnQnIGluIGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xudmFyIEhBU19SQU5HRV9TVVBQT1JUID0gISFkb2MgJiYgZG9jLmNyZWF0ZVJhbmdlICYmICdjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQnIGluIGRvYy5jcmVhdGVSYW5nZSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKSB7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKGRvYy5ib2R5KTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoc3RyKTtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnYm9keScpO1xuICAgIGZyYWdtZW50LmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFib3V0IHRoZSBzYW1lXG4gKiB2YXIgaHRtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyLCAndGV4dC9odG1sJyk7XG4gKiByZXR1cm4gaHRtbC5ib2R5LmZpcnN0Q2hpbGQ7XG4gKlxuICogQG1ldGhvZCB0b0VsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gdG9FbGVtZW50KHN0cikge1xuICAgIHN0ciA9IHN0ci50cmltKCk7XG4gICAgaWYgKEhBU19URU1QTEFURV9TVVBQT1JUKSB7XG4gICAgICAvLyBhdm9pZCByZXN0cmljdGlvbnMgb24gY29udGVudCBmb3IgdGhpbmdzIGxpa2UgYDx0cj48dGg+SGk8L3RoPjwvdHI+YCB3aGljaFxuICAgICAgLy8gY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IGRvZXNuJ3Qgc3VwcG9ydFxuICAgICAgLy8gPHRlbXBsYXRlPiBzdXBwb3J0IG5vdCBhdmFpbGFibGUgaW4gSUVcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpO1xuICAgIH0gZWxzZSBpZiAoSEFTX1JBTkdFX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHR3byBub2RlJ3MgbmFtZXMgYXJlIHRoZSBzYW1lLlxuICpcbiAqIE5PVEU6IFdlIGRvbid0IGJvdGhlciBjaGVja2luZyBgbmFtZXNwYWNlVVJJYCBiZWNhdXNlIHlvdSB3aWxsIG5ldmVyIGZpbmQgdHdvIEhUTUwgZWxlbWVudHMgd2l0aCB0aGUgc2FtZVxuICogICAgICAgbm9kZU5hbWUgYW5kIGRpZmZlcmVudCBuYW1lc3BhY2UgVVJJcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYiBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTmFtZXMoZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGZyb21Ob2RlTmFtZSA9IGZyb21FbC5ub2RlTmFtZTtcbiAgICB2YXIgdG9Ob2RlTmFtZSA9IHRvRWwubm9kZU5hbWU7XG4gICAgdmFyIGZyb21Db2RlU3RhcnQsIHRvQ29kZVN0YXJ0O1xuXG4gICAgaWYgKGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmcm9tQ29kZVN0YXJ0ID0gZnJvbU5vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgdG9Db2RlU3RhcnQgPSB0b05vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSB2aXJ0dWFsIERPTSBub2RlIG9yIFNWRyBub2RlIHRoZW4gd2UgbWF5XG4gICAgLy8gbmVlZCB0byBub3JtYWxpemUgdGhlIHRhZyBuYW1lIGJlZm9yZSBjb21wYXJpbmcuIE5vcm1hbCBIVE1MIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgLy8gaW4gdGhlIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiXG4gICAgLy8gYXJlIGNvbnZlcnRlZCB0byB1cHBlciBjYXNlXG4gICAgaWYgKGZyb21Db2RlU3RhcnQgPD0gOTAgJiYgdG9Db2RlU3RhcnQgPj0gOTcpIHsgLy8gZnJvbSBpcyB1cHBlciBhbmQgdG8gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodG9Db2RlU3RhcnQgPD0gOTAgJiYgZnJvbUNvZGVTdGFydCA+PSA5NykgeyAvLyB0byBpcyB1cHBlciBhbmQgZnJvbSBpcyBsb3dlclxuICAgICAgICByZXR1cm4gdG9Ob2RlTmFtZSA9PT0gZnJvbU5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWxlbWVudCwgb3B0aW9uYWxseSB3aXRoIGEga25vd24gbmFtZXNwYWNlIFVSSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZWxlbWVudCBuYW1lLCBlLmcuICdkaXYnIG9yICdzdmcnXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVzcGFjZVVSSV0gdGhlIGVsZW1lbnQncyBuYW1lc3BhY2UgVVJJLCBpLmUuIHRoZSB2YWx1ZSBvZlxuICogaXRzIGB4bWxuc2AgYXR0cmlidXRlIG9yIGl0cyBpbmZlcnJlZCBuYW1lc3BhY2UuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWUsIG5hbWVzcGFjZVVSSSkge1xuICAgIHJldHVybiAhbmFtZXNwYWNlVVJJIHx8IG5hbWVzcGFjZVVSSSA9PT0gTlNfWEhUTUwgP1xuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudChuYW1lKSA6XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIGNoaWxkcmVuIG9mIG9uZSBET00gZWxlbWVudCB0byBhbm90aGVyIERPTSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIG1vdmVDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB0b0VsLmFwcGVuZENoaWxkKGN1ckNoaWxkKTtcbiAgICAgICAgY3VyQ2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB0b0VsO1xufVxuXG5mdW5jdGlvbiBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgbmFtZSkge1xuICAgIGlmIChmcm9tRWxbbmFtZV0gIT09IHRvRWxbbmFtZV0pIHtcbiAgICAgICAgZnJvbUVsW25hbWVdID0gdG9FbFtuYW1lXTtcbiAgICAgICAgaWYgKGZyb21FbFtuYW1lXSkge1xuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgc3BlY2lhbEVsSGFuZGxlcnMgPSB7XG4gICAgT1BUSU9OOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBmcm9tRWwucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdPUFRHUk9VUCcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnU0VMRUNUJyAmJiAhcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUVsLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSAmJiAhdG9FbC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBNUyBFZGdlIGJ1ZyB3aGVyZSB0aGUgJ3NlbGVjdGVkJyBhdHRyaWJ1dGUgY2FuIG9ubHkgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlZCBpZiBzZXQgdG8gYSBub24tZW1wdHkgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEyMDg3Njc5L1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHJlc2V0IHNlbGVjdCBlbGVtZW50J3Mgc2VsZWN0ZWRJbmRleCB0byAtMSwgb3RoZXJ3aXNlIHNldHRpbmdcbiAgICAgICAgICAgICAgICAvLyBmcm9tRWwuc2VsZWN0ZWQgdXNpbmcgdGhlIHN5bmNCb29sZWFuQXR0clByb3AgYmVsb3cgaGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY29ycmVjdCBzZWxlY3RlZEluZGV4IHdpbGwgYmUgc2V0IGluIHRoZSBTRUxFQ1Qgc3BlY2lhbCBoYW5kbGVyIGJlbG93LlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnc2VsZWN0ZWQnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBcInZhbHVlXCIgYXR0cmlidXRlIGlzIHNwZWNpYWwgZm9yIHRoZSA8aW5wdXQ+IGVsZW1lbnQgc2luY2UgaXQgc2V0c1xuICAgICAqIHRoZSBpbml0aWFsIHZhbHVlLiBDaGFuZ2luZyB0aGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSB3aXRob3V0IGNoYW5naW5nIHRoZVxuICAgICAqIFwidmFsdWVcIiBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gZWZmZWN0IHNpbmNlIGl0IGlzIG9ubHkgdXNlZCB0byB0aGUgc2V0IHRoZVxuICAgICAqIGluaXRpYWwgdmFsdWUuICBTaW1pbGFyIGZvciB0aGUgXCJjaGVja2VkXCIgYXR0cmlidXRlLCBhbmQgXCJkaXNhYmxlZFwiLlxuICAgICAqL1xuICAgIElOUFVUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdjaGVja2VkJyk7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnZGlzYWJsZWQnKTtcblxuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSB0b0VsLnZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBURVhUQVJFQTogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAvLyBOZWVkZWQgZm9yIElFLiBBcHBhcmVudGx5IElFIHNldHMgdGhlIHBsYWNlaG9sZGVyIGFzIHRoZVxuICAgICAgICAgICAgLy8gbm9kZSB2YWx1ZSBhbmQgdmlzZSB2ZXJzYS4gVGhpcyBpZ25vcmVzIGFuIGVtcHR5IHVwZGF0ZS5cbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT0gbmV3VmFsdWUgfHwgKCFuZXdWYWx1ZSAmJiBvbGRWYWx1ZSA9PSBmcm9tRWwucGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBTRUxFQ1Q6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBsb29wIHRocm91Z2ggY2hpbGRyZW4gb2YgZnJvbUVsLCBub3QgdG9FbCBzaW5jZSBub2RlcyBjYW4gYmUgbW92ZWRcbiAgICAgICAgICAgIC8vIGZyb20gdG9FbCB0byBmcm9tRWwgZGlyZWN0bHkgd2hlbiBtb3JwaGluZy5cbiAgICAgICAgICAgIC8vIEF0IHRoZSB0aW1lIHRoaXMgc3BlY2lhbCBoYW5kbGVyIGlzIGludm9rZWQsIGFsbCBjaGlsZHJlbiBoYXZlIGFscmVhZHkgYmVlbiBtb3JwaGVkXG4gICAgICAgICAgICAvLyBhbmQgYXBwZW5kZWQgdG8gLyByZW1vdmVkIGZyb20gZnJvbUVsLCBzbyB1c2luZyBmcm9tRWwgaGVyZSBpcyBzYWZlIGFuZCBjb3JyZWN0LlxuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgb3B0Z3JvdXA7XG4gICAgICAgICAgICB2YXIgbm9kZU5hbWU7XG4gICAgICAgICAgICB3aGlsZShjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGVOYW1lID0gY3VyQ2hpbGQubm9kZU5hbWUgJiYgY3VyQ2hpbGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRHUk9VUCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAgPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVElPTicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1ckNoaWxkICYmIG9wdGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9tRWwuc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEgPSAxMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0Tm9kZUtleShub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB8fCBub2RlLmlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbW9ycGhkb20oZnJvbU5vZGUsIHRvTm9kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9Ob2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50JyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9Ob2RlSHRtbCA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgICAgICAgICAgICAgIHRvTm9kZS5pbm5lckhUTUwgPSB0b05vZGVIdG1sO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b05vZGUgPSB0b0VsZW1lbnQodG9Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZXROb2RlS2V5ID0gb3B0aW9ucy5nZXROb2RlS2V5IHx8IGRlZmF1bHRHZXROb2RlS2V5O1xuICAgICAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbk5vZGVBZGRlZCA9IG9wdGlvbnMub25Ob2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlRWxVcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25FbFVwZGF0ZWQgPSBvcHRpb25zLm9uRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZU5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25Ob2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbk5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIGNoaWxkcmVuT25seSA9IG9wdGlvbnMuY2hpbGRyZW5Pbmx5ID09PSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgYSBsb29rdXAgdG8gcXVpY2tseSBmaW5kIGFsbCBrZXllZCBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgIHZhciBmcm9tTm9kZXNMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIga2V5ZWRSZW1vdmFsTGlzdCA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEtleWVkUmVtb3ZhbChrZXkpIHtcbiAgICAgICAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcEtleWVkTm9kZXMgJiYgKGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHNraXBwaW5nIGtleWVkIG5vZGVzIHRoZW4gd2UgYWRkIHRoZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGEgbGlzdCBzbyB0aGF0IGl0IGNhbiBiZSBoYW5kbGVkIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXBvcnQgdGhlIG5vZGUgYXMgZGlzY2FyZGVkIGlmIGl0IGlzIG5vdCBrZXllZC4gV2UgZG8gdGhpcyBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZW5kIHdlIGxvb3AgdGhyb3VnaCBhbGwga2V5ZWQgZWxlbWVudHMgdGhhdCB3ZXJlIHVubWF0Y2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gZGlzY2FyZCB0aGVtIGluIG9uZSBmaW5hbCBwYXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoY3VyQ2hpbGQsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBET00gbm9kZSBvdXQgb2YgdGhlIG9yaWdpbmFsIERPTVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICAgICAgKiBAcGFyYW0gIHtOb2RlfSBwYXJlbnROb2RlIFRoZSBub2RlcyBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcEtleWVkTm9kZXMgSWYgdHJ1ZSB0aGVuIGVsZW1lbnRzIHdpdGgga2V5cyB3aWxsIGJlIHNraXBwZWQgYW5kIG5vdCBkaXNjYXJkZWQuXG4gICAgICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSwgcGFyZW50Tm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVEaXNjYXJkZWQobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC8vIFRyZWVXYWxrZXIgaW1wbGVtZW50YXRpb24gaXMgbm8gZmFzdGVyLCBidXQga2VlcGluZyB0aGlzIGFyb3VuZCBpbiBjYXNlIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShyb290KSB7XG4gICAgICAgIC8vICAgICB2YXIgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgICAgIC8vICAgICAgICAgcm9vdCxcbiAgICAgICAgLy8gICAgICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICB2YXIgZWw7XG4gICAgICAgIC8vICAgICB3aGlsZSgoZWwgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyAvLyBOb2RlSXRlcmF0b3IgaW1wbGVtZW50YXRpb24gaXMgbm8gZmFzdGVyLCBidXQga2VlcGluZyB0aGlzIGFyb3VuZCBpbiBjYXNlIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgIC8vICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yKG5vZGUsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgLy8gICAgIHZhciBlbDtcbiAgICAgICAgLy8gICAgIHdoaWxlKChlbCA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgICAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXYWxrIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHJlZShjdXJDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU5vZGVBZGRlZChlbCkge1xuICAgICAgICAgICAgb25Ob2RlQWRkZWQoZWwpO1xuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5tYXRjaGVkRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBkdXBsaWNhdGUgI2lkIG5vZGUgaW4gY2FjaGUsIHJlcGxhY2UgYGVsYCB3aXRoIGNhY2hlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtb3JwaCBpdCB0byB0aGUgY2hpbGQgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVubWF0Y2hlZEZyb21FbCAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckNoaWxkLCB1bm1hdGNoZWRGcm9tRWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoRWwodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsIGZvciBjdXJDaGlsZCBhbmQgaXQncyBjaGlsZHJlbiB0byBzZWUgaWYgd2UgZmluZCBzb21ldGhpbmcgaW5cbiAgICAgICAgICAgICAgICAgIC8vIGZyb21Ob2Rlc0xvb2t1cFxuICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgb2YgdGhlIFwidG8gbm9kZXNcIi4gSWYgY3VyRnJvbU5vZGVDaGlsZCBpc1xuICAgICAgICAgICAgLy8gbm9uLW51bGwgdGhlbiB3ZSBzdGlsbCBoYXZlIHNvbWUgZnJvbSBub2RlcyBsZWZ0IG92ZXIgdGhhdCBuZWVkXG4gICAgICAgICAgICAvLyB0byBiZSByZW1vdmVkXG4gICAgICAgICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmICgoY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vcnBoRWwoZnJvbUVsLCB0b0VsLCBjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgIHZhciB0b0VsS2V5ID0gZ2V0Tm9kZUtleSh0b0VsKTtcblxuICAgICAgICAgICAgaWYgKHRvRWxLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBlbGVtZW50IHdpdGggYW4gSUQgaXMgYmVpbmcgbW9ycGhlZCB0aGVuIGl0IHdpbGwgYmUgaW4gdGhlIGZpbmFsXG4gICAgICAgICAgICAgICAgLy8gRE9NIHNvIGNsZWFyIGl0IG91dCBvZiB0aGUgc2F2ZWQgZWxlbWVudHMgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcm9tTm9kZXNMb29rdXBbdG9FbEtleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVFbFVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50IGZpcnN0XG4gICAgICAgICAgICAgICAgbW9ycGhBdHRycyhmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgb25FbFVwZGF0ZWQoZnJvbUVsKTtcblxuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgICAgICAgbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcnMuVEVYVEFSRUEoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIGN1clRvTm9kZUtleTtcbiAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUtleTtcblxuICAgICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIHZhciB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRnJvbUVsO1xuXG4gICAgICAgICAgICAvLyB3YWxrIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChjdXJUb05vZGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRvTmV4dFNpYmxpbmcgPSBjdXJUb05vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgIC8vIHdhbGsgdGhlIGZyb21Ob2RlIGNoaWxkcmVuIGFsbCB0aGUgd2F5IHRocm91Z2hcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlICYmIGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVUeXBlID0gY3VyRnJvbU5vZGVDaGlsZC5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGlmIHRoZSBjdXJGcm9tTm9kZUNoaWxkIGRvZXNudCBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VyVG9Ob2RlQ2hpbGRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQ29tcGF0aWJsZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgRWxlbWVudCBub2Rlc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IG5vZGUgaGFzIGEga2V5IHNvIHdlIHdhbnQgdG8gbWF0Y2ggaXQgdXAgd2l0aCB0aGUgY29ycmVjdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUgZG9lcyBub3QgaGF2ZSBhIG1hdGNoaW5nIGtleSBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgY2hlY2sgb3VyIGxvb2t1cCB0byBzZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbU5leHRTaWJsaW5nID09PSBtYXRjaGluZ0Zyb21FbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHNpbmdsZSBlbGVtZW50IHJlbW92YWxzLiBUbyBhdm9pZCByZW1vdmluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRE9NIG5vZGUgb3V0IG9mIHRoZSB0cmVlIChzaW5jZSB0aGF0IGNhbiBicmVhayBDU1MgdHJhbnNpdGlvbnMsIGV0Yy4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIGluc3RlYWQgZGlzY2FyZCB0aGUgY3VycmVudCBub2RlIGFuZCB3YWl0IHVudGlsIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiB0byBwcm9wZXJseSBtYXRjaCB1cCB0aGUga2V5ZWQgdGFyZ2V0IGVsZW1lbnQgd2l0aCBpdHMgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG1hdGNoaW5nIGtleWVkIGVsZW1lbnQgc29tZXdoZXJlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgbW92ZSB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgaW50byB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgbW9ycGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogV2UgdXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIHJlcGxhY2VDaGlsZCBiZWNhdXNlIHdlIHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlbW92ZU5vZGUoKWAgZnVuY3Rpb24gZm9yIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZGlzY2FyZGVkIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGxpZmVjeWNsZSBob29rcyBhcmUgY29ycmVjdGx5IGludm9rZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmluc2VydEJlZm9yZShtYXRjaGluZ0Zyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IG1hdGNoaW5nRnJvbUVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVzIGFyZSBub3QgY29tcGF0aWJsZSBzaW5jZSB0aGUgXCJ0b1wiIG5vZGUgaGFzIGEga2V5IGFuZCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIG1hdGNoaW5nIGtleWVkIG5vZGUgaW4gdGhlIHNvdXJjZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBoYXMgYSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gaXNDb21wYXRpYmxlICE9PSBmYWxzZSAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGNvbXBhdGlibGUgRE9NIGVsZW1lbnRzIHNvIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBcImZyb21cIiBub2RlIHRvIG1hdGNoIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCBET00gbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IGN1ckZyb21Ob2RlVHlwZSA9PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBUZXh0IG9yIENvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXBseSB1cGRhdGUgbm9kZVZhbHVlIG9uIHRoZSBvcmlnaW5hbCBub2RlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSB0ZXh0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlICE9PSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgPSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIGJvdGggdGhlIFwidG9cIiBjaGlsZCBhbmQgdGhlIFwiZnJvbVwiIGNoaWxkIHNpbmNlIHdlIGZvdW5kIGEgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgZWxzZSB0byBkbyBhcyB3ZSBhbHJlYWR5IHJlY3Vyc2l2ZWx5IGNhbGxlZCBtb3JwaENoaWxkcmVuIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjb21wYXRpYmxlIG1hdGNoIHNvIHJlbW92ZSB0aGUgb2xkIG5vZGUgZnJvbSB0aGUgRE9NIGFuZCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoIGluIHRoZSBvcmlnaW5hbCBET00uIEhvd2V2ZXIsIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgZnJvbSBub2RlIGlzIG5vdCBrZXllZFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0aGF0IGEga2V5ZWQgbm9kZSBtaWdodCBtYXRjaCB1cCB3aXRoIGEgbm9kZSBzb21ld2hlcmUgZWxzZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IHRyZWUgYW5kIHdlIGRvbid0IHdhbnQgdG8gZGlzY2FyZCBpdCBqdXN0IHlldCBzaW5jZSBpdCBzdGlsbCBtaWdodCBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gaG9tZSBpbiB0aGUgZmluYWwgRE9NIHRyZWUuIEFmdGVyIGV2ZXJ5dGhpbmcgaXMgZG9uZSB3ZSB3aWxsIHJlbW92ZSBhbnkga2V5ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBkaWRuJ3QgZmluZCBhIGhvbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSAvLyBFTkQ6IHdoaWxlKGN1ckZyb21Ob2RlQ2hpbGQpIHt9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB3ZSBkaWQgbm90IGZpbmQgYSBjYW5kaWRhdGUgbWF0Y2ggZm9yXG4gICAgICAgICAgICAgICAgLy8gb3VyIFwidG8gbm9kZVwiIGFuZCB3ZSBleGhhdXN0ZWQgYWxsIG9mIHRoZSBjaGlsZHJlbiBcImZyb21cIlxuICAgICAgICAgICAgICAgIC8vIG5vZGVzLiBUaGVyZWZvcmUsIHdlIHdpbGwganVzdCBhcHBlbmQgdGhlIGN1cnJlbnQgXCJ0b1wiIG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAmJiAobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkgJiYgY29tcGFyZU5vZGVOYW1lcyhtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChtYXRjaGluZ0Zyb21FbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoRWwobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgPSBvbkJlZm9yZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZShmcm9tRWwub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KTtcblxuICAgICAgICAgICAgdmFyIHNwZWNpYWxFbEhhbmRsZXIgPSBzcGVjaWFsRWxIYW5kbGVyc1tmcm9tRWwubm9kZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVyKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRU5EOiBtb3JwaENoaWxkcmVuKC4uLilcblxuICAgICAgICB2YXIgbW9ycGhlZE5vZGUgPSBmcm9tTm9kZTtcbiAgICAgICAgdmFyIG1vcnBoZWROb2RlVHlwZSA9IG1vcnBoZWROb2RlLm5vZGVUeXBlO1xuICAgICAgICB2YXIgdG9Ob2RlVHlwZSA9IHRvTm9kZS5ub2RlVHlwZTtcblxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBnaXZlbiB0d28gRE9NIG5vZGVzIHRoYXQgYXJlIG5vdFxuICAgICAgICAgICAgLy8gY29tcGF0aWJsZSAoZS5nLiA8ZGl2PiAtLT4gPHNwYW4+IG9yIDxkaXY+IC0tPiBURVhUKVxuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmVOb2RlTmFtZXMoZnJvbU5vZGUsIHRvTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vdmVDaGlsZHJlbihmcm9tTm9kZSwgY3JlYXRlRWxlbWVudE5TKHRvTm9kZS5ub2RlTmFtZSwgdG9Ob2RlLm5hbWVzcGFjZVVSSSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR29pbmcgZnJvbSBhbiBlbGVtZW50IG5vZGUgdG8gYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBtb3JwaGVkTm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkgeyAvLyBUZXh0IG9yIGNvbW1lbnQgbm9kZVxuICAgICAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBtb3JwaGVkTm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLm5vZGVWYWx1ZSAhPT0gdG9Ob2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUubm9kZVZhbHVlID0gdG9Ob2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZXh0IG5vZGUgdG8gc29tZXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBcInRvIG5vZGVcIiB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgXCJmcm9tIG5vZGVcIiBzbyB3ZSBoYWQgdG9cbiAgICAgICAgICAgIC8vIHRvc3Mgb3V0IHRoZSBcImZyb20gbm9kZVwiIGFuZCB1c2UgdGhlIFwidG8gbm9kZVwiXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvTm9kZS5pc1NhbWVOb2RlICYmIHRvTm9kZS5pc1NhbWVOb2RlKG1vcnBoZWROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9ycGhFbChtb3JwaGVkTm9kZSwgdG9Ob2RlLCBjaGlsZHJlbk9ubHkpO1xuXG4gICAgICAgICAgICAvLyBXZSBub3cgbmVlZCB0byBsb29wIG92ZXIgYW55IGtleWVkIG5vZGVzIHRoYXQgbWlnaHQgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gcmVtb3ZlZC4gV2Ugb25seSBkbyB0aGUgcmVtb3ZhbCBpZiB3ZSBrbm93IHRoYXQgdGhlIGtleWVkIG5vZGVcbiAgICAgICAgICAgIC8vIG5ldmVyIGZvdW5kIGEgbWF0Y2guIFdoZW4gYSBrZXllZCBub2RlIGlzIG1hdGNoZWQgdXAgd2UgcmVtb3ZlXG4gICAgICAgICAgICAvLyBpdCBvdXQgb2YgZnJvbU5vZGVzTG9va3VwIGFuZCB3ZSB1c2UgZnJvbU5vZGVzTG9va3VwIHRvIGRldGVybWluZVxuICAgICAgICAgICAgLy8gaWYgYSBrZXllZCBub2RlIGhhcyBiZWVuIG1hdGNoZWQgdXAgb3Igbm90XG4gICAgICAgICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWtleWVkUmVtb3ZhbExpc3QubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbFRvUmVtb3ZlID0gZnJvbU5vZGVzTG9va3VwW2tleWVkUmVtb3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxUb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShlbFRvUmVtb3ZlLCBlbFRvUmVtb3ZlLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5ICYmIG1vcnBoZWROb2RlICE9PSBmcm9tTm9kZSAmJiBmcm9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3JwaGVkTm9kZS5hY3R1YWxpemUoZnJvbU5vZGUub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGFkIHRvIHN3YXAgb3V0IHRoZSBmcm9tIG5vZGUgd2l0aCBhIG5ldyBub2RlIGJlY2F1c2UgdGhlIG9sZFxuICAgICAgICAgICAgLy8gbm9kZSB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgdGFyZ2V0IG5vZGUgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBvbGQgRE9NIG5vZGUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLiBUaGlzIGlzIG9ubHlcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIGlmIHRoZSBvcmlnaW5hbCBET00gbm9kZSB3YXMgcGFydCBvZiBhIERPTSB0cmVlIHdoaWNoXG4gICAgICAgICAgICAvLyB3ZSBrbm93IGlzIHRoZSBjYXNlIGlmIGl0IGhhcyBhIHBhcmVudCBub2RlLlxuICAgICAgICAgICAgZnJvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobW9ycGhlZE5vZGUsIGZyb21Ob2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICB9O1xufVxuXG52YXIgbW9ycGhkb20gPSBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vcnBoZG9tO1xuIiwgImltcG9ydCB7XG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9ESVNBQkxFX1dJVEgsXG4gIFBIWF9GRUVEQkFDS19GT1IsXG4gIFBIWF9QUlVORSxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU0tJUCxcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1RSSUdHRVJfQUNUSU9OLFxuICBQSFhfVVBEQVRFXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGRldGVjdER1cGxpY2F0ZUlkcyxcbiAgaXNDaWRcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgRE9NUG9zdE1vcnBoUmVzdG9yZXIgZnJvbSBcIi4vZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXJcIlxuaW1wb3J0IG1vcnBoZG9tIGZyb20gXCJtb3JwaGRvbVwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTVBhdGNoIHtcbiAgc3RhdGljIHBhdGNoRWwoZnJvbUVsLCB0b0VsLCBhY3RpdmVFbGVtZW50KXtcbiAgICBtb3JwaGRvbShmcm9tRWwsIHRvRWwsIHtcbiAgICAgIGNoaWxkcmVuT25seTogZmFsc2UsXG4gICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICBpZihhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShmcm9tRWwpICYmIERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpKXtcbiAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHRhcmdldENJRCl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5yb290SUQgPSB2aWV3LnJvb3QuaWRcbiAgICB0aGlzLmh0bWwgPSBodG1sXG4gICAgdGhpcy50YXJnZXRDSUQgPSB0YXJnZXRDSURcbiAgICB0aGlzLmNpZFBhdGNoID0gaXNDaWQodGhpcy50YXJnZXRDSUQpXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICBiZWZvcmVhZGRlZDogW10sIGJlZm9yZXVwZGF0ZWQ6IFtdLCBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVyYWRkZWQ6IFtdLCBhZnRlcnVwZGF0ZWQ6IFtdLCBhZnRlcmRpc2NhcmRlZDogW10sIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXVxuICAgIH1cbiAgfVxuXG4gIGJlZm9yZShraW5kLCBjYWxsYmFjayl7IHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0ucHVzaChjYWxsYmFjaykgfVxuICBhZnRlcihraW5kLCBjYWxsYmFjayl7IHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG5cbiAgdHJhY2tCZWZvcmUoa2luZCwgLi4uYXJncyl7XG4gICAgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgdHJhY2tBZnRlcihraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSlcbiAgfVxuXG4gIG1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCl7XG4gICAgRE9NLmFsbCh0aGlzLmNvbnRhaW5lciwgXCJbcGh4LXVwZGF0ZT1hcHBlbmRdID4gKiwgW3BoeC11cGRhdGU9cHJlcGVuZF0gPiAqXCIsIGVsID0+IHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUFJVTkUsIFwiXCIpXG4gICAgfSlcbiAgfVxuXG4gIHBlcmZvcm0oKXtcbiAgICBsZXQge3ZpZXcsIGxpdmVTb2NrZXQsIGNvbnRhaW5lciwgaHRtbH0gPSB0aGlzXG4gICAgbGV0IHRhcmdldENvbnRhaW5lciA9IHRoaXMuaXNDSURQYXRjaCgpID8gdGhpcy50YXJnZXRDSURDb250YWluZXIoaHRtbCkgOiBjb250YWluZXJcbiAgICBpZih0aGlzLmlzQ0lEUGF0Y2goKSAmJiAhdGFyZ2V0Q29udGFpbmVyKXsgcmV0dXJuIH1cblxuICAgIGxldCBmb2N1c2VkID0gbGl2ZVNvY2tldC5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBsZXQge3NlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmR9ID0gZm9jdXNlZCAmJiBET00uaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkgPyBmb2N1c2VkIDoge31cbiAgICBsZXQgcGh4VXBkYXRlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9VUERBVEUpXG4gICAgbGV0IHBoeEZlZWRiYWNrRm9yID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19GT1IpXG4gICAgbGV0IGRpc2FibGVXaXRoID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpXG4gICAgbGV0IHBoeFRyaWdnZXJFeHRlcm5hbCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVFJJR0dFUl9BQ1RJT04pXG4gICAgbGV0IHBoeFJlbW92ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhcInJlbW92ZVwiKVxuICAgIGxldCBhZGRlZCA9IFtdXG4gICAgbGV0IHVwZGF0ZXMgPSBbXVxuICAgIGxldCBhcHBlbmRQcmVwZW5kVXBkYXRlcyA9IFtdXG4gICAgbGV0IHBlbmRpbmdSZW1vdmVzID0gW11cbiAgICBsZXQgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gbnVsbFxuXG4gICAgbGV0IGRpZmZIVE1MID0gbGl2ZVNvY2tldC50aW1lKFwicHJlbW9ycGggY29udGFpbmVyIHByZXBcIiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGREaWZmSFRNTChjb250YWluZXIsIGh0bWwsIHBoeFVwZGF0ZSwgdGFyZ2V0Q29udGFpbmVyKVxuICAgIH0pXG5cbiAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgY29udGFpbmVyKVxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGNvbnRhaW5lciwgY29udGFpbmVyKVxuXG4gICAgbGl2ZVNvY2tldC50aW1lKFwibW9ycGhkb21cIiwgKCkgPT4ge1xuICAgICAgbW9ycGhkb20odGFyZ2V0Q29udGFpbmVyLCBkaWZmSFRNTCwge1xuICAgICAgICBjaGlsZHJlbk9ubHk6IHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IG51bGwsXG4gICAgICAgIGdldE5vZGVLZXk6IChub2RlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIERPTS5pc1BoeERlc3Ryb3llZChub2RlKSA/IG51bGwgOiBub2RlLmlkXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgZWwpXG4gICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAvLyBoYWNrIHRvIGZpeCBTYWZhcmkgaGFuZGxpbmcgb2YgaW1nIHNyY3NldCBhbmQgdmlkZW8gdGFnc1xuICAgICAgICAgIGlmKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBlbC5zcmNzZXQpe1xuICAgICAgICAgICAgZWwuc3Jjc2V0ID0gZWwuc3Jjc2V0XG4gICAgICAgICAgfSBlbHNlIGlmKGVsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBlbC5hdXRvcGxheSl7XG4gICAgICAgICAgICBlbC5wbGF5KClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cbiAgICAgICAgICAvL2lucHV0IGhhbmRsaW5nXG4gICAgICAgICAgRE9NLmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0ZvcilcbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKChET00uaXNQaHhDaGlsZChlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbCkpIHx8IERPTS5pc1BoeFN0aWNreShlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbC5wYXJlbnROb2RlKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsKVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZC5wdXNoKGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbk5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoRE9NLmlzUGh4Q2hpbGQoZWwpIHx8IERPTS5pc1BoeFN0aWNreShlbCkpeyBsaXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChlbCkgfVxuICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcImRpc2NhcmRlZFwiLCBlbClcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVOb2RlRGlzY2FyZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBpZihlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9QUlVORSkgIT09IG51bGwpeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgICAgaWYoZWwucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiBET00uaXNQaHhVcGRhdGUoZWwucGFyZW50Tm9kZSwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSAmJiBlbC5pZCl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhSZW1vdmUpKXtcbiAgICAgICAgICAgIHBlbmRpbmdSZW1vdmVzLnB1c2goZWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodGhpcy5za2lwQ0lEU2libGluZyhlbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9uRWxVcGRhdGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZXMucHVzaChlbClcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgICBET00uY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSlcbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKHRvRWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihET00uaXNQaHhTdGlja3koZnJvbUVsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoRE9NLmlzSWdub3JlZChmcm9tRWwsIHBoeFVwZGF0ZSkpe1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7aXNJZ25vcmVkOiB0cnVlfSlcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihmcm9tRWwudHlwZSA9PT0gXCJudW1iZXJcIiAmJiAoZnJvbUVsLnZhbGlkaXR5ICYmIGZyb21FbC52YWxpZGl0eS5iYWRJbnB1dCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKCFET00uc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCkpe1xuICAgICAgICAgICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSl7XG4gICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZihET00uaXNQaHhDaGlsZCh0b0VsKSl7XG4gICAgICAgICAgICBsZXQgcHJldlNlc3Npb24gPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKVxuICAgICAgICAgICAgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7ZXhjbHVkZTogW1BIWF9TVEFUSUNdfSlcbiAgICAgICAgICAgIGlmKHByZXZTZXNzaW9uICE9PSBcIlwiKXsgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgcHJldlNlc3Npb24pIH1cbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdElEKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpbnB1dCBoYW5kbGluZ1xuICAgICAgICAgIERPTS5jb3B5UHJpdmF0ZXModG9FbCwgZnJvbUVsKVxuICAgICAgICAgIERPTS5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCB0b0VsLCBwaHhGZWVkYmFja0ZvcilcblxuICAgICAgICAgIGxldCBpc0ZvY3VzZWRGb3JtRWwgPSBmb2N1c2VkICYmIGZyb21FbC5pc1NhbWVOb2RlKGZvY3VzZWQpICYmIERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpXG4gICAgICAgICAgaWYoaXNGb2N1c2VkRm9ybUVsKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyhmcm9tRWwpXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoRE9NLmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHModG9FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnModG9FbClcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpZihsaXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpeyBkZXRlY3REdXBsaWNhdGVJZHMoKSB9XG5cbiAgICBpZihhcHBlbmRQcmVwZW5kVXBkYXRlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudGltZShcInBvc3QtbW9ycGggYXBwZW5kL3ByZXBlbmQgcmVzdG9yYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB1cGRhdGUucGVyZm9ybSgpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gRE9NLnJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSlcbiAgICBET00uZGlzcGF0Y2hFdmVudChkb2N1bWVudCwgXCJwaHg6dXBkYXRlXCIpXG4gICAgYWRkZWQuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJhZGRlZFwiLCBlbCkpXG4gICAgdXBkYXRlcy5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcInVwZGF0ZWRcIiwgZWwpKVxuXG4gICAgaWYocGVuZGluZ1JlbW92ZXMubGVuZ3RoID4gMCl7XG4gICAgICBsaXZlU29ja2V0LnRyYW5zaXRpb25SZW1vdmVzKHBlbmRpbmdSZW1vdmVzKVxuICAgICAgbGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlbW92ZXMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkID0gRE9NLmZpcnN0UGh4Q2hpbGQoZWwpXG4gICAgICAgICAgaWYoY2hpbGQpeyBsaXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChjaGlsZCkgfVxuICAgICAgICAgIGVsLnJlbW92ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudHJhY2tBZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIHBlbmRpbmdSZW1vdmVzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZihleHRlcm5hbEZvcm1UcmlnZ2VyZWQpe1xuICAgICAgbGl2ZVNvY2tldC5kaXNjb25uZWN0KClcbiAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZC5zdWJtaXQoKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaXNDSURQYXRjaCgpeyByZXR1cm4gdGhpcy5jaWRQYXRjaCB9XG5cbiAgc2tpcENJRFNpYmxpbmcoZWwpe1xuICAgIHJldHVybiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TS0lQKSAhPT0gbnVsbFxuICB9XG5cbiAgdGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpe1xuICAgIGlmKCF0aGlzLmlzQ0lEUGF0Y2goKSl7IHJldHVybiB9XG4gICAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICBpZihyZXN0Lmxlbmd0aCA9PT0gMCAmJiBET00uY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKXtcbiAgICAgIHJldHVybiBmaXJzdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIC8vIGJ1aWxkcyBIVE1MIGZvciBtb3JwaGRvbSBwYXRjaFxuICAvLyAtIGZvciBmdWxsIHBhdGNoZXMgb2YgTGl2ZVZpZXcgb3IgYSBjb21wb25lbnQgd2l0aCBhIHNpbmdsZVxuICAvLyAgIHJvb3Qgbm9kZSwgc2ltcGx5IHJldHVybnMgdGhlIEhUTUxcbiAgLy8gLSBmb3IgcGF0Y2hlcyBvZiBhIGNvbXBvbmVudCB3aXRoIG11bHRpcGxlIHJvb3Qgbm9kZXMsIHRoZVxuICAvLyAgIHBhcmVudCBub2RlIGJlY29tZXMgdGhlIHRhcmdldCBjb250YWluZXIgYW5kIG5vbi1jb21wb25lbnRcbiAgLy8gICBzaWJsaW5ncyBhcmUgbWFya2VkIGFzIHNraXAuXG4gIGJ1aWxkRGlmZkhUTUwoY29udGFpbmVyLCBodG1sLCBwaHhVcGRhdGUsIHRhcmdldENvbnRhaW5lcil7XG4gICAgbGV0IGlzQ0lEUGF0Y2ggPSB0aGlzLmlzQ0lEUGF0Y2goKVxuICAgIGxldCBpc0NJRFdpdGhTaW5nbGVSb290ID0gaXNDSURQYXRjaCAmJiB0YXJnZXRDb250YWluZXIuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpID09PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpXG4gICAgaWYoIWlzQ0lEUGF0Y2ggfHwgaXNDSURXaXRoU2luZ2xlUm9vdCl7XG4gICAgICByZXR1cm4gaHRtbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wb25lbnQgcGF0Y2ggd2l0aCBtdWx0aXBsZSBDSUQgcm9vdHNcbiAgICAgIGxldCBkaWZmQ29udGFpbmVyID0gbnVsbFxuICAgICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgICBkaWZmQ29udGFpbmVyID0gRE9NLmNsb25lTm9kZSh0YXJnZXRDb250YWluZXIpXG4gICAgICBsZXQgW2ZpcnN0Q29tcG9uZW50LCAuLi5yZXN0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QoZGlmZkNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpXG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgICByZXN0LmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpXG4gICAgICBBcnJheS5mcm9tKGRpZmZDb250YWluZXIuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIC8vIHdlIGNhbiBvbmx5IHNraXAgdHJhY2thYmxlIG5vZGVzIHdpdGggYW4gSURcbiAgICAgICAgaWYoY2hpbGQuaWQgJiYgY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGNoaWxkLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSAhPT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKSl7XG4gICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9TS0lQLCBcIlwiKVxuICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IFwiXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIEFycmF5LmZyb20odGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsID0+IGRpZmZDb250YWluZXIuaW5zZXJ0QmVmb3JlKGVsLCBmaXJzdENvbXBvbmVudCkpXG4gICAgICBmaXJzdENvbXBvbmVudC5yZW1vdmUoKVxuICAgICAgcmV0dXJuIGRpZmZDb250YWluZXIub3V0ZXJIVE1MXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQ09NUE9ORU5UUyxcbiAgRFlOQU1JQ1MsXG4gIFRFTVBMQVRFUyxcbiAgRVZFTlRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfU0tJUCxcbiAgUkVQTFksXG4gIFNUQVRJQyxcbiAgVElUTEVcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIGxvZ0Vycm9yLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlZCB7XG4gIHN0YXRpYyBleHRyYWN0KGRpZmYpe1xuICAgIGxldCB7W1JFUExZXTogcmVwbHksIFtFVkVOVFNdOiBldmVudHMsIFtUSVRMRV06IHRpdGxlfSA9IGRpZmZcbiAgICBkZWxldGUgZGlmZltSRVBMWV1cbiAgICBkZWxldGUgZGlmZltFVkVOVFNdXG4gICAgZGVsZXRlIGRpZmZbVElUTEVdXG4gICAgcmV0dXJuIHtkaWZmLCB0aXRsZSwgcmVwbHk6IHJlcGx5IHx8IG51bGwsIGV2ZW50czogZXZlbnRzIHx8IFtdfVxuICB9XG5cbiAgY29uc3RydWN0b3Iodmlld0lkLCByZW5kZXJlZCl7XG4gICAgdGhpcy52aWV3SWQgPSB2aWV3SWRcbiAgICB0aGlzLnJlbmRlcmVkID0ge31cbiAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZClcbiAgfVxuXG4gIHBhcmVudFZpZXdJZCgpeyByZXR1cm4gdGhpcy52aWV3SWQgfVxuXG4gIHRvU3RyaW5nKG9ubHlDaWRzKXtcbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyh0aGlzLnJlbmRlcmVkLCB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcylcbiAgfVxuXG4gIHJlY3Vyc2l2ZVRvU3RyaW5nKHJlbmRlcmVkLCBjb21wb25lbnRzID0gcmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKXtcbiAgICBvbmx5Q2lkcyA9IG9ubHlDaWRzID8gbmV3IFNldChvbmx5Q2lkcykgOiBudWxsXG4gICAgbGV0IG91dHB1dCA9IHtidWZmZXI6IFwiXCIsIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIG9ubHlDaWRzOiBvbmx5Q2lkc31cbiAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBudWxsLCBvdXRwdXQpXG4gICAgcmV0dXJuIG91dHB1dC5idWZmZXJcbiAgfVxuXG4gIGNvbXBvbmVudENJRHMoZGlmZil7IHJldHVybiBPYmplY3Qua2V5cyhkaWZmW0NPTVBPTkVOVFNdIHx8IHt9KS5tYXAoaSA9PiBwYXJzZUludChpKSkgfVxuXG4gIGlzQ29tcG9uZW50T25seURpZmYoZGlmZil7XG4gICAgaWYoIWRpZmZbQ09NUE9ORU5UU10peyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPT09IDFcbiAgfVxuXG4gIGdldENvbXBvbmVudChkaWZmLCBjaWQpeyByZXR1cm4gZGlmZltDT01QT05FTlRTXVtjaWRdIH1cblxuICBtZXJnZURpZmYoZGlmZil7XG4gICAgbGV0IG5ld2MgPSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgbGV0IGNhY2hlID0ge31cbiAgICBkZWxldGUgZGlmZltDT01QT05FTlRTXVxuICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKVxuICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdIHx8IHt9XG5cbiAgICBpZihuZXdjKXtcbiAgICAgIGxldCBvbGRjID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXtcbiAgICAgICAgbmV3Y1tjaWRdID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgbmV3Y1tjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSlcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBjaWQgaW4gbmV3Yyl7IG9sZGNbY2lkXSA9IG5ld2NbY2lkXSB9XG4gICAgICBkaWZmW0NPTVBPTkVOVFNdID0gbmV3Y1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBjZGlmZiwgb2xkYywgbmV3YywgY2FjaGUpe1xuICAgIGlmKGNhY2hlW2NpZF0pe1xuICAgICAgcmV0dXJuIGNhY2hlW2NpZF1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5kaWZmLCBzdGF0LCBzY2lkID0gY2RpZmZbU1RBVElDXVxuXG4gICAgICBpZihpc0NpZChzY2lkKSl7XG4gICAgICAgIGxldCB0ZGlmZlxuXG4gICAgICAgIGlmKHNjaWQgPiAwKXtcbiAgICAgICAgICB0ZGlmZiA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChzY2lkLCBuZXdjW3NjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZGlmZiA9IG9sZGNbLXNjaWRdXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ID0gdGRpZmZbU1RBVElDXVxuICAgICAgICBuZGlmZiA9IHRoaXMuY2xvbmVNZXJnZSh0ZGlmZiwgY2RpZmYpXG4gICAgICAgIG5kaWZmW1NUQVRJQ10gPSBzdGF0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGlmZiA9IGNkaWZmW1NUQVRJQ10gIT09IHVuZGVmaW5lZCA/IGNkaWZmIDogdGhpcy5jbG9uZU1lcmdlKG9sZGNbY2lkXSB8fCB7fSwgY2RpZmYpXG4gICAgICB9XG5cbiAgICAgIGNhY2hlW2NpZF0gPSBuZGlmZlxuICAgICAgcmV0dXJuIG5kaWZmXG4gICAgfVxuICB9XG5cbiAgbXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBpZihzb3VyY2VbU1RBVElDXSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiBzb3VyY2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSlcbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG4gIH1cblxuICBkb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgZm9yKGxldCBrZXkgaW4gc291cmNlKXtcbiAgICAgIGxldCB2YWwgPSBzb3VyY2Vba2V5XVxuICAgICAgbGV0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXG4gICAgICBpZihpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0VmFsLCB2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsb25lTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGxldCBtZXJnZWQgPSB7Li4udGFyZ2V0LCAuLi5zb3VyY2V9XG4gICAgZm9yKGxldCBrZXkgaW4gbWVyZ2VkKXtcbiAgICAgIGxldCB2YWwgPSBzb3VyY2Vba2V5XVxuICAgICAgbGV0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXG4gICAgICBpZihpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwgdmFsKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkXG4gIH1cblxuICBjb21wb25lbnRUb1N0cmluZyhjaWQpeyByZXR1cm4gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBjaWQpIH1cblxuICBwcnVuZUNJRHMoY2lkcyl7XG4gICAgY2lkcy5mb3JFYWNoKGNpZCA9PiBkZWxldGUgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdKVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGdldCgpeyByZXR1cm4gdGhpcy5yZW5kZXJlZCB9XG5cbiAgaXNOZXdGaW5nZXJwcmludChkaWZmID0ge30peyByZXR1cm4gISFkaWZmW1NUQVRJQ10gfVxuXG4gIHRlbXBsYXRlU3RhdGljKHBhcnQsIHRlbXBsYXRlcyl7XG4gICAgaWYodHlwZW9mIChwYXJ0KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlc1twYXJ0XVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFydFxuICAgIH1cbiAgfVxuXG4gIHRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCl7XG4gICAgaWYocmVuZGVyZWRbRFlOQU1JQ1NdKXsgcmV0dXJuIHRoaXMuY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCkgfVxuICAgIGxldCB7W1NUQVRJQ106IHN0YXRpY3N9ID0gcmVuZGVyZWRcbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG5cbiAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKyl7XG4gICAgICB0aGlzLmR5bmFtaWNUb0J1ZmZlcihyZW5kZXJlZFtpIC0gMV0sIHRlbXBsYXRlcywgb3V0cHV0KVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgfVxuICB9XG5cbiAgY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCl7XG4gICAgbGV0IHtbRFlOQU1JQ1NdOiBkeW5hbWljcywgW1NUQVRJQ106IHN0YXRpY3N9ID0gcmVuZGVyZWRcbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGNvbXBUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMgfHwgcmVuZGVyZWRbVEVNUExBVEVTXVxuXG4gICAgZm9yKGxldCBkID0gMDsgZCA8IGR5bmFtaWNzLmxlbmd0aDsgZCsrKXtcbiAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY3NbZF1cbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmR5bmFtaWNUb0J1ZmZlcihkeW5hbWljW2kgLSAxXSwgY29tcFRlbXBsYXRlcywgb3V0cHV0KVxuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBpZih0eXBlb2YgKHJlbmRlcmVkKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcob3V0cHV0LmNvbXBvbmVudHMsIHJlbmRlcmVkLCBvdXRwdXQub25seUNpZHMpXG4gICAgfSBlbHNlIGlmKGlzT2JqZWN0KHJlbmRlcmVkKSl7XG4gICAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dClcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LmJ1ZmZlciArPSByZW5kZXJlZFxuICAgIH1cbiAgfVxuXG4gIHJlY3Vyc2l2ZUNJRFRvU3RyaW5nKGNvbXBvbmVudHMsIGNpZCwgb25seUNpZHMpe1xuICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gfHwgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3IgQ0lEICR7Y2lkfWAsIGNvbXBvbmVudHMpXG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyhjb21wb25lbnQsIGNvbXBvbmVudHMsIG9ubHlDaWRzKVxuICAgIGxldCBjb250YWluZXIgPSB0ZW1wbGF0ZS5jb250ZW50XG4gICAgbGV0IHNraXAgPSBvbmx5Q2lkcyAmJiAhb25seUNpZHMuaGFzKGNpZClcblxuICAgIGxldCBbaGFzQ2hpbGROb2RlcywgaGFzQ2hpbGRDb21wb25lbnRzXSA9XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5jaGlsZE5vZGVzKS5yZWR1Y2UoKFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c10sIGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmKGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSl7XG4gICAgICAgICAgaWYoY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKXtcbiAgICAgICAgICAgIHJldHVybiBbaGFzTm9kZXMsIHRydWVdXG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpXG4gICAgICAgICAgaWYoIWNoaWxkLmlkKXsgY2hpbGQuaWQgPSBgJHt0aGlzLnBhcmVudFZpZXdJZCgpfS0ke2NpZH0tJHtpfWAgfVxuICAgICAgICAgIGlmKHNraXApe1xuICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9TS0lQLCBcIlwiKVxuICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIlxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3RydWUsIGhhc0NvbXBvbmVudHNdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoY2hpbGQubm9kZVZhbHVlLnRyaW0oKSAhPT0gXCJcIil7XG4gICAgICAgICAgICBsb2dFcnJvcihcIm9ubHkgSFRNTCBlbGVtZW50IHRhZ3MgYXJlIGFsbG93ZWQgYXQgdGhlIHJvb3Qgb2YgY29tcG9uZW50cy5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIGBnb3Q6IFwiJHtjaGlsZC5ub2RlVmFsdWUudHJpbSgpfVwiXFxuXFxuYCArXG4gICAgICAgICAgICAgIFwid2l0aGluOlxcblwiLCB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKVxuICAgICAgICAgICAgY2hpbGQucmVwbGFjZVdpdGgodGhpcy5jcmVhdGVTcGFuKGNoaWxkLm5vZGVWYWx1ZSwgY2lkKSlcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c11cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgICAgIHJldHVybiBbaGFzTm9kZXMsIGhhc0NvbXBvbmVudHNdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBbZmFsc2UsIGZhbHNlXSlcblxuICAgIGlmKCFoYXNDaGlsZE5vZGVzICYmICFoYXNDaGlsZENvbXBvbmVudHMpe1xuICAgICAgbG9nRXJyb3IoXCJleHBlY3RlZCBhdCBsZWFzdCBvbmUgSFRNTCBlbGVtZW50IHRhZyBpbnNpZGUgYSBjb21wb25lbnQsIGJ1dCB0aGUgY29tcG9uZW50IGlzIGVtcHR5OlxcblwiLFxuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3BhbihcIlwiLCBjaWQpLm91dGVySFRNTFxuICAgIH0gZWxzZSBpZighaGFzQ2hpbGROb2RlcyAmJiBoYXNDaGlsZENvbXBvbmVudHMpe1xuICAgICAgbG9nRXJyb3IoXCJleHBlY3RlZCBhdCBsZWFzdCBvbmUgSFRNTCBlbGVtZW50IHRhZyBkaXJlY3RseSBpbnNpZGUgYSBjb21wb25lbnQsIGJ1dCBvbmx5IHN1YmNvbXBvbmVudHMgd2VyZSBmb3VuZC4gQSBjb21wb25lbnQgbXVzdCByZW5kZXIgYXQgbGVhc3Qgb25lIEhUTUwgdGFnIGRpcmVjdGx5IGluc2lkZSBpdHNlbGYuXCIsXG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUxcbiAgICB9XG4gIH1cblxuICBjcmVhdGVTcGFuKHRleHQsIGNpZCl7XG4gICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKVxuICAgIHNwYW4uaW5uZXJUZXh0ID0gdGV4dFxuICAgIHNwYW4uc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZClcbiAgICByZXR1cm4gc3BhblxuICB9XG59XG4iLCAibGV0IHZpZXdIb29rSUQgPSAxXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3SG9vayB7XG4gIHN0YXRpYyBtYWtlSUQoKXsgcmV0dXJuIHZpZXdIb29rSUQrKyB9XG4gIHN0YXRpYyBlbGVtZW50SUQoZWwpeyByZXR1cm4gZWwucGh4SG9va0lkIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3LCBlbCwgY2FsbGJhY2tzKXtcbiAgICB0aGlzLl9fdmlldyA9IHZpZXdcbiAgICB0aGlzLl9fbGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuX19jYWxsYmFja3MgPSBjYWxsYmFja3NcbiAgICB0aGlzLl9fbGlzdGVuZXJzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLmVsID0gZWxcbiAgICB0aGlzLmVsLnBoeEhvb2tJZCA9IHRoaXMuY29uc3RydWN0b3IubWFrZUlEKClcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLl9fY2FsbGJhY2tzKXsgdGhpc1trZXldID0gdGhpcy5fX2NhbGxiYWNrc1trZXldIH1cbiAgfVxuXG4gIF9fbW91bnRlZCgpeyB0aGlzLm1vdW50ZWQgJiYgdGhpcy5tb3VudGVkKCkgfVxuICBfX3VwZGF0ZWQoKXsgdGhpcy51cGRhdGVkICYmIHRoaXMudXBkYXRlZCgpIH1cbiAgX19iZWZvcmVVcGRhdGUoKXsgdGhpcy5iZWZvcmVVcGRhdGUgJiYgdGhpcy5iZWZvcmVVcGRhdGUoKSB9XG4gIF9fZGVzdHJveWVkKCl7IHRoaXMuZGVzdHJveWVkICYmIHRoaXMuZGVzdHJveWVkKCkgfVxuICBfX3JlY29ubmVjdGVkKCl7XG4gICAgaWYodGhpcy5fX2lzRGlzY29ubmVjdGVkKXtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLnJlY29ubmVjdGVkICYmIHRoaXMucmVjb25uZWN0ZWQoKVxuICAgIH1cbiAgfVxuICBfX2Rpc2Nvbm5lY3RlZCgpe1xuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLmRpc2Nvbm5lY3RlZCgpXG4gIH1cblxuICBwdXNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcucHVzaEhvb2tFdmVudChudWxsLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgfVxuXG4gIHB1c2hFdmVudFRvKHBoeFRhcmdldCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgY2FsbGJhY2tSZWYgPSAoY3VzdG9tRXZlbnQsIGJ5cGFzcykgPT4gYnlwYXNzID8gZXZlbnQgOiBjYWxsYmFjayhjdXN0b21FdmVudC5kZXRhaWwpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuYWRkKGNhbGxiYWNrUmVmKVxuICAgIHJldHVybiBjYWxsYmFja1JlZlxuICB9XG5cbiAgcmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpe1xuICAgIGxldCBldmVudCA9IGNhbGxiYWNrUmVmKG51bGwsIHRydWUpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrUmVmKVxuICB9XG5cbiAgdXBsb2FkKG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKVxuICB9XG5cbiAgdXBsb2FkVG8ocGh4VGFyZ2V0LCBuYW1lLCBmaWxlcyl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCB2aWV3ID0+IHZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKSlcbiAgfVxuXG4gIF9fY2xlYW51cF9fKCl7XG4gICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrUmVmID0+IHRoaXMucmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpKVxuICB9XG59XG4iLCAiaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5sZXQgSlMgPSB7XG4gIGV4ZWMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGRlZmF1bHRzKXtcbiAgICBsZXQgW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc10gPSBkZWZhdWx0cyB8fCBbbnVsbCwge31dXG4gICAgbGV0IGNvbW1hbmRzID0gcGh4RXZlbnQuY2hhckF0KDApID09PSBcIltcIiA/XG4gICAgICBKU09OLnBhcnNlKHBoeEV2ZW50KSA6IFtbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXV1cblxuICAgIGNvbW1hbmRzLmZvckVhY2goKFtraW5kLCBhcmdzXSkgPT4ge1xuICAgICAgaWYoa2luZCA9PT0gZGVmYXVsdEtpbmQgJiYgZGVmYXVsdEFyZ3MuZGF0YSl7XG4gICAgICAgIGFyZ3MuZGF0YSA9IE9iamVjdC5hc3NpZ24oYXJncy5kYXRhIHx8IHt9LCBkZWZhdWx0QXJncy5kYXRhKVxuICAgICAgfVxuICAgICAgdGhpcy5maWx0ZXJUb0Vscyhzb3VyY2VFbCwgYXJncykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpe1xuICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICAvLyBjb21tYW5kc1xuXG4gIGV4ZWNfZGlzcGF0Y2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7dG8sIGV2ZW50LCBkZXRhaWx9KXtcbiAgICBET00uZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIGRldGFpbClcbiAgfSxcblxuICBleGVjX3B1c2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKXtcbiAgICBsZXQge2V2ZW50LCBkYXRhLCB0YXJnZXQsIHBhZ2VfbG9hZGluZywgbG9hZGluZywgdmFsdWV9ID0gYXJnc1xuICAgIGxldCBwdXNoT3B0cyA9IHtsb2FkaW5nLCB2YWx1ZSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmc6ICEhcGFnZV9sb2FkaW5nfVxuICAgIGxldCB0YXJnZXRTcmMgPSBldmVudFR5cGUgPT09IFwiY2hhbmdlXCIgPyBzb3VyY2VFbC5mb3JtIDogc291cmNlRWxcbiAgICBsZXQgcGh4VGFyZ2V0ID0gdGFyZ2V0IHx8IHRhcmdldFNyYy5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFwidGFyZ2V0XCIpKSB8fCB0YXJnZXRTcmNcbiAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBpZihldmVudFR5cGUgPT09IFwiY2hhbmdlXCIpe1xuICAgICAgICBsZXQge25ld0NpZCwgX3RhcmdldCwgY2FsbGJhY2t9ID0gYXJnc1xuICAgICAgICBpZihfdGFyZ2V0KXsgcHVzaE9wdHMuX3RhcmdldCA9IF90YXJnZXQgfVxuICAgICAgICB0YXJnZXRWaWV3LnB1c2hJbnB1dChzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBuZXdDaWQsIGV2ZW50IHx8IHBoeEV2ZW50LCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9IGVsc2UgaWYoZXZlbnRUeXBlID09PSBcInN1Ym1pdFwiKXtcbiAgICAgICAgdGFyZ2V0Vmlldy5zdWJtaXRGb3JtKHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBwdXNoT3B0cylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFZpZXcucHVzaEV2ZW50KGV2ZW50VHlwZSwgc291cmNlRWwsIHRhcmdldEN0eCwgZXZlbnQgfHwgcGh4RXZlbnQsIGRhdGEsIHB1c2hPcHRzKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19hZGRfY2xhc3MoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgbmFtZXMsIFtdLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KVxuICB9LFxuXG4gIGV4ZWNfcmVtb3ZlX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge25hbWVzLCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldylcbiAgfSxcblxuICBleGVjX3RyYW5zaXRpb24oZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7dGltZSwgdHJhbnNpdGlvbn0pe1xuICAgIGxldCBbdHJhbnNpdGlvbl9zdGFydCwgcnVubmluZywgdHJhbnNpdGlvbl9lbmRdID0gdHJhbnNpdGlvblxuICAgIGxldCBvblN0YXJ0ID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHJ1bm5pbmcpLCBbXSlcbiAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fZW5kLCB0cmFuc2l0aW9uX3N0YXJ0LmNvbmNhdChydW5uaW5nKSlcbiAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9LFxuXG4gIGV4ZWNfdG9nZ2xlKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIGlucywgb3V0cywgdGltZX0pe1xuICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSlcbiAgfSxcblxuICBleGVjX3Nob3coZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfaGlkZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5oaWRlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19zZXRfYXR0cihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHthdHRyOiBbYXR0ciwgdmFsXX0pe1xuICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWxdXSwgW10pXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfYXR0cihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHthdHRyfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbXSwgW2F0dHJdKVxuICB9LFxuXG4gIC8vIHV0aWxzIGZvciBjb21tYW5kc1xuXG4gIHNob3coZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSl7XG4gICAgaWYoIXRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCBudWxsLCB0aW1lKVxuICAgIH1cbiAgfSxcblxuICBoaWRlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpe1xuICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBudWxsLCB0cmFuc2l0aW9uLCB0aW1lKVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lKXtcbiAgICBsZXQgW2luQ2xhc3NlcywgaW5TdGFydENsYXNzZXMsIGluRW5kQ2xhc3Nlc10gPSBpbnMgfHwgW1tdLCBbXSwgW11dXG4gICAgbGV0IFtvdXRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMsIG91dEVuZENsYXNzZXNdID0gb3V0cyB8fCBbW10sIFtdLCBbXV1cbiAgICBpZihpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApe1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRFbmRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG91dENsYXNzZXMuY29uY2F0KG91dEVuZENsYXNzZXMpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZXZlbnRUeXBlID09PSBcInJlbW92ZVwiKXsgcmV0dXJuIH1cbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluU3RhcnRDbGFzc2VzLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRTdGFydENsYXNzZXMpLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSAoZGlzcGxheSB8fCBcImJsb2NrXCIpKVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpXG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBpbkNsYXNzZXMuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgfHwgXCJibG9ja1wiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMsIHJlbW92ZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpe1xuICAgIGxldCBbdHJhbnNpdGlvbl9ydW4sIHRyYW5zaXRpb25fc3RhcnQsIHRyYW5zaXRpb25fZW5kXSA9IHRyYW5zaXRpb24gfHwgW1tdLCBbXSwgW11dXG4gICAgaWYodHJhbnNpdGlvbl9ydW4ubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgb25TdGFydCA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX3N0YXJ0LmNvbmNhdCh0cmFuc2l0aW9uX3J1biksIFtdKVxuICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLmNvbmNhdCh0cmFuc2l0aW9uX2VuZCksIHJlbW92ZXMuY29uY2F0KHRyYW5zaXRpb25fcnVuKS5jb25jYXQodHJhbnNpdGlvbl9zdGFydCkpXG4gICAgICByZXR1cm4gdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgICB9XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBsZXQgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgW1tdLCBbXV0pXG4gICAgICBsZXQga2VlcEFkZHMgPSBhZGRzLmZpbHRlcihuYW1lID0+IHByZXZBZGRzLmluZGV4T2YobmFtZSkgPCAwICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQga2VlcFJlbW92ZXMgPSByZW1vdmVzLmZpbHRlcihuYW1lID0+IHByZXZSZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBuZXdBZGRzID0gcHJldkFkZHMuZmlsdGVyKG5hbWUgPT4gcmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBBZGRzKVxuICAgICAgbGV0IG5ld1JlbW92ZXMgPSBwcmV2UmVtb3Zlcy5maWx0ZXIobmFtZSA9PiBhZGRzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcFJlbW92ZXMpXG5cbiAgICAgIERPTS5wdXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgICBjdXJyZW50RWwuY2xhc3NMaXN0LnJlbW92ZSguLi5uZXdSZW1vdmVzKVxuICAgICAgICBjdXJyZW50RWwuY2xhc3NMaXN0LmFkZCguLi5uZXdBZGRzKVxuICAgICAgICByZXR1cm4gW25ld0FkZHMsIG5ld1JlbW92ZXNdXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgc2V0T3JSZW1vdmVBdHRycyhlbCwgc2V0cywgcmVtb3Zlcyl7XG4gICAgbGV0IFtwcmV2U2V0cywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJhdHRyc1wiLCBbW10sIFtdXSlcbiAgICBsZXQga2VlcFNldHMgPSBzZXRzLmZpbHRlcigoW2F0dHIsIF92YWxdKSA9PiAhdGhpcy5oYXNTZXQocHJldlNldHMsIGF0dHIpICYmICFlbC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShhdHRyKSlcbiAgICBsZXQga2VlcFJlbW92ZXMgPSByZW1vdmVzLmZpbHRlcihhdHRyID0+IHByZXZSZW1vdmVzLmluZGV4T2YoYXR0cikgPCAwICYmIGVsLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKGF0dHIpKVxuICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+IHJlbW92ZXMuaW5kZXhPZihhdHRyKSA8IDApLmNvbmNhdChrZWVwU2V0cylcbiAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcihhdHRyID0+ICF0aGlzLmhhc1NldChzZXRzLCBhdHRyKSkuY29uY2F0KGtlZXBSZW1vdmVzKVxuXG4gICAgRE9NLnB1dFN0aWNreShlbCwgXCJhdHRyc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgbmV3UmVtb3Zlcy5mb3JFYWNoKGF0dHIgPT4gY3VycmVudEVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSlcbiAgICAgIG5ld1NldHMuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IGN1cnJlbnRFbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKSlcbiAgICAgIHJldHVybiBbbmV3U2V0cywgbmV3UmVtb3Zlc11cbiAgICB9KVxuICB9LFxuXG4gIGhhc1NldChzZXRzLCBuYW1lU2VhcmNoKXsgcmV0dXJuIHNldHMuZmluZCgoW25hbWUsIHZhbF0pID0+IG5hbWUgPT09IG5hbWVTZWFyY2gpIH0sXG5cbiAgaGFzQWxsQ2xhc3NlcyhlbCwgY2xhc3Nlcyl7IHJldHVybiBjbGFzc2VzLmV2ZXJ5KG5hbWUgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKSB9LFxuXG4gIGlzVG9nZ2xlZE91dChlbCwgb3V0Q2xhc3Nlcyl7XG4gICAgcmV0dXJuICF0aGlzLmlzVmlzaWJsZShlbCkgfHwgdGhpcy5oYXNBbGxDbGFzc2VzKGVsLCBvdXRDbGFzc2VzKVxuICB9LFxuXG4gIGZpbHRlclRvRWxzKHNvdXJjZUVsLCB7dG99KXtcbiAgICByZXR1cm4gdG8gPyBET00uYWxsKGRvY3VtZW50LCB0bykgOiBbc291cmNlRWxdXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSlNcbiIsICJpbXBvcnQge1xuICBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VULFxuICBDSEVDS0FCTEVfSU5QVVRTLFxuICBDT05TRUNVVElWRV9SRUxPQURTLFxuICBQSFhfQVVUT19SRUNPVkVSLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICBQSFhfRElTQUJMRV9XSVRILFxuICBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsXG4gIFBIWF9ESVNBQkxFRCxcbiAgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyxcbiAgUEhYX0VWRU5UX0NMQVNTRVMsXG4gIFBIWF9FUlJPUl9DTEFTUyxcbiAgUEhYX0ZFRURCQUNLX0ZPUixcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9IT09LLFxuICBQSFhfUEFHRV9MT0FESU5HLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJPR1JFU1MsXG4gIFBIWF9SRUFET05MWSxcbiAgUEhYX1JFRixcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1RSQUNLX1NUQVRJQyxcbiAgUEhYX1RSQUNLX1VQTE9BRFMsXG4gIFBIWF9VUERBVEUsXG4gIFBIWF9VUExPQURfUkVGLFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUFVTSF9USU1FT1VULFxuICBQSFhfTUFJTixcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBpc0VtcHR5LFxuICBpc0VxdWFsT2JqLFxuICBsb2dFcnJvcixcbiAgbWF5YmUsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBhdGNoIGZyb20gXCIuL2RvbV9wYXRjaFwiXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuaW1wb3J0IFJlbmRlcmVkIGZyb20gXCIuL3JlbmRlcmVkXCJcbmltcG9ydCBWaWV3SG9vayBmcm9tIFwiLi92aWV3X2hvb2tcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxubGV0IHNlcmlhbGl6ZUZvcm0gPSAoZm9ybSwgbWV0YSA9IHt9KSA9PiB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKVxuICBsZXQgdG9SZW1vdmUgPSBbXVxuXG4gIGZvcm1EYXRhLmZvckVhY2goKHZhbCwga2V5LCBfaW5kZXgpID0+IHtcbiAgICBpZih2YWwgaW5zdGFuY2VvZiBGaWxlKXsgdG9SZW1vdmUucHVzaChrZXkpIH1cbiAgfSlcblxuICAvLyBDbGVhbnVwIGFmdGVyIGJ1aWxkaW5nIGZpbGVEYXRhXG4gIHRvUmVtb3ZlLmZvckVhY2goa2V5ID0+IGZvcm1EYXRhLmRlbGV0ZShrZXkpKVxuXG4gIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgZm9yKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSl7IHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpIH1cbiAgZm9yKGxldCBtZXRhS2V5IGluIG1ldGEpeyBwYXJhbXMuYXBwZW5kKG1ldGFLZXksIG1ldGFbbWV0YUtleV0pIH1cblxuICByZXR1cm4gcGFyYW1zLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKGVsLCBsaXZlU29ja2V0LCBwYXJlbnRWaWV3LCBmbGFzaCl7XG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZmxhc2ggPSBmbGFzaFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Vmlld1xuICAgIHRoaXMucm9vdCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LnJvb3QgOiB0aGlzXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5pZCA9IHRoaXMuZWwuaWRcbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5sb2FkZXJUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5wcnVuaW5nQ0lEcyA9IFtdXG4gICAgdGhpcy5yZWRpcmVjdCA9IGZhbHNlXG4gICAgdGhpcy5ocmVmID0gbnVsbFxuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gZnVuY3Rpb24ob25Eb25lKXsgb25Eb25lICYmIG9uRG9uZSgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gdGhpcy5wYXJlbnQgPyBudWxsIDogW11cbiAgICB0aGlzLnZpZXdIb29rcyA9IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSB7fVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSBbXVxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLnBhcmVudCA/IG51bGwgOiB7fVxuICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSA9IHt9XG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5saXZlU29ja2V0LmNoYW5uZWwoYGx2OiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCA/IHRoaXMuaHJlZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXJsOiB0aGlzLnJlZGlyZWN0ID8gdW5kZWZpbmVkIDogdGhpcy5ocmVmIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgc2Vzc2lvbjogdGhpcy5nZXRTZXNzaW9uKCksXG4gICAgICAgIHN0YXRpYzogdGhpcy5nZXRTdGF0aWMoKSxcbiAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dClcbiAgICB0aGlzLmJpbmRDaGFubmVsKClcbiAgfVxuXG4gIHNldEhyZWYoaHJlZil7IHRoaXMuaHJlZiA9IGhyZWYgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpe1xuICAgIHRoaXMucmVkaXJlY3QgPSB0cnVlXG4gICAgdGhpcy5ocmVmID0gaHJlZlxuICB9XG5cbiAgaXNNYWluKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikgIT09IG51bGwgfVxuXG4gIGNvbm5lY3RQYXJhbXMoKXtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKVxuICAgIGxldCBtYW5pZmVzdCA9XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKVxuICAgICAgICAubWFwKG5vZGUgPT4gbm9kZS5zcmMgfHwgbm9kZS5ocmVmKS5maWx0ZXIodXJsID0+IHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIilcblxuICAgIGlmKG1hbmlmZXN0Lmxlbmd0aCA+IDApeyBwYXJhbXNbXCJfdHJhY2tfc3RhdGljXCJdID0gbWFuaWZlc3QgfVxuICAgIHBhcmFtc1tcIl9tb3VudHNcIl0gPSB0aGlzLmpvaW5Db3VudFxuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYW5QdXNoKCkgfVxuXG4gIGdldFNlc3Npb24oKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSB9XG5cbiAgZ2V0U3RhdGljKCl7XG4gICAgbGV0IHZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgcmV0dXJuIHZhbCA9PT0gXCJcIiA/IG51bGwgOiB2YWxcbiAgfVxuXG4gIGRlc3Ryb3koY2FsbGJhY2sgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1cbiAgICBpZih0aGlzLnBhcmVudCl7IGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3Mpe1xuICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET00ubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpXG5cbiAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pXG4gICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKVxuICB9XG5cbiAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKXtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICAgICAgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9FUlJPUl9DTEFTU1xuICAgIClcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NlcylcbiAgfVxuXG4gIHNob3dMb2FkZXIodGltZW91dCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgaWYodGltZW91dCl7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dMb2FkZXIoKSwgdGltZW91dClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX2Rpc2Nvbm5lY3RlZCgpIH1cbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTKVxuICAgIH1cbiAgfVxuXG4gIGhpZGVMb2FkZXIoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUylcbiAgfVxuXG4gIHRyaWdnZXJSZWNvbm5lY3RlZCgpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpIH1cbiAgfVxuXG4gIGxvZyhraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LmxvZyh0aGlzLCBraW5kLCBtc2dDYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spe1xuICAgIGlmKHBoeFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHBoeFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5vd25lcihwaHhUYXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgcGh4VGFyZ2V0KSlcbiAgICB9XG5cbiAgICBpZihpc0NpZChwaHhUYXJnZXQpKXtcbiAgICAgIGxldCB0YXJnZXRzID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiAke3BoeFRhcmdldH1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGh4VGFyZ2V0KSlcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXsgbG9nRXJyb3IoYG5vdGhpbmcgZm91bmQgbWF0Y2hpbmcgdGhlIHBoeC10YXJnZXQgc2VsZWN0b3IgXCIke3BoeFRhcmdldH1cImApIH1cbiAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSlcbiAgICB9XG4gIH1cblxuICBhcHBseURpZmYodHlwZSwgcmF3RGlmZiwgY2FsbGJhY2spe1xuICAgIHRoaXMubG9nKHR5cGUsICgpID0+IFtcIlwiLCBjbG9uZShyYXdEaWZmKV0pXG4gICAgbGV0IHtkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZX0gPSBSZW5kZXJlZC5leHRyYWN0KHJhd0RpZmYpXG4gICAgaWYodGl0bGUpeyBET00ucHV0VGl0bGUodGl0bGUpIH1cblxuICAgIGNhbGxiYWNrKHtkaWZmLCByZXBseSwgZXZlbnRzfSlcbiAgICByZXR1cm4gcmVwbHlcbiAgfVxuXG4gIG9uSm9pbihyZXNwKXtcbiAgICBsZXQge3JlbmRlcmVkLCBjb250YWluZXJ9ID0gcmVzcFxuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyXG4gICAgICB0aGlzLmVsID0gRE9NLnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpXG4gICAgfVxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZmxhc2ggPSBudWxsXG5cbiAgICBCcm93c2VyLmRyb3BMb2NhbCh0aGlzLmxpdmVTb2NrZXQubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMpXG4gICAgdGhpcy5hcHBseURpZmYoXCJtb3VudFwiLCByZW5kZXJlZCwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpXG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKG51bGwsIFwiam9pblwiKVxuICAgICAgdGhpcy5kcm9wUGVuZGluZ1JlZnMoKVxuICAgICAgbGV0IGZvcm1zID0gdGhpcy5mb3Jtc0ZvclJlY292ZXJ5KGh0bWwpXG4gICAgICB0aGlzLmpvaW5Db3VudCsrXG5cbiAgICAgIGlmKGZvcm1zLmxlbmd0aCA+IDApe1xuICAgICAgICBmb3Jtcy5mb3JFYWNoKChbZm9ybSwgbmV3Rm9ybSwgbmV3Q2lkXSwgaSkgPT4ge1xuICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIHJlc3AgPT4ge1xuICAgICAgICAgICAgaWYoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZHJvcFBlbmRpbmdSZWZzKCl7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfV1gLCBlbCA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQylcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luQ29tcGxldGUoe2xpdmVfcGF0Y2h9LCBodG1sLCBldmVudHMpe1xuICAgIC8vIEluIG9yZGVyIHRvIHByb3ZpZGUgYSBiZXR0ZXIgZXhwZXJpZW5jZSwgd2Ugd2FudCB0byBqb2luXG4gICAgLy8gYWxsIExpdmVWaWV3cyBmaXJzdCBhbmQgb25seSB0aGVuIGFwcGx5IHRoZWlyIHBhdGNoZXMuXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxIHx8ICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuaXNKb2luUGVuZGluZygpKSl7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXG4gICAgfVxuXG4gICAgLy8gT25lIGRvd25zaWRlIG9mIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB3ZSBuZWVkIHRvIGZpbmQgcGh4Q2hpbGRyZW5cbiAgICAvLyBpbiB0aGUgaHRtbCBmcmFnbWVudCwgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgRE9NLiBUaGUgZnJhZ21lbnRcbiAgICAvLyBhbHNvIGRvZXMgbm90IGluY2x1ZGUgUEhYX1NUQVRJQywgc28gd2UgbmVlZCB0byBjb3B5IGl0IG92ZXIgZnJvbVxuICAgIC8vIHRoZSBET00uXG4gICAgbGV0IG5ld0NoaWxkcmVuID0gRE9NLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKHRvRWwgPT4ge1xuICAgICAgbGV0IGZyb21FbCA9IHRvRWwuaWQgJiYgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke3RvRWwuaWR9XCJdYClcbiAgICAgIGxldCBwaHhTdGF0aWMgPSBmcm9tRWwgJiYgZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgICAgaWYocGh4U3RhdGljKXsgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQywgcGh4U3RhdGljKSB9XG4gICAgICByZXR1cm4gdGhpcy5qb2luQ2hpbGQodG9FbClcbiAgICB9KVxuXG4gICAgaWYobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgICB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoVHJ1ZURvY0VsKCl7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZClcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyl7XG4gICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKClcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UpXG4gICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKVxuICAgIERPTS5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMuYWRkSG9vayhob29rRWwpXG4gICAgICBpZihob29rKXsgaG9vay5fX21vdW50ZWQoKSB9XG4gICAgfSlcblxuICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcblxuICAgIGlmKGxpdmVfcGF0Y2gpe1xuICAgICAgbGV0IHtraW5kLCB0b30gPSBsaXZlX3BhdGNoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICAgIH1cbiAgICB0aGlzLmhpZGVMb2FkZXIoKVxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSl7IHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrKClcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLCBbZnJvbUVsLCB0b0VsXSlcbiAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhmcm9tRWwpXG4gICAgbGV0IGlzSWdub3JlZCA9IGhvb2sgJiYgRE9NLmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSlcbiAgICBpZihob29rICYmICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiYgIShpc0lnbm9yZWQgJiYgaXNFcXVhbE9iaihmcm9tRWwuZGF0YXNldCwgdG9FbC5kYXRhc2V0KSkpe1xuICAgICAgaG9vay5fX2JlZm9yZVVwZGF0ZSgpXG4gICAgICByZXR1cm4gaG9va1xuICAgIH1cbiAgfVxuXG4gIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzKXtcbiAgICBsZXQgcmVtb3ZlZEVscyA9IFtdXG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZVxuICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG5cbiAgICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKVxuICAgICAgaWYobmV3SG9vayl7IG5ld0hvb2suX19tb3VudGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwgPT4ge1xuICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGVsKSl7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5qb2luUm9vdFZpZXdzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbClcbiAgICAgIGlmKGhvb2speyB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCBlbCA9PiB7XG4gICAgICBpZih1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKXsgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXsgcmVtb3ZlZEVscy5wdXNoKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgZWxzID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKVxuICAgIHBhdGNoLnBlcmZvcm0oKVxuICAgIHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQocmVtb3ZlZEVscywgcHJ1bmVDaWRzKVxuXG4gICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGFmdGVyRWxlbWVudHNSZW1vdmVkKGVsZW1lbnRzLCBwcnVuZUNpZHMpe1xuICAgIGxldCBkZXN0cm95ZWRDSURzID0gW11cbiAgICBlbGVtZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICBsZXQgY29tcG9uZW50cyA9IERPTS5hbGwocGFyZW50LCBgWyR7UEhYX0NPTVBPTkVOVH1dYClcbiAgICAgICAgY29tcG9uZW50cy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgbGV0IGNpZCA9IHRoaXMuY29tcG9uZW50SUQoZWwpXG4gICAgICAgIGlmKGlzQ2lkKGNpZCkgJiYgZGVzdHJveWVkQ0lEcy5pbmRleE9mKGNpZCkgPT09IC0xKXsgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCkgfVxuICAgICAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhlbClcbiAgICAgICAgaG9vayAmJiB0aGlzLmRlc3Ryb3lIb29rKGhvb2spXG4gICAgICB9KVxuICAgIH0pXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcnVuZUNpZHMgb24gam9pbnMuIE90aGVyd2lzZSwgaW4gY2FzZSBvZlxuICAgIC8vIHJlam9pbnMsIHdlIG1heSBub3RpZnkgY2lkcyB0aGF0IG5vIGxvbmdlciBiZWxvbmcgdG8gdGhlXG4gICAgLy8gY3VycmVudCBMaXZlVmlldyB0byBiZSByZW1vdmVkLlxuICAgIGlmKHBydW5lQ2lkcyl7XG4gICAgICB0aGlzLm1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcylcbiAgICB9XG4gIH1cblxuICBqb2luTmV3Q2hpbGRyZW4oKXtcbiAgICBET00uZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goZWwgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKVxuICB9XG5cbiAgZ2V0Q2hpbGRCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVtpZF0gfVxuXG4gIGdldERlc2NlbmRlbnRCeUVsKGVsKXtcbiAgICBpZihlbC5pZCA9PT0gdGhpcy5pZCl7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCldW2VsLmlkXVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lEZXNjZW5kZW50KGlkKXtcbiAgICBmb3IobGV0IHBhcmVudElkIGluIHRoaXMucm9vdC5jaGlsZHJlbil7XG4gICAgICBmb3IobGV0IGNoaWxkSWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXSl7XG4gICAgICAgIGlmKGNoaWxkSWQgPT09IGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF1bY2hpbGRJZF0uZGVzdHJveSgpIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqb2luQ2hpbGQoZWwpe1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRCeUlkKGVsLmlkKVxuICAgIGlmKCFjaGlsZCl7XG4gICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLmxpdmVTb2NrZXQsIHRoaXMpXG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bdmlldy5pZF0gPSB2aWV3XG4gICAgICB2aWV3LmpvaW4oKVxuICAgICAgdGhpcy5jaGlsZEpvaW5zKytcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgaXNKb2luUGVuZGluZygpeyByZXR1cm4gdGhpcy5qb2luUGVuZGluZyB9XG5cbiAgYWNrSm9pbihfY2hpbGQpe1xuICAgIHRoaXMuY2hpbGRKb2lucy0tXG5cbiAgICBpZih0aGlzLmNoaWxkSm9pbnMgPT09IDApe1xuICAgICAgaWYodGhpcy5wYXJlbnQpe1xuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpe1xuICAgIHRoaXMuam9pbkNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZighdmlldy5pc0Rlc3Ryb3llZCgpKXsgb3AoKSB9XG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdXG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZShkaWZmLCBldmVudHMpe1xuICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpIHx8IHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpKXtcbiAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKHtkaWZmLCBldmVudHN9KVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZWQubWVyZ2VEaWZmKGRpZmYpXG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZVxuXG4gICAgLy8gV2hlbiB0aGUgZGlmZiBvbmx5IGNvbnRhaW5zIGNvbXBvbmVudCBkaWZmcywgdGhlbiB3YWxrIGNvbXBvbmVudHNcbiAgICAvLyBhbmQgcGF0Y2ggb25seSB0aGUgcGFyZW50IGNvbXBvbmVudCBjb250YWluZXJzIGZvdW5kIGluIHRoZSBkaWZmLlxuICAgIC8vIE90aGVyd2lzZSwgcGF0Y2ggZW50aXJlIExWIGNvbnRhaW5lci5cbiAgICBpZih0aGlzLnJlbmRlcmVkLmlzQ29tcG9uZW50T25seURpZmYoZGlmZikpe1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRpbWUoXCJjb21wb25lbnQgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICBsZXQgcGFyZW50Q2lkcyA9IERPTS5maW5kUGFyZW50Q0lEcyh0aGlzLmVsLCB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikpXG4gICAgICAgIHBhcmVudENpZHMuZm9yRWFjaChwYXJlbnRDSUQgPT4ge1xuICAgICAgICAgIGlmKHRoaXMuY29tcG9uZW50UGF0Y2godGhpcy5yZW5kZXJlZC5nZXRDb21wb25lbnQoZGlmZiwgcGFyZW50Q0lEKSwgcGFyZW50Q0lEKSl7IHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmKCFpc0VtcHR5KGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiZnVsbCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIoZGlmZiwgXCJ1cGRhdGVcIilcbiAgICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIG51bGwpXG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cylcbiAgICBpZihwaHhDaGlsZHJlbkFkZGVkKXsgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKSB9XG4gIH1cblxuICByZW5kZXJDb250YWluZXIoZGlmZiwga2luZCl7XG4gICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC50aW1lKGB0b1N0cmluZyBkaWZmICgke2tpbmR9KWAsICgpID0+IHtcbiAgICAgIGxldCB0YWcgPSB0aGlzLmVsLnRhZ05hbWVcbiAgICAgIC8vIERvbid0IHNraXAgYW55IGNvbXBvbmVudCBpbiB0aGUgZGlmZiBub3IgYW55IG1hcmtlZCBhcyBwcnVuZWRcbiAgICAgIC8vIChhcyB0aGV5IG1heSBoYXZlIGJlZW4gYWRkZWQgYmFjaylcbiAgICAgIGxldCBjaWRzID0gZGlmZiA/IHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKS5jb25jYXQodGhpcy5wcnVuaW5nQ0lEcykgOiBudWxsXG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcylcbiAgICAgIHJldHVybiBgPCR7dGFnfT4ke2h0bWx9PC8ke3RhZ30+YFxuICAgIH0pXG4gIH1cblxuICBjb21wb25lbnRQYXRjaChkaWZmLCBjaWQpe1xuICAgIGlmKGlzRW1wdHkoZGlmZikpIHJldHVybiBmYWxzZVxuICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRUb1N0cmluZyhjaWQpXG4gICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIGNpZClcbiAgICBsZXQgY2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgIHJldHVybiBjaGlsZHJlbkFkZGVkXG4gIH1cblxuICBnZXRIb29rKGVsKXsgcmV0dXJuIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChlbCldIH1cblxuICBhZGRIb29rKGVsKXtcbiAgICBpZihWaWV3SG9vay5lbGVtZW50SUQoZWwpIHx8ICFlbC5nZXRBdHRyaWJ1dGUpeyByZXR1cm4gfVxuICAgIGxldCBob29rTmFtZSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS1waHgtJHtQSFhfSE9PS31gKSB8fCBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9IT09LKSlcbiAgICBpZihob29rTmFtZSAmJiAhdGhpcy5vd25zRWxlbWVudChlbCkpeyByZXR1cm4gfVxuICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0SG9va0NhbGxiYWNrcyhob29rTmFtZSlcblxuICAgIGlmKGNhbGxiYWNrcyl7XG4gICAgICBpZighZWwuaWQpeyBsb2dFcnJvcihgbm8gRE9NIElEIGZvciBob29rIFwiJHtob29rTmFtZX1cIi4gSG9va3MgcmVxdWlyZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIGVsZW1lbnQuYCwgZWwpIH1cbiAgICAgIGxldCBob29rID0gbmV3IFZpZXdIb29rKHRoaXMsIGVsLCBjYWxsYmFja3MpXG4gICAgICB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldID0gaG9va1xuICAgICAgcmV0dXJuIGhvb2tcbiAgICB9IGVsc2UgaWYoaG9va05hbWUgIT09IG51bGwpe1xuICAgICAgbG9nRXJyb3IoYHVua25vd24gaG9vayBmb3VuZCBmb3IgXCIke2hvb2tOYW1lfVwiYCwgZWwpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveUhvb2soaG9vayl7XG4gICAgaG9vay5fX2Rlc3Ryb3llZCgpXG4gICAgaG9vay5fX2NsZWFudXBfXygpXG4gICAgZGVsZXRlIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV1cbiAgfVxuXG4gIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKXtcbiAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKCh7ZGlmZiwgZXZlbnRzfSkgPT4gdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKSlcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gIH1cblxuICBvbkNoYW5uZWwoZXZlbnQsIGNiKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCwgZXZlbnQsIHJlc3AgPT4ge1xuICAgICAgaWYodGhpcy5pc0pvaW5QZW5kaW5nKCkpe1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gY2IocmVzcCldKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gY2IocmVzcCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmRDaGFubmVsKCl7XG4gICAgLy8gVGhlIGRpZmYgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIHJlZ3VsYXIgdXBkYXRlIG9wZXJhdGlvbnMuXG4gICAgLy8gQWxsIG90aGVyIG9wZXJhdGlvbnMgYXJlIHF1ZXVlZCB0byBiZSBhcHBsaWVkIG9ubHkgYWZ0ZXIgam9pbi5cbiAgICB0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCwgXCJkaWZmXCIsIChyYXdEaWZmKSA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJhd0RpZmYsICh7ZGlmZiwgZXZlbnRzfSkgPT4gdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLm9uQ2hhbm5lbChcInJlZGlyZWN0XCIsICh7dG8sIGZsYXNofSkgPT4gdGhpcy5vblJlZGlyZWN0KHt0bywgZmxhc2h9KSlcbiAgICB0aGlzLm9uQ2hhbm5lbChcImxpdmVfcGF0Y2hcIiwgKHJlZGlyKSA9PiB0aGlzLm9uTGl2ZVBhdGNoKHJlZGlyKSlcbiAgICB0aGlzLm9uQ2hhbm5lbChcImxpdmVfcmVkaXJlY3RcIiwgKHJlZGlyKSA9PiB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlZGlyKSlcbiAgICB0aGlzLmNoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5vbkVycm9yKHJlYXNvbikpXG4gICAgdGhpcy5jaGFubmVsLm9uQ2xvc2UocmVhc29uID0+IHRoaXMub25DbG9zZShyZWFzb24pKVxuICB9XG5cbiAgZGVzdHJveUFsbENoaWxkcmVuKCl7XG4gICAgZm9yKGxldCBpZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0pe1xuICAgICAgdGhpcy5nZXRDaGlsZEJ5SWQoaWQpLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIG9uTGl2ZVJlZGlyZWN0KHJlZGlyKXtcbiAgICBsZXQge3RvLCBraW5kLCBmbGFzaH0gPSByZWRpclxuICAgIGxldCB1cmwgPSB0aGlzLmV4cGFuZFVSTCh0bylcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KHVybCwga2luZCwgZmxhc2gpXG4gIH1cblxuICBvbkxpdmVQYXRjaChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZH0gPSByZWRpclxuICAgIHRoaXMuaHJlZiA9IHRoaXMuZXhwYW5kVVJMKHRvKVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpXG4gIH1cblxuICBleHBhbmRVUkwodG8pe1xuICAgIHJldHVybiB0by5zdGFydHNXaXRoKFwiL1wiKSA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gIDogdG9cbiAgfVxuXG4gIG9uUmVkaXJlY3Qoe3RvLCBmbGFzaH0peyB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3QodG8sIGZsYXNoKSB9XG5cbiAgaXNEZXN0cm95ZWQoKXsgcmV0dXJuIHRoaXMuZGVzdHJveWVkIH1cblxuICBqb2luKGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmlzTWFpbigpKXtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7dG86IHRoaXMuaHJlZiwga2luZDogXCJpbml0aWFsXCJ9KVxuICAgIH1cbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IChvbkRvbmUpID0+IHtcbiAgICAgIG9uRG9uZSA9IG9uRG9uZSB8fCBmdW5jdGlvbigpe31cbiAgICAgIGNhbGxiYWNrID8gY2FsbGJhY2sodGhpcy5qb2luQ291bnQsIG9uRG9uZSkgOiBvbkRvbmUoKVxuICAgIH1cbiAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywge3RpbWVvdXQ6IGZhbHNlfSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5qb2luKClcbiAgICAgICAgLnJlY2VpdmUoXCJva1wiLCBkYXRhID0+IHtcbiAgICAgICAgICBpZighdGhpcy5pc0Rlc3Ryb3llZCgpKXtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHRoaXMub25Kb2luKGRhdGEpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCByZXNwID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgdGhpcy5vbkpvaW5FcnJvcihyZXNwKSlcbiAgICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgdGhpcy5vbkpvaW5FcnJvcih7cmVhc29uOiBcInRpbWVvdXRcIn0pKVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW5FcnJvcihyZXNwKXtcbiAgICBpZihyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKXtcbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hdXRob3JpemVkIGxpdmVfcmVkaXJlY3QuIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlcXVlc3RcIiwgcmVzcF0pXG4gICAgICByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHt0bzogdGhpcy5ocmVmfSlcbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCB8fCByZXNwLmxpdmVfcmVkaXJlY3Qpe1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmFibGUgdG8gam9pblwiLCByZXNwXSlcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcylcbiAgfVxuXG4gIG9uQ2xvc2UocmVhc29uKXtcbiAgICBpZih0aGlzLmlzRGVzdHJveWVkKCkpeyByZXR1cm4gfVxuICAgIGlmKCh0aGlzLmlzSm9pblBlbmRpbmcoKSAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIpIHx8XG4gICAgICAodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgcmVhc29uICE9PSBcImxlYXZlXCIpKXtcblxuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsIGluIEludGVybmV0IEV4cGxvcmVyIDExXG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IocmVhc29uKXtcbiAgICB0aGlzLm9uQ2xvc2UocmVhc29uKVxuICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widmlldyBjcmFzaGVkXCIsIHJlYXNvbl0pXG4gICAgaWYoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpeyB0aGlzLmRpc3BsYXlFcnJvcigpIH1cbiAgfVxuXG4gIGRpc3BsYXlFcnJvcigpe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpeyBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7dG86IHRoaXMuaHJlZiwga2luZDogXCJlcnJvclwifSkgfVxuICAgIHRoaXMuc2hvd0xvYWRlcigpXG4gICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUylcbiAgfVxuXG4gIHB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cblxuICAgIGxldCBbcmVmLCBbZWxdLCBvcHRzXSA9IHJlZkdlbmVyYXRvciA/IHJlZkdlbmVyYXRvcigpIDogW251bGwsIFtdLCB7fV1cbiAgICBsZXQgb25Mb2FkaW5nRG9uZSA9IGZ1bmN0aW9uKCl7IH1cbiAgICBpZihvcHRzLnBhZ2VfbG9hZGluZyB8fCAoZWwgJiYgKGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORykpICE9PSBudWxsKSkpe1xuICAgICAgb25Mb2FkaW5nRG9uZSA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe2tpbmQ6IFwiZWxlbWVudFwiLCB0YXJnZXQ6IGVsfSlcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgKHBheWxvYWQuY2lkKSAhPT0gXCJudW1iZXJcIil7IGRlbGV0ZSBwYXlsb2FkLmNpZCB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubGl2ZVNvY2tldC53cmFwUHVzaCh0aGlzLCB7dGltZW91dDogdHJ1ZX0sICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5wdXNoKGV2ZW50LCBwYXlsb2FkLCBQVVNIX1RJTUVPVVQpLnJlY2VpdmUoXCJva1wiLCByZXNwID0+IHtcbiAgICAgICAgICBpZihyZWYgIT09IG51bGwpeyB0aGlzLnVuZG9SZWZzKHJlZikgfVxuICAgICAgICAgIGxldCBmaW5pc2ggPSAoaG9va1JlcGx5KSA9PiB7XG4gICAgICAgICAgICBpZihyZXNwLnJlZGlyZWN0KXsgdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9wYXRjaCl7IHRoaXMub25MaXZlUGF0Y2gocmVzcC5saXZlX3BhdGNoKSB9XG4gICAgICAgICAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCkgfVxuICAgICAgICAgICAgb25Mb2FkaW5nRG9uZSgpXG4gICAgICAgICAgICBvblJlcGx5KHJlc3AsIGhvb2tSZXBseSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzcC5kaWZmKXtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgbGV0IGhvb2tSZXBseSA9IHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJlc3AuZGlmZiwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBmaW5pc2goaG9va1JlcGx5KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmluaXNoKG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICB1bmRvUmVmcyhyZWYpe1xuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMuaWR9XCJdWyR7UEhYX1JFRn09XCIke3JlZn1cIl1gLCBlbCA9PiB7XG4gICAgICBsZXQgZGlzYWJsZWRWYWwgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKVxuICAgICAgLy8gcmVtb3ZlIHJlZnNcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGKVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKVxuICAgICAgLy8gcmVzdG9yZSBpbnB1dHNcbiAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpICE9PSBudWxsKXtcbiAgICAgICAgZWwucmVhZE9ubHkgPSBmYWxzZVxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKVxuICAgICAgfVxuICAgICAgaWYoZGlzYWJsZWRWYWwgIT09IG51bGwpe1xuICAgICAgICBlbC5kaXNhYmxlZCA9IGRpc2FibGVkVmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZVxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGNsYXNzZXNcbiAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goY2xhc3NOYW1lID0+IERPTS5yZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSlcbiAgICAgIC8vIHJlc3RvcmUgZGlzYWJsZXNcbiAgICAgIGxldCBkaXNhYmxlUmVzdG9yZSA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICBpZihkaXNhYmxlUmVzdG9yZSAhPT0gbnVsbCl7XG4gICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVSZXN0b3JlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICB9XG4gICAgICBsZXQgdG9FbCA9IERPTS5wcml2YXRlKGVsLCBQSFhfUkVGKVxuICAgICAgaWYodG9FbCl7XG4gICAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhlbCwgdG9FbClcbiAgICAgICAgRE9NUGF0Y2gucGF0Y2hFbChlbCwgdG9FbCwgdGhpcy5saXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKSlcbiAgICAgICAgaWYoaG9vayl7IGhvb2suX191cGRhdGVkKCkgfVxuICAgICAgICBET00uZGVsZXRlUHJpdmF0ZShlbCwgUEhYX1JFRilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHV0UmVmKGVsZW1lbnRzLCBldmVudCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYrK1xuICAgIGxldCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKVxuICAgIGlmKG9wdHMubG9hZGluZyl7IGVsZW1lbnRzID0gZWxlbWVudHMuY29uY2F0KERPTS5hbGwoZG9jdW1lbnQsIG9wdHMubG9hZGluZykpfVxuXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGBwaHgtJHtldmVudH0tbG9hZGluZ2ApXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgbmV3UmVmKVxuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCB0aGlzLmVsLmlkKVxuICAgICAgbGV0IGRpc2FibGVUZXh0ID0gZWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKVxuICAgICAgaWYoZGlzYWJsZVRleHQgIT09IG51bGwpe1xuICAgICAgICBpZighZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSkpe1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsIGVsLmlubmVyVGV4dClcbiAgICAgICAgfVxuICAgICAgICBpZihkaXNhYmxlVGV4dCAhPT0gXCJcIil7IGVsLmlubmVyVGV4dCA9IGRpc2FibGVUZXh0IH1cbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBbbmV3UmVmLCBlbGVtZW50cywgb3B0c11cbiAgfVxuXG4gIGNvbXBvbmVudElEKGVsKXtcbiAgICBsZXQgY2lkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKVxuICAgIHJldHVybiBjaWQgPyBwYXJzZUludChjaWQpIDogbnVsbFxuICB9XG5cbiAgdGFyZ2V0Q29tcG9uZW50SUQodGFyZ2V0LCB0YXJnZXRDdHgsIG9wdHMgPSB7fSl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7IHJldHVybiB0YXJnZXRDdHggfVxuXG4gICAgbGV0IGNpZE9yU2VsZWN0b3IgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSlcbiAgICBpZihpc0NpZChjaWRPclNlbGVjdG9yKSl7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoY2lkT3JTZWxlY3RvcilcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4ICYmIChjaWRPclNlbGVjdG9yICE9PSBudWxsIHx8IG9wdHMudGFyZ2V0KSl7XG4gICAgICByZXR1cm4gdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpe1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpe1xuICAgICAgcmV0dXJuIHRhcmdldEN0eFxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHgpe1xuICAgICAgcmV0dXJuIG1heWJlKHRhcmdldEN0eC5jbG9zZXN0KGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgZWwgPT4gdGhpcy5vd25zRWxlbWVudChlbCkgJiYgdGhpcy5jb21wb25lbnRJRChlbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgIHRoaXMubG9nKFwiaG9va1wiLCAoKSA9PiBbXCJ1bmFibGUgdG8gcHVzaCBob29rIGV2ZW50LiBMaXZlVmlldyBub3QgY29ubmVjdGVkXCIsIGV2ZW50LCBwYXlsb2FkXSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBsZXQgW3JlZiwgZWxzLCBvcHRzXSA9IHRoaXMucHV0UmVmKFtdLCBcImhvb2tcIilcbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gW3JlZiwgZWxzLCBvcHRzXSwgXCJldmVudFwiLCB7XG4gICAgICB0eXBlOiBcImhvb2tcIixcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIHZhbHVlOiBwYXlsb2FkLFxuICAgICAgY2lkOiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSwgKHJlc3AsIHJlcGx5KSA9PiBvblJlcGx5KHJlcGx5LCByZWYpKVxuXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgZXh0cmFjdE1ldGEoZWwsIG1ldGEsIHZhbHVlKXtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbGV0IG5hbWUgPSBlbC5hdHRyaWJ1dGVzW2ldLm5hbWVcbiAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKXsgbWV0YVtuYW1lLnJlcGxhY2UocHJlZml4LCBcIlwiKV0gPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgfVxuICAgIH1cbiAgICBpZihlbC52YWx1ZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIG1ldGEudmFsdWUgPSBlbC52YWx1ZVxuXG4gICAgICBpZihlbC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgJiYgIWVsLmNoZWNrZWQpe1xuICAgICAgICBkZWxldGUgbWV0YS52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZih2YWx1ZSl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBmb3IobGV0IGtleSBpbiB2YWx1ZSl7IG1ldGFba2V5XSA9IHZhbHVlW2tleV0gfVxuICAgIH1cbiAgICByZXR1cm4gbWV0YVxuICB9XG5cbiAgcHVzaEV2ZW50KHR5cGUsIGVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBtZXRhLCBvcHRzID0ge30pe1xuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihbZWxdLCB0eXBlLCBvcHRzKSwgXCJldmVudFwiLCB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IHRoaXMuZXh0cmFjdE1ldGEoZWwsIG1ldGEsIG9wdHMudmFsdWUpLFxuICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGVsLCB0YXJnZXRDdHgsIG9wdHMpXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hGaWxlUHJvZ3Jlc3MoZmlsZUVsLCBlbnRyeVJlZiwgcHJvZ3Jlc3MsIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmaWxlRWwuZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgdmlldy5wdXNoV2l0aFJlcGx5KG51bGwsIFwicHJvZ3Jlc3NcIiwge1xuICAgICAgICBldmVudDogZmlsZUVsLmdldEF0dHJpYnV0ZSh2aWV3LmJpbmRpbmcoUEhYX1BST0dSRVNTKSksXG4gICAgICAgIHJlZjogZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgIGVudHJ5X3JlZjogZW50cnlSZWYsXG4gICAgICAgIHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgICAgY2lkOiB2aWV3LnRhcmdldENvbXBvbmVudElEKGZpbGVFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICB9LCBvblJlcGx5KVxuICAgIH0pXG4gIH1cblxuICBwdXNoSW5wdXQoaW5wdXRFbCwgdGFyZ2V0Q3R4LCBmb3JjZUNpZCwgcGh4RXZlbnQsIG9wdHMsIGNhbGxiYWNrKXtcbiAgICBsZXQgdXBsb2Fkc1xuICAgIGxldCBjaWQgPSBpc0NpZChmb3JjZUNpZCkgPyBmb3JjZUNpZCA6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHRoaXMucHV0UmVmKFtpbnB1dEVsLCBpbnB1dEVsLmZvcm1dLCBcImNoYW5nZVwiLCBvcHRzKVxuICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCB7X3RhcmdldDogb3B0cy5fdGFyZ2V0fSlcbiAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKVxuICAgIH1cbiAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbClcbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgIHVwbG9hZHM6IHVwbG9hZHMsXG4gICAgICBjaWQ6IGNpZFxuICAgIH1cbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIERPTS5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpXG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKXtcbiAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCl7XG4gICAgcmV0dXJuIHRoaXMuZm9ybVN1Ym1pdHMuZmluZCgoW2VsLCBfcmVmLCBfb3B0cywgX2NhbGxiYWNrXSkgPT4gZWwuaXNTYW1lTm9kZShmb3JtRWwpKVxuICB9XG5cbiAgc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpKXsgcmV0dXJuIHRydWUgfVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMucHVzaChbZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrXSlcbiAgfVxuXG4gIGNhbmNlbFN1Ym1pdChmb3JtRWwpe1xuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSB0aGlzLmZvcm1TdWJtaXRzLmZpbHRlcigoW2VsLCByZWYsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cywgb25SZXBseSl7XG4gICAgbGV0IGZpbHRlcklnbm9yZWQgPSBlbCA9PiB7XG4gICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKVxuICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckRpc2FibGVzID0gZWwgPT4ge1xuICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJCdXR0b24gPSBlbCA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCJcblxuICAgIGxldCBmaWx0ZXJJbnB1dCA9IGVsID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSlcblxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKVxuICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG4gICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgYnV0dG9uLmRpc2FibGVkKVxuICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9KVxuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlXG4gICAgICAgIGlmKGlucHV0LmZpbGVzKXtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgICBpbnB1dC5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKVxuICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiLCBvcHRzKVxuICAgIH1cblxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KVxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIHB1c2gpXG4gICAgfSBlbHNlIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IFtyZWYsIGVsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgbGV0IHByb3h5UmVmR2VuID0gKCkgPT4gW3JlZiwgZWxzLCBvcHRzXVxuICAgICAgdGhpcy51cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pXG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWQ6IGNpZFxuICAgICAgICB9LCBvblJlcGx5KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwpXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICBjaWQ6IGNpZFxuICAgICAgfSwgb25SZXBseSlcbiAgICB9XG4gIH1cblxuICB1cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIG9uQ29tcGxldGUpe1xuICAgIGxldCBqb2luQ291bnRBdFVwbG9hZCA9IHRoaXMuam9pbkNvdW50XG4gICAgbGV0IGlucHV0RWxzID0gTGl2ZVVwbG9hZGVyLmFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKVxuICAgIGxldCBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9IGlucHV0RWxzLmxlbmd0aFxuXG4gICAgLy8gZ2V0IGVhY2ggZmlsZSBpbnB1dFxuICAgIGlucHV0RWxzLmZvckVhY2goaW5wdXRFbCA9PiB7XG4gICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgTGl2ZVVwbG9hZGVyKGlucHV0RWwsIHRoaXMsICgpID0+IHtcbiAgICAgICAgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MtLVxuICAgICAgICBpZihudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9PT0gMCl7IG9uQ29tcGxldGUoKSB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy51cGxvYWRlcnNbaW5wdXRFbF0gPSB1cGxvYWRlclxuICAgICAgbGV0IGVudHJpZXMgPSB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKVxuXG4gICAgICBsZXQgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wic2VuZGluZyBwcmVmbGlnaHQgcmVxdWVzdFwiLCBwYXlsb2FkXSlcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiYWxsb3dfdXBsb2FkXCIsIHBheWxvYWQsIHJlc3AgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKVxuICAgICAgICBpZihyZXNwLmVycm9yKXtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZilcbiAgICAgICAgICBsZXQgW2VudHJ5X3JlZiwgcmVhc29uXSA9IHJlc3AuZXJyb3JcbiAgICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbYGVycm9yIGZvciBlbnRyeSAke2VudHJ5X3JlZn1gLCByZWFzb25dKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuam9pbkNvdW50ID09PSBqb2luQ291bnRBdFVwbG9hZCl7IGNhbGxiYWNrKCkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXNPckJsb2JzKXtcbiAgICBsZXQgaW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHModGhpcy5lbCkuZmlsdGVyKGVsID0+IGVsLm5hbWUgPT09IG5hbWUpXG4gICAgaWYoaW5wdXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBubyBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgaWYoaW5wdXRzLmxlbmd0aCA+IDEpeyBsb2dFcnJvcihgZHVwbGljYXRlIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKSB9XG4gICAgZWxzZSB7IERPTS5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHtmaWxlczogZmlsZXNPckJsb2JzfSkgfVxuICB9XG5cbiAgcHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIGNhbGxiYWNrKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGxldCBpbnB1dCA9IGZvcm0uZWxlbWVudHNbMF1cbiAgICAgIGxldCBwaHhFdmVudCA9IGZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfQVVUT19SRUNPVkVSKSkgfHwgZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKVxuXG4gICAgICBKUy5leGVjKFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB2aWV3LCBpbnB1dCwgW1wicHVzaFwiLCB7X3RhcmdldDogaW5wdXQubmFtZSwgbmV3Q2lkOiBuZXdDaWQsIGNhbGxiYWNrOiBjYWxsYmFja31dKVxuICAgIH0pXG4gIH1cblxuICBwdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IGxpbmtSZWYgPSB0aGlzLmxpdmVTb2NrZXQuc2V0UGVuZGluZ0xpbmsoaHJlZilcbiAgICBsZXQgcmVmR2VuID0gdGFyZ2V0RWwgPyAoKSA9PiB0aGlzLnB1dFJlZihbdGFyZ2V0RWxdLCBcImNsaWNrXCIpIDogbnVsbFxuICAgIGxldCBmYWxsYmFjayA9ICgpID0+IHRoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh3aW5kb3cubG9jYXRpb24uaHJlZilcblxuICAgIGxldCBwdXNoID0gdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbiwgXCJsaXZlX3BhdGNoXCIsIHt1cmw6IGhyZWZ9LCByZXNwID0+IHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYocmVzcC5saW5rX3JlZGlyZWN0KXtcbiAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2ssIGxpbmtSZWYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYodGhpcy5saXZlU29ja2V0LmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXtcbiAgICAgICAgICAgIHRoaXMuaHJlZiA9IGhyZWZcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhsaW5rUmVmKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpZihwdXNoKXtcbiAgICAgIHB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgZmFsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBmb3Jtc0ZvclJlY292ZXJ5KGh0bWwpe1xuICAgIGlmKHRoaXMuam9pbkNvdW50ID09PSAwKXsgcmV0dXJuIFtdIH1cblxuICAgIGxldCBwaHhDaGFuZ2UgPSB0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIilcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG5cbiAgICByZXR1cm4gKFxuICAgICAgRE9NLmFsbCh0aGlzLmVsLCBgZm9ybVske3BoeENoYW5nZX1dYClcbiAgICAgICAgLmZpbHRlcihmb3JtID0+IGZvcm0uaWQgJiYgdGhpcy5vd25zRWxlbWVudChmb3JtKSlcbiAgICAgICAgLmZpbHRlcihmb3JtID0+IGZvcm0uZWxlbWVudHMubGVuZ3RoID4gMClcbiAgICAgICAgLmZpbHRlcihmb3JtID0+IGZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfQVVUT19SRUNPVkVSKSkgIT09IFwiaWdub3JlXCIpXG4gICAgICAgIC5tYXAoZm9ybSA9PiB7XG4gICAgICAgICAgbGV0IG5ld0Zvcm0gPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoYGZvcm1baWQ9XCIke2Zvcm0uaWR9XCJdWyR7cGh4Q2hhbmdlfT1cIiR7Zm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKX1cIl1gKVxuICAgICAgICAgIGlmKG5ld0Zvcm0pe1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtLCBuZXdGb3JtLCB0aGlzLnRhcmdldENvbXBvbmVudElEKG5ld0Zvcm0pXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm0sIG51bGwsIG51bGxdXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKChbZm9ybSwgbmV3Rm9ybSwgbmV3Q2lkXSkgPT4gbmV3Rm9ybSlcbiAgICApXG4gIH1cblxuICBtYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpe1xuICAgIGxldCB3aWxsRGVzdHJveUNJRHMgPSBkZXN0cm95ZWRDSURzLmZpbHRlcihjaWQgPT4ge1xuICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICB9KVxuICAgIGlmKHdpbGxEZXN0cm95Q0lEcy5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMucHJ1bmluZ0NJRHMucHVzaCguLi53aWxsRGVzdHJveUNJRHMpXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfd2lsbF9kZXN0cm95XCIsIHtjaWRzOiB3aWxsRGVzdHJveUNJRHN9LCAoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBjaWRzIGFyZSBlaXRoZXIgYmFjayBvbiB0aGUgcGFnZSBvciB0aGV5IHdpbGwgYmUgZnVsbHkgcmVtb3ZlZCxcbiAgICAgICAgLy8gc28gd2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHBydW5pbmdDSURzLlxuICAgICAgICB0aGlzLnBydW5pbmdDSURzID0gdGhpcy5wcnVuaW5nQ0lEcy5maWx0ZXIoY2lkID0+IHdpbGxEZXN0cm95Q0lEcy5pbmRleE9mKGNpZCkgIT09IC0xKVxuXG4gICAgICAgIC8vIFNlZSBpZiBhbnkgb2YgdGhlIGNpZHMgd2Ugd2FudGVkIHRvIGRlc3Ryb3kgd2VyZSBhZGRlZCBiYWNrLFxuICAgICAgICAvLyBpZiB0aGV5IHdlcmUgYWRkZWQgYmFjaywgd2UgZG9uJ3QgYWN0dWFsbHkgZGVzdHJveSB0aGVtLlxuICAgICAgICBsZXQgY29tcGxldGVseURlc3Ryb3lDSURzID0gd2lsbERlc3Ryb3lDSURzLmZpbHRlcihjaWQgPT4ge1xuICAgICAgICAgIHJldHVybiBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYoY29tcGxldGVseURlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfZGVzdHJveWVkXCIsIHtjaWRzOiBjb21wbGV0ZWx5RGVzdHJveUNJRHN9LCAocmVzcCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZC5wcnVuZUNJRHMocmVzcC5jaWRzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgb3duc0VsZW1lbnQoZWwpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCkgPT09IHRoaXMuaWQgfHxcbiAgICAgIG1heWJlKGVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBub2RlID0+IG5vZGUuaWQpID09PSB0aGlzLmlkXG4gIH1cblxuICBzdWJtaXRGb3JtKGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMgPSB7fSl7XG4gICAgRE9NLnB1dFByaXZhdGUoZm9ybSwgUEhYX0hBU19TVUJNSVRURUQsIHRydWUpXG4gICAgbGV0IHBoeEZlZWRiYWNrID0gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUilcbiAgICBsZXQgaW5wdXRzID0gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICAgIHRoaXMubGl2ZVNvY2tldC5ibHVyQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cywgKCkgPT4ge1xuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gRE9NLnNob3dFcnJvcihpbnB1dCwgcGh4RmVlZGJhY2spKVxuICAgICAgdGhpcy5saXZlU29ja2V0LnJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKVxuICAgIH0pXG4gIH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoa2luZCkgfVxufVxuIiwgIi8qKiBJbml0aWFsaXplcyB0aGUgTGl2ZVNvY2tldFxuICpcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzczovL2V4YW1wbGUuY29tL2xpdmVcImAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL2xpdmVcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge1Bob2VuaXguU29ja2V0fSBzb2NrZXQgLSB0aGUgcmVxdWlyZWQgUGhvZW5peCBTb2NrZXQgY2xhc3MgaW1wb3J0ZWQgZnJvbSBcInBob2VuaXhcIi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gKiAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICogICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uLiBPdXRzaWRlIG9mIGtleXMgbGlzdGVkIGJlbG93LCBhbGxcbiAqIGNvbmZpZ3VyYXRpb24gaXMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBQaG9lbml4IFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0c10gLSBUaGUgb3B0aW9uYWwgZGVmYXVsdHMgdG8gdXNlIGZvciB2YXJpb3VzIGJpbmRpbmdzLFxuICogc3VjaCBhcyBgcGh4LWRlYm91bmNlYC4gU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBrZXlzOlxuICpcbiAqICAgLSBkZWJvdW5jZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtZGVib3VuY2UgdGltZS4gRGVmYXVsdHMgMzAwXG4gKiAgIC0gdGhyb3R0bGUgLSB0aGUgbWlsbGlzZWNvbmQgcGh4LXRocm90dGxlIHRpbWUuIERlZmF1bHRzIDMwMFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gZm9yIHBhc3NpbmcgY29ubmVjdCBwYXJhbXMuXG4gKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gTGl2ZVZpZXcuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAoZWwpID0+IHt2aWV3OiBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW15LXZpZXctbmFtZVwiLCB0b2tlbjogd2luZG93Lm15VG9rZW59XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmRpbmdQcmVmaXhdIC0gVGhlIG9wdGlvbmFsIHByZWZpeCB0byB1c2UgZm9yIGFsbCBwaHggRE9NIGFubm90YXRpb25zLlxuICogRGVmYXVsdHMgdG8gXCJwaHgtXCIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuaG9va3NdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgaG9vayBjYWxsYmFja3MuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMudXBsb2FkZXJzXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgZm9yIHJlZmVyZW5jaW5nIExpdmVWaWV3IHVwbG9hZGVyIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubG9hZGVyVGltZW91dF0gLSBUaGUgb3B0aW9uYWwgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGFwcGx5XG4gKiBsb2FkaW5nIHN0YXRlcy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubWF4UmVsb2Fkc10gLSBUaGUgbWF4aW11bSByZWxvYWRzIGJlZm9yZSBlbnRlcmluZyBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5yZWxvYWRKaXR0ZXJNaW5dIC0gVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIG5vcm1hbCByZWxvYWQgYXR0ZW1wdHMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1heF0gLSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMuZmFpbHNhZmVKaXR0ZXJdIC0gVGhlIHRpbWUgYmV0d2VlbiByZWxvYWQgYXR0ZW1wdHMgaW4gZmFpbHNhZmUgbW9kZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnZpZXdMb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvZyBkZWJ1ZyBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4gY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5tZXRhZGF0YV0gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gZnVuY3Rpb25zIGZvclxuICogcG9wdWxhdGluZyBldmVudCBtZXRhZGF0YS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIG1ldGFkYXRhOiB7XG4gKiAgICAgICBjbGljazogKGUsIGVsKSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBkZXRhaWw6IGUuZGV0YWlsIHx8IDEsXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICBrZXlkb3duOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBrZXk6IGUua2V5LFxuICogICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gKiAgICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBVc2VmdWwgd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgc2Vzc2lvblN0b3JhZ2VgLiAgRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAqIGhhcHBlbiBpZiBhIHNpdGUgbG9hZHMgYSBjcm9zcy1kb21haW4gTGl2ZVZpZXcgaW4gYW4gaWZyYW1lLiAgRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgY2xhc3MgSW5NZW1vcnlTdG9yYWdlIHtcbiAqICAgICAgIGNvbnN0cnVjdG9yKCkgeyB0aGlzLnN0b3JhZ2UgPSB7fSB9XG4gKiAgICAgICBnZXRJdGVtKGtleU5hbWUpIHsgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB9XG4gKiAgICAgICByZW1vdmVJdGVtKGtleU5hbWUpIHsgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB9XG4gKiAgICAgICBzZXRJdGVtKGtleU5hbWUsIGtleVZhbHVlKSB7IHRoaXMuc3RvcmFnZVtrZXlOYW1lXSA9IGtleVZhbHVlIH1cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmxvY2FsU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBVc2VmdWwgZm9yIHdoZW4gTGl2ZVZpZXcgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYGxvY2FsU3RvcmFnZWAuXG4gKiBTZWUgYG9wdHMuc2Vzc2lvblN0b3JhZ2VgIGZvciBleGFtcGxlcy5cbiovXG5cbmltcG9ydCB7XG4gIEJJTkRJTkdfUFJFRklYLFxuICBDT05TRUNVVElWRV9SRUxPQURTLFxuICBERUZBVUxUUyxcbiAgRkFJTFNBRkVfSklUVEVSLFxuICBMT0FERVJfVElNRU9VVCxcbiAgTUFYX1JFTE9BRFMsXG4gIFBIWF9ERUJPVU5DRSxcbiAgUEhYX0RST1BfVEFSR0VULFxuICBQSFhfSEFTX0ZPQ1VTRUQsXG4gIFBIWF9LRVksXG4gIFBIWF9MSU5LX1NUQVRFLFxuICBQSFhfTElWRV9MSU5LLFxuICBQSFhfTFZfREVCVUcsXG4gIFBIWF9MVl9MQVRFTkNZX1NJTSxcbiAgUEhYX0xWX1BST0ZJTEUsXG4gIFBIWF9NQUlOLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9USFJPVFRMRSxcbiAgUEhYX1RSQUNLX1VQTE9BRFMsXG4gIFBIWF9TRVNTSU9OLFxuICBSRUxPQURfSklUVEVSX01JTixcbiAgUkVMT0FEX0pJVFRFUl9NQVgsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb25lLFxuICBjbG9zZXN0UGh4QmluZGluZyxcbiAgY2xvc3VyZSxcbiAgZGVidWcsXG4gIGlzT2JqZWN0LFxuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IEhvb2tzIGZyb20gXCIuL2hvb2tzXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgVmlldyBmcm9tIFwiLi92aWV3XCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVTb2NrZXQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHBoeFNvY2tldCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnVubG9hZGVkID0gZmFsc2VcbiAgICBpZighcGh4U29ja2V0IHx8IHBoeFNvY2tldC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBhIHBob2VuaXggU29ja2V0IG11c3QgYmUgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGl2ZVNvY2tldCBjb25zdHJ1Y3Rvci4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuICAgICAgICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbiAgICAgICAgICBsZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7Li4ufSlcbiAgICAgIGApXG4gICAgfVxuICAgIHRoaXMuc29ja2V0ID0gbmV3IHBoeFNvY2tldCh1cmwsIG9wdHMpXG4gICAgdGhpcy5iaW5kaW5nUHJlZml4ID0gb3B0cy5iaW5kaW5nUHJlZml4IHx8IEJJTkRJTkdfUFJFRklYXG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnZpZXdMb2dnZXIgPSBvcHRzLnZpZXdMb2dnZXJcbiAgICB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzID0gb3B0cy5tZXRhZGF0YSB8fCB7fVxuICAgIHRoaXMuZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKGNsb25lKERFRkFVTFRTKSwgb3B0cy5kZWZhdWx0cyB8fCB7fSlcbiAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZVxuICAgIHRoaXMubWFpbiA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5jbGlja1JlZiA9IDFcbiAgICB0aGlzLnJvb3RzID0ge31cbiAgICB0aGlzLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZSh3aW5kb3cubG9jYXRpb24pXG4gICAgdGhpcy5ob29rcyA9IG9wdHMuaG9va3MgfHwge31cbiAgICB0aGlzLnVwbG9hZGVycyA9IG9wdHMudXBsb2FkZXJzIHx8IHt9XG4gICAgdGhpcy5sb2FkZXJUaW1lb3V0ID0gb3B0cy5sb2FkZXJUaW1lb3V0IHx8IExPQURFUl9USU1FT1VUXG4gICAgdGhpcy5tYXhSZWxvYWRzID0gb3B0cy5tYXhSZWxvYWRzIHx8IE1BWF9SRUxPQURTXG4gICAgdGhpcy5yZWxvYWRKaXR0ZXJNaW4gPSBvcHRzLnJlbG9hZEppdHRlck1pbiB8fCBSRUxPQURfSklUVEVSX01JTlxuICAgIHRoaXMucmVsb2FkSml0dGVyTWF4ID0gb3B0cy5yZWxvYWRKaXR0ZXJNYXggfHwgUkVMT0FEX0pJVFRFUl9NQVhcbiAgICB0aGlzLmZhaWxzYWZlSml0dGVyID0gb3B0cy5mYWlsc2FmZUppdHRlciB8fCBGQUlMU0FGRV9KSVRURVJcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG9wdHMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICB0aGlzLnNlc3Npb25TdG9yYWdlID0gb3B0cy5zZXNzaW9uU3RvcmFnZSB8fCB3aW5kb3cuc2Vzc2lvblN0b3JhZ2VcbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSBmYWxzZVxuICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7b25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSwgb25CZWZvcmVFbFVwZGF0ZWQ6IGNsb3N1cmUoKX0sIG9wdHMuZG9tIHx8IHt9KVxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvblNldCgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICB0aGlzLnVubG9hZGVkID0gdHJ1ZVxuICAgIH0pXG4gICAgdGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuaXNVbmxvYWRlZCgpKXtcbiAgICAgICAgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGUgYW5kIGJyb3dzZXIgZG9lcyBub3QgZW1pdCBcInBhZ2VzaG93XCJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHB1YmxpY1xuXG4gIGlzUHJvZmlsZUVuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRW5hYmxlZCgpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ERUJVRykgPT09IFwidHJ1ZVwiIH1cblxuICBlbmFibGVEZWJ1ZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIikgfVxuXG4gIGVuYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKSB9XG5cbiAgZGlzYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfREVCVUcpIH1cblxuICBkaXNhYmxlUHJvZmlsaW5nKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfUFJPRklMRSkgfVxuXG4gIGVuYWJsZUxhdGVuY3lTaW0odXBwZXJCb3VuZE1zKXtcbiAgICB0aGlzLmVuYWJsZURlYnVnKClcbiAgICBjb25zb2xlLmxvZyhcImxhdGVuY3kgc2ltdWxhdG9yIGVuYWJsZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGlzIGJyb3dzZXIgc2Vzc2lvbi4gQ2FsbCBkaXNhYmxlTGF0ZW5jeVNpbSgpIHRvIGRpc2FibGVcIilcbiAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNLCB1cHBlckJvdW5kTXMpXG4gIH1cblxuICBkaXNhYmxlTGF0ZW5jeVNpbSgpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKSB9XG5cbiAgZ2V0TGF0ZW5jeVNpbSgpe1xuICAgIGxldCBzdHIgPSB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKVxuICAgIHJldHVybiBzdHIgPyBwYXJzZUludChzdHIpIDogbnVsbFxuICB9XG5cbiAgZ2V0U29ja2V0KCl7IHJldHVybiB0aGlzLnNvY2tldCB9XG5cbiAgY29ubmVjdCgpe1xuICAgIGxldCBkb0Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgICBpZih0aGlzLmpvaW5Sb290Vmlld3MoKSl7XG4gICAgICAgIHRoaXMuYmluZFRvcExldmVsRXZlbnRzKClcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKFtcImNvbXBsZXRlXCIsIFwibG9hZGVkXCIsIFwiaW50ZXJhY3RpdmVcIl0uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKSA+PSAwKXtcbiAgICAgIGRvQ29ubmVjdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IGRvQ29ubmVjdCgpKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2speyB0aGlzLnNvY2tldC5kaXNjb25uZWN0KGNhbGxiYWNrKSB9XG5cbiAgZXhlY0pTKGVsLCBlbmNvZGVkSlMsIGV2ZW50VHlwZSA9IG51bGwpe1xuICAgIHRoaXMub3duZXIoZWwsIHZpZXcgPT4gSlMuZXhlYyhldmVudFR5cGUsIGVuY29kZWRKUywgdmlldywgZWwpKVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIHRyaWdnZXJET00oa2luZCwgYXJncyl7IHRoaXMuZG9tQ2FsbGJhY2tzW2tpbmRdKC4uLmFyZ3MpIH1cblxuICB0aW1lKG5hbWUsIGZ1bmMpe1xuICAgIGlmKCF0aGlzLmlzUHJvZmlsZUVuYWJsZWQoKSB8fCAhY29uc29sZS50aW1lKXsgcmV0dXJuIGZ1bmMoKSB9XG4gICAgY29uc29sZS50aW1lKG5hbWUpXG4gICAgbGV0IHJlc3VsdCA9IGZ1bmMoKVxuICAgIGNvbnNvbGUudGltZUVuZChuYW1lKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGxvZyh2aWV3LCBraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgaWYodGhpcy52aWV3TG9nZ2VyKXtcbiAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKVxuICAgICAgdGhpcy52aWV3TG9nZ2VyKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH0gZWxzZSBpZih0aGlzLmlzRGVidWdFbmFibGVkKCkpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICBkZWJ1Zyh2aWV3LCBraW5kLCBtc2csIG9iailcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0RE9NVXBkYXRlKGNhbGxiYWNrKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFmdGVyKGNhbGxiYWNrKVxuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpe30pe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICBvbkNoYW5uZWwoY2hhbm5lbCwgZXZlbnQsIGNiKXtcbiAgICBjaGFubmVsLm9uKGV2ZW50LCBkYXRhID0+IHtcbiAgICAgIGxldCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKClcbiAgICAgIGlmKCFsYXRlbmN5KXtcbiAgICAgICAgY2IoZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBzaW11bGF0aW5nICR7bGF0ZW5jeX1tcyBvZiBsYXRlbmN5IGZyb20gc2VydmVyIHRvIGNsaWVudGApXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2IoZGF0YSksIGxhdGVuY3kpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdyYXBQdXNoKHZpZXcsIG9wdHMsIHB1c2gpe1xuICAgIGxldCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKClcbiAgICBsZXQgb2xkSm9pbkNvdW50ID0gdmlldy5qb2luQ291bnRcbiAgICBpZighbGF0ZW5jeSl7XG4gICAgICBpZihvcHRzLnRpbWVvdXQpe1xuICAgICAgICByZXR1cm4gcHVzaCgpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgICAgICBpZih2aWV3LmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50ICYmICF2aWV3LmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2codmlldywgXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJgKVxuICAgIGxldCBmYWtlUHVzaCA9IHtcbiAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgIHJlY2VpdmUoa2luZCwgY2IpeyB0aGlzLnJlY2VpdmVzLnB1c2goW2tpbmQsIGNiXSkgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgICBmYWtlUHVzaC5yZWNlaXZlcy5yZWR1Y2UoKGFjYywgW2tpbmQsIGNiXSkgPT4gYWNjLnJlY2VpdmUoa2luZCwgY2IpLCBwdXNoKCkpXG4gICAgfSwgbGF0ZW5jeSlcbiAgICByZXR1cm4gZmFrZVB1c2hcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKXtcbiAgICB2aWV3LmRlc3Ryb3koKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgbGV0IG1pbk1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNaW5cbiAgICBsZXQgbWF4TXMgPSB0aGlzLnJlbG9hZEppdHRlck1heFxuICAgIGxldCBhZnRlck1zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heE1zIC0gbWluTXMgKyAxKSkgKyBtaW5Nc1xuICAgIGxldCB0cmllcyA9IEJyb3dzZXIudXBkYXRlTG9jYWwodGhpcy5sb2NhbFN0b3JhZ2UsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgQ09OU0VDVVRJVkVfUkVMT0FEUywgMCwgY291bnQgPT4gY291bnQgKyAxKVxuICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKVxuICAgIGlmKHRyaWVzID4gdGhpcy5tYXhSZWxvYWRzKXtcbiAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7dGhpcy5tYXhSZWxvYWRzfSBjb25zZWN1dGl2ZSByZWxvYWRzLiBFbnRlcmluZyBmYWlsc2FmZSBtb2RlYF0pXG4gICAgICBhZnRlck1zID0gdGhpcy5mYWlsc2FmZUppdHRlclxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSl7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIGFmdGVyTXMpXG4gIH1cblxuICBnZXRIb29rQ2FsbGJhY2tzKG5hbWUpe1xuICAgIHJldHVybiBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aChcIlBob2VuaXguXCIpID8gSG9va3NbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXVxuICB9XG5cbiAgaXNVbmxvYWRlZCgpeyByZXR1cm4gdGhpcy51bmxvYWRlZCB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgfVxuXG4gIGdldEJpbmRpbmdQcmVmaXgoKXsgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeCB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIGAke3RoaXMuZ2V0QmluZGluZ1ByZWZpeCgpfSR7a2luZH1gIH1cblxuICBjaGFubmVsKHRvcGljLCBwYXJhbXMpeyByZXR1cm4gdGhpcy5zb2NrZXQuY2hhbm5lbCh0b3BpYywgcGFyYW1zKSB9XG5cbiAgam9pblJvb3RWaWV3cygpe1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2VcbiAgICBET00uYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCByb290RWwgPT4ge1xuICAgICAgaWYoIXRoaXMuZ2V0Um9vdEJ5SWQocm9vdEVsLmlkKSl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpXG4gICAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSlcbiAgICAgICAgdmlldy5qb2luKClcbiAgICAgICAgaWYocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpeyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIH1cbiAgICAgIHJvb3RzRm91bmQgPSB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdHNGb3VuZFxuICB9XG5cbiAgcmVkaXJlY3QodG8sIGZsYXNoKXtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIEJyb3dzZXIucmVkaXJlY3QodG8sIGZsYXNoKVxuICB9XG5cbiAgcmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIGNhbGxiYWNrID0gbnVsbCwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpe1xuICAgIGxldCBvbGRNYWluRWwgPSB0aGlzLm1haW4uZWxcbiAgICBsZXQgbmV3TWFpbkVsID0gRE9NLmNsb25lTm9kZShvbGRNYWluRWwsIFwiXCIpXG4gICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMubWFpbi5kZXN0cm95KClcblxuICAgIHRoaXMubWFpbiA9IHRoaXMubmV3Um9vdFZpZXcobmV3TWFpbkVsLCBmbGFzaClcbiAgICB0aGlzLm1haW4uc2V0UmVkaXJlY3QoaHJlZilcbiAgICB0aGlzLnRyYW5zaXRpb25SZW1vdmVzKClcbiAgICB0aGlzLm1haW4uam9pbigoam9pbkNvdW50LCBvbkRvbmUpID0+IHtcbiAgICAgIGlmKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBET00uZmluZFBoeFN0aWNreShkb2N1bWVudCkuZm9yRWFjaChlbCA9PiBuZXdNYWluRWwuYXBwZW5kQ2hpbGQoZWwpKVxuICAgICAgICAgIG9sZE1haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzKXtcbiAgICBsZXQgcmVtb3ZlQXR0ciA9IHRoaXMuYmluZGluZyhcInJlbW92ZVwiKVxuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgfHwgRE9NLmFsbChkb2N1bWVudCwgYFske3JlbW92ZUF0dHJ9XWApXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZihkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSl7IC8vIHNraXAgY2hpbGRyZW4gYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlzUGh4VmlldyhlbCl7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCB9XG5cbiAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoKXtcbiAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLCBudWxsLCBmbGFzaClcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlld1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICBvd25lcihjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBlbCA9PiB0aGlzLmdldFZpZXdCeUVsKGVsKSkgfHwgdGhpcy5tYWluXG4gICAgaWYodmlldyl7IGNhbGxiYWNrKHZpZXcpIH1cbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgdGhpcy5vd25lcihjaGlsZEVsLCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKVxuICB9XG5cbiAgZ2V0Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpXG4gICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgcm9vdCA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSlcbiAgfVxuXG4gIGdldFJvb3RCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdHNbaWRdIH1cblxuICBkZXN0cm95QWxsVmlld3MoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdHMpe1xuICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tpZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290ID0gdGhpcy5nZXRSb290QnlJZChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpKVxuICAgIGlmKHJvb3QgJiYgcm9vdC5pZCA9PT0gZWwuaWQpe1xuICAgICAgcm9vdC5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdXG4gICAgfSBlbHNlIGlmKHJvb3Qpe1xuICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZClcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmVFbGVtZW50KHRhcmdldCl7XG4gICAgaWYodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpeyByZXR1cm4gfVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IHRhcmdldFxuICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBpZih0YXJnZXQgPT09IHRoaXMuYWN0aXZlRWxlbWVudCl7IHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGwgfVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMpXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMpXG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBjYW5jZWwpXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBjYW5jZWwpXG4gIH1cblxuICBnZXRBY3RpdmVFbGVtZW50KCl7XG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keVxuICAgIH1cbiAgfVxuXG4gIGRyb3BBY3RpdmVFbGVtZW50KHZpZXcpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB2aWV3Lm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgYmx1ckFjdGl2ZUVsZW1lbnQoKXtcbiAgICB0aGlzLnByZXZBY3RpdmUgPSB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7IHRoaXMucHJldkFjdGl2ZS5ibHVyKCkgfVxuICB9XG5cbiAgYmluZFRvcExldmVsRXZlbnRzKCl7XG4gICAgaWYodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWVcbiAgICAvLyBlbnRlciBmYWlsc2FmZSByZWxvYWQgaWYgc2VydmVyIGhhcyBnb25lIGF3YXkgaW50ZW50aW9uYWxseSwgc3VjaCBhcyBcImRpc2Nvbm5lY3RcIiBicm9hZGNhc3RcbiAgICB0aGlzLnNvY2tldC5vbkNsb3NlKGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50LmNvZGUgPT09IDEwMDAgJiYgdGhpcy5tYWluKXtcbiAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHRoaXMubWFpbilcbiAgICAgIH1cbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpeyB9KSAvLyBlbnN1cmUgYWxsIGNsaWNrIGV2ZW50cyBidWJibGUgZm9yIG1vYmlsZSBTYWZhcmlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIGUgPT4ge1xuICAgICAgaWYoZS5wZXJzaXN0ZWQpeyAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZVxuICAgICAgICB0aGlzLmdldFNvY2tldCgpLmRpc2Nvbm5lY3QoKVxuICAgICAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9KVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9LCB0cnVlKVxuICAgIHRoaXMuYmluZE5hdigpXG4gICAgdGhpcy5iaW5kQ2xpY2tzKClcbiAgICB0aGlzLmJpbmRGb3JtcygpXG4gICAgdGhpcy5iaW5kKHtrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9LRVkpKVxuICAgICAgbGV0IHByZXNzZWRLZXkgPSBlLmtleSAmJiBlLmtleS50b0xvd2VyQ2FzZSgpIC8vIGNocm9tZSBjbGlja2VkIGF1dG9jb21wbGV0ZXMgc2VuZCBhIGtleWRvd24gd2l0aG91dCBrZXlcbiAgICAgIGlmKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBpZighZXZlbnRUYXJnZXQpe1xuICAgICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiYmx1clwiLCBmb2N1czogXCJmb2N1c1wifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgIC8vIGJsdXIgYW5kIGZvY3VzIGFyZSB0cmlnZ2VyZWQgb24gZG9jdW1lbnQgYW5kIHdpbmRvdy4gRGlzY2FyZCBvbmUgdG8gYXZvaWQgZHVwc1xuICAgICAgaWYocGh4VGFyZ2V0ID09PSBcIndpbmRvd1wiKXtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbClcbiAgICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsZXQgZHJvcFRhcmdldElkID0gbWF5YmUoY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKSwgdHJ1ZVRhcmdldCA9PiB7XG4gICAgICAgIHJldHVybiB0cnVlVGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSlcbiAgICAgIH0pXG4gICAgICBsZXQgZHJvcFRhcmdldCA9IGRyb3BUYXJnZXRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcm9wVGFyZ2V0SWQpXG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzIHx8IFtdKVxuICAgICAgaWYoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKXsgcmV0dXJuIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMpXG4gICAgICBkcm9wVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIGUgPT4ge1xuICAgICAgbGV0IHVwbG9hZFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZighRE9NLmlzVXBsb2FkSW5wdXQodXBsb2FkVGFyZ2V0KSl7IHJldHVybiB9XG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGV0YWlsLmZpbGVzIHx8IFtdKS5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYilcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpXG4gICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gIH1cblxuICBldmVudE1ldGEoZXZlbnROYW1lLCBlLCB0YXJnZXRFbCl7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tZXRhZGF0YUNhbGxiYWNrc1tldmVudE5hbWVdXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZSwgdGFyZ2V0RWwpIDoge31cbiAgfVxuXG4gIHNldFBlbmRpbmdMaW5rKGhyZWYpe1xuICAgIHRoaXMubGlua1JlZisrXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IGhyZWZcbiAgICByZXR1cm4gdGhpcy5saW5rUmVmXG4gIH1cblxuICBjb21taXRQZW5kaW5nTGluayhsaW5rUmVmKXtcbiAgICBpZih0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGdldEhyZWYoKXsgcmV0dXJuIHRoaXMuaHJlZiB9XG5cbiAgaGFzUGVuZGluZ0xpbmsoKXsgcmV0dXJuICEhdGhpcy5wZW5kaW5nTGluayB9XG5cbiAgYmluZChldmVudHMsIGNhbGxiYWNrKXtcbiAgICBmb3IobGV0IGV2ZW50IGluIGV2ZW50cyl7XG4gICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF1cblxuICAgICAgdGhpcy5vbihicm93c2VyRXZlbnROYW1lLCBlID0+IHtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcoZXZlbnQpXG4gICAgICAgIGxldCB3aW5kb3dCaW5kaW5nID0gdGhpcy5iaW5kaW5nKGB3aW5kb3ctJHtldmVudH1gKVxuICAgICAgICBsZXQgdGFyZ2V0UGh4RXZlbnQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKGJpbmRpbmcpXG4gICAgICAgIGlmKHRhcmdldFBoeEV2ZW50KXtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3dpbmRvd0JpbmRpbmd9XWAsIGVsID0+IHtcbiAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGVsLCBwaHhFdmVudCwgXCJ3aW5kb3dcIilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBiaW5kQ2xpY2tzKCl7XG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIsIGZhbHNlKVxuICAgIHRoaXMuYmluZENsaWNrKFwibW91c2Vkb3duXCIsIFwiY2FwdHVyZS1jbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUsIGNhcHR1cmUpe1xuICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGUgPT4ge1xuICAgICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG4gICAgICB0aGlzLmNsaWNrUmVmKytcbiAgICAgIGxldCBjbGlja1JlZldhcyA9IHRoaXMuY2xpY2tSZWZcbiAgICAgIGxldCB0YXJnZXQgPSBudWxsXG4gICAgICBpZihjYXB0dXJlKXtcbiAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQubWF0Y2hlcyhgWyR7Y2xpY2t9XWApID8gZS50YXJnZXQgOiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yKGBbJHtjbGlja31dYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBjbGljaylcbiAgICAgICAgdGhpcy5kaXNwYXRjaENsaWNrQXdheShlLCBjbGlja1JlZldhcylcbiAgICAgIH1cbiAgICAgIGxldCBwaHhFdmVudCA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKGNsaWNrKVxuICAgICAgaWYoIXBoeEV2ZW50KXsgcmV0dXJuIH1cbiAgICAgIGlmKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIil7IGUucHJldmVudERlZmF1bHQoKSB9XG5cbiAgICAgIHRoaXMuZGVib3VuY2UodGFyZ2V0LCBlLCAoKSA9PiB7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKHRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXQsIFtcInB1c2hcIiwge2RhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgdGFyZ2V0KX1dKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LCBjYXB0dXJlKVxuICB9XG5cbiAgZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tSZWZXYXMpe1xuICAgIGxldCBwaHhDbGlja0F3YXkgPSB0aGlzLmJpbmRpbmcoXCJjbGljay1hd2F5XCIpXG4gICAgbGV0IHBoeENsaWNrID0gdGhpcy5iaW5kaW5nKFwiY2xpY2tcIilcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7cGh4Q2xpY2tBd2F5fV1gLCBlbCA9PiB7XG4gICAgICBpZighKGVsLmlzU2FtZU5vZGUoZS50YXJnZXQpIHx8IGVsLmNvbnRhaW5zKGUudGFyZ2V0KSkpe1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHBoeENsaWNrQXdheSlcbiAgICAgICAgICBpZihKUy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldC5jbG9zZXN0KGBbJHtwaHhDbGlja31dYCkgfHwgZS50YXJnZXRcbiAgICAgICAgICAgIEpTLmV4ZWMoXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgZWwsIFtcInB1c2hcIiwge2RhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgZS50YXJnZXQpfV0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kTmF2KCl7XG4gICAgaWYoIUJyb3dzZXIuY2FuUHVzaFN0YXRlKCkpeyByZXR1cm4gfVxuICAgIGlmKGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24peyBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIiB9XG4gICAgbGV0IHNjcm9sbFRpbWVyID0gbnVsbFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIF9lID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChzY3JvbGxUaW1lcilcbiAgICAgIHNjcm9sbFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIudXBkYXRlQ3VycmVudFN0YXRlKHN0YXRlID0+IE9iamVjdC5hc3NpZ24oc3RhdGUsIHtzY3JvbGw6IHdpbmRvdy5zY3JvbGxZfSkpXG4gICAgICB9LCAxMDApXG4gICAgfSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmKCF0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKSl7IHJldHVybiB9XG4gICAgICBsZXQge3R5cGUsIGlkLCByb290LCBzY3JvbGx9ID0gZXZlbnQuc3RhdGUgfHwge31cbiAgICAgIGxldCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodGhpcy5tYWluLmlzQ29ubmVjdGVkKCkgJiYgKHR5cGUgPT09IFwicGF0Y2hcIiAmJiBpZCA9PT0gdGhpcy5tYWluLmlkKSl7XG4gICAgICAgICAgdGhpcy5tYWluLnB1c2hMaW5rUGF0Y2goaHJlZiwgbnVsbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIGlmKHJvb3QpeyB0aGlzLnJlcGxhY2VSb290SGlzdG9yeSgpIH1cbiAgICAgICAgICAgIGlmKHR5cGVvZihzY3JvbGwpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHNjcm9sbClcbiAgICAgICAgICAgICAgfSwgMCkgLy8gdGhlIGJvZHkgbmVlZHMgdG8gcmVuZGVyIGJlZm9yZSB3ZSBzY3JvbGwuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgbGV0IHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBQSFhfTElWRV9MSU5LKVxuICAgICAgbGV0IHR5cGUgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElWRV9MSU5LKVxuICAgICAgbGV0IHdhbnRzTmV3VGFiID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLmJ1dHRvbiA9PT0gMVxuICAgICAgaWYoIXR5cGUgfHwgIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluIHx8IHdhbnRzTmV3VGFiKXsgcmV0dXJuIH1cbiAgICAgIGxldCBocmVmID0gdGFyZ2V0LmhyZWZcbiAgICAgIGxldCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBpZih0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJwYXRjaFwiKXtcbiAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBgcGh4OiR7ZXZlbnR9YCwgcGF5bG9hZClcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnRzKGV2ZW50cyl7XG4gICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpXG4gIH1cblxuICB3aXRoUGFnZUxvYWRpbmcoaW5mbywgY2FsbGJhY2spe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8pXG4gICAgbGV0IGRvbmUgPSAoKSA9PiBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIGluZm8pXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZG9uZSkgOiBkb25lXG4gIH1cblxuICBwdXNoSGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgdGFyZ2V0RWwpe1xuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJwYXRjaFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgbGlua1JlZiA9PiB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZilcbiAgICAgICAgZG9uZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgaWYoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpeyByZXR1cm4gfVxuXG4gICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSwgaHJlZilcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gpe1xuICAgIGxldCBzY3JvbGwgPSB3aW5kb3cuc2Nyb2xsWVxuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIGZsYXNoLCAoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge3R5cGU6IFwicmVkaXJlY3RcIiwgaWQ6IHRoaXMubWFpbi5pZCwgc2Nyb2xsOiBzY3JvbGx9LCBocmVmKVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VSb290SGlzdG9yeSgpe1xuICAgIEJyb3dzZXIucHVzaFN0YXRlKFwicmVwbGFjZVwiLCB7cm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgSlMuZXhlYyhcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwge31dKVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcblxuICAgIGZvcihsZXQgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSl7XG4gICAgICB0aGlzLm9uKHR5cGUsIGUgPT4ge1xuICAgICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldFxuICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dC5mb3JtICYmIGlucHV0LmZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSlcbiAgICAgICAgaWYoIXBoeEV2ZW50KXsgcmV0dXJuIH1cbiAgICAgICAgaWYoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbnB1dC52YWxpZGl0eSAmJiBpbnB1dC52YWxpZGl0eS5iYWRJbnB1dCl7IHJldHVybiB9XG4gICAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnNcbiAgICAgICAgaXRlcmF0aW9ucysrXG4gICAgICAgIGxldCB7YXQ6IGF0LCB0eXBlOiBsYXN0VHlwZX0gPSBET00ucHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiKSB8fCB7fVxuICAgICAgICAvLyBkZXRlY3QgZHVwIGJlY2F1c2Ugc29tZSBicm93c2VycyBkaXNwYXRjaCBib3RoIFwiaW5wdXRcIiBhbmQgXCJjaGFuZ2VcIlxuICAgICAgICBpZihhdCA9PT0gY3VycmVudEl0ZXJhdGlvbnMgLSAxICYmIHR5cGUgIT09IGxhc3RUeXBlKXsgcmV0dXJuIH1cblxuICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7YXQ6IGN1cnJlbnRJdGVyYXRpb25zLCB0eXBlOiB0eXBlfSlcblxuICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoaW5wdXQuZm9ybSwgdmlldyA9PiB7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VELCB0cnVlKVxuICAgICAgICAgICAgaWYoIURPTS5pc1RleHR1YWxJbnB1dChpbnB1dCkpe1xuICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZUVsZW1lbnQoaW5wdXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBKUy5leGVjKFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB2aWV3LCBpbnB1dCwgW1wicHVzaFwiLCB7X3RhcmdldDogZS50YXJnZXQubmFtZX1dKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcGh4RGVib3VuY2UgPSB0aGlzLmJpbmRpbmcoUEhYX0RFQk9VTkNFKVxuICAgIGxldCBwaHhUaHJvdHRsZSA9IHRoaXMuYmluZGluZyhQSFhfVEhST1RUTEUpXG4gICAgbGV0IGRlZmF1bHREZWJvdW5jZSA9IHRoaXMuZGVmYXVsdHMuZGVib3VuY2UudG9TdHJpbmcoKVxuICAgIGxldCBkZWZhdWx0VGhyb3R0bGUgPSB0aGlzLmRlZmF1bHRzLnRocm90dGxlLnRvU3RyaW5nKClcbiAgICBET00uZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBjYWxsYmFjaylcbiAgfVxuXG4gIHNpbGVuY2VFdmVudHMoY2FsbGJhY2spe1xuICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlXG4gICAgY2FsbGJhY2soKVxuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZVxuICB9XG5cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiB7XG4gICAgICBpZighdGhpcy5zaWxlbmNlZCl7IGNhbGxiYWNrKGUpIH1cbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIFRyYW5zaXRpb25TZXQge1xuICBjb25zdHJ1Y3Rvcigpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLnBlbmRpbmdPcHMgPSBbXVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmZvckVhY2godGltZXIgPT4ge1xuICAgICAgY2FuY2VsVGltZW91dCh0aW1lcilcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKVxuICAgIH0pXG4gICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICB9XG5cbiAgYWZ0ZXIoY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc2l6ZSgpID09PSAwKXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoUGVuZGluZ09wKGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKXtcbiAgICBvblN0YXJ0KClcbiAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKVxuICAgICAgb25Eb25lKClcbiAgICAgIGlmKHRoaXMuc2l6ZSgpID09PSAwKXsgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKSB9XG4gICAgfSwgdGltZSlcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFkZCh0aW1lcilcbiAgfVxuXG4gIHB1c2hQZW5kaW5nT3Aob3ApeyB0aGlzLnBlbmRpbmdPcHMucHVzaChvcCkgfVxuXG4gIHNpemUoKXsgcmV0dXJuIHRoaXMudHJhbnNpdGlvbnMuc2l6ZSB9XG5cbiAgZmx1c2hQZW5kaW5nT3BzKCl7XG4gICAgdGhpcy5wZW5kaW5nT3BzLmZvckVhY2gob3AgPT4gb3AoKSlcbiAgICB0aGlzLnBlbmRpbmdPcHMgPSBbXVxuICB9XG59XG4iLCAiY2xhc3MgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuXG4gICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbmNlbGFibGU7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuICB9XG5cbiAgY2FuY2VsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbGVkO1xuICB9XG5cbiAgY2xvbmUoZGF0YSkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAuLi50aGlzLmRhdGEsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gIH1cbn1cblxuQWJzdHJhY3RFdmVudC50eXBlID0gJ2V2ZW50JztcblxuQWJzdHJhY3RFdmVudC5jYW5jZWxhYmxlID0gZmFsc2U7XG5cbmV4cG9ydCB7IEFic3RyYWN0RXZlbnQgfTtcbiIsICJjbGFzcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0UGx1Z2luIH07XG4iLCAiY29uc3QgZGVmYXVsdERlbGF5ID0ge1xuICBtb3VzZTogMCxcbiAgZHJhZzogMCxcbiAgdG91Y2g6IDEwMFxufTtcblxuY2xhc3MgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9IG51bGw7XG5cbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5kZWxheSA9IGNhbGNEZWxheShvcHRpb25zLmRlbGF5KTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XG4gIH1cblxuICByZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykge1xuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xuICB9XG5cbiAgdHJpZ2dlcihlbGVtZW50LCBzZW5zb3JFdmVudCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuZGV0YWlsID0gc2Vuc29yRXZlbnQ7XG4gICAgZXZlbnQuaW5pdEV2ZW50KHNlbnNvckV2ZW50LnR5cGUsIHRydWUsIHRydWUpO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgdGhpcy5sYXN0RXZlbnQgPSBzZW5zb3JFdmVudDtcbiAgICByZXR1cm4gc2Vuc29yRXZlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY0RlbGF5KG9wdGlvbnNEZWxheSkge1xuICBjb25zdCBkZWxheSA9IHt9O1xuICBpZiAob3B0aW9uc0RlbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdERlbGF5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnNEZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RGVsYXkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmYXVsdERlbGF5LCBrZXkpKSB7XG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RGVsYXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHREZWxheSwga2V5KSkge1xuICAgICAgaWYgKG9wdGlvbnNEZWxheVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsYXlba2V5XSA9IGRlZmF1bHREZWxheVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsYXlba2V5XSA9IG9wdGlvbnNEZWxheVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsYXk7XG59XG5cbmV4cG9ydCB7IFNlbnNvciBhcyBkZWZhdWx0IH07XG4iLCAiZnVuY3Rpb24gY2xvc2VzdChub2RlLCB2YWx1ZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY29uZGl0aW9uRm4oY3VycmVudE5vZGUpIHtcbiAgICBpZiAoY3VycmVudE5vZGUgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1NlbGVjdG9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMuY2FsbChjdXJyZW50Tm9kZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNOb2RlTGlzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbLi4udmFsdWVdLmluY2x1ZGVzKGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlKGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBsZXQgY3VycmVudCA9IG5vZGU7XG4gIGRvIHtcbiAgICBjdXJyZW50ID0gY3VycmVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBjdXJyZW50LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGN1cnJlbnQ7XG4gICAgaWYgKGNvbmRpdGlvbkZuKGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudE5vZGUgfHwgbnVsbDtcbiAgfSB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0b3IodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBOb2RlKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IHsgY2xvc2VzdCBhcyBkZWZhdWx0IH07XG4iLCAiZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiogMiArICh5MiAtIHkxKSAqKiAyKTtcbn1cblxuZXhwb3J0IHsgZGlzdGFuY2UgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIFNlbnNvckV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbEV2ZW50O1xuICB9XG5cbiAgZ2V0IGNsaWVudFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRYO1xuICB9XG5cbiAgZ2V0IGNsaWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRZO1xuICB9XG5cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRhcmdldDtcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb250YWluZXI7XG4gIH1cblxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcbiAgfVxuXG4gIGdldCBwcmVzc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xuICB9XG59XG5cbmNsYXNzIERyYWdTdGFydFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cblxuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcbmNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxuXG5EcmFnTW92ZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcbmNsYXNzIERyYWdTdG9wU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxuXG5EcmFnU3RvcFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcbmNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cbkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XG5cbmV4cG9ydCB7IERyYWdNb3ZlU2Vuc29yRXZlbnQsIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50LCBEcmFnU3RhcnRTZW5zb3JFdmVudCwgRHJhZ1N0b3BTZW5zb3JFdmVudCwgU2Vuc29yRXZlbnQgfTtcbiIsICJpbXBvcnQgY2xvc2VzdCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyc7XG5pbXBvcnQgZGlzdGFuY2UgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Rpc3RhbmNlL2Rpc3RhbmNlLm1qcyc7XG5pbXBvcnQgU2Vuc29yIGZyb20gJy4uL1NlbnNvci9TZW5zb3IubWpzJztcbmltcG9ydCB7IERyYWdTdGFydFNlbnNvckV2ZW50LCBEcmFnTW92ZVNlbnNvckV2ZW50LCBEcmFnU3RvcFNlbnNvckV2ZW50IH0gZnJvbSAnLi4vU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcblxuY29uc3Qgb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmcgPSBTeW1ib2woJ29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nJyk7XG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XG5cbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gbnVsbDtcblxuICAgIHRoaXMucGFnZVggPSBudWxsO1xuXG4gICAgdGhpcy5wYWdlWSA9IG51bGw7XG4gICAgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10gPSB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tzdGFydERyYWddID0gdGhpc1tzdGFydERyYWddLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgW29uTW91c2VEb3duXShldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIGV2ZW50LnRhcmdldCAmJiAhY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVsYXlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IGV2ZW50O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0pO1xuICAgIHRoaXMub25Nb3VzZURvd25BdCA9IERhdGUubm93KCk7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbFNvdXJjZTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKHtcbiAgICAgICAgcGFnZVg6IHRoaXMucGFnZVgsXG4gICAgICAgIHBhZ2VZOiB0aGlzLnBhZ2VZXG4gICAgICB9KTtcbiAgICB9LCBkZWxheS5tb3VzZSk7XG4gIH1cblxuICBbc3RhcnREcmFnXSgpIHtcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcbiAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2U7XG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogc3RhcnRFdmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogc3RhcnRFdmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgb3JpZ2luYWxFdmVudDogc3RhcnRFdmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIH1cbiAgfVxuXG4gIFtvbkRpc3RhbmNlQ2hhbmdlXShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlJDFcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0RXZlbnQsXG4gICAgICBkZWxheVxuICAgIH0gPSB0aGlzO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0pO1xuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Nb3VzZURvd25BdDtcbiAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9IGRpc3RhbmNlKHN0YXJ0RXZlbnQucGFnZVgsIHN0YXJ0RXZlbnQucGFnZVksIHBhZ2VYLCBwYWdlWSkgfHwgMDtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcbiAgICBpZiAodGltZUVsYXBzZWQgPCBkZWxheS5tb3VzZSkge1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVHJhdmVsbGVkID49IGRpc3RhbmNlJDEpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xuICAgICAgdGhpc1tzdGFydERyYWddKCk7XG4gICAgfVxuICB9XG5cbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgRHJhZ01vdmVTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcbiAgfVxuXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IERyYWdTdG9wU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gIH1cblxuICBbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJldmVudE5hdGl2ZURyYWdTdGFydChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5leHBvcnQgeyBNb3VzZVNlbnNvciBhcyBkZWZhdWx0IH07XG4iLCAiZnVuY3Rpb24gdG91Y2hDb29yZHMoZXZlbnQpIHtcbiAgY29uc3Qge1xuICAgIHRvdWNoZXMsXG4gICAgY2hhbmdlZFRvdWNoZXNcbiAgfSA9IGV2ZW50O1xuICByZXR1cm4gdG91Y2hlcyAmJiB0b3VjaGVzWzBdIHx8IGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzWzBdO1xufVxuXG5leHBvcnQgeyB0b3VjaENvb3JkcyBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IGRpc3RhbmNlIGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9kaXN0YW5jZS9kaXN0YW5jZS5tanMnO1xuaW1wb3J0IHRvdWNoQ29vcmRzIGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy90b3VjaENvb3Jkcy90b3VjaENvb3Jkcy5tanMnO1xuaW1wb3J0IFNlbnNvciBmcm9tICcuLi9TZW5zb3IvU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBEcmFnU3RhcnRTZW5zb3JFdmVudCwgRHJhZ01vdmVTZW5zb3JFdmVudCwgRHJhZ1N0b3BTZW5zb3JFdmVudCB9IGZyb20gJy4uL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uVG91Y2hTdGFydCA9IFN5bWJvbCgnb25Ub3VjaFN0YXJ0Jyk7XG5jb25zdCBvblRvdWNoRW5kID0gU3ltYm9sKCdvblRvdWNoRW5kJyk7XG5jb25zdCBvblRvdWNoTW92ZSA9IFN5bWJvbCgnb25Ub3VjaE1vdmUnKTtcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XG5cbmxldCBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudCA9PiB7XG4gIGlmICghcHJldmVudFNjcm9sbGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59LCB7XG4gIHBhc3NpdmU6IGZhbHNlXG59KTtcblxuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBTZW5zb3Ige1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmN1cnJlbnRTY3JvbGxhYmxlUGFyZW50ID0gbnVsbDtcblxuICAgIHRoaXMudGFwVGltZW91dCA9IG51bGw7XG5cbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucGFnZVggPSBudWxsO1xuXG4gICAgdGhpcy5wYWdlWSA9IG51bGw7XG4gICAgdGhpc1tvblRvdWNoU3RhcnRdID0gdGhpc1tvblRvdWNoU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblRvdWNoRW5kXSA9IHRoaXNbb25Ub3VjaEVuZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uVG91Y2hNb3ZlXSA9IHRoaXNbb25Ub3VjaE1vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tzdGFydERyYWddID0gdGhpc1tzdGFydERyYWddLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpc1tvblRvdWNoU3RhcnRdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpc1tvblRvdWNoU3RhcnRdKTtcbiAgfVxuXG4gIFtvblRvdWNoU3RhcnRdKGV2ZW50KSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgZXZlbnQudGFyZ2V0ICYmICFjbG9zZXN0KGV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSBjbG9zZXN0KGV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgaWYgKCFvcmlnaW5hbFNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkaXN0YW5jZSA9IDBcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB0b3VjaENvb3JkcyhldmVudCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSk7XG4gICAgdGhpcy5vblRvdWNoU3RhcnRBdCA9IERhdGUubm93KCk7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbFNvdXJjZTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XG4gICAgaWYgKGRpc3RhbmNlKSB7XG4gICAgICBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy50YXBUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7XG4gICAgICAgIHRvdWNoZXM6IFt7XG4gICAgICAgICAgcGFnZVg6IHRoaXMucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IHRoaXMucGFnZVlcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5LnRvdWNoKTtcbiAgfVxuXG4gIFtzdGFydERyYWddKCkge1xuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB0aGlzLnN0YXJ0RXZlbnQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xuICAgIGNvbnN0IHRvdWNoID0gdG91Y2hDb29yZHMoc3RhcnRFdmVudCk7XG4gICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlO1xuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxuICAgICAgY2xpZW50WTogdG91Y2gucGFnZVksXG4gICAgICB0YXJnZXQ6IHN0YXJ0RXZlbnQudGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xuICAgIH1cbiAgICBwcmV2ZW50U2Nyb2xsaW5nID0gdGhpcy5kcmFnZ2luZztcbiAgfVxuXG4gIFtvbkRpc3RhbmNlQ2hhbmdlXShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSQxXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBzdGFydEV2ZW50LFxuICAgICAgZGVsYXlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdGFydCA9IHRvdWNoQ29vcmRzKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0b3VjaENvb3JkcyhldmVudCk7XG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5vblRvdWNoU3RhcnRBdDtcbiAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9IGRpc3RhbmNlKHN0YXJ0LnBhZ2VYLCBzdGFydC5wYWdlWSwgY3VycmVudC5wYWdlWCwgY3VycmVudC5wYWdlWSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjdXJyZW50KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KTtcbiAgICBpZiAodGltZUVsYXBzZWQgPCBkZWxheS50b3VjaCkge1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVHJhdmVsbGVkID49IGRpc3RhbmNlJDEpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xuICAgICAgdGhpc1tzdGFydERyYWddKCk7XG4gICAgfVxuICB9XG5cbiAgW29uVG91Y2hNb3ZlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHRvdWNoQ29vcmRzKGV2ZW50KTtcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgRHJhZ01vdmVTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBwYWdlWCxcbiAgICAgIGNsaWVudFk6IHBhZ2VZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xuICB9XG5cbiAgW29uVG91Y2hFbmRdKGV2ZW50KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XG4gICAgcHJldmVudFNjcm9sbGluZyA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpc1tvblRvdWNoRW5kXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICBpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHRvdWNoQ29vcmRzKGV2ZW50KTtcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBEcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IHBhZ2VYLFxuICAgICAgY2xpZW50WTogcGFnZVksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gb25Db250ZXh0TWVudShldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IHsgVG91Y2hTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBTZW5zb3IgZnJvbSAnLi4vU2Vuc29yL1NlbnNvci5tanMnO1xuaW1wb3J0IHsgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQsIERyYWdNb3ZlU2Vuc29yRXZlbnQsIERyYWdTdG9wU2Vuc29yRXZlbnQgfSBmcm9tICcuLi9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcbmNvbnN0IG9uRHJhZ0VuZCA9IFN5bWJvbCgnb25EcmFnRW5kJyk7XG5jb25zdCBvbkRyb3AgPSBTeW1ib2woJ29uRHJvcCcpO1xuY29uc3QgcmVzZXQgPSBTeW1ib2woJ3Jlc2V0Jyk7XG5cbmNsYXNzIERyYWdTZW5zb3IgZXh0ZW5kcyBTZW5zb3Ige1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBudWxsO1xuXG4gICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnRW5kXSA9IHRoaXNbb25EcmFnRW5kXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Ecm9wXSA9IHRoaXNbb25Ecm9wXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gIH1cblxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XG5cbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsICcnKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IHRoaXMub3B0aW9ucy50eXBlO1xuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSB0aGlzLmRyYWdnYWJsZUVsZW1lbnQ7XG4gICAgaWYgKCFvcmlnaW5hbFNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBEcmFnU3RhcnRTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XG4gICAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xuICAgIGlmICghZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnRW5kXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IERyYWdTdG9wU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgIHRoaXNbcmVzZXRdKCk7XG4gIH1cblxuICBbb25Ecm9wXShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIChldmVudC50YXJnZXQuZm9ybSB8fCBldmVudC50YXJnZXQuY29udGVudGVkaXRhYmxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgdGFyZ2V0ICYmICFjbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSBjbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgaWYgKCFvcmlnaW5hbFNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gY2xvc2VzdChldmVudC50YXJnZXQsIGVsZW1lbnQgPT4gZWxlbWVudC5kcmFnZ2FibGUpO1xuICAgIGlmIChuYXRpdmVEcmFnZ2FibGVFbGVtZW50KSB7XG4gICAgICBuYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbmF0aXZlRHJhZ2dhYmxlRWxlbWVudDtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgb3JpZ2luYWxTb3VyY2UuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG9yaWdpbmFsU291cmNlO1xuICAgIH0sIHRoaXMuZGVsYXkuZHJhZyk7XG4gIH1cblxuICBbb25Nb3VzZVVwXSgpIHtcbiAgICB0aGlzW3Jlc2V0XSgpO1xuICB9XG5cbiAgW3Jlc2V0XSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCB0aGlzW29uRHJhZ0VuZF0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kcmFnZ2FibGVFbGVtZW50KSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBEcmFnU2Vuc29yIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgY2xvc2VzdCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyc7XG5pbXBvcnQgU2Vuc29yIGZyb20gJy4uL1NlbnNvci9TZW5zb3IubWpzJztcbmltcG9ydCB7IERyYWdTdGFydFNlbnNvckV2ZW50LCBEcmFnU3RvcFNlbnNvckV2ZW50LCBEcmFnTW92ZVNlbnNvckV2ZW50LCBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCB9IGZyb20gJy4uL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uTW91c2VGb3JjZVdpbGxCZWdpbiA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlV2lsbEJlZ2luJyk7XG5jb25zdCBvbk1vdXNlRm9yY2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VEb3duJyk7XG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcbmNvbnN0IG9uTW91c2VGb3JjZUNoYW5nZSA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlQ2hhbmdlJyk7XG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XG5jb25zdCBvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUdsb2JhbENoYW5nZScpO1xuXG5jbGFzcyBGb3JjZVRvdWNoU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcbiAgICB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0gPSB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VGb3JjZURvd25dID0gdGhpc1tvbk1vdXNlRm9yY2VEb3duXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0gPSB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZXdpbGxiZWdpbicsIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSwgZmFsc2UpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZCcsIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZXdpbGxiZWdpbicsIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSwgZmFsc2UpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZCcsIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XG4gIH1cblxuICBbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5taWdodERyYWcgPSB0cnVlO1xuICB9XG5cbiAgW29uTW91c2VGb3JjZURvd25dKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIHRhcmdldCAmJiAhY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcbiAgfVxuXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgRHJhZ1N0b3BTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xuICB9XG5cbiAgW29uTW91c2VEb3duXShldmVudCkge1xuICAgIGlmICghdGhpcy5taWdodERyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgRHJhZ01vdmVTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcbiAgfVxuXG4gIFtvbk1vdXNlRm9yY2VDaGFuZ2VdKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcbiAgfVxuXG4gIFtvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2VdKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XG4gICAgICBwcmVzc3VyZTogZXZlbnQud2Via2l0Rm9yY2UsXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgRm9yY2VUb3VjaFNlbnNvciBhcyBkZWZhdWx0IH07XG4iLCAiZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2xsaWRhYmxlIH0gZnJvbSAnLi9Db2xsaWRhYmxlL0NvbGxpZGFibGUubWpzJztcbmltcG9ydCAnLi9Db2xsaWRhYmxlL0NvbGxpZGFibGVFdmVudC9Db2xsaWRhYmxlRXZlbnQubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVzaXplTWlycm9yLCBkZWZhdWx0T3B0aW9ucyBhcyBkZWZhdWx0UmVzaXplTWlycm9yT3B0aW9ucyB9IGZyb20gJy4vUmVzaXplTWlycm9yL1Jlc2l6ZU1pcnJvci5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbmFwcGFibGUgfSBmcm9tICcuL1NuYXBwYWJsZS9TbmFwcGFibGUubWpzJztcbmltcG9ydCAnLi9TbmFwcGFibGUvU25hcHBhYmxlRXZlbnQvU25hcHBhYmxlRXZlbnQubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3dhcEFuaW1hdGlvbiwgZGVmYXVsdE9wdGlvbnMgYXMgZGVmYXVsdFN3YXBBbmltYXRpb25PcHRpb25zIH0gZnJvbSAnLi9Td2FwQW5pbWF0aW9uL1N3YXBBbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU29ydEFuaW1hdGlvbiwgZGVmYXVsdE9wdGlvbnMgYXMgZGVmYXVsdFNvcnRBbmltYXRpb25PcHRpb25zIH0gZnJvbSAnLi9Tb3J0QW5pbWF0aW9uL1NvcnRBbmltYXRpb24ubWpzJztcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBDb2xsaWRhYmxlRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cbn1cbkNvbGxpZGFibGVFdmVudC50eXBlID0gJ2NvbGxpZGFibGUnO1xuXG5jbGFzcyBDb2xsaWRhYmxlSW5FdmVudCBleHRlbmRzIENvbGxpZGFibGVFdmVudCB7XG5cbiAgZ2V0IGNvbGxpZGluZ0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb2xsaWRpbmdFbGVtZW50O1xuICB9XG59XG5Db2xsaWRhYmxlSW5FdmVudC50eXBlID0gJ2NvbGxpZGFibGU6aW4nO1xuXG5jbGFzcyBDb2xsaWRhYmxlT3V0RXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xuXG4gIGdldCBjb2xsaWRpbmdFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcbiAgfVxufVxuQ29sbGlkYWJsZU91dEV2ZW50LnR5cGUgPSAnY29sbGlkYWJsZTpvdXQnO1xuXG5leHBvcnQgeyBDb2xsaWRhYmxlRXZlbnQsIENvbGxpZGFibGVJbkV2ZW50LCBDb2xsaWRhYmxlT3V0RXZlbnQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IHsgQ29sbGlkYWJsZUluRXZlbnQsIENvbGxpZGFibGVPdXRFdmVudCB9IGZyb20gJy4vQ29sbGlkYWJsZUV2ZW50L0NvbGxpZGFibGVFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XG5jb25zdCBvblJlcXVlc3RBbmltYXRpb25GcmFtZSA9IFN5bWJvbCgnb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuY2xhc3MgQ29sbGlkYWJsZSBleHRlbmRzIEFic3RyYWN0UGx1Z2luIHtcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xuXG4gICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSA9IHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICBnZXRDb2xsaWRhYmxlcygpIHtcbiAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuY29sbGlkYWJsZXM7XG4gICAgaWYgKHR5cGVvZiBjb2xsaWRhYmxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNvbGxpZGFibGVzKSk7XG4gICAgfSBlbHNlIGlmIChjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbGxpZGFibGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb2xsaWRhYmxlcyk7XG4gICAgfSBlbHNlIGlmIChjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gW2NvbGxpZGFibGVzXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2xsaWRhYmxlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNvbGxpZGFibGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5zZW5zb3JFdmVudC50YXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0odGFyZ2V0KSk7XG4gICAgaWYgKHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCkge1xuICAgICAgZXZlbnQuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbGxpZGFibGVJbkV2ZW50ID0gbmV3IENvbGxpZGFibGVJbkV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcbiAgICB9KTtcbiAgICBjb25zdCBjb2xsaWRhYmxlT3V0RXZlbnQgPSBuZXcgQ29sbGlkYWJsZU91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50XG4gICAgfSk7XG4gICAgY29uc3QgZW50ZXJpbmdDb2xsaWRhYmxlID0gQm9vbGVhbih0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgJiYgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCAhPT0gdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50KTtcbiAgICBjb25zdCBsZWF2aW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4oIXRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCAmJiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KTtcbiAgICBpZiAoZW50ZXJpbmdDb2xsaWRhYmxlKSB7XG4gICAgICBpZiAodGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVJbkV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGxlYXZpbmdDb2xsaWRhYmxlKSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQ7XG4gIH1cblxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBjb25zdCBsYXN0Q29sbGlkaW5nRWxlbWVudCA9IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCB8fCB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50O1xuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBDb2xsaWRhYmxlT3V0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IGxhc3RDb2xsaWRpbmdFbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKGxhc3RDb2xsaWRpbmdFbGVtZW50KSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XG4gIH1cblxuICBbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKHRhcmdldCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZ2V0Q29sbGlkYWJsZXMoKTtcbiAgICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IGNsb3Nlc3QodGFyZ2V0LCBlbGVtZW50ID0+IGNvbGxpZGFibGVzLmluY2x1ZGVzKGVsZW1lbnQpKTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB7IENvbGxpZGFibGUgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIGNyZWF0ZUFkZEluaXRpYWxpemVyTWV0aG9kKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyKSB7XG4gICAgYXNzZXJ0Tm90RmluaXNoZWQodCwgXCJhZGRJbml0aWFsaXplclwiKSwgYXNzZXJ0Q2FsbGFibGUociwgXCJBbiBpbml0aWFsaXplclwiKSwgZS5wdXNoKHIpO1xuICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VJZlByaXZhdGUoZSwgdCkge1xuICBpZiAoIWUodCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gYWNjZXNzIHByaXZhdGUgZWxlbWVudCBvbiBub24taW5zdGFuY2VcIik7XG59XG5mdW5jdGlvbiBtZW1iZXJEZWMoZSwgdCwgciwgYSwgbiwgaSwgcywgbywgYywgbCwgdSkge1xuICB2YXIgZjtcbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgZiA9IFwiYWNjZXNzb3JcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGYgPSBcIm1ldGhvZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZiA9IFwiZ2V0dGVyXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBmID0gXCJzZXR0ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmID0gXCJmaWVsZFwiO1xuICB9XG4gIHZhciBkLFxuICAgIHAsXG4gICAgaCA9IHtcbiAgICAgIGtpbmQ6IGYsXG4gICAgICBuYW1lOiBvID8gXCIjXCIgKyByIDogcixcbiAgICAgIHN0YXRpYzogcyxcbiAgICAgIHByaXZhdGU6IG8sXG4gICAgICBtZXRhZGF0YTogdVxuICAgIH0sXG4gICAgdiA9IHtcbiAgICAgIHY6ICExXG4gICAgfTtcbiAgaWYgKDAgIT09IGkgJiYgKGguYWRkSW5pdGlhbGl6ZXIgPSBjcmVhdGVBZGRJbml0aWFsaXplck1ldGhvZChuLCB2KSksIG8gfHwgMCAhPT0gaSAmJiAyICE9PSBpKSB7XG4gICAgaWYgKDIgPT09IGkpIGQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGFzc2VydEluc3RhbmNlSWZQcml2YXRlKGwsIGUpLCBhLnZhbHVlO1xuICAgIH07ZWxzZSB7XG4gICAgICB2YXIgeSA9IDAgPT09IGkgfHwgMSA9PT0gaTtcbiAgICAgICh5IHx8IDMgPT09IGkpICYmIChkID0gbyA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBhc3NlcnRJbnN0YW5jZUlmUHJpdmF0ZShsLCBlKSwgYS5nZXQuY2FsbChlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gYS5nZXQuY2FsbChlKTtcbiAgICAgIH0pLCAoeSB8fCA0ID09PSBpKSAmJiAocCA9IG8gPyBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBhc3NlcnRJbnN0YW5jZUlmUHJpdmF0ZShsLCBlKSwgYS5zZXQuY2FsbChlLCB0KTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBhLnNldC5jYWxsKGUsIHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGVbcl07XG4gIH0sIDAgPT09IGkgJiYgKHAgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgIGVbcl0gPSB0O1xuICB9KTtcbiAgdmFyIG0gPSBvID8gbC5iaW5kKCkgOiBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiByIGluIGU7XG4gIH07XG4gIGguYWNjZXNzID0gZCAmJiBwID8ge1xuICAgIGdldDogZCxcbiAgICBzZXQ6IHAsXG4gICAgaGFzOiBtXG4gIH0gOiBkID8ge1xuICAgIGdldDogZCxcbiAgICBoYXM6IG1cbiAgfSA6IHtcbiAgICBzZXQ6IHAsXG4gICAgaGFzOiBtXG4gIH07XG4gIHRyeSB7XG4gICAgcmV0dXJuIGUuY2FsbCh0LCBjLCBoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB2LnYgPSAhMDtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Tm90RmluaXNoZWQoZSwgdCkge1xuICBpZiAoZS52KSB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0ZWQgdG8gY2FsbCBcIiArIHQgKyBcIiBhZnRlciBkZWNvcmF0aW9uIHdhcyBmaW5pc2hlZFwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENhbGxhYmxlKGUsIHQpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgdGhyb3cgbmV3IFR5cGVFcnJvcih0ICsgXCIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRSZXR1cm5WYWx1ZShlLCB0KSB7XG4gIHZhciByID0gdHlwZW9mIHQ7XG4gIGlmICgxID09PSBlKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT09IHIgfHwgbnVsbCA9PT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFjY2Vzc29yIGRlY29yYXRvcnMgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggZ2V0LCBzZXQsIG9yIGluaXQgcHJvcGVydGllcyBvciB2b2lkIDBcIik7XG4gICAgdm9pZCAwICE9PSB0LmdldCAmJiBhc3NlcnRDYWxsYWJsZSh0LmdldCwgXCJhY2Nlc3Nvci5nZXRcIiksIHZvaWQgMCAhPT0gdC5zZXQgJiYgYXNzZXJ0Q2FsbGFibGUodC5zZXQsIFwiYWNjZXNzb3Iuc2V0XCIpLCB2b2lkIDAgIT09IHQuaW5pdCAmJiBhc3NlcnRDYWxsYWJsZSh0LmluaXQsIFwiYWNjZXNzb3IuaW5pdFwiKTtcbiAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgIT09IHIpIHtcbiAgICB2YXIgYTtcbiAgICB0aHJvdyBhID0gMCA9PT0gZSA/IFwiZmllbGRcIiA6IDUgPT09IGUgPyBcImNsYXNzXCIgOiBcIm1ldGhvZFwiLCBuZXcgVHlwZUVycm9yKGEgKyBcIiBkZWNvcmF0b3JzIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24gb3Igdm9pZCAwXCIpO1xuICB9XG59XG5mdW5jdGlvbiBjdXJyeVRoaXMxKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZSh0aGlzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGN1cnJ5VGhpczIoZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICBlKHRoaXMsIHQpO1xuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlNZW1iZXJEZWMoZSwgdCwgciwgYSwgbiwgaSwgcywgbywgYywgbCwgdSkge1xuICB2YXIgZixcbiAgICBkLFxuICAgIHAsXG4gICAgaCxcbiAgICB2LFxuICAgIHksXG4gICAgbSA9IHJbMF07XG4gIGEgfHwgQXJyYXkuaXNBcnJheShtKSB8fCAobSA9IFttXSksIG8gPyBmID0gMCA9PT0gaSB8fCAxID09PSBpID8ge1xuICAgIGdldDogY3VycnlUaGlzMShyWzNdKSxcbiAgICBzZXQ6IGN1cnJ5VGhpczIocls0XSlcbiAgfSA6IDMgPT09IGkgPyB7XG4gICAgZ2V0OiByWzNdXG4gIH0gOiA0ID09PSBpID8ge1xuICAgIHNldDogclszXVxuICB9IDoge1xuICAgIHZhbHVlOiByWzNdXG4gIH0gOiAwICE9PSBpICYmIChmID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBuKSksIDEgPT09IGkgPyBwID0ge1xuICAgIGdldDogZi5nZXQsXG4gICAgc2V0OiBmLnNldFxuICB9IDogMiA9PT0gaSA/IHAgPSBmLnZhbHVlIDogMyA9PT0gaSA/IHAgPSBmLmdldCA6IDQgPT09IGkgJiYgKHAgPSBmLnNldCk7XG4gIGZvciAodmFyIGcgPSBhID8gMiA6IDEsIGIgPSBtLmxlbmd0aCAtIDE7IGIgPj0gMDsgYiAtPSBnKSB7XG4gICAgdmFyIEk7XG4gICAgaWYgKHZvaWQgMCAhPT0gKGggPSBtZW1iZXJEZWMobVtiXSwgYSA/IG1bYiAtIDFdIDogdm9pZCAwLCBuLCBmLCBjLCBpLCBzLCBvLCBwLCBsLCB1KSkpIGFzc2VydFZhbGlkUmV0dXJuVmFsdWUoaSwgaCksIDAgPT09IGkgPyBJID0gaCA6IDEgPT09IGkgPyAoSSA9IGguaW5pdCwgdiA9IGguZ2V0IHx8IHAuZ2V0LCB5ID0gaC5zZXQgfHwgcC5zZXQsIHAgPSB7XG4gICAgICBnZXQ6IHYsXG4gICAgICBzZXQ6IHlcbiAgICB9KSA6IHAgPSBoLCB2b2lkIDAgIT09IEkgJiYgKHZvaWQgMCA9PT0gZCA/IGQgPSBJIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkID8gZCA9IFtkLCBJXSA6IGQucHVzaChJKSk7XG4gIH1cbiAgaWYgKDAgPT09IGkgfHwgMSA9PT0gaSkge1xuICAgIGlmICh2b2lkIDAgPT09IGQpIGQgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtlbHNlIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGQpIHtcbiAgICAgIHZhciB3ID0gZDtcbiAgICAgIGQgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBmb3IgKHZhciByID0gdCwgYSA9IHcubGVuZ3RoIC0gMTsgYSA+PSAwOyBhLS0pIHIgPSB3W2FdLmNhbGwoZSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIE0gPSBkO1xuICAgICAgZCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBNLmNhbGwoZSwgdCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBlLnB1c2goZCk7XG4gIH1cbiAgMCAhPT0gaSAmJiAoMSA9PT0gaSA/IChmLmdldCA9IHAuZ2V0LCBmLnNldCA9IHAuc2V0KSA6IDIgPT09IGkgPyBmLnZhbHVlID0gcCA6IDMgPT09IGkgPyBmLmdldCA9IHAgOiA0ID09PSBpICYmIChmLnNldCA9IHApLCBvID8gMSA9PT0gaSA/IChlLnB1c2goZnVuY3Rpb24gKGUsIHQpIHtcbiAgICByZXR1cm4gcC5nZXQuY2FsbChlLCB0KTtcbiAgfSksIGUucHVzaChmdW5jdGlvbiAoZSwgdCkge1xuICAgIHJldHVybiBwLnNldC5jYWxsKGUsIHQpO1xuICB9KSkgOiAyID09PSBpID8gZS5wdXNoKHApIDogZS5wdXNoKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgcmV0dXJuIHAuY2FsbChlLCB0KTtcbiAgfSkgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbiwgZikpO1xufVxuZnVuY3Rpb24gYXBwbHlNZW1iZXJEZWNzKGUsIHQsIHIsIGEpIHtcbiAgZm9yICh2YXIgbiwgaSwgcywgbyA9IFtdLCBjID0gbmV3IE1hcCgpLCBsID0gbmV3IE1hcCgpLCB1ID0gMDsgdSA8IHQubGVuZ3RoOyB1KyspIHtcbiAgICB2YXIgZiA9IHRbdV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZikpIHtcbiAgICAgIHZhciBkLFxuICAgICAgICBwLFxuICAgICAgICBoID0gZlsxXSxcbiAgICAgICAgdiA9IGZbMl0sXG4gICAgICAgIHkgPSBmLmxlbmd0aCA+IDMsXG4gICAgICAgIG0gPSAxNiAmIGgsXG4gICAgICAgIGcgPSAhISg4ICYgaCksXG4gICAgICAgIGIgPSByO1xuICAgICAgaWYgKGggJj0gNywgZyA/IChkID0gZSwgMCAhPT0gaCAmJiAocCA9IGkgPSBpIHx8IFtdKSwgeSAmJiAhcyAmJiAocyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBfY2hlY2tJblJIUyh0KSA9PT0gZTtcbiAgICAgIH0pLCBiID0gcykgOiAoZCA9IGUucHJvdG90eXBlLCAwICE9PSBoICYmIChwID0gbiA9IG4gfHwgW10pKSwgMCAhPT0gaCAmJiAheSkge1xuICAgICAgICB2YXIgSSA9IGcgPyBsIDogYyxcbiAgICAgICAgICB3ID0gSS5nZXQodikgfHwgMDtcbiAgICAgICAgaWYgKCEwID09PSB3IHx8IDMgPT09IHcgJiYgNCAhPT0gaCB8fCA0ID09PSB3ICYmIDMgIT09IGgpIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNvcmF0ZSBhIHB1YmxpYyBtZXRob2QvYWNjZXNzb3IgdGhhdCBoYXMgdGhlIHNhbWUgbmFtZSBhcyBhIHByZXZpb3VzbHkgZGVjb3JhdGVkIHB1YmxpYyBtZXRob2QvYWNjZXNzb3IuIFRoaXMgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIGRlY29yYXRvcnMgcGx1Z2luLiBQcm9wZXJ0eSBuYW1lIHdhczogXCIgKyB2KTtcbiAgICAgICAgSS5zZXQodiwgISghdyAmJiBoID4gMikgfHwgaCk7XG4gICAgICB9XG4gICAgICBhcHBseU1lbWJlckRlYyhvLCBkLCBmLCBtLCB2LCBoLCBnLCB5LCBwLCBiLCBhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHB1c2hJbml0aWFsaXplcnMobywgbiksIHB1c2hJbml0aWFsaXplcnMobywgaSksIG87XG59XG5mdW5jdGlvbiBwdXNoSW5pdGlhbGl6ZXJzKGUsIHQpIHtcbiAgdCAmJiBlLnB1c2goZnVuY3Rpb24gKGUpIHtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHRbcl0uY2FsbChlKTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBseUNsYXNzRGVjcyhlLCB0LCByLCBhKSB7XG4gIGlmICh0Lmxlbmd0aCkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IGUsIHMgPSBlLm5hbWUsIG8gPSByID8gMiA6IDEsIGMgPSB0Lmxlbmd0aCAtIDE7IGMgPj0gMDsgYyAtPSBvKSB7XG4gICAgICB2YXIgbCA9IHtcbiAgICAgICAgdjogITFcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdSA9IHRbY10uY2FsbChyID8gdFtjIC0gMV0gOiB2b2lkIDAsIGksIHtcbiAgICAgICAgICBraW5kOiBcImNsYXNzXCIsXG4gICAgICAgICAgbmFtZTogcyxcbiAgICAgICAgICBhZGRJbml0aWFsaXplcjogY3JlYXRlQWRkSW5pdGlhbGl6ZXJNZXRob2QobiwgbCksXG4gICAgICAgICAgbWV0YWRhdGE6IGFcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBsLnYgPSAhMDtcbiAgICAgIH1cbiAgICAgIHZvaWQgMCAhPT0gdSAmJiAoYXNzZXJ0VmFsaWRSZXR1cm5WYWx1ZSg1LCB1KSwgaSA9IHUpO1xuICAgIH1cbiAgICByZXR1cm4gW2RlZmluZU1ldGFkYXRhKGksIGEpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG4ubGVuZ3RoOyBlKyspIG5bZV0uY2FsbChpKTtcbiAgICB9XTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEoZSwgdCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFN5bWJvbC5tZXRhZGF0YSB8fCBTeW1ib2wuZm9yKFwiU3ltYm9sLm1ldGFkYXRhXCIpLCB7XG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICB2YWx1ZTogdFxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hcHBseURlY3MyMzA1KGUsIHQsIHIsIGEsIG4sIGkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNikgdmFyIHMgPSBpW1N5bWJvbC5tZXRhZGF0YSB8fCBTeW1ib2wuZm9yKFwiU3ltYm9sLm1ldGFkYXRhXCIpXTtcbiAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKHZvaWQgMCA9PT0gcyA/IG51bGwgOiBzKSxcbiAgICBjID0gYXBwbHlNZW1iZXJEZWNzKGUsIHQsIG4sIG8pO1xuICByZXR1cm4gci5sZW5ndGggfHwgZGVmaW5lTWV0YWRhdGEoZSwgbyksIHtcbiAgICBlOiBjLFxuICAgIGdldCBjKCkge1xuICAgICAgcmV0dXJuIGFwcGx5Q2xhc3NEZWNzKGUsIHIsIGEsIG8pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIF9jaGVja0luUkhTKGUpIHtcbiAgaWYgKE9iamVjdChlKSAhPT0gZSkgdGhyb3cgVHlwZUVycm9yKFwicmlnaHQtaGFuZCBzaWRlIG9mICdpbicgc2hvdWxkIGJlIGFuIG9iamVjdCwgZ290IFwiICsgKG51bGwgIT09IGUgPyB0eXBlb2YgZSA6IFwibnVsbFwiKSk7XG4gIHJldHVybiBlO1xufVxuXG5leHBvcnQgeyBfYXBwbHlEZWNzMjMwNSBhcyBhcHBseURlY3MyMzA1LCBfY2hlY2tJblJIUyBhcyBjaGVja0luUkhTIH07XG4iLCAiZnVuY3Rpb24gQXV0b0JpbmQob3JpZ2luYWxNZXRob2QsIHtcbiAgbmFtZSxcbiAgYWRkSW5pdGlhbGl6ZXJcbn0pIHtcbiAgYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpc1tuYW1lXSA9IG9yaWdpbmFsTWV0aG9kLmJpbmQodGhpcyk7XG5cbiAgfSk7XG59XG5cbmV4cG9ydCB7IEF1dG9CaW5kIH07XG4iLCAiZnVuY3Rpb24gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgRHJhZ0V2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlO1xuICB9XG5cbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XG4gIH1cblxuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG5cbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBzZW5zb3JFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xuICB9XG5cbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuc2Vuc29yRXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbkRyYWdFdmVudC50eXBlID0gJ2RyYWcnO1xuY2xhc3MgRHJhZ1N0YXJ0RXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cblxuRHJhZ1N0YXJ0RXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcbkRyYWdTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgRHJhZ01vdmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxuXG5EcmFnTW92ZUV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcblxuY2xhc3MgRHJhZ092ZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG59XG5EcmFnT3ZlckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyJztcbkRyYWdPdmVyRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5mdW5jdGlvbiBpc0RyYWdPdmVyRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IERyYWdPdmVyRXZlbnQudHlwZTtcbn1cblxuY2xhc3MgRHJhZ091dEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cblxuICBnZXQgb3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XG4gIH1cbn1cblxuRHJhZ091dEV2ZW50LnR5cGUgPSAnZHJhZzpvdXQnO1xuXG5jbGFzcyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblxuRHJhZ092ZXJDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcjpjb250YWluZXInO1xuXG5jbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xuXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcbiAgfVxufVxuXG5EcmFnT3V0Q29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm91dDpjb250YWluZXInO1xuXG5jbGFzcyBEcmFnUHJlc3N1cmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgZ2V0IHByZXNzdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucHJlc3N1cmU7XG4gIH1cbn1cblxuRHJhZ1ByZXNzdXJlRXZlbnQudHlwZSA9ICdkcmFnOnByZXNzdXJlJztcbmNsYXNzIERyYWdTdG9wRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cblxuRHJhZ1N0b3BFdmVudC50eXBlID0gJ2RyYWc6c3RvcCc7XG5EcmFnU3RvcEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgRHJhZ1N0b3BwZWRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxuRHJhZ1N0b3BwZWRFdmVudC50eXBlID0gJ2RyYWc6c3RvcHBlZCc7XG5cbmV4cG9ydCB7IERyYWdFdmVudCwgRHJhZ01vdmVFdmVudCwgRHJhZ091dENvbnRhaW5lckV2ZW50LCBEcmFnT3V0RXZlbnQsIERyYWdPdmVyQ29udGFpbmVyRXZlbnQsIERyYWdPdmVyRXZlbnQsIERyYWdQcmVzc3VyZUV2ZW50LCBEcmFnU3RhcnRFdmVudCwgRHJhZ1N0b3BFdmVudCwgRHJhZ1N0b3BwZWRFdmVudCwgaXNEcmFnT3ZlckV2ZW50IH07XG4iLCAiaW1wb3J0IHsgYXBwbHlEZWNzMjMwNSBhcyBfYXBwbHlEZWNzMjMwNSB9IGZyb20gJy4uLy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMubWpzJztcbmltcG9ydCB7IEFic3RyYWN0UGx1Z2luIH0gZnJvbSAnLi4vLi4vc2hhcmVkL0Fic3RyYWN0UGx1Z2luL0Fic3RyYWN0UGx1Z2luLm1qcyc7XG5pbXBvcnQgeyBBdXRvQmluZCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy9kZWNvcmF0b3JzL0F1dG9CaW5kLm1qcyc7XG5pbXBvcnQgcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZS9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lLm1qcyc7XG5pbXBvcnQgeyBpc0RyYWdPdmVyRXZlbnQgfSBmcm9tICcuLi8uLi9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuXG52YXIgX2luaXRQcm90bywgX2NsYXNzO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG5jbGFzcyBSZXNpemVNaXJyb3IgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgX2luaXRQcm90byhzdXBlcihkcmFnZ2FibGUpKTtcblxuICAgIHRoaXMubGFzdFdpZHRoID0gMDtcblxuICAgIHRoaXMubGFzdEhlaWdodCA9IDA7XG5cbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ21pcnJvcjpjcmVhdGVkJywgdGhpcy5vbk1pcnJvckNyZWF0ZWQpLm9uKCdkcmFnOm92ZXInLCB0aGlzLm9uRHJhZ092ZXIpLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpcy5vbkRyYWdPdmVyKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpcy5vbk1pcnJvckNyZWF0ZWQpLm9mZignbWlycm9yOmRlc3Ryb3knLCB0aGlzLm9uTWlycm9yRGVzdHJveSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzLm9uRHJhZ092ZXIpLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXMub25EcmFnT3Zlcik7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnJlc2l6ZU1pcnJvciB8fCB7fTtcbiAgfVxuXG4gIG9uTWlycm9yQ3JlYXRlZCh7XG4gICAgbWlycm9yXG4gIH0pIHtcbiAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgfVxuXG4gIG9uTWlycm9yRGVzdHJveSgpIHtcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG4gIH1cblxuICBvbkRyYWdPdmVyKGRyYWdFdmVudCkge1xuICAgIHRoaXMucmVzaXplKGRyYWdFdmVudCk7XG4gIH1cblxuICByZXNpemUoZHJhZ0V2ZW50KSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBvdmVyID0gbnVsbDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3ZlckNvbnRhaW5lclxuICAgICAgfSA9IGRyYWdFdmVudDtcbiAgICAgIGlmICh0aGlzLm1pcnJvciA9PSBudWxsIHx8IHRoaXMubWlycm9yLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5taXJyb3IucGFyZW50Tm9kZSAhPT0gb3ZlckNvbnRhaW5lcikge1xuICAgICAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RyYWdPdmVyRXZlbnQoZHJhZ0V2ZW50KSkge1xuICAgICAgICBvdmVyID0gZHJhZ0V2ZW50Lm92ZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVyRWxlbWVudCA9IG92ZXIgfHwgdGhpcy5kcmFnZ2FibGUuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIob3ZlckNvbnRhaW5lcilbMF07XG4gICAgICBpZiAoIW92ZXJFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBvdmVyUmVjdCA9IG92ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAodGhpcy5taXJyb3IgPT0gbnVsbCB8fCB0aGlzLmxhc3RIZWlnaHQgPT09IG92ZXJSZWN0LmhlaWdodCAmJiB0aGlzLmxhc3RXaWR0aCA9PT0gb3ZlclJlY3Qud2lkdGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUud2lkdGggPSBgJHtvdmVyUmVjdC53aWR0aH1weGA7XG4gICAgICAgIHRoaXMubWlycm9yLnN0eWxlLmhlaWdodCA9IGAke292ZXJSZWN0LmhlaWdodH1weGA7XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IG92ZXJSZWN0LmhlaWdodDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5fY2xhc3MgPSBSZXNpemVNaXJyb3I7XG5bX2luaXRQcm90b10gPSBfYXBwbHlEZWNzMjMwNShfY2xhc3MsIFtbQXV0b0JpbmQsIDIsIFwib25NaXJyb3JDcmVhdGVkXCJdLCBbQXV0b0JpbmQsIDIsIFwib25NaXJyb3JEZXN0cm95XCJdLCBbQXV0b0JpbmQsIDIsIFwib25EcmFnT3ZlclwiXV0sIFtdLCAwLCB2b2lkIDAsIEFic3RyYWN0UGx1Z2luKS5lO1xuXG5leHBvcnQgeyBSZXNpemVNaXJyb3IgYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBTbmFwRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG5cbiAgZ2V0IHNuYXBwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNuYXBwYWJsZTtcbiAgfVxufVxuXG5TbmFwRXZlbnQudHlwZSA9ICdzbmFwJztcbmNsYXNzIFNuYXBJbkV2ZW50IGV4dGVuZHMgU25hcEV2ZW50IHt9XG5cblNuYXBJbkV2ZW50LnR5cGUgPSAnc25hcDppbic7XG5TbmFwSW5FdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbmNsYXNzIFNuYXBPdXRFdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxuU25hcE91dEV2ZW50LnR5cGUgPSAnc25hcDpvdXQnO1xuU25hcE91dEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5leHBvcnQgeyBTbmFwRXZlbnQsIFNuYXBJbkV2ZW50LCBTbmFwT3V0RXZlbnQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IHsgU25hcEluRXZlbnQsIFNuYXBPdXRFdmVudCB9IGZyb20gJy4vU25hcHBhYmxlRXZlbnQvU25hcHBhYmxlRXZlbnQubWpzJztcblxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XG5jb25zdCBvbkRyYWdPdXQgPSBTeW1ib2woJ29uRHJhZ091dCcpO1xuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcbmNvbnN0IG9uTWlycm9yRGVzdHJveSA9IFN5bWJvbCgnb25NaXJyb3JEZXN0cm95Jyk7XG5cbmNsYXNzIFNuYXBwYWJsZSBleHRlbmRzIEFic3RyYWN0UGx1Z2luIHtcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xuXG4gICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XG5cbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ091dF0gPSB0aGlzW29uRHJhZ091dF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTWlycm9yQ3JlYXRlZF0gPSB0aGlzW29uTWlycm9yQ3JlYXRlZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub24oJ2Ryb3BwYWJsZTpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2Ryb3BwYWJsZTpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vZmYoJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9mZignZHJvcHBhYmxlOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2Ryb3BwYWJsZTpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOmRlc3Ryb3knLCB0aGlzW29uTWlycm9yRGVzdHJveV0pO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBldmVudC5zb3VyY2U7XG4gIH1cblxuICBbb25EcmFnU3RvcF0oKSB7XG4gICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XG4gIH1cblxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuZHJhZ0V2ZW50LnNvdXJjZTtcbiAgICBpZiAoc291cmNlID09PSB0aGlzLmZpcnN0U291cmNlKSB7XG4gICAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc25hcEluRXZlbnQgPSBuZXcgU25hcEluRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHNuYXBwYWJsZTogZXZlbnQub3ZlciB8fCBldmVudC5kcm9wcGFibGVcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBJbkV2ZW50KTtcbiAgICBpZiAoc25hcEluRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5taXJyb3IpIHtcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIHNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcbiAgICBzb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xuICAgIH0sIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XG4gIH1cblxuICBbb25EcmFnT3V0XShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5kcmFnRXZlbnQuc291cmNlO1xuICAgIGNvbnN0IHNuYXBPdXRFdmVudCA9IG5ldyBTbmFwT3V0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHNuYXBwYWJsZTogZXZlbnQub3ZlciB8fCBldmVudC5kcm9wcGFibGVcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBPdXRFdmVudCk7XG4gICAgaWYgKHNuYXBPdXRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1pcnJvcikge1xuICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBzb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XG4gIH1cblxuICBbb25NaXJyb3JDcmVhdGVkXSh7XG4gICAgbWlycm9yXG4gIH0pIHtcbiAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgfVxuXG4gIFtvbk1pcnJvckRlc3Ryb3ldKCkge1xuICAgIHRoaXMubWlycm9yID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBTbmFwcGFibGUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IGFwcGx5RGVjczIzMDUgYXMgX2FwcGx5RGVjczIzMDUgfSBmcm9tICcuLi8uLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IHsgQXV0b0JpbmQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvZGVjb3JhdG9ycy9BdXRvQmluZC5tanMnO1xuXG52YXIgX2luaXRQcm90bywgX2NsYXNzO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHVyYXRpb246IDE1MCxcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCcsXG4gIGhvcml6b250YWw6IGZhbHNlXG59O1xuXG5jbGFzcyBTd2FwQW5pbWF0aW9uIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIF9pbml0UHJvdG8oc3VwZXIoZHJhZ2dhYmxlKSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpcy5vblNvcnRhYmxlU29ydGVkKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXMub25Tb3J0YWJsZVNvcnRlZCk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnN3YXBBbmltYXRpb24gfHwge307XG4gIH1cblxuICBvblNvcnRhYmxlU29ydGVkKHtcbiAgICBvbGRJbmRleCxcbiAgICBuZXdJbmRleCxcbiAgICBkcmFnRXZlbnRcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXJcbiAgICB9ID0gZHJhZ0V2ZW50O1xuICAgIGlmICh0aGlzLmxhc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChvbGRJbmRleCA+PSBuZXdJbmRleCkge1xuICAgICAgICBhbmltYXRlKHNvdXJjZSwgb3ZlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuaW1hdGUob3Zlciwgc291cmNlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbl9jbGFzcyA9IFN3YXBBbmltYXRpb247XG5bX2luaXRQcm90b10gPSBfYXBwbHlEZWNzMjMwNShfY2xhc3MsIFtbQXV0b0JpbmQsIDIsIFwib25Tb3J0YWJsZVNvcnRlZFwiXV0sIFtdLCAwLCB2b2lkIDAsIEFic3RyYWN0UGx1Z2luKS5lO1xuZnVuY3Rpb24gYW5pbWF0ZShmcm9tLCB0bywge1xuICBkdXJhdGlvbixcbiAgZWFzaW5nRnVuY3Rpb24sXG4gIGhvcml6b250YWxcbn0pIHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIH1cbiAgaWYgKGhvcml6b250YWwpIHtcbiAgICBjb25zdCB3aWR0aCA9IGZyb20ub2Zmc2V0V2lkdGg7XG4gICAgZnJvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt3aWR0aH1weCwgMCwgMClgO1xuICAgIHRvLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgtJHt3aWR0aH1weCwgMCwgMClgO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhlaWdodCA9IGZyb20ub2Zmc2V0SGVpZ2h0O1xuICAgIGZyb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsICR7aGVpZ2h0fXB4LCAwKWA7XG4gICAgdG8uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsIC0ke2hlaWdodH1weCwgMClgO1xuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7ZHVyYXRpb259bXMgJHtlYXNpbmdGdW5jdGlvbn1gO1xuICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LnRhcmdldCA9PSBudWxsIHx8ICFpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gQm9vbGVhbignc3R5bGUnIGluIGV2ZW50VGFyZ2V0KTtcbn1cblxuZXhwb3J0IHsgU3dhcEFuaW1hdGlvbiBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0UGx1Z2luIH0gZnJvbSAnLi4vLi4vc2hhcmVkL0Fic3RyYWN0UGx1Z2luL0Fic3RyYWN0UGx1Z2luLm1qcyc7XG5cbmNvbnN0IG9uU29ydGFibGVTb3J0ZWQgPSBTeW1ib2woJ29uU29ydGFibGVTb3J0ZWQnKTtcbmNvbnN0IG9uU29ydGFibGVTb3J0ID0gU3ltYm9sKCdvblNvcnRhYmxlU29ydCcpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHVyYXRpb246IDE1MCxcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCdcbn07XG5cbmNsYXNzIFNvcnRBbmltYXRpb24gZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMubGFzdEVsZW1lbnRzID0gW107XG4gICAgdGhpc1tvblNvcnRhYmxlU29ydGVkXSA9IHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uU29ydGFibGVTb3J0XSA9IHRoaXNbb25Tb3J0YWJsZVNvcnRdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnQnLCB0aGlzW29uU29ydGFibGVTb3J0XSk7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRdKTtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zb3J0QW5pbWF0aW9uIHx8IHt9O1xuICB9XG5cbiAgW29uU29ydGFibGVTb3J0XSh7XG4gICAgZHJhZ0V2ZW50XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VDb250YWluZXJcbiAgICB9ID0gZHJhZ0V2ZW50O1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5kcmFnZ2FibGUuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoc291cmNlQ29udGFpbmVyKTtcbiAgICB0aGlzLmxhc3RFbGVtZW50cyA9IEFycmF5LmZyb20oZWxlbWVudHMpLm1hcChlbCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb21FbDogZWwsXG4gICAgICAgIG9mZnNldFRvcDogZWwub2Zmc2V0VG9wLFxuICAgICAgICBvZmZzZXRMZWZ0OiBlbC5vZmZzZXRMZWZ0XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgW29uU29ydGFibGVTb3J0ZWRdKHtcbiAgICBvbGRJbmRleCxcbiAgICBuZXdJbmRleFxuICB9KSB7XG4gICAgaWYgKG9sZEluZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZmZlY3RlZEVsZW1lbnRzID0gW107XG4gICAgbGV0IHN0YXJ0O1xuICAgIGxldCBlbmQ7XG4gICAgbGV0IG51bTtcbiAgICBpZiAob2xkSW5kZXggPiBuZXdJbmRleCkge1xuICAgICAgc3RhcnQgPSBuZXdJbmRleDtcbiAgICAgIGVuZCA9IG9sZEluZGV4IC0gMTtcbiAgICAgIG51bSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gb2xkSW5kZXggKyAxO1xuICAgICAgZW5kID0gbmV3SW5kZXg7XG4gICAgICBudW0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBmcm9tID0gdGhpcy5sYXN0RWxlbWVudHNbaV07XG4gICAgICBjb25zdCB0byA9IHRoaXMubGFzdEVsZW1lbnRzW2kgKyBudW1dO1xuICAgICAgZWZmZWN0ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG9cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxhc3RBbmltYXRpb25GcmFtZSk7XG5cbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBlZmZlY3RlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiBhbmltYXRlKGVsZW1lbnQsIHRoaXMub3B0aW9ucykpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGUoe1xuICBmcm9tLFxuICB0b1xufSwge1xuICBkdXJhdGlvbixcbiAgZWFzaW5nRnVuY3Rpb25cbn0pIHtcbiAgY29uc3QgZG9tRWwgPSBmcm9tLmRvbUVsO1xuICBjb25zdCB4ID0gZnJvbS5vZmZzZXRMZWZ0IC0gdG8ub2Zmc2V0TGVmdDtcbiAgY29uc3QgeSA9IGZyb20ub2Zmc2V0VG9wIC0gdG8ub2Zmc2V0VG9wO1xuICBkb21FbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICBkb21FbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYDtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBkb21FbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKTtcbiAgICBkb21FbC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcbiAgICBkb21FbC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xuICBldmVudC50YXJnZXQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICBldmVudC50YXJnZXQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XG59XG5cbmV4cG9ydCB7IFNvcnRBbmltYXRpb24gYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuXG5jb25zdCBvbkluaXRpYWxpemUgPSBTeW1ib2woJ29uSW5pdGlhbGl6ZScpO1xuY29uc3Qgb25EZXN0cm95ID0gU3ltYm9sKCdvbkRlc3Ryb3knKTtcbmNvbnN0IGFubm91bmNlRXZlbnQgPSBTeW1ib2woJ2Fubm91bmNlRXZlbnQnKTtcbmNvbnN0IGFubm91bmNlTWVzc2FnZSA9IFN5bWJvbCgnYW5ub3VuY2VNZXNzYWdlJyk7XG5jb25zdCBBUklBX1JFTEVWQU5UID0gJ2FyaWEtcmVsZXZhbnQnO1xuY29uc3QgQVJJQV9BVE9NSUMgPSAnYXJpYS1hdG9taWMnO1xuY29uc3QgQVJJQV9MSVZFID0gJ2FyaWEtbGl2ZSc7XG5jb25zdCBST0xFID0gJ3JvbGUnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZXhwaXJlOiA3MDAwXG59O1xuXG5jbGFzcyBBbm5vdW5jZW1lbnQgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuXG4gICAgdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2QgPSB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyO1xuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmFubm91bmNlbWVudHMgfHwge307XG4gIH1cblxuICBbYW5ub3VuY2VFdmVudF0oZXZlbnQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5vcHRpb25zW2V2ZW50LnR5cGVdO1xuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UoZXZlbnQpKTtcbiAgICB9XG4gIH1cblxuICBbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKSB7XG4gICAgYW5ub3VuY2UobWVzc2FnZSwge1xuICAgICAgZXhwaXJlOiB0aGlzLm9wdGlvbnMuZXhwaXJlXG4gICAgfSk7XG4gIH1cblxuICBbb25Jbml0aWFsaXplXSgpIHtcblxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIgPSBldmVudCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzW2Fubm91bmNlRXZlbnRdKGV2ZW50KTtcbiAgICAgIH0gZmluYWxseSB7XG5cbiAgICAgICAgdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2QuY2FsbCh0aGlzLmRyYWdnYWJsZSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBbb25EZXN0cm95XSgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2Q7XG4gIH1cbn1cblxuY29uc3QgbGl2ZVJlZ2lvbiA9IGNyZWF0ZVJlZ2lvbigpO1xuXG5mdW5jdGlvbiBhbm5vdW5jZShtZXNzYWdlLCB7XG4gIGV4cGlyZVxufSkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICBsaXZlUmVnaW9uLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgbGl2ZVJlZ2lvbi5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfSwgZXhwaXJlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaW9uKCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsICdkcmFnZ2FibGUtbGl2ZS1yZWdpb24nKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9SRUxFVkFOVCwgJ2FkZGl0aW9ucycpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0FUT01JQywgJ3RydWUnKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9MSVZFLCAnYXNzZXJ0aXZlJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFJPTEUsICdsb2cnKTtcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnMXB4JztcbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgZWxlbWVudC5zdHlsZS50b3AgPSAnLTFweCc7XG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZVJlZ2lvbik7XG59KTtcblxuZXhwb3J0IHsgQW5ub3VuY2VtZW50IGFzIGRlZmF1bHQsIGRlZmF1bHRPcHRpb25zIH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcblxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge307XG5cbmNsYXNzIEZvY3VzYWJsZSBleHRlbmRzIEFic3RyYWN0UGx1Z2luIHtcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKVxuICAgIH07XG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRlc3Ryb3ldID0gdGhpc1tvbkRlc3Ryb3ldLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vbignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xuXG4gICAgdGhpc1tvbkRlc3Ryb3ldKCk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmZvY3VzYWJsZSB8fCB7fTtcbiAgfVxuXG4gIGdldEVsZW1lbnRzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5kcmFnZ2FibGUuY29udGFpbmVycywgLi4udGhpcy5kcmFnZ2FibGUuZ2V0RHJhZ2dhYmxlRWxlbWVudHMoKV07XG4gIH1cblxuICBbb25Jbml0aWFsaXplXSgpIHtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IGRlY29yYXRlRWxlbWVudChlbGVtZW50KSk7XG4gICAgfSk7XG4gIH1cblxuICBbb25EZXN0cm95XSgpIHtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IHN0cmlwRWxlbWVudChlbGVtZW50KSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4ID0gW107XG5cbmZ1bmN0aW9uIGRlY29yYXRlRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IGhhc01pc3NpbmdUYWJJbmRleCA9IEJvb2xlYW4oIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICYmIGVsZW1lbnQudGFiSW5kZXggPT09IC0xKTtcbiAgaWYgKGhhc01pc3NpbmdUYWJJbmRleCkge1xuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5wdXNoKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHRhYkluZGV4RWxlbWVudFBvc2l0aW9uID0gZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LmluZGV4T2YoZWxlbWVudCk7XG4gIGlmICh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LnNwbGljZSh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiwgMSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgRm9jdXNhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBNaXJyb3JFdmVudCBleHRlbmRzIEFic3RyYWN0RXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcbiAgfVxuXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xuICB9XG5cbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBzZW5zb3JFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xuICB9XG5cbiAgZ2V0IGRyYWdFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcbiAgfVxuXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jbGFzcyBNaXJyb3JDcmVhdGVFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHt9XG5NaXJyb3JDcmVhdGVFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGUnO1xuXG5jbGFzcyBNaXJyb3JDcmVhdGVkRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XG5cbiAgZ2V0IG1pcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcbiAgfVxufVxuTWlycm9yQ3JlYXRlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmNyZWF0ZWQnO1xuXG5jbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cbk1pcnJvckF0dGFjaGVkRXZlbnQudHlwZSA9ICdtaXJyb3I6YXR0YWNoZWQnO1xuXG5jbGFzcyBNaXJyb3JNb3ZlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XG5cbiAgZ2V0IG1pcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcbiAgfVxuXG4gIGdldCBwYXNzZWRUaHJlc2hYKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucGFzc2VkVGhyZXNoWDtcbiAgfVxuXG4gIGdldCBwYXNzZWRUaHJlc2hZKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucGFzc2VkVGhyZXNoWTtcbiAgfVxufVxuTWlycm9yTW92ZUV2ZW50LnR5cGUgPSAnbWlycm9yOm1vdmUnO1xuTWlycm9yTW92ZUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBNaXJyb3JNb3ZlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cblxuICBnZXQgcGFzc2VkVGhyZXNoWCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFg7XG4gIH1cblxuICBnZXQgcGFzc2VkVGhyZXNoWSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFk7XG4gIH1cbn1cbk1pcnJvck1vdmVkRXZlbnQudHlwZSA9ICdtaXJyb3I6bW92ZWQnO1xuXG5jbGFzcyBNaXJyb3JEZXN0cm95RXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XG5cbiAgZ2V0IG1pcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcbiAgfVxufVxuTWlycm9yRGVzdHJveUV2ZW50LnR5cGUgPSAnbWlycm9yOmRlc3Ryb3knO1xuTWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5leHBvcnQgeyBNaXJyb3JBdHRhY2hlZEV2ZW50LCBNaXJyb3JDcmVhdGVFdmVudCwgTWlycm9yQ3JlYXRlZEV2ZW50LCBNaXJyb3JEZXN0cm95RXZlbnQsIE1pcnJvckV2ZW50LCBNaXJyb3JNb3ZlRXZlbnQsIE1pcnJvck1vdmVkRXZlbnQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IHsgTWlycm9yQ3JlYXRlRXZlbnQsIE1pcnJvckNyZWF0ZWRFdmVudCwgTWlycm9yQXR0YWNoZWRFdmVudCwgTWlycm9yTW92ZUV2ZW50LCBNaXJyb3JEZXN0cm95RXZlbnQsIE1pcnJvck1vdmVkRXZlbnQgfSBmcm9tICcuL01pcnJvckV2ZW50L01pcnJvckV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcbmNvbnN0IG9uTWlycm9yTW92ZSA9IFN5bWJvbCgnb25NaXJyb3JNb3ZlJyk7XG5jb25zdCBvblNjcm9sbCA9IFN5bWJvbCgnb25TY3JvbGwnKTtcbmNvbnN0IGdldEFwcGVuZGFibGVDb250YWluZXIgPSBTeW1ib2woJ2dldEFwcGVuZGFibGVDb250YWluZXInKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGNvbnN0cmFpbkRpbWVuc2lvbnM6IGZhbHNlLFxuICB4QXhpczogdHJ1ZSxcbiAgeUF4aXM6IHRydWUsXG4gIGN1cnNvck9mZnNldFg6IG51bGwsXG4gIGN1cnNvck9mZnNldFk6IG51bGwsXG4gIHRocmVzaG9sZFg6IG51bGwsXG4gIHRocmVzaG9sZFk6IG51bGxcbn07XG5cbmNsYXNzIE1pcnJvciBleHRlbmRzIEFic3RyYWN0UGx1Z2luIHtcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKVxuICAgIH07XG5cbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxuICAgICAgeTogd2luZG93LnNjcm9sbFlcbiAgICB9O1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvck1vdmVdID0gdGhpc1tvbk1pcnJvck1vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblNjcm9sbF0gPSB0aGlzW29uU2Nyb2xsXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub24oJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vbignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6bW92ZScsIHRoaXNbb25NaXJyb3JNb3ZlXSk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLm1pcnJvciB8fCB7fTtcbiAgfVxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxuICAgICAgeTogd2luZG93LnNjcm9sbFlcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnRcbiAgICB9ID0gZHJhZ0V2ZW50O1xuXG4gICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQgPSB7XG4gICAgICB4OiBzZW5zb3JFdmVudC5jbGllbnRYLFxuICAgICAgeTogc2Vuc29yRXZlbnQuY2xpZW50WVxuICAgIH07XG4gICAgY29uc3QgbWlycm9yQ3JlYXRlRXZlbnQgPSBuZXcgTWlycm9yQ3JlYXRlRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudFxuICAgIH0pO1xuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlRXZlbnQpO1xuICAgIGlmIChpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkgfHwgbWlycm9yQ3JlYXRlRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcHBlbmRhYmxlQ29udGFpbmVyID0gdGhpc1tnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHx8IHNvdXJjZUNvbnRhaW5lcjtcbiAgICB0aGlzLm1pcnJvciA9IHNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgY29uc3QgbWlycm9yQ3JlYXRlZEV2ZW50ID0gbmV3IE1pcnJvckNyZWF0ZWRFdmVudCh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgZHJhZ0V2ZW50LFxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxuICAgIH0pO1xuICAgIGNvbnN0IG1pcnJvckF0dGFjaGVkRXZlbnQgPSBuZXcgTWlycm9yQXR0YWNoZWRFdmVudCh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgZHJhZ0V2ZW50LFxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxuICAgIH0pO1xuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlZEV2ZW50KTtcbiAgICBhcHBlbmRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckF0dGFjaGVkRXZlbnQpO1xuICB9XG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubWlycm9yIHx8IGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnRcbiAgICB9ID0gZHJhZ0V2ZW50O1xuICAgIGxldCBwYXNzZWRUaHJlc2hYID0gdHJ1ZTtcbiAgICBsZXQgcGFzc2VkVGhyZXNoWSA9IHRydWU7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJlc2hvbGRYIHx8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IGxhc3RYLFxuICAgICAgICB5OiBsYXN0WVxuICAgICAgfSA9IHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50O1xuICAgICAgaWYgKE1hdGguYWJzKGxhc3RYIC0gc2Vuc29yRXZlbnQuY2xpZW50WCkgPCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWCkge1xuICAgICAgICBwYXNzZWRUaHJlc2hYID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudC54ID0gc2Vuc29yRXZlbnQuY2xpZW50WDtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WSAtIHNlbnNvckV2ZW50LmNsaWVudFkpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFkpIHtcbiAgICAgICAgcGFzc2VkVGhyZXNoWSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueSA9IHNlbnNvckV2ZW50LmNsaWVudFk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhc3NlZFRocmVzaFggJiYgIXBhc3NlZFRocmVzaFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtaXJyb3JNb3ZlRXZlbnQgPSBuZXcgTWlycm9yTW92ZUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBkcmFnRXZlbnQsXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgcGFzc2VkVGhyZXNoWCxcbiAgICAgIHBhc3NlZFRocmVzaFlcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvck1vdmVFdmVudCk7XG4gIH1cbiAgW29uRHJhZ1N0b3BdKGRyYWdFdmVudCkge1xuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNbb25TY3JvbGxdLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIGlmICghdGhpcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnRcbiAgICB9ID0gZHJhZ0V2ZW50O1xuICAgIGNvbnN0IG1pcnJvckRlc3Ryb3lFdmVudCA9IG5ldyBNaXJyb3JEZXN0cm95RXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgZHJhZ0V2ZW50XG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JEZXN0cm95RXZlbnQpO1xuICAgIGlmICghbWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHRoaXMubWlycm9yLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBbb25TY3JvbGxdKCkge1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0ge1xuICAgICAgeDogd2luZG93LnNjcm9sbFggLSB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQueCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LnlcbiAgICB9O1xuICB9XG5cbiAgW29uTWlycm9yQ3JlYXRlZF0oe1xuICAgIG1pcnJvcixcbiAgICBzb3VyY2UsXG4gICAgc2Vuc29yRXZlbnRcbiAgfSkge1xuICAgIGNvbnN0IG1pcnJvckNsYXNzZXMgPSB0aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdtaXJyb3InKTtcbiAgICBjb25zdCBzZXRTdGF0ZSA9ICh7XG4gICAgICBtaXJyb3JPZmZzZXQsXG4gICAgICBpbml0aWFsWCxcbiAgICAgIGluaXRpYWxZLFxuICAgICAgLi4uYXJnc1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgICAgdGhpcy5pbml0aWFsWCA9IGluaXRpYWxYO1xuICAgICAgdGhpcy5pbml0aWFsWSA9IGluaXRpYWxZO1xuICAgICAgdGhpcy5sYXN0TW92ZWRYID0gaW5pdGlhbFg7XG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBpbml0aWFsWTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pcnJvck9mZnNldCxcbiAgICAgICAgaW5pdGlhbFgsXG4gICAgICAgIGluaXRpYWxZLFxuICAgICAgICAuLi5hcmdzXG4gICAgICB9O1xuICAgIH07XG4gICAgbWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgbWlycm9yLFxuICAgICAgc291cmNlLFxuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBtaXJyb3JDbGFzc2VzLFxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHBhc3NlZFRocmVzaFg6IHRydWUsXG4gICAgICBwYXNzZWRUaHJlc2hZOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxTdGF0ZSlcblxuICAgIC50aGVuKGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKS50aGVuKGNhbGN1bGF0ZU1pcnJvck9mZnNldCkudGhlbihyZXNldE1pcnJvcikudGhlbihhZGRNaXJyb3JDbGFzc2VzKS50aGVuKHBvc2l0aW9uTWlycm9yKHtcbiAgICAgIGluaXRpYWw6IHRydWVcbiAgICB9KSkudGhlbihyZW1vdmVNaXJyb3JJRCkudGhlbihzZXRTdGF0ZSk7XG4gIH1cblxuICBbb25NaXJyb3JNb3ZlXShtaXJyb3JFdmVudCkge1xuICAgIGlmIChtaXJyb3JFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoe1xuICAgICAgbGFzdE1vdmVkWCxcbiAgICAgIGxhc3RNb3ZlZFksXG4gICAgICAuLi5hcmdzXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5sYXN0TW92ZWRYID0gbGFzdE1vdmVkWDtcbiAgICAgIHRoaXMubGFzdE1vdmVkWSA9IGxhc3RNb3ZlZFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXN0TW92ZWRYLFxuICAgICAgICBsYXN0TW92ZWRZLFxuICAgICAgICAuLi5hcmdzXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgdHJpZ2dlck1vdmVkID0gYXJncyA9PiB7XG4gICAgICBjb25zdCBtaXJyb3JNb3ZlZEV2ZW50ID0gbmV3IE1pcnJvck1vdmVkRXZlbnQoe1xuICAgICAgICBzb3VyY2U6IG1pcnJvckV2ZW50LnNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IG1pcnJvckV2ZW50Lm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IG1pcnJvckV2ZW50LnNvdXJjZUNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQ6IG1pcnJvckV2ZW50LnNlbnNvckV2ZW50LFxuICAgICAgICBkcmFnRXZlbnQ6IG1pcnJvckV2ZW50LmRyYWdFdmVudCxcbiAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgcGFzc2VkVGhyZXNoWDogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWCxcbiAgICAgICAgcGFzc2VkVGhyZXNoWTogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvck1vdmVkRXZlbnQpO1xuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICBtaXJyb3I6IG1pcnJvckV2ZW50Lm1pcnJvcixcbiAgICAgIHNlbnNvckV2ZW50OiBtaXJyb3JFdmVudC5zZW5zb3JFdmVudCxcbiAgICAgIG1pcnJvck9mZnNldDogdGhpcy5taXJyb3JPZmZzZXQsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBpbml0aWFsWDogdGhpcy5pbml0aWFsWCxcbiAgICAgIGluaXRpYWxZOiB0aGlzLmluaXRpYWxZLFxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcbiAgICAgIHBhc3NlZFRocmVzaFg6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFgsXG4gICAgICBwYXNzZWRUaHJlc2hZOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hZLFxuICAgICAgbGFzdE1vdmVkWDogdGhpcy5sYXN0TW92ZWRYLFxuICAgICAgbGFzdE1vdmVkWTogdGhpcy5sYXN0TW92ZWRZXG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxTdGF0ZSkudGhlbihwb3NpdGlvbk1pcnJvcih7XG4gICAgICByYWY6IHRydWVcbiAgICB9KSkudGhlbihzZXRTdGF0ZSkudGhlbih0cmlnZ2VyTW92ZWQpO1xuICB9XG5cbiAgW2dldEFwcGVuZGFibGVDb250YWluZXJdKHNvdXJjZSkge1xuICAgIGNvbnN0IGFwcGVuZFRvID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xuICAgIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBlbmRUbyk7XG4gICAgfSBlbHNlIGlmIChhcHBlbmRUbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gYXBwZW5kVG87XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhcHBlbmRUbyhzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc291cmNlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKHtcbiAgc291cmNlLFxuICAuLi5hcmdzXG59KSB7XG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCBzb3VyY2VSZWN0ID0gc291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlc29sdmUoe1xuICAgICAgc291cmNlLFxuICAgICAgc291cmNlUmVjdCxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1pcnJvck9mZnNldCh7XG4gIHNlbnNvckV2ZW50LFxuICBzb3VyY2VSZWN0LFxuICBvcHRpb25zLFxuICAuLi5hcmdzXG59KSB7XG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCB0b3AgPSBvcHRpb25zLmN1cnNvck9mZnNldFkgPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRZIC0gc291cmNlUmVjdC50b3AgOiBvcHRpb25zLmN1cnNvck9mZnNldFk7XG4gICAgY29uc3QgbGVmdCA9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WCA9PT0gbnVsbCA/IHNlbnNvckV2ZW50LmNsaWVudFggLSBzb3VyY2VSZWN0LmxlZnQgOiBvcHRpb25zLmN1cnNvck9mZnNldFg7XG4gICAgY29uc3QgbWlycm9yT2Zmc2V0ID0ge1xuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH07XG4gICAgcmVzb2x2ZSh7XG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIHNvdXJjZVJlY3QsXG4gICAgICBtaXJyb3JPZmZzZXQsXG4gICAgICBvcHRpb25zLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRNaXJyb3Ioe1xuICBtaXJyb3IsXG4gIHNvdXJjZSxcbiAgb3B0aW9ucyxcbiAgLi4uYXJnc1xufSkge1xuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IG9mZnNldEhlaWdodDtcbiAgICBsZXQgb2Zmc2V0V2lkdGg7XG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xuICAgICAgY29uc3QgY29tcHV0ZWRTb3VyY2VTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNvdXJjZSk7XG4gICAgICBvZmZzZXRIZWlnaHQgPSBjb21wdXRlZFNvdXJjZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgICAgIG9mZnNldFdpZHRoID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKTtcbiAgICB9XG4gICAgbWlycm9yLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgIG1pcnJvci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgbWlycm9yLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgbWlycm9yLnN0eWxlLnRvcCA9IDA7XG4gICAgbWlycm9yLnN0eWxlLmxlZnQgPSAwO1xuICAgIG1pcnJvci5zdHlsZS5tYXJnaW4gPSAwO1xuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcbiAgICAgIG1pcnJvci5zdHlsZS5oZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gICAgICBtaXJyb3Iuc3R5bGUud2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgcmVzb2x2ZSh7XG4gICAgICBtaXJyb3IsXG4gICAgICBzb3VyY2UsXG4gICAgICBvcHRpb25zLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkTWlycm9yQ2xhc3Nlcyh7XG4gIG1pcnJvcixcbiAgbWlycm9yQ2xhc3NlcyxcbiAgLi4uYXJnc1xufSkge1xuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbWlycm9yLmNsYXNzTGlzdC5hZGQoLi4ubWlycm9yQ2xhc3Nlcyk7XG4gICAgcmVzb2x2ZSh7XG4gICAgICBtaXJyb3IsXG4gICAgICBtaXJyb3JDbGFzc2VzLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTWlycm9ySUQoe1xuICBtaXJyb3IsXG4gIC4uLmFyZ3Ncbn0pIHtcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIG1pcnJvci5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgZGVsZXRlIG1pcnJvci5pZDtcbiAgICByZXNvbHZlKHtcbiAgICAgIG1pcnJvcixcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uTWlycm9yKHtcbiAgd2l0aEZyYW1lID0gZmFsc2UsXG4gIGluaXRpYWwgPSBmYWxzZVxufSA9IHt9KSB7XG4gIHJldHVybiAoe1xuICAgIG1pcnJvcixcbiAgICBzZW5zb3JFdmVudCxcbiAgICBtaXJyb3JPZmZzZXQsXG4gICAgaW5pdGlhbFksXG4gICAgaW5pdGlhbFgsXG4gICAgc2Nyb2xsT2Zmc2V0LFxuICAgIG9wdGlvbnMsXG4gICAgcGFzc2VkVGhyZXNoWCxcbiAgICBwYXNzZWRUaHJlc2hZLFxuICAgIGxhc3RNb3ZlZFgsXG4gICAgbGFzdE1vdmVkWSxcbiAgICAuLi5hcmdzXG4gIH0pID0+IHtcbiAgICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG1pcnJvcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG1pcnJvck9mZnNldCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfTtcbiAgICAgIGlmIChtaXJyb3JPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgeCA9IHBhc3NlZFRocmVzaFggPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRYIC0gbWlycm9yT2Zmc2V0LmxlZnQgLSBzY3JvbGxPZmZzZXQueCkgLyAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpKSAqIChvcHRpb25zLnRocmVzaG9sZFggfHwgMSkgOiBNYXRoLnJvdW5kKGxhc3RNb3ZlZFgpO1xuICAgICAgICBjb25zdCB5ID0gcGFzc2VkVGhyZXNoWSA/IE1hdGgucm91bmQoKHNlbnNvckV2ZW50LmNsaWVudFkgLSBtaXJyb3JPZmZzZXQudG9wIC0gc2Nyb2xsT2Zmc2V0LnkpIC8gKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRZIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRZKTtcbiAgICAgICAgaWYgKG9wdGlvbnMueEF4aXMgJiYgb3B0aW9ucy55QXhpcyB8fCBpbml0aWFsKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMueEF4aXMgJiYgIW9wdGlvbnMueUF4aXMpIHtcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHtpbml0aWFsWX1weCwgMClgO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMueUF4aXMgJiYgIW9wdGlvbnMueEF4aXMpIHtcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7aW5pdGlhbFh9cHgsICR7eX1weCwgMClgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxYID0geDtcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRYID0geDtcbiAgICAgICAgcmVzdWx0Lmxhc3RNb3ZlZFkgPSB5O1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIHtcbiAgICAgIGZyYW1lOiB3aXRoRnJhbWVcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gd2l0aFByb21pc2UoY2FsbGJhY2ssIHtcbiAgcmFmID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChyYWYpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkge1xuICByZXR1cm4gL15kcmFnLy50ZXN0KHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSk7XG59XG5cbmV4cG9ydCB7IE1pcnJvciBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucywgZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciwgb25EcmFnTW92ZSwgb25EcmFnU3RhcnQsIG9uRHJhZ1N0b3AsIG9uTWlycm9yQ3JlYXRlZCwgb25NaXJyb3JNb3ZlLCBvblNjcm9sbCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0UGx1Z2luIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0UGx1Z2luL0Fic3RyYWN0UGx1Z2luLm1qcyc7XG5pbXBvcnQgY2xvc2VzdCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgc2Nyb2xsID0gU3ltYm9sKCdzY3JvbGwnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHNwZWVkOiA2LFxuICBzZW5zaXRpdml0eTogNTAsXG4gIHNjcm9sbGFibGVFbGVtZW50czogW11cbn07XG5cbmNsYXNzIFNjcm9sbGFibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblxuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW3Njcm9sbF0gPSB0aGlzW3Njcm9sbF0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnNjcm9sbGFibGUgfHwge307XG4gIH1cblxuICBnZXRTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5oYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkpIHtcbiAgICAgIHJldHVybiBjbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cykgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzLmxlbmd0aCAhPT0gMCk7XG4gIH1cblxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNvdXJjZSk7XG4gICAgfSk7XG4gIH1cblxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudChkcmFnRXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0KTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBkcmFnRXZlbnQuc2Vuc29yRXZlbnQ7XG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgIHNjcm9sbE9mZnNldC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIHNjcm9sbE9mZnNldC54ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0ge1xuICAgICAgY2xpZW50WDogc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNjcm9sbE9mZnNldC54LFxuICAgICAgY2xpZW50WTogc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNjcm9sbE9mZnNldC55XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XG4gIH1cblxuICBbb25EcmFnU3RvcF0oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSk7XG4gICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XG4gIH1cblxuICBbc2Nyb2xsXSgpIHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgfHwgIXRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgc3BlZWQsXG4gICAgICBzZW5zaXRpdml0eVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYm90dG9tQ3V0T2ZmID0gcmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgY29uc3QgdG9wQ3V0T2ZmID0gcmVjdC50b3AgPCAwO1xuICAgIGNvbnN0IGN1dE9mZiA9IHRvcEN1dE9mZiB8fCBib3R0b21DdXRPZmY7XG4gICAgY29uc3QgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID0gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50O1xuICAgIGNvbnN0IGNsaWVudFggPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFg7XG4gICAgY29uc3QgY2xpZW50WSA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WTtcbiAgICBpZiAoc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhY3V0T2ZmKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldEhlaWdodCxcbiAgICAgICAgb2Zmc2V0V2lkdGhcbiAgICAgIH0gPSBzY3JvbGxhYmxlRWxlbWVudDtcbiAgICAgIGlmIChyZWN0LnRvcCArIG9mZnNldEhlaWdodCAtIGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFkgLSByZWN0LnRvcCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0LmxlZnQgKyBvZmZzZXRXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRYIC0gcmVjdC5sZWZ0IDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbm5lckhlaWdodCxcbiAgICAgICAgaW5uZXJXaWR0aFxuICAgICAgfSA9IHdpbmRvdztcbiAgICAgIGlmIChjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCArPSBzcGVlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlubmVyV2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tzY3JvbGxdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNPdmVyZmxvdyhlbGVtZW50KSB7XG4gIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgY29uc3Qgb3ZlcmZsb3cgPSBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteScpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpO1xuICByZXR1cm4gb3ZlcmZsb3dSZWdleC50ZXN0KG92ZXJmbG93KTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNhbGx5UG9zaXRpb25lZChlbGVtZW50KSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICByZXR1cm4gcG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBjbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XG4gIH1cbiAgY29uc3QgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG4gIGNvbnN0IGV4Y2x1ZGVTdGF0aWNQYXJlbnRzID0gcG9zaXRpb24gPT09ICdhYnNvbHV0ZSc7XG4gIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gY2xvc2VzdChlbGVtZW50LCBwYXJlbnQgPT4ge1xuICAgIGlmIChleGNsdWRlU3RhdGljUGFyZW50cyAmJiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc092ZXJmbG93KHBhcmVudCk7XG4gIH0pO1xuICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcgfHwgIXNjcm9sbGFibGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY3JvbGxhYmxlRWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKSB7XG4gIHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuZXhwb3J0IHsgU2Nyb2xsYWJsZSBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucywgb25EcmFnTW92ZSwgb25EcmFnU3RhcnQsIG9uRHJhZ1N0b3AsIHNjcm9sbCB9O1xuIiwgImNsYXNzIEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICB9XG5cbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFja3NbdHlwZV0ucHVzaCguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvcHkgPSB0aGlzLmNhbGxiYWNrc1t0eXBlXS5zbGljZSgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gY29weVtpXSkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJpZ2dlcihldmVudCkge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnQudHlwZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjYWxsYmFja3MgPSBbLi4udGhpcy5jYWxsYmFja3NbZXZlbnQudHlwZV1dO1xuICAgIGNvbnN0IGNhdWdodEVycm9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2F1Z2h0RXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2F1Z2h0RXJyb3JzLmxlbmd0aCkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKGBEcmFnZ2FibGUgY2F1Z2h0IGVycm9ycyB3aGlsZSB0cmlnZ2VyaW5nICcke2V2ZW50LnR5cGV9J2AsIGNhdWdodEVycm9ycyk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgeyBFbWl0dGVyIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBEcmFnZ2FibGVFdmVudCBleHRlbmRzIEFic3RyYWN0RXZlbnQge1xuXG4gIGdldCBkcmFnZ2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnZ2FibGU7XG4gIH1cbn1cblxuRHJhZ2dhYmxlRXZlbnQudHlwZSA9ICdkcmFnZ2FibGUnO1xuY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XG5cbkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQudHlwZSA9ICdkcmFnZ2FibGU6aW5pdGlhbGl6ZSc7XG5jbGFzcyBEcmFnZ2FibGVEZXN0cm95RXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxuRHJhZ2dhYmxlRGVzdHJveUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmRlc3Ryb3knO1xuXG5leHBvcnQgeyBEcmFnZ2FibGVEZXN0cm95RXZlbnQsIERyYWdnYWJsZUV2ZW50LCBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IEFubm91bmNlbWVudCBmcm9tICcuL1BsdWdpbnMvQW5ub3VuY2VtZW50L0Fubm91bmNlbWVudC5tanMnO1xuaW1wb3J0IEZvY3VzYWJsZSBmcm9tICcuL1BsdWdpbnMvRm9jdXNhYmxlL0ZvY3VzYWJsZS5tanMnO1xuaW1wb3J0IE1pcnJvciBmcm9tICcuL1BsdWdpbnMvTWlycm9yL01pcnJvci5tanMnO1xuaW1wb3J0IFNjcm9sbGFibGUgZnJvbSAnLi9QbHVnaW5zL1Njcm9sbGFibGUvU2Nyb2xsYWJsZS5tanMnO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi9FbWl0dGVyL0VtaXR0ZXIubWpzJztcbmltcG9ydCBNb3VzZVNlbnNvciBmcm9tICcuL1NlbnNvcnMvTW91c2VTZW5zb3IvTW91c2VTZW5zb3IubWpzJztcbmltcG9ydCBUb3VjaFNlbnNvciBmcm9tICcuL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzJztcbmltcG9ydCAnLi9TZW5zb3JzL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50LCBEcmFnZ2FibGVEZXN0cm95RXZlbnQgfSBmcm9tICcuL0RyYWdnYWJsZUV2ZW50L0RyYWdnYWJsZUV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBEcmFnU3RhcnRFdmVudCwgRHJhZ01vdmVFdmVudCwgRHJhZ091dEV2ZW50LCBEcmFnT3V0Q29udGFpbmVyRXZlbnQsIERyYWdPdmVyQ29udGFpbmVyRXZlbnQsIERyYWdPdmVyRXZlbnQsIERyYWdTdG9wRXZlbnQsIERyYWdTdG9wcGVkRXZlbnQsIERyYWdQcmVzc3VyZUV2ZW50IH0gZnJvbSAnLi9EcmFnRXZlbnQvRHJhZ0V2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgb25EcmFnUHJlc3N1cmUgPSBTeW1ib2woJ29uRHJhZ1ByZXNzdXJlJyk7XG5jb25zdCBkcmFnU3RvcCA9IFN5bWJvbCgnZHJhZ1N0b3AnKTtcblxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gICdkcmFnOnN0YXJ0JzogZXZlbnQgPT4gYFBpY2tlZCB1cCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YCxcbiAgJ2RyYWc6c3RvcCc6IGV2ZW50ID0+IGBSZWxlYXNlZCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YFxufTtcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAnY29udGFpbmVyOmRyYWdnaW5nJzogJ2RyYWdnYWJsZS1jb250YWluZXItLWlzLWRyYWdnaW5nJyxcbiAgJ3NvdXJjZTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtc291cmNlLS1pcy1kcmFnZ2luZycsXG4gICdzb3VyY2U6cGxhY2VkJzogJ2RyYWdnYWJsZS1zb3VyY2UtLXBsYWNlZCcsXG4gICdjb250YWluZXI6cGxhY2VkJzogJ2RyYWdnYWJsZS1jb250YWluZXItLXBsYWNlZCcsXG4gICdib2R5OmRyYWdnaW5nJzogJ2RyYWdnYWJsZS0taXMtZHJhZ2dpbmcnLFxuICAnZHJhZ2dhYmxlOm92ZXInOiAnZHJhZ2dhYmxlLS1vdmVyJyxcbiAgJ2NvbnRhaW5lcjpvdmVyJzogJ2RyYWdnYWJsZS1jb250YWluZXItLW92ZXInLFxuICAnc291cmNlOm9yaWdpbmFsJzogJ2RyYWdnYWJsZS0tb3JpZ2luYWwnLFxuICBtaXJyb3I6ICdkcmFnZ2FibGUtbWlycm9yJ1xufTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBkcmFnZ2FibGU6ICcuZHJhZ2dhYmxlLXNvdXJjZScsXG4gIGhhbmRsZTogbnVsbCxcbiAgZGVsYXk6IHt9LFxuICBkaXN0YW5jZTogMCxcbiAgcGxhY2VkVGltZW91dDogODAwLFxuICBwbHVnaW5zOiBbXSxcbiAgc2Vuc29yczogW10sXG4gIGV4Y2x1ZGU6IHtcbiAgICBwbHVnaW5zOiBbXSxcbiAgICBzZW5zb3JzOiBbXVxuICB9XG59O1xuXG5jbGFzcyBEcmFnZ2FibGUge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbZG9jdW1lbnQuYm9keV0sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb250YWluZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXJzID0gW2NvbnRhaW5lcnNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZSBjb250YWluZXJzIGFyZSBleHBlY3RlZCB0byBiZSBvZiB0eXBlIGBOb2RlTGlzdGAsIGBIVE1MRWxlbWVudFtdYCBvciBgSFRNTEVsZW1lbnRgJyk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgLi4uZGVmYXVsdENsYXNzZXMsXG4gICAgICAgIC4uLihvcHRpb25zLmNsYXNzZXMgfHwge30pXG4gICAgICB9LFxuICAgICAgYW5ub3VuY2VtZW50czoge1xuICAgICAgICAuLi5kZWZhdWx0QW5ub3VuY2VtZW50cyxcbiAgICAgICAgLi4uKG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcbiAgICAgIH0sXG4gICAgICBleGNsdWRlOiB7XG4gICAgICAgIHBsdWdpbnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUucGx1Z2lucyB8fCBbXSxcbiAgICAgICAgc2Vuc29yczogb3B0aW9ucy5leGNsdWRlICYmIG9wdGlvbnMuZXhjbHVkZS5zZW5zb3JzIHx8IFtdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcblxuICAgIHRoaXMuc2Vuc29ycyA9IFtdO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdQcmVzc3VyZV0gPSB0aGlzW29uRHJhZ1ByZXNzdXJlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbZHJhZ1N0b3BdID0gdGhpc1tkcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6cHJlc3N1cmUnLCB0aGlzW29uRHJhZ1ByZXNzdXJlXSwgdHJ1ZSk7XG4gICAgY29uc3QgZGVmYXVsdFBsdWdpbnMgPSBPYmplY3QudmFsdWVzKERyYWdnYWJsZS5QbHVnaW5zKS5maWx0ZXIoUGx1Z2luID0+ICF0aGlzLm9wdGlvbnMuZXhjbHVkZS5wbHVnaW5zLmluY2x1ZGVzKFBsdWdpbikpO1xuICAgIGNvbnN0IGRlZmF1bHRTZW5zb3JzID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuU2Vuc29ycykuZmlsdGVyKHNlbnNvciA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IpKTtcbiAgICB0aGlzLmFkZFBsdWdpbiguLi5bLi4uZGVmYXVsdFBsdWdpbnMsIC4uLnRoaXMub3B0aW9ucy5wbHVnaW5zXSk7XG4gICAgdGhpcy5hZGRTZW5zb3IoLi4uWy4uLmRlZmF1bHRTZW5zb3JzLCAuLi50aGlzLm9wdGlvbnMuc2Vuc29yc10pO1xuICAgIGNvbnN0IGRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBuZXcgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCh7XG4gICAgICBkcmFnZ2FibGU6IHRoaXNcbiAgICB9KTtcbiAgICB0aGlzLm9uKCdtaXJyb3I6Y3JlYXRlZCcsICh7XG4gICAgICBtaXJyb3JcbiAgICB9KSA9PiB0aGlzLm1pcnJvciA9IG1pcnJvcik7XG4gICAgdGhpcy5vbignbWlycm9yOmRlc3Ryb3knLCAoKSA9PiB0aGlzLm1pcnJvciA9IG51bGwpO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xuICAgIGNvbnN0IGRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IG5ldyBEcmFnZ2FibGVEZXN0cm95RXZlbnQoe1xuICAgICAgZHJhZ2dhYmxlOiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyYWdnYWJsZURlc3Ryb3lFdmVudCk7XG4gICAgdGhpcy5yZW1vdmVQbHVnaW4oLi4udGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLmNvbnN0cnVjdG9yKSk7XG4gICAgdGhpcy5yZW1vdmVTZW5zb3IoLi4udGhpcy5zZW5zb3JzLm1hcChzZW5zb3IgPT4gc2Vuc29yLmNvbnN0cnVjdG9yKSk7XG4gIH1cblxuICBhZGRQbHVnaW4oLi4ucGx1Z2lucykge1xuICAgIGNvbnN0IGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLm1hcChQbHVnaW4gPT4gbmV3IFBsdWdpbih0aGlzKSk7XG4gICAgYWN0aXZlUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uYXR0YWNoKCkpO1xuICAgIHRoaXMucGx1Z2lucyA9IFsuLi50aGlzLnBsdWdpbnMsIC4uLmFjdGl2ZVBsdWdpbnNdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlUGx1Z2luKC4uLnBsdWdpbnMpIHtcbiAgICBjb25zdCByZW1vdmVkUGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XG4gICAgcmVtb3ZlZFBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmRldGFjaCgpKTtcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uY29uc3RydWN0b3IpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZFNlbnNvciguLi5zZW5zb3JzKSB7XG4gICAgY29uc3QgYWN0aXZlU2Vuc29ycyA9IHNlbnNvcnMubWFwKFNlbnNvciA9PiBuZXcgU2Vuc29yKHRoaXMuY29udGFpbmVycywgdGhpcy5vcHRpb25zKSk7XG4gICAgYWN0aXZlU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYXR0YWNoKCkpO1xuICAgIHRoaXMuc2Vuc29ycyA9IFsuLi50aGlzLnNlbnNvcnMsIC4uLmFjdGl2ZVNlbnNvcnNdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlU2Vuc29yKC4uLnNlbnNvcnMpIHtcbiAgICBjb25zdCByZW1vdmVkU2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+IHNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XG4gICAgcmVtb3ZlZFNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmRldGFjaCgpKTtcbiAgICB0aGlzLnNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiAhc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IuY29uc3RydWN0b3IpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hZGRDb250YWluZXIoLi4uY29udGFpbmVycykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcbiAgICB0aGlzLnNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLnJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbih0eXBlLCAuLi5jYWxsYmFja3MpIHtcbiAgICB0aGlzLmVtaXR0ZXIub24odHlwZSwgLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vZmYodHlwZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJpZ2dlcihldmVudCkge1xuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldENsYXNzTmFtZUZvcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcihuYW1lKVswXTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZXNGb3IobmFtZSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1tuYW1lXTtcbiAgICBpZiAoY2xhc3NOYW1lcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyB8fCBjbGFzc05hbWVzIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gW2NsYXNzTmFtZXNdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgaXNEcmFnZ2luZygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmRyYWdnaW5nKTtcbiAgfVxuXG4gIGdldERyYWdnYWJsZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcnMucmVkdWNlKChjdXJyZW50LCBjb250YWluZXIpID0+IHtcbiAgICAgIHJldHVybiBbLi4uY3VycmVudCwgLi4udGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpXTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICBnZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBjb25zdCBhbGxEcmFnZ2FibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHJldHVybiBbLi4uYWxsRHJhZ2dhYmxlRWxlbWVudHNdLmZpbHRlcihjaGlsZEVsZW1lbnQgPT4ge1xuICAgICAgcmV0dXJuIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5vcmlnaW5hbFNvdXJjZSAmJiBjaGlsZEVsZW1lbnQgIT09IHRoaXMubWlycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXNbZHJhZ1N0b3BdKCk7XG4gIH1cblxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxTb3VyY2VcbiAgICB9ID0gc2Vuc29yRXZlbnQ7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiB0YXJnZXQgJiYgIWNsb3Nlc3QodGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbFNvdXJjZTtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlICYmIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGxhY2VkVGltZW91dElEKTtcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcbiAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuc291cmNlLCB0aGlzLm9yaWdpbmFsU291cmNlKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgRHJhZ1N0YXJ0RXZlbnQoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RhcnRFdmVudCk7XG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xuICAgIGlmIChkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICB0aGlzLnNvdXJjZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcbiAgICB0aGlzLnNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6ZHJhZ2dpbmcnKSk7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignYm9keTpkcmFnZ2luZycpKTtcbiAgICBhcHBseVVzZXJTZWxlY3QoZG9jdW1lbnQuYm9keSwgJ25vbmUnKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgb2xkU2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XG4gICAgICBjb25zdCBuZXdTZW5zb3JFdmVudCA9IG9sZFNlbnNvckV2ZW50LmNsb25lKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnNvdXJjZVxuICAgICAgfSk7XG4gICAgICB0aGlzW29uRHJhZ01vdmVdKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIGRldGFpbDogbmV3U2Vuc29yRXZlbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lclxuICAgIH0gPSBzZW5zb3JFdmVudDtcbiAgICBsZXQgdGFyZ2V0ID0gc2Vuc29yRXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgRHJhZ01vdmVFdmVudCh7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyYWdNb3ZlRXZlbnQpO1xuICAgIGlmIChkcmFnTW92ZUV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xuICAgIH1cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgY29uc3Qgd2l0aGluQ29ycmVjdENvbnRhaW5lciA9IGNsb3Nlc3Qoc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGNvbnN0IG92ZXJDb250YWluZXIgPSBzZW5zb3JFdmVudC5vdmVyQ29udGFpbmVyIHx8IHdpdGhpbkNvcnJlY3RDb250YWluZXI7XG4gICAgY29uc3QgaXNMZWF2aW5nQ29udGFpbmVyID0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAmJiBvdmVyQ29udGFpbmVyICE9PSB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyO1xuICAgIGNvbnN0IGlzTGVhdmluZ0RyYWdnYWJsZSA9IHRoaXMuY3VycmVudE92ZXIgJiYgdGFyZ2V0ICE9PSB0aGlzLmN1cnJlbnRPdmVyO1xuICAgIGNvbnN0IGlzT3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXIgJiYgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAhPT0gb3ZlckNvbnRhaW5lcjtcbiAgICBjb25zdCBpc092ZXJEcmFnZ2FibGUgPSB3aXRoaW5Db3JyZWN0Q29udGFpbmVyICYmIHRhcmdldCAmJiB0aGlzLmN1cnJlbnRPdmVyICE9PSB0YXJnZXQ7XG4gICAgaWYgKGlzTGVhdmluZ0RyYWdnYWJsZSkge1xuICAgICAgY29uc3QgZHJhZ091dEV2ZW50ID0gbmV3IERyYWdPdXRFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXI6IHRoaXMuY3VycmVudE92ZXIsXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0RXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNMZWF2aW5nQ29udGFpbmVyKSB7XG4gICAgICBjb25zdCBkcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBuZXcgRHJhZ091dENvbnRhaW5lckV2ZW50KHtcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBzZW5zb3JFdmVudCxcbiAgICAgICAgb3ZlckNvbnRhaW5lcjogdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lclxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdXRDb250YWluZXJFdmVudCk7XG4gICAgfVxuICAgIGlmIChpc092ZXJDb250YWluZXIpIHtcbiAgICAgIG92ZXJDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xuICAgICAgY29uc3QgZHJhZ092ZXJDb250YWluZXJFdmVudCA9IG5ldyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50KHtcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBzZW5zb3JFdmVudCxcbiAgICAgICAgb3ZlckNvbnRhaW5lclxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lcjtcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckNvbnRhaW5lckV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzT3ZlckRyYWdnYWJsZSkge1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcbiAgICAgIGNvbnN0IGRyYWdPdmVyRXZlbnQgPSBuZXcgRHJhZ092ZXJFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXJDb250YWluZXIsXG4gICAgICAgIG92ZXI6IHRhcmdldFxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gdGFyZ2V0O1xuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdmVyRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIFtkcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgRHJhZ1N0b3BFdmVudCh7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXG4gICAgICBzZW5zb3JFdmVudDogZXZlbnQgPyBldmVudC5zZW5zb3JFdmVudCA6IG51bGwsXG4gICAgICBzb3VyY2VDb250YWluZXI6IHRoaXMuc291cmNlQ29udGFpbmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyYWdTdG9wRXZlbnQpO1xuICAgIGlmICghZHJhZ1N0b3BFdmVudC5jYW5jZWxlZCgpKSB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm9yaWdpbmFsU291cmNlLCB0aGlzLnNvdXJjZSk7XG4gICAgdGhpcy5zb3VyY2UucmVtb3ZlKCk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICcnKTtcbiAgICBpZiAodGhpcy5jdXJyZW50T3Zlcikge1xuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0UGxhY2VkU291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZTtcbiAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSB0aGlzLnNvdXJjZUNvbnRhaW5lcjtcbiAgICB0aGlzLnBsYWNlZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSkge1xuICAgICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSBudWxsO1xuICAgIH0sIHRoaXMub3B0aW9ucy5wbGFjZWRUaW1lb3V0KTtcbiAgICBjb25zdCBkcmFnU3RvcHBlZEV2ZW50ID0gbmV3IERyYWdTdG9wcGVkRXZlbnQoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50ID8gZXZlbnQuc2Vuc29yRXZlbnQgOiBudWxsLFxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcHBlZEV2ZW50KTtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBudWxsO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgdGhpc1tkcmFnU3RvcF0oZXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ1ByZXNzdXJlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCBjbG9zZXN0KHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBEcmFnUHJlc3N1cmVFdmVudCh7XG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHByZXNzdXJlOiBzZW5zb3JFdmVudC5wcmVzc3VyZVxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cbn1cblxuRHJhZ2dhYmxlLlBsdWdpbnMgPSB7XG4gIEFubm91bmNlbWVudCxcbiAgRm9jdXNhYmxlLFxuICBNaXJyb3IsXG4gIFNjcm9sbGFibGVcbn07XG5cbkRyYWdnYWJsZS5TZW5zb3JzID0ge1xuICBNb3VzZVNlbnNvcixcbiAgVG91Y2hTZW5zb3Jcbn07XG5mdW5jdGlvbiBnZXRTZW5zb3JFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuZGV0YWlsO1xufVxuZnVuY3Rpb24gYXBwbHlVc2VyU2VsZWN0KGVsZW1lbnQsIHZhbHVlKSB7XG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9IHZhbHVlO1xuICBlbGVtZW50LnN0eWxlLm1velVzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS5vVXNlclNlbGVjdCA9IHZhbHVlO1xuICBlbGVtZW50LnN0eWxlLnVzZXJTZWxlY3QgPSB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgRHJhZ2dhYmxlIGFzIGRlZmF1bHQsIGRlZmF1bHRPcHRpb25zIH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgRHJvcHBhYmxlRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cbn1cbkRyb3BwYWJsZUV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlJztcblxuY2xhc3MgRHJvcHBhYmxlU3RhcnRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcblxuICBnZXQgZHJvcHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcbiAgfVxufVxuRHJvcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdGFydCc7XG5Ecm9wcGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBEcm9wcGFibGVEcm9wcGVkRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgZ2V0IGRyb3B6b25lKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XG4gIH1cbn1cbkRyb3BwYWJsZURyb3BwZWRFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpkcm9wcGVkJztcbkRyb3BwYWJsZURyb3BwZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgRHJvcHBhYmxlUmV0dXJuZWRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcblxuICBnZXQgZHJvcHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcbiAgfVxufVxuRHJvcHBhYmxlUmV0dXJuZWRFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpyZXR1cm5lZCc7XG5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBEcm9wcGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgZ2V0IGRyb3B6b25lKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XG4gIH1cbn1cbkRyb3BwYWJsZVN0b3BFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdG9wJztcbkRyb3BwYWJsZVN0b3BFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuZXhwb3J0IHsgRHJvcHBhYmxlRHJvcHBlZEV2ZW50LCBEcm9wcGFibGVFdmVudCwgRHJvcHBhYmxlUmV0dXJuZWRFdmVudCwgRHJvcHBhYmxlU3RhcnRFdmVudCwgRHJvcHBhYmxlU3RvcEV2ZW50IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IERyYWdnYWJsZSBmcm9tICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlLm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9EcmFnRXZlbnQvRHJhZ0V2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9EcmFnZ2FibGVFdmVudC9EcmFnZ2FibGVFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9Bbm5vdW5jZW1lbnQvQW5ub3VuY2VtZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9QbHVnaW5zL01pcnJvci9NaXJyb3JFdmVudC9NaXJyb3JFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvU2Vuc29ycy9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvU2Vuc29ycy9Ub3VjaFNlbnNvci9Ub3VjaFNlbnNvci5tanMnO1xuaW1wb3J0IHsgRHJvcHBhYmxlU3RhcnRFdmVudCwgRHJvcHBhYmxlU3RvcEV2ZW50LCBEcm9wcGFibGVEcm9wcGVkRXZlbnQsIERyb3BwYWJsZVJldHVybmVkRXZlbnQgfSBmcm9tICcuL0Ryb3BwYWJsZUV2ZW50L0Ryb3BwYWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3QgZHJvcEluRHJvcHpvbmUgPSBTeW1ib2woJ2Ryb3BJbkRyb3Bab25lJyk7XG5jb25zdCByZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUgPSBTeW1ib2woJ3JldHVyblRvT3JpZ2luYWxEcm9wem9uZScpO1xuY29uc3QgY2xvc2VzdERyb3B6b25lID0gU3ltYm9sKCdjbG9zZXN0RHJvcHpvbmUnKTtcbmNvbnN0IGdldERyb3B6b25lcyA9IFN5bWJvbCgnZ2V0RHJvcHpvbmVzJyk7XG5cbmZ1bmN0aW9uIG9uRHJvcHBhYmxlRHJvcHBlZERlZmF1bHRBbm5vdW5jZW1lbnQoe1xuICBkcmFnRXZlbnQsXG4gIGRyb3B6b25lXG59KSB7XG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCc7XG4gIGNvbnN0IGRyb3B6b25lVGV4dCA9IGRyb3B6b25lLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcm9wem9uZS5pZCB8fCAnZHJvcHBhYmxlIGVsZW1lbnQnO1xuICByZXR1cm4gYERyb3BwZWQgJHtzb3VyY2VUZXh0fSBpbnRvICR7ZHJvcHpvbmVUZXh0fWA7XG59XG5cbmZ1bmN0aW9uIG9uRHJvcHBhYmxlUmV0dXJuZWREZWZhdWx0QW5ub3VuY2VtZW50KHtcbiAgZHJhZ0V2ZW50LFxuICBkcm9wem9uZVxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnO1xuICBjb25zdCBkcm9wem9uZVRleHQgPSBkcm9wem9uZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJvcHpvbmUuaWQgfHwgJ2Ryb3BwYWJsZSBlbGVtZW50JztcbiAgcmV0dXJuIGBSZXR1cm5lZCAke3NvdXJjZVRleHR9IGZyb20gJHtkcm9wem9uZVRleHR9YDtcbn1cblxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gICdkcm9wcGFibGU6ZHJvcHBlZCc6IG9uRHJvcHBhYmxlRHJvcHBlZERlZmF1bHRBbm5vdW5jZW1lbnQsXG4gICdkcm9wcGFibGU6cmV0dXJuZWQnOiBvbkRyb3BwYWJsZVJldHVybmVkRGVmYXVsdEFubm91bmNlbWVudFxufTtcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAnZHJvcHBhYmxlOmFjdGl2ZSc6ICdkcmFnZ2FibGUtZHJvcHpvbmUtLWFjdGl2ZScsXG4gICdkcm9wcGFibGU6b2NjdXBpZWQnOiAnZHJhZ2dhYmxlLWRyb3B6b25lLS1vY2N1cGllZCdcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHJvcHpvbmU6ICcuZHJhZ2dhYmxlLWRyb3BwYWJsZSdcbn07XG5cbmNsYXNzIERyb3BwYWJsZSBleHRlbmRzIERyYWdnYWJsZSB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRDbGFzc2VzLFxuICAgICAgICAuLi4ob3B0aW9ucy5jbGFzc2VzIHx8IHt9KVxuICAgICAgfSxcbiAgICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgICAgIC4uLihvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmRyb3B6b25lcyA9IG51bGw7XG5cbiAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XG5cbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IG51bGw7XG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcm9wem9uZXMgPSBbLi4udGhpc1tnZXREcm9wem9uZXNdKCldO1xuICAgIGNvbnN0IGRyb3B6b25lID0gY2xvc2VzdChldmVudC5zZW5zb3JFdmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcm9wem9uZSk7XG4gICAgaWYgKCFkcm9wem9uZSkge1xuICAgICAgZXZlbnQuY2FuY2VsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyb3BwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgRHJvcHBhYmxlU3RhcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlU3RhcnRFdmVudCk7XG4gICAgaWYgKGRyb3BwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgZXZlbnQuY2FuY2VsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lID0gZHJvcHpvbmU7XG4gICAgZm9yIChjb25zdCBkcm9wem9uZUVsZW1lbnQgb2YgdGhpcy5kcm9wem9uZXMpIHtcbiAgICAgIGlmIChkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2Ryb3BwYWJsZTphY3RpdmUnKSk7XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHJvcHpvbmUgPSB0aGlzW2Nsb3Nlc3REcm9wem9uZV0oZXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBvdmVyRW1wdHlEcm9wem9uZSA9IGRyb3B6b25lICYmICFkcm9wem9uZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpKTtcbiAgICBpZiAob3ZlckVtcHR5RHJvcHpvbmUgJiYgdGhpc1tkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSkge1xuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBkcm9wem9uZTtcbiAgICB9IGVsc2UgaWYgKCghZHJvcHpvbmUgfHwgZHJvcHpvbmUgPT09IHRoaXMuaW5pdGlhbERyb3B6b25lKSAmJiB0aGlzLmxhc3REcm9wem9uZSkge1xuICAgICAgdGhpc1tyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmVdKGV2ZW50KTtcbiAgICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBjb25zdCBkcm9wcGFibGVTdG9wRXZlbnQgPSBuZXcgRHJvcHBhYmxlU3RvcEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBkcm9wem9uZTogdGhpcy5sYXN0RHJvcHpvbmUgfHwgdGhpcy5pbml0aWFsRHJvcHpvbmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlU3RvcEV2ZW50KTtcbiAgICBjb25zdCBvY2N1cGllZENsYXNzZXMgPSB0aGlzLmdldENsYXNzTmFtZXNGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpO1xuICAgIGZvciAoY29uc3QgZHJvcHpvbmUgb2YgdGhpcy5kcm9wem9uZXMpIHtcbiAgICAgIGRyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUgJiYgdGhpcy5sYXN0RHJvcHpvbmUgIT09IHRoaXMuaW5pdGlhbERyb3B6b25lKSB7XG4gICAgICB0aGlzLmluaXRpYWxEcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLm9jY3VwaWVkQ2xhc3Nlcyk7XG4gICAgfVxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcbiAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xuICB9XG5cbiAgW2Ryb3BJbkRyb3B6b25lXShldmVudCwgZHJvcHpvbmUpIHtcbiAgICBjb25zdCBkcm9wcGFibGVEcm9wcGVkRXZlbnQgPSBuZXcgRHJvcHBhYmxlRHJvcHBlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBkcm9wem9uZVxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcm9wcGFibGVEcm9wcGVkRXZlbnQpO1xuICAgIGlmIChkcm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvY2N1cGllZENsYXNzZXMgPSB0aGlzLmdldENsYXNzTmFtZXNGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpO1xuICAgIGlmICh0aGlzLmxhc3REcm9wem9uZSkge1xuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi5vY2N1cGllZENsYXNzZXMpO1xuICAgIH1cbiAgICBkcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xuICAgIGRyb3B6b25lLmNsYXNzTGlzdC5hZGQoLi4ub2NjdXBpZWRDbGFzc2VzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIFtyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmVdKGV2ZW50KSB7XG4gICAgY29uc3QgZHJvcHBhYmxlUmV0dXJuZWRFdmVudCA9IG5ldyBEcm9wcGFibGVSZXR1cm5lZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBkcm9wem9uZTogdGhpcy5sYXN0RHJvcHpvbmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlUmV0dXJuZWRFdmVudCk7XG4gICAgaWYgKGRyb3BwYWJsZVJldHVybmVkRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xuICAgIHRoaXMubGFzdERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XG4gIH1cblxuICBbY2xvc2VzdERyb3B6b25lXSh0YXJnZXQpIHtcbiAgICBpZiAoIXRoaXMuZHJvcHpvbmVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3QodGFyZ2V0LCB0aGlzLmRyb3B6b25lcyk7XG4gIH1cblxuICBbZ2V0RHJvcHpvbmVzXSgpIHtcbiAgICBjb25zdCBkcm9wem9uZSA9IHRoaXMub3B0aW9ucy5kcm9wem9uZTtcbiAgICBpZiAodHlwZW9mIGRyb3B6b25lID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZHJvcHpvbmUpO1xuICAgIH0gZWxzZSBpZiAoZHJvcHpvbmUgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBkcm9wem9uZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcHpvbmU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHJvcHpvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkcm9wem9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IERyb3BwYWJsZSBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgU3dhcHBhYmxlRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cbn1cblxuU3dhcHBhYmxlRXZlbnQudHlwZSA9ICdzd2FwcGFibGUnO1xuY2xhc3MgU3dhcHBhYmxlU3RhcnRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHt9XG5Td2FwcGFibGVTdGFydEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN0YXJ0JztcblN3YXBwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIFN3YXBwYWJsZVN3YXBFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcblxuICBnZXQgb3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XG4gIH1cblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblN3YXBwYWJsZVN3YXBFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzd2FwJztcblN3YXBwYWJsZVN3YXBFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgU3dhcHBhYmxlU3dhcHBlZEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge1xuXG4gIGdldCBzd2FwcGVkRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN3YXBwZWRFbGVtZW50O1xuICB9XG59XG5cblN3YXBwYWJsZVN3YXBwZWRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzd2FwcGVkJztcbmNsYXNzIFN3YXBwYWJsZVN0b3BFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHt9XG5Td2FwcGFibGVTdG9wRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3RvcCc7XG5cbmV4cG9ydCB7IFN3YXBwYWJsZUV2ZW50LCBTd2FwcGFibGVTdGFydEV2ZW50LCBTd2FwcGFibGVTdG9wRXZlbnQsIFN3YXBwYWJsZVN3YXBFdmVudCwgU3dhcHBhYmxlU3dhcHBlZEV2ZW50IH07XG4iLCAiaW1wb3J0IERyYWdnYWJsZSBmcm9tICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlLm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9EcmFnRXZlbnQvRHJhZ0V2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9EcmFnZ2FibGVFdmVudC9EcmFnZ2FibGVFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9Bbm5vdW5jZW1lbnQvQW5ub3VuY2VtZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9QbHVnaW5zL01pcnJvci9NaXJyb3JFdmVudC9NaXJyb3JFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvU2Vuc29ycy9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvU2Vuc29ycy9Ub3VjaFNlbnNvci9Ub3VjaFNlbnNvci5tanMnO1xuaW1wb3J0IHsgU3dhcHBhYmxlU3RhcnRFdmVudCwgU3dhcHBhYmxlU3dhcEV2ZW50LCBTd2FwcGFibGVTd2FwcGVkRXZlbnQsIFN3YXBwYWJsZVN0b3BFdmVudCB9IGZyb20gJy4vU3dhcHBhYmxlRXZlbnQvU3dhcHBhYmxlRXZlbnQubWpzJztcblxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XG5cbmZ1bmN0aW9uIG9uU3dhcHBhYmxlU3dhcHBlZERlZmF1bHRBbm5vdW5jZW1lbnQoe1xuICBkcmFnRXZlbnQsXG4gIHN3YXBwZWRFbGVtZW50XG59KSB7XG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdzd2FwcGFibGUgZWxlbWVudCc7XG4gIGNvbnN0IG92ZXJUZXh0ID0gc3dhcHBlZEVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpIHx8IHN3YXBwZWRFbGVtZW50LmlkIHx8ICdzd2FwcGFibGUgZWxlbWVudCc7XG4gIHJldHVybiBgU3dhcHBlZCAke3NvdXJjZVRleHR9IHdpdGggJHtvdmVyVGV4dH1gO1xufVxuXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcbiAgJ3N3YXBwYWJsZWQ6c3dhcHBlZCc6IG9uU3dhcHBhYmxlU3dhcHBlZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5cbmNsYXNzIFN3YXBwYWJsZSBleHRlbmRzIERyYWdnYWJsZSB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYW5ub3VuY2VtZW50czoge1xuICAgICAgICAuLi5kZWZhdWx0QW5ub3VuY2VtZW50cyxcbiAgICAgICAgLi4uKG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCkub2ZmKCdkcmFnOm92ZXInLCB0aGlzLl9vbkRyYWdPdmVyKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXMuX29uRHJhZ1N0b3ApO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIGNvbnN0IHN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgU3dhcHBhYmxlU3RhcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN0YXJ0RXZlbnQpO1xuICAgIGlmIChzd2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xuICAgIGlmIChldmVudC5vdmVyID09PSBldmVudC5vcmlnaW5hbFNvdXJjZSB8fCBldmVudC5vdmVyID09PSBldmVudC5zb3VyY2UgfHwgZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzd2FwcGFibGVTd2FwRXZlbnQgPSBuZXcgU3dhcHBhYmxlU3dhcEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvdmVyOiBldmVudC5vdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lcjogZXZlbnQub3ZlckNvbnRhaW5lclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTd2FwRXZlbnQpO1xuICAgIGlmIChzd2FwcGFibGVTd2FwRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxhc3RPdmVyICYmIHRoaXMubGFzdE92ZXIgIT09IGV2ZW50Lm92ZXIpIHtcbiAgICAgIHN3YXAodGhpcy5sYXN0T3ZlciwgZXZlbnQuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdE92ZXIgPT09IGV2ZW50Lm92ZXIpIHtcbiAgICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhc3RPdmVyID0gZXZlbnQub3ZlcjtcbiAgICB9XG4gICAgc3dhcChldmVudC5zb3VyY2UsIGV2ZW50Lm92ZXIpO1xuICAgIGNvbnN0IHN3YXBwYWJsZVN3YXBwZWRFdmVudCA9IG5ldyBTd2FwcGFibGVTd2FwcGVkRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHN3YXBwZWRFbGVtZW50OiBldmVudC5vdmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN3YXBwZWRFdmVudCk7XG4gIH1cblxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBjb25zdCBzd2FwcGFibGVTdG9wRXZlbnQgPSBuZXcgU3dhcHBhYmxlU3RvcEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3RvcEV2ZW50KTtcbiAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aFRlbXBFbGVtZW50KGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY2FsbGJhY2sodG1wRWxlbWVudCk7XG4gIHRtcEVsZW1lbnQucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBzd2FwKHNvdXJjZSwgb3Zlcikge1xuICBjb25zdCBvdmVyUGFyZW50ID0gb3Zlci5wYXJlbnROb2RlO1xuICBjb25zdCBzb3VyY2VQYXJlbnQgPSBzb3VyY2UucGFyZW50Tm9kZTtcbiAgd2l0aFRlbXBFbGVtZW50KHRtcEVsZW1lbnQgPT4ge1xuICAgIHNvdXJjZVBhcmVudC5pbnNlcnRCZWZvcmUodG1wRWxlbWVudCwgc291cmNlKTtcbiAgICBvdmVyUGFyZW50Lmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xuICAgIHNvdXJjZVBhcmVudC5pbnNlcnRCZWZvcmUob3ZlciwgdG1wRWxlbWVudCk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBTd2FwcGFibGUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIFNvcnRhYmxlRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cbn1cblNvcnRhYmxlRXZlbnQudHlwZSA9ICdzb3J0YWJsZSc7XG5cbmNsYXNzIFNvcnRhYmxlU3RhcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIGdldCBzdGFydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnRJbmRleDtcbiAgfVxuXG4gIGdldCBzdGFydENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0Q29udGFpbmVyO1xuICB9XG59XG5Tb3J0YWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzdGFydCc7XG5Tb3J0YWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIFNvcnRhYmxlU29ydEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XG5cbiAgZ2V0IGN1cnJlbnRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmN1cnJlbnRJbmRleDtcbiAgfVxuXG4gIGdldCBvdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcbiAgfVxuXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50Lm92ZXJDb250YWluZXI7XG4gIH1cbn1cblNvcnRhYmxlU29ydEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c29ydCc7XG5Tb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIGdldCBvbGRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4O1xuICB9XG5cbiAgZ2V0IG5ld0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubmV3SW5kZXg7XG4gIH1cblxuICBnZXQgb2xkQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcbiAgfVxufVxuU29ydGFibGVTb3J0ZWRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnNvcnRlZCc7XG5cbmNsYXNzIFNvcnRhYmxlU3RvcEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XG5cbiAgZ2V0IG9sZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkSW5kZXg7XG4gIH1cblxuICBnZXQgbmV3SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdJbmRleDtcbiAgfVxuXG4gIGdldCBvbGRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRDb250YWluZXI7XG4gIH1cblxuICBnZXQgbmV3Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubmV3Q29udGFpbmVyO1xuICB9XG59XG5Tb3J0YWJsZVN0b3BFdmVudC50eXBlID0gJ3NvcnRhYmxlOnN0b3AnO1xuXG5leHBvcnQgeyBTb3J0YWJsZUV2ZW50LCBTb3J0YWJsZVNvcnRFdmVudCwgU29ydGFibGVTb3J0ZWRFdmVudCwgU29ydGFibGVTdGFydEV2ZW50LCBTb3J0YWJsZVN0b3BFdmVudCB9O1xuIiwgImltcG9ydCBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlRXZlbnQvRHJhZ2dhYmxlRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvQW5ub3VuY2VtZW50L0Fubm91bmNlbWVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9NaXJyb3IvTWlycm9yRXZlbnQvTWlycm9yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzJztcbmltcG9ydCB7IFNvcnRhYmxlU3RhcnRFdmVudCwgU29ydGFibGVTb3J0RXZlbnQsIFNvcnRhYmxlU29ydGVkRXZlbnQsIFNvcnRhYmxlU3RvcEV2ZW50IH0gZnJvbSAnLi9Tb3J0YWJsZUV2ZW50L1NvcnRhYmxlRXZlbnQubWpzJztcblxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XG5jb25zdCBvbkRyYWdPdmVyQ29udGFpbmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyQ29udGFpbmVyJyk7XG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XG5cbmZ1bmN0aW9uIG9uU29ydGFibGVTb3J0ZWREZWZhdWx0QW5ub3VuY2VtZW50KHtcbiAgZHJhZ0V2ZW50XG59KSB7XG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdzb3J0YWJsZSBlbGVtZW50JztcbiAgaWYgKGRyYWdFdmVudC5vdmVyKSB7XG4gICAgY29uc3Qgb3ZlclRleHQgPSBkcmFnRXZlbnQub3Zlci50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50Lm92ZXIuaWQgfHwgJ3NvcnRhYmxlIGVsZW1lbnQnO1xuICAgIGNvbnN0IGlzRm9sbG93aW5nID0gZHJhZ0V2ZW50LnNvdXJjZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkcmFnRXZlbnQub3ZlcikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICBpZiAoaXNGb2xsb3dpbmcpIHtcbiAgICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gYWZ0ZXIgJHtvdmVyVGV4dH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGJlZm9yZSAke292ZXJUZXh0fWA7XG4gICAgfVxuICB9IGVsc2Uge1xuXG4gICAgcmV0dXJuIGBQbGFjZWQgJHtzb3VyY2VUZXh0fSBpbnRvIGEgZGlmZmVyZW50IGNvbnRhaW5lcmA7XG4gIH1cbn1cblxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gICdzb3J0YWJsZTpzb3J0ZWQnOiBvblNvcnRhYmxlU29ydGVkRGVmYXVsdEFubm91bmNlbWVudFxufTtcblxuY2xhc3MgU29ydGFibGUgZXh0ZW5kcyBEcmFnZ2FibGUge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgICAgIC4uLihvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xuXG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0gPSB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdKS5vbignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgaW5kZXgoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRhYmxlRWxlbWVudHNGb3JDb250YWluZXIoZWxlbWVudC5wYXJlbnROb2RlKS5pbmRleE9mKGVsZW1lbnQpO1xuICB9XG5cbiAgZ2V0U29ydGFibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBjb25zdCBhbGxTb3J0YWJsZUVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgcmV0dXJuIFsuLi5hbGxTb3J0YWJsZUVsZW1lbnRzXS5maWx0ZXIoY2hpbGRFbGVtZW50ID0+IHtcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvciAmJiBjaGlsZEVsZW1lbnQucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyO1xuICAgIH0pO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBldmVudC5zb3VyY2UucGFyZW50Tm9kZTtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSk7XG4gICAgY29uc3Qgc29ydGFibGVTdGFydEV2ZW50ID0gbmV3IFNvcnRhYmxlU3RhcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgc3RhcnRJbmRleDogdGhpcy5zdGFydEluZGV4LFxuICAgICAgc3RhcnRDb250YWluZXI6IHRoaXMuc3RhcnRDb250YWluZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTdGFydEV2ZW50KTtcbiAgICBpZiAoc29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIFtvbkRyYWdPdmVyQ29udGFpbmVyXShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXIsXG4gICAgICBvdmVyQ29udGFpbmVyXG4gICAgfSA9IGV2ZW50O1xuICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xuICAgIGNvbnN0IHNvcnRhYmxlU29ydEV2ZW50ID0gbmV3IFNvcnRhYmxlU29ydEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjdXJyZW50SW5kZXg6IG9sZEluZGV4LFxuICAgICAgc291cmNlLFxuICAgICAgb3ZlclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRFdmVudCk7XG4gICAgaWYgKHNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldFNvcnRhYmxlRWxlbWVudHNGb3JDb250YWluZXIob3ZlckNvbnRhaW5lcik7XG4gICAgY29uc3QgbW92ZXMgPSBtb3ZlKHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXIsXG4gICAgICBvdmVyQ29udGFpbmVyLFxuICAgICAgY2hpbGRyZW5cbiAgICB9KTtcbiAgICBpZiAoIW1vdmVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9sZENvbnRhaW5lcixcbiAgICAgIG5ld0NvbnRhaW5lclxuICAgIH0gPSBtb3ZlcztcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKTtcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRlZEV2ZW50ID0gbmV3IFNvcnRhYmxlU29ydGVkRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIG9sZEluZGV4LFxuICAgICAgbmV3SW5kZXgsXG4gICAgICBvbGRDb250YWluZXIsXG4gICAgICBuZXdDb250YWluZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0ZWRFdmVudCk7XG4gIH1cblxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXIsXG4gICAgICBvdmVyQ29udGFpbmVyXG4gICAgfSA9IGV2ZW50O1xuICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xuICAgIGNvbnN0IHNvcnRhYmxlU29ydEV2ZW50ID0gbmV3IFNvcnRhYmxlU29ydEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjdXJyZW50SW5kZXg6IG9sZEluZGV4LFxuICAgICAgc291cmNlLFxuICAgICAgb3ZlclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRFdmVudCk7XG4gICAgaWYgKHNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lcixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gICAgaWYgKCFtb3Zlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvbGRDb250YWluZXIsXG4gICAgICBuZXdDb250YWluZXJcbiAgICB9ID0gbW92ZXM7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLmluZGV4KHNvdXJjZSk7XG4gICAgY29uc3Qgc29ydGFibGVTb3J0ZWRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvbGRJbmRleCxcbiAgICAgIG5ld0luZGV4LFxuICAgICAgb2xkQ29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydGVkRXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3Qgc29ydGFibGVTdG9wRXZlbnQgPSBuZXcgU29ydGFibGVTdG9wRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIG9sZEluZGV4OiB0aGlzLnN0YXJ0SW5kZXgsXG4gICAgICBuZXdJbmRleDogdGhpcy5pbmRleChldmVudC5zb3VyY2UpLFxuICAgICAgb2xkQ29udGFpbmVyOiB0aGlzLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyOiBldmVudC5zb3VyY2UucGFyZW50Tm9kZVxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVN0b3BFdmVudCk7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4sIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gbW92ZSh7XG4gIHNvdXJjZSxcbiAgb3ZlcixcbiAgb3ZlckNvbnRhaW5lcixcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgZW1wdHlPdmVyQ29udGFpbmVyID0gIWNoaWxkcmVuLmxlbmd0aDtcbiAgY29uc3QgZGlmZmVyZW50Q29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGUgIT09IG92ZXJDb250YWluZXI7XG4gIGNvbnN0IHNhbWVDb250YWluZXIgPSBvdmVyICYmIHNvdXJjZS5wYXJlbnROb2RlID09PSBvdmVyLnBhcmVudE5vZGU7XG4gIGlmIChlbXB0eU92ZXJDb250YWluZXIpIHtcbiAgICByZXR1cm4gbW92ZUluc2lkZUVtcHR5Q29udGFpbmVyKHNvdXJjZSwgb3ZlckNvbnRhaW5lcik7XG4gIH0gZWxzZSBpZiAoc2FtZUNvbnRhaW5lcikge1xuICAgIHJldHVybiBtb3ZlV2l0aGluQ29udGFpbmVyKHNvdXJjZSwgb3Zlcik7XG4gIH0gZWxzZSBpZiAoZGlmZmVyZW50Q29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG1vdmVPdXRzaWRlQ29udGFpbmVyKHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpIHtcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XG4gIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgcmV0dXJuIHtcbiAgICBvbGRDb250YWluZXIsXG4gICAgbmV3Q29udGFpbmVyOiBvdmVyQ29udGFpbmVyXG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlV2l0aGluQ29udGFpbmVyKHNvdXJjZSwgb3Zlcikge1xuICBjb25zdCBvbGRJbmRleCA9IGluZGV4KHNvdXJjZSk7XG4gIGNvbnN0IG5ld0luZGV4ID0gaW5kZXgob3Zlcik7XG4gIGlmIChvbGRJbmRleCA8IG5ld0luZGV4KSB7XG4gICAgc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlci5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgb2xkQ29udGFpbmVyOiBzb3VyY2UucGFyZW50Tm9kZSxcbiAgICBuZXdDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlXG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlT3V0c2lkZUNvbnRhaW5lcihzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIpIHtcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XG4gIGlmIChvdmVyKSB7XG4gICAgb3Zlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xuICB9IGVsc2Uge1xuXG4gICAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICB9XG4gIHJldHVybiB7XG4gICAgb2xkQ29udGFpbmVyLFxuICAgIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IHsgU29ydGFibGUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCBDaGFydCBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQuanNcIjtcbmltcG9ydCBDaGFydERhdGFMYWJlbHMgZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5qc1wiO1xuaW1wb3J0IFwiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzLXBsdWdpbi1sYWJlbHMtZHYvZGlzdC9jaGFydGpzLXBsdWdpbi1sYWJlbHMubWluLmpzXCI7XG5cbmNvbnN0IGNvbG9ycyA9IFtcIiMzNmEyZWJcIl07XG5jb25zdCBtb250aCA9IFtcbiAgXCJKYW52aWVyXCIsXG4gIFwiRlx1MDBFOXZyaWVyXCIsXG4gIFwiTWFyc1wiLFxuICBcIkF2cmlsXCIsXG4gIFwiTWFpXCIsXG4gIFwiSnVpblwiLFxuICBcIkp1aWxsZXRcIixcbiAgXCJBb1x1MDBGQnRcIixcbiAgXCJTZXB0ZW1icmVcIixcbiAgXCJPY3RvYnJlXCIsXG4gIFwiTm92ZW1icmVcIixcbiAgXCJEXHUwMEU5Y2VtYnJlXCIsXG5dO1xuXG5jb25zdCBTVVJWRVkgPSBbXG4gIFwiUXVhbGl0XHUwMEU5IGR1IHRyYXZhaWwgZWZmZWN0dVx1MDBFOVwiLFxuICBcIkdhaW4gZGUgdGVtcHMgZHUgY2xpZW50XCIsXG4gIFwiUmVzcGVjdCBkdSBkXHUwMEU5bGFpIGRlIGxpdnJhaXNvblwiLFxuICBcIlF1YWxpdFx1MDBFOSBkZSBsYSBjb21tdW5pY2F0aW9uXCIsXG5dO1xuXG5jbGFzcyBEb3VnaE51dENoYXJ0IHtcbiAgY29uc3RydWN0b3IoY3R4LCBsYWJlbHMsIHZhbHVlcykge1xuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgICB0eXBlOiBcImRvdWdobnV0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIkxpc3RlIGRlcyB0XHUwMEUyY2hlc1wiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICB0ZXh0OiBcIkxpc3RlIGRlcyB0XHUwMEUyY2hlcyBwYXIgY29udHJpYnV0ZXVyc1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcGx1Z2luczogQ2hhcnREYXRhTGFiZWxzLFxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIEhvcml6b250YWxCYXJDaGFydCB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgbGFiZWxzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xuICAgICAgdHlwZTogXCJiYXJcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYXhpczogXCJ4XCIsXG4gICAgICAgICAgICBsYWJlbDogXCJMaXN0ZSBkZXMgdFx1MDBFMmNoZXNcIixcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlcyxcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9ycyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGluZGV4QXhpczogXCJ4XCIsXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIHJlbmRlcjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgZm9udENvbG9yOiBcIiM1YzVjNWNcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcIm91dHNpZGVcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIHRleHQ6IFwiTGlzdGUgZGVzIHRcdTAwRTJjaGVzIHBhciBjb250cmlidXRldXJzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgU3RhY2tlZEJhckNoYXJ0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgY3R4LFxuICAgIHRvZG9fdGFza3MsXG4gICAgYmxvY2tlZF90YXNrcyxcbiAgICB0YXNrc19pbl9wcm9ncmVzcyxcbiAgICB0YXNrc19pbl9jb250cm9sLFxuICAgIGFjaGlldmVkX3Rhc2tzXG4gICkge1xuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbHM6IG1vbnRoLFxuICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIFx1MDBFMCBmYWlyZVwiLFxuICAgICAgICAgICAgZGF0YTogdG9kb190YXNrcyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBlbiBibG9jYWdlXCIsXG4gICAgICAgICAgICBkYXRhOiBibG9ja2VkX3Rhc2tzLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlNjdlMjJcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGNvdXJzXCIsXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9wcm9ncmVzcyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjdhZTYwXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBlbiBjb250clx1MDBGNGxlXCIsXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9jb250cm9sLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM4ZTQ0YWRcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGFjaGV2XHUwMEU5ZXNcIixcbiAgICAgICAgICAgIGRhdGE6IGFjaGlldmVkX3Rhc2tzLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjYzODRcIixcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgcmVuZGVyOiBcInZhbHVlXCIsXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwib3V0c2lkZVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgdGV4dDogXCJUXHUwMEUyY2hlcyBwYXIgbW9pc1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIExpbmVDaGFydCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGN0eCxcbiAgICB0b2RvX3Rhc2tzLFxuICAgIGJsb2NrZWRfdGFza3MsXG4gICAgdGFza3NfaW5fcHJvZ3Jlc3MsXG4gICAgdGFza3NfaW5fY29udHJvbCxcbiAgICBhY2hpZXZlZF90YXNrc1xuICApIHtcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbHM6IG1vbnRoLFxuICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBcdTAwRTAgZmFpcmVcIixcbiAgICAgICAgICAgIGRhdGE6IHRvZG9fdGFza3MsXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiNmZjYzODRcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmY2Mzg0XCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gYmxvY2thZ2VcIixcbiAgICAgICAgICAgIGRhdGE6IGJsb2NrZWRfdGFza3MsXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzNmEyZWJcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY291cnNcIixcbiAgICAgICAgICAgIGRhdGE6IHRhc2tzX2luX3Byb2dyZXNzLFxuICAgICAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjQsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMzZhMmViXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGNvbnRyXHUwMEY0bGVcIixcbiAgICAgICAgICAgIGRhdGE6IHRhc2tzX2luX2NvbnRyb2wsXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzNmEyZWJcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgYWNoZXZcdTAwRTllc1wiLFxuICAgICAgICAgICAgZGF0YTogYWNoaWV2ZWRfdGFza3MsXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzNmEyZWJcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICB0ZXh0OiBcIlRcdTAwRTJjaGVzIHBhciBtb2lzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgU3VydmV5Q2hhcnQge1xuICBjb25zdHJ1Y3RvcihjdHgsIHZhbHVlcykge1xuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbHM6IFNVUlZFWSxcbiAgICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBheGlzOiBcInhcIixcbiAgICAgICAgICAgIGxhYmVsOiBcIlBvdXJjZW50YWdlIGRlIHNhdGlzZmFjdGlvbiBlbiAlXCIsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb2xvcnMsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycyxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICAgICAgY29sb3I6IFwiI2ZmZlwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICAgICAgaW5kZXhBeGlzOiBcInlcIixcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgcmVuZGVyOiBcInZhbHVlXCIsXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwib3V0c2lkZVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgdGV4dDogXCJUYXV4IGRlIHNhdGlzZmFjdGlvbiBkdSBjbGllbnRcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBEb3VnaE51dENoYXJ0LFxuICBIb3Jpem9udGFsQmFyQ2hhcnQsXG4gIFN0YWNrZWRCYXJDaGFydCxcbiAgTGluZUNoYXJ0LFxuICBTdXJ2ZXlDaGFydFxufTtcbiIsICIhZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTp0KCl9KChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO1xuLyoqXG4gICAqIFtjaGFydGpzLXBsdWdpbi1sYWJlbHNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZGVWaW9sYW50ZS9jaGFydGpzLXBsdWdpbi1sYWJlbHN9XG4gICAqXG4gICAqIEB2ZXJzaW9uIDMuMS4wXG4gICAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dLCBEYXZpZGUgVmlvbGFudGUsIFlvdXNlZiBBbHRhaGVyXG4gICAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNy0yMDE4XG4gICAqIEBsaWNlbnNlIE1JVFxuICAgKi8hZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQ2hhcnQpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkNhbm5vdCBmaW5kIENoYXJ0IG9iamVjdC5cIik7Y29uc3QgdD1DaGFydC5oZWxwZXJzO1wiZnVuY3Rpb25cIiE9dHlwZW9mIE9iamVjdC5hc3NpZ24mJihPYmplY3QuYXNzaWduPWZ1bmN0aW9uKHQpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7Y29uc3QgZT1PYmplY3QodCk7Zm9yKGxldCB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7Y29uc3Qgbz1hcmd1bWVudHNbdF07aWYobylmb3IoY29uc3QgdCBpbiBvKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLHQpJiYoZVt0XT1vW3RdKX1yZXR1cm4gZX0pO2NvbnN0IGU9e307ZnVuY3Rpb24gbygpe3RoaXMucmVuZGVyVG9EYXRhc2V0PXRoaXMucmVuZGVyVG9EYXRhc2V0LmJpbmQodGhpcyl9ZnVuY3Rpb24gbih0KXtjb25zdCBlPXQuX2NvbnRleHQuY2hhcnQuY29uZmlnLl9jb25maWc7cmV0dXJuISghZS5vcHRpb25zfHwhZS5vcHRpb25zLnBsdWdpbnMpJiYhIWUub3B0aW9ucy5wbHVnaW5zLmxhYmVsc31bXCJwaWVcIixcImRvdWdobnV0XCIsXCJwb2xhckFyZWFcIixcImJhclwiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPSEwfSkpLG8ucHJvdG90eXBlLnNldHVwPWZ1bmN0aW9uKHQsZSl7dGhpcy5jaGFydD10LHRoaXMuY3R4PXQuY3R4LHRoaXMuYXJncz17fSx0aGlzLmJhclRvdGFsPXt9O2NvbnN0IG89dC5jb25maWcub3B0aW9uczt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7cG9zaXRpb246XCJkZWZhdWx0XCIscHJlY2lzaW9uOjAsZm9udFNpemU6by5mb250P28uZm9udC5zaXplOjEyLGZvbnRDb2xvcjpvLmNvbG9yfHxcIiMzMzMzMzNcIixmb250U3R5bGU6by5mb250P28uZm9udC5zdHlsZTpcIm5vcm1hbFwiLGZvbnRGYW1pbHk6by5mb250P28uZm9udC5mYW1pbHk6XCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLHNoYWRvd09mZnNldFg6MyxzaGFkb3dPZmZzZXRZOjMsc2hhZG93Q29sb3I6XCJyZ2JhKDAsMCwwLDAuMylcIixzaGFkb3dCbHVyOjYsaW1hZ2VzOltdLG91dHNpZGVQYWRkaW5nOjIsdGV4dE1hcmdpbjoyLG92ZXJsYXA6ITB9LGUpLFwiYmFyXCI9PT10LmNvbmZpZy50eXBlJiYodGhpcy5vcHRpb25zLnBvc2l0aW9uPVwiZGVmYXVsdFwiLHRoaXMub3B0aW9ucy5hcmM9ITEsdGhpcy5vcHRpb25zLm92ZXJsYXA9ITApfSxvLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt0aGlzLmxhYmVsQm91bmRzPVtdLHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKHRoaXMucmVuZGVyVG9EYXRhc2V0KX0sby5wcm90b3R5cGUucmVuZGVyVG9EYXRhc2V0PWZ1bmN0aW9uKHQsZSl7dGhpcy50b3RhbFBlcmNlbnRhZ2U9MCx0aGlzLnRvdGFsPW51bGw7Y29uc3Qgbz10aGlzLmFyZ3NbZV07by5tZXRhLmRhdGEuZm9yRWFjaChmdW5jdGlvbihlLG4pe3RoaXMucmVuZGVyVG9FbGVtZW50KHQsbyxlLG4pfS5iaW5kKHRoaXMpKX0sby5wcm90b3R5cGUucmVuZGVyVG9FbGVtZW50PWZ1bmN0aW9uKGUsbyxuLGkpe2lmKCF0aGlzLnNob3VsZFJlbmRlclRvRWxlbWVudChvLm1ldGEsbikpcmV0dXJuO3RoaXMucGVyY2VudGFnZT1udWxsO2NvbnN0IHM9dGhpcy5nZXRMYWJlbChlLG4saSk7aWYoIXMpcmV0dXJuO2NvbnN0IHI9dGhpcy5jdHg7ci5zYXZlKCksci5mb250PXQuZm9udFN0cmluZyh0aGlzLm9wdGlvbnMuZm9udFNpemUsdGhpcy5vcHRpb25zLmZvbnRTdHlsZSx0aGlzLm9wdGlvbnMuZm9udEZhbWlseSk7Y29uc3QgYT10aGlzLmdldFJlbmRlckluZm8obixzKTt0aGlzLmRyYXdhYmxlKG4scyxhKT8oci5iZWdpblBhdGgoKSxyLmZpbGxTdHlsZT10aGlzLmdldEZvbnRDb2xvcihlLG4saSksdGhpcy5yZW5kZXJMYWJlbChzLGEpLHIucmVzdG9yZSgpKTpyLnJlc3RvcmUoKX0sby5wcm90b3R5cGUucmVuZGVyTGFiZWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5vcHRpb25zLmFyYz90aGlzLnJlbmRlckFyY0xhYmVsKHQsZSk6dGhpcy5yZW5kZXJCYXNlTGFiZWwodCxlKX0sby5wcm90b3R5cGUucmVuZGVyQmFzZUxhYmVsPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbz10aGlzLmN0eDtpZihcIm9iamVjdFwiPT10eXBlb2YgdClvLmRyYXdJbWFnZSh0LGUueC10LndpZHRoLzIsZS55LXQuaGVpZ2h0LzIsdC53aWR0aCx0LmhlaWdodCk7ZWxzZXtvLnNhdmUoKSxvLnRleHRCYXNlbGluZT1cInRvcFwiLG8udGV4dEFsaWduPVwiY2VudGVyXCIsdGhpcy5vcHRpb25zLnRleHRTaGFkb3cmJihvLnNoYWRvd09mZnNldFg9dGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFgsby5zaGFkb3dPZmZzZXRZPXRoaXMub3B0aW9ucy5zaGFkb3dPZmZzZXRZLG8uc2hhZG93Q29sb3I9dGhpcy5vcHRpb25zLnNoYWRvd0NvbG9yLG8uc2hhZG93Qmx1cj10aGlzLm9wdGlvbnMuc2hhZG93Qmx1cik7Y29uc3Qgbj10LnNwbGl0KFwiXFxuXCIpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBpPWUueS10aGlzLm9wdGlvbnMuZm9udFNpemUvMipuLmxlbmd0aCt0aGlzLm9wdGlvbnMuZm9udFNpemUqdDtvLmZpbGxUZXh0KG5bdF0sZS54LGkpfW8ucmVzdG9yZSgpfX0sby5wcm90b3R5cGUucmVuZGVyQXJjTGFiZWw9ZnVuY3Rpb24odCxlKXtjb25zdCBvPXRoaXMuY3R4LG49ZS5yYWRpdXMsaT1lLnZpZXc7aWYoby5zYXZlKCksby50cmFuc2xhdGUoaS54LGkueSksXCJzdHJpbmdcIj09dHlwZW9mIHQpe28ucm90YXRlKGUuc3RhcnRBbmdsZSksby50ZXh0QmFzZWxpbmU9XCJtaWRkbGVcIixvLnRleHRBbGlnbj1cImxlZnRcIjtjb25zdCBpPXQuc3BsaXQoXCJcXG5cIik7bGV0IHM9MDtjb25zdCByPVtdO2xldCBhLGg9MDtcImJvcmRlclwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uJiYoaD0oaS5sZW5ndGgtMSkqdGhpcy5vcHRpb25zLmZvbnRTaXplLzIpO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7Kyt0KWE9by5tZWFzdXJlVGV4dChpW3RdKSxhLndpZHRoPnMmJihzPWEud2lkdGgpLHIucHVzaChhLndpZHRoKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoOysrdCl7Y29uc3QgZT1pW3RdLGw9KGkubGVuZ3RoLTEtdCkqLXRoaXMub3B0aW9ucy5mb250U2l6ZStoO28uc2F2ZSgpO2NvbnN0IGM9KHMtclt0XSkvMjtvLnJvdGF0ZShjL24pO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBpPWUuY2hhckF0KHQpO2E9by5tZWFzdXJlVGV4dChpKSxvLnNhdmUoKSxvLnRyYW5zbGF0ZSgwLC0xKm4pLG8uZmlsbFRleHQoaSwwLGwpLG8ucmVzdG9yZSgpLG8ucm90YXRlKGEud2lkdGgvbil9by5yZXN0b3JlKCl9fWVsc2Ugby5yb3RhdGUoKGkuc3RhcnRBbmdsZStNYXRoLlBJLzIrZS5lbmRBbmdsZSkvMiksby50cmFuc2xhdGUoMCwtMSpuKSx0aGlzLnJlbmRlckxhYmVsKHQse3g6MCx5OjB9KTtvLnJlc3RvcmUoKX0sby5wcm90b3R5cGUuc2hvdWxkUmVuZGVyVG9FbGVtZW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIXQuaGlkZGVuJiYodGhpcy5vcHRpb25zLnNob3daZXJvfHxcInBvbGFyQXJlYVwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZT8wIT09ZS5vdXRlclJhZGl1czowIT09ZS5jaXJjdW1mZXJlbmNlKX0sby5wcm90b3R5cGUuZ2V0TGFiZWw9ZnVuY3Rpb24odCxlLG8pe2xldCBuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5yZW5kZXIpbj10aGlzLm9wdGlvbnMucmVuZGVyKHtsYWJlbDp0aGlzLmNoYXJ0LmNvbmZpZy5kYXRhLmxhYmVsc1tvXSx2YWx1ZTp0LmRhdGFbb10scGVyY2VudGFnZTp0aGlzLmdldFBlcmNlbnRhZ2UodCxlLG8pLGRhdGFzZXQ6dCxpbmRleDpvfSk7ZWxzZSBzd2l0Y2godGhpcy5vcHRpb25zLnJlbmRlcil7Y2FzZVwidmFsdWVcIjpuPXQuZGF0YVtvXTticmVhaztjYXNlXCJsYWJlbFwiOm49dGhpcy5jaGFydC5jb25maWcuZGF0YS5sYWJlbHNbb107YnJlYWs7Y2FzZVwiaW1hZ2VcIjpuPXRoaXMub3B0aW9ucy5pbWFnZXNbb10/dGhpcy5sb2FkSW1hZ2UodGhpcy5vcHRpb25zLmltYWdlc1tvXSk6XCJcIjticmVhaztkZWZhdWx0Om49dGhpcy5nZXRQZXJjZW50YWdlKHQsZSxvKStcIiVcIn1yZXR1cm5cIm9iamVjdFwiPT10eXBlb2Ygbj9uPXRoaXMubG9hZEltYWdlKG4pOm4mJihuPW4udG9TdHJpbmcoKSksbn0sby5wcm90b3R5cGUuZ2V0Rm9udENvbG9yPWZ1bmN0aW9uKHQsZSxvKXtsZXQgbj10aGlzLm9wdGlvbnMuZm9udENvbG9yO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bj1uKHtsYWJlbDp0aGlzLmNoYXJ0LmNvbmZpZy5kYXRhLmxhYmVsc1tvXSx2YWx1ZTp0LmRhdGFbb10scGVyY2VudGFnZTp0aGlzLmdldFBlcmNlbnRhZ2UodCxlLG8pLGJhY2tncm91bmRDb2xvcjp0LmJhY2tncm91bmRDb2xvcltvXSxkYXRhc2V0OnQsaW5kZXg6b30pOlwic3RyaW5nXCIhPXR5cGVvZiBuJiYobj1uW29dfHx0aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLmNvbG9yKSxufSxvLnByb3RvdHlwZS5nZXRQZXJjZW50YWdlPWZ1bmN0aW9uKHQsZSxvKXtpZih0aGlzLnBlcmNlbnRhZ2UpcmV0dXJuIHRoaXMucGVyY2VudGFnZTtsZXQgbjtpZihcInBvbGFyQXJlYVwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZXx8XCJkb3VnaG51dFwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZXx8XCJwaWVcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGUpe2lmKCF0aGlzLnRvdGFsKXt0aGlzLnRvdGFsPTA7Zm9yKGxldCBlPTA7ZTx0LmRhdGEubGVuZ3RoOysrZSl0aGlzLnRvdGFsKz10LmRhdGFbZV19bj10LmRhdGFbb10vdGhpcy50b3RhbCoxMDB9ZWxzZSBpZihcImJhclwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZSl7aWYoIXRoaXMuYmFyVG90YWxbb10pe3RoaXMuYmFyVG90YWxbb109MDtmb3IobGV0IHQ9MDt0PHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7Kyt0KXRoaXMuYmFyVG90YWxbb10rPXRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0XS5kYXRhW29dfW49dC5kYXRhW29dL3RoaXMuYmFyVG90YWxbb10qMTAwfWVsc2Ugbj1lLmNpcmN1bWZlcmVuY2UvdGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5jaXJjdW1mZXJlbmNlKjEwMDtyZXR1cm4gbj1wYXJzZUZsb2F0KG4udG9GaXhlZCh0aGlzLm9wdGlvbnMucHJlY2lzaW9uKSksdGhpcy5vcHRpb25zLnNob3dBY3R1YWxQZXJjZW50YWdlc3x8KFwiYmFyXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlJiYodGhpcy50b3RhbFBlcmNlbnRhZ2U9dGhpcy5iYXJUb3RhbFBlcmNlbnRhZ2Vbb118fDApLHRoaXMudG90YWxQZXJjZW50YWdlKz1uLHRoaXMudG90YWxQZXJjZW50YWdlPjEwMCYmKG4tPXRoaXMudG90YWxQZXJjZW50YWdlLTEwMCxuPXBhcnNlRmxvYXQobi50b0ZpeGVkKHRoaXMub3B0aW9ucy5wcmVjaXNpb24pKSksXCJiYXJcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGUmJih0aGlzLmJhclRvdGFsUGVyY2VudGFnZVtvXT10aGlzLnRvdGFsUGVyY2VudGFnZSkpLHRoaXMucGVyY2VudGFnZT1uLG59LG8ucHJvdG90eXBlLmdldFJlbmRlckluZm89ZnVuY3Rpb24odCxlKXtyZXR1cm5cImJhclwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZT90aGlzLmdldEJhclJlbmRlckluZm8odCxlKTp0aGlzLm9wdGlvbnMuYXJjP3RoaXMuZ2V0QXJjUmVuZGVySW5mbyh0LGUpOnRoaXMuZ2V0QmFzZVJlbmRlckluZm8odCxlKX0sby5wcm90b3R5cGUuZ2V0QmFzZVJlbmRlckluZm89ZnVuY3Rpb24odCxlKXtpZihcIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbnx8XCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbil7bGV0IG8sbj17fTtjb25zdCBpPXQscz1pLnN0YXJ0QW5nbGUrKGkuZW5kQW5nbGUtaS5zdGFydEFuZ2xlKS8yLHI9aS5vdXRlclJhZGl1cy8yO2lmKFwiYm9yZGVyXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24/bz0oaS5vdXRlclJhZGl1cy1yKS8yK3I6XCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24mJihvPWkub3V0ZXJSYWRpdXMtcityK3RoaXMub3B0aW9ucy50ZXh0TWFyZ2luKSxuPXt4OmkueCtNYXRoLmNvcyhzKSpvLHk6aS55K01hdGguc2luKHMpKm99LFwib3V0c2lkZVwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uKXtjb25zdCB0PXRoaXMub3B0aW9ucy50ZXh0TWFyZ2luK3RoaXMubWVhc3VyZUxhYmVsKGUpLndpZHRoLzI7bi54Kz1uLng8aS54Py10OnR9cmV0dXJuIG59cmV0dXJuIHQudG9vbHRpcFBvc2l0aW9uKCl9LG8ucHJvdG90eXBlLmdldEFyY1JlbmRlckluZm89ZnVuY3Rpb24odCxlKXtsZXQgbztjb25zdCBuPXQ7bz1cIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbj9uLm91dGVyUmFkaXVzK3RoaXMub3B0aW9ucy5mb250U2l6ZSt0aGlzLm9wdGlvbnMudGV4dE1hcmdpbjpcImJvcmRlclwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uPyhuLm91dGVyUmFkaXVzLzIrbi5vdXRlclJhZGl1cykvMjoobi5pbm5lclJhZGl1cytuLm91dGVyUmFkaXVzKS8yO2xldCBpPW4uc3RhcnRBbmdsZSxzPW4uZW5kQW5nbGU7Y29uc3Qgcj1zLWk7aSs9TWF0aC5QSS8yLHMrPU1hdGguUEkvMjtyZXR1cm4gaSs9KHMtKHRoaXMubWVhc3VyZUxhYmVsKGUpLndpZHRoL28raSkpLzIse3JhZGl1czpvLHN0YXJ0QW5nbGU6aSxlbmRBbmdsZTpzLHRvdGFsQW5nbGU6cix2aWV3Om59fSxvLnByb3RvdHlwZS5nZXRCYXJSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbz10LnRvb2x0aXBQb3NpdGlvbigpO3JldHVybiBvLnktPXRoaXMubWVhc3VyZUxhYmVsKGUpLmhlaWdodC8yK3RoaXMub3B0aW9ucy50ZXh0TWFyZ2luLG99LG8ucHJvdG90eXBlLmRyYXdhYmxlPWZ1bmN0aW9uKHQsZSxvKXtpZih0aGlzLm9wdGlvbnMub3ZlcmxhcClyZXR1cm4hMDtpZih0aGlzLm9wdGlvbnMuYXJjKXJldHVybiBvLmVuZEFuZ2xlLW8uc3RhcnRBbmdsZTw9by50b3RhbEFuZ2xlO3tjb25zdCBuPXRoaXMubWVhc3VyZUxhYmVsKGUpLGk9by54LW4ud2lkdGgvMixzPW8ueCtuLndpZHRoLzIscj1vLnktbi5oZWlnaHQvMixhPW8ueStuLmhlaWdodC8yO3JldHVyblwib3V0c2lkZVwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uP3RoaXMub3V0c2lkZUluUmFuZ2UoaSxzLHIsYSk6dC5pblJhbmdlKGkscikmJnQuaW5SYW5nZShpLGEpJiZ0LmluUmFuZ2UocyxyKSYmdC5pblJhbmdlKHMsYSl9fSxvLnByb3RvdHlwZS5vdXRzaWRlSW5SYW5nZT1mdW5jdGlvbih0LGUsbyxuKXtjb25zdCBpPXRoaXMubGFiZWxCb3VuZHM7Zm9yKGxldCBzPTA7czxpLmxlbmd0aDsrK3Mpe2NvbnN0IHI9aVtzXTtsZXQgYT1bW3Qsb10sW3Qsbl0sW2Usb10sW2Usbl1dO2ZvcihsZXQgdD0wO3Q8YS5sZW5ndGg7Kyt0KXtjb25zdCBlPWFbdF1bMF0sbz1hW3RdWzFdO2lmKGU+PXIubGVmdCYmZTw9ci5yaWdodCYmbz49ci50b3AmJm88PXIuYm90dG9tKXJldHVybiExfWE9W1tyLmxlZnQsci50b3BdLFtyLmxlZnQsci5ib3R0b21dLFtyLnJpZ2h0LHIudG9wXSxbci5yaWdodCxyLmJvdHRvbV1dO2ZvcihsZXQgaT0wO2k8YS5sZW5ndGg7KytpKXtjb25zdCBzPWFbaV1bMF0scj1hW2ldWzFdO2lmKHM+PXQmJnM8PWUmJnI+PW8mJnI8PW4pcmV0dXJuITF9fXJldHVybiBpLnB1c2goe2xlZnQ6dCxyaWdodDplLHRvcDpvLGJvdHRvbTpufSksITB9LG8ucHJvdG90eXBlLm1lYXN1cmVMYWJlbD1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiPT10eXBlb2YgdClyZXR1cm57d2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHR9O3tsZXQgZT0wO2NvbnN0IG89dC5zcGxpdChcIlxcblwiKTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoOysrdCl7Y29uc3Qgbj10aGlzLmN0eC5tZWFzdXJlVGV4dChvW3RdKTtuLndpZHRoPmUmJihlPW4ud2lkdGgpfXJldHVybnt3aWR0aDplLGhlaWdodDp0aGlzLm9wdGlvbnMuZm9udFNpemUqby5sZW5ndGh9fX0sby5wcm90b3R5cGUubG9hZEltYWdlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IEltYWdlO3JldHVybiBlLnNyYz10LnNyYyxlLndpZHRoPXQud2lkdGgsZS5oZWlnaHQ9dC5oZWlnaHQsZX0sQ2hhcnQucmVnaXN0ZXIoe2lkOlwibGFiZWxzXCIsYmVmb3JlRGF0YXNldHNVcGRhdGU6ZnVuY3Rpb24odCxpLHMpe2lmKCFlW3QuY29uZmlnLnR5cGVdfHwhbihzKSlyZXR1cm47cy5sZW5ndGh8fChzPVtzXSk7Y29uc3Qgcj1zLmxlbmd0aDt0Ll9sYWJlbHMmJnI9PT10Ll9sYWJlbHMubGVuZ3RofHwodC5fbGFiZWxzPXMubWFwKChmdW5jdGlvbigpe3JldHVybiBuZXcgb30pKSk7bGV0IGE9ITEsaD0wO2ZvcihsZXQgZT0wO2U8cjsrK2Upe2NvbnN0IG89dC5fbGFiZWxzW2VdO2lmKG8uc2V0dXAodCxzW2VdKSxcIm91dHNpZGVcIj09PW8ub3B0aW9ucy5wb3NpdGlvbil7YT0hMDtjb25zdCB0PTEuNSpvLm9wdGlvbnMuZm9udFNpemUrby5vcHRpb25zLm91dHNpZGVQYWRkaW5nO3Q+aCYmKGg9dCl9fWEmJih0LmNoYXJ0QXJlYS50b3ArPWgsdC5jaGFydEFyZWEuYm90dG9tLT1oKX0sYWZ0ZXJEYXRhc2V0VXBkYXRlOmZ1bmN0aW9uKHQsbyxpKXtlW3QuY29uZmlnLnR5cGVdJiZuKGkpJiZ0Ll9sYWJlbHM/LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QuYXJnc1tvLmluZGV4XT1vfSkpfSxiZWZvcmVEcmF3OmZ1bmN0aW9uKHQsbyxpKXtlW3QuY29uZmlnLnR5cGVdJiZuKGkpJiZ0Ll9sYWJlbHM/LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QuYmFyVG90YWxQZXJjZW50YWdlPXt9fSkpfSxhZnRlckRhdGFzZXRzRHJhdzpmdW5jdGlvbih0LG8saSl7ZVt0LmNvbmZpZy50eXBlXSYmbihpKSYmdC5fbGFiZWxzPy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnJlbmRlcigpfSkpfX0pfSgpfSkpO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSwyQkFBbUIsUUFBYyxVQUE2QjtBQUM3RCxpQkFBTyxNQUFNLE9BQU8sUUFBUyxXQUFTO0FBQ3JDLHFCQUFTOzs7QUFJSSx5QkFBZ0I7VUFJOUIsY0FBYTtBQUFBLGlCQUZOLFVBQU87QUFHYixpQkFBSyxVQUFVOztVQUdoQixHQUFHLFFBQWUsS0FBYztBQUMvQixzQkFBVSxRQUFRLFdBQVU7QUFDM0Isb0JBQU0sY0FBYyxLQUFLLFFBQVEsVUFBVTtBQUMzQywwQkFBWSxLQUFLO0FBQ2pCLG1CQUFLLFFBQVEsU0FBUzs7O1VBSXhCLElBQUksUUFBZSxLQUFjO0FBQ2hDLGdCQUFJLElBQUksVUFBVTtBQUNsQixnQkFBSSxNQUFNLEdBQUc7QUFDWixtQkFBSyxVQUFVO0FBQ2Y7O0FBR0Qsc0JBQVUsUUFBUSxXQUFVO0FBRTNCLGtCQUFJLE1BQU0sR0FBRTtBQUNYLHVCQUFPLEtBQUssUUFBUTtBQUNwQjs7QUFHRCxvQkFBTSxjQUFjLEtBQUssUUFBUTtBQUNqQyxrQkFBSSxnQkFBZ0I7QUFBWTtBQUVoQywwQkFBWSxPQUFPLFlBQVksUUFBUSxNQUFNO0FBQzdDLG1CQUFLLFFBQVEsU0FBUzs7O1VBSXhCLFFBQVEsV0FBa0IsTUFBUztBQUNsQyxnQkFBSSxRQUFPO0FBRVgsc0JBQVUsUUFBUSxXQUFVO0FBQzNCLG9CQUFNLGNBQWMsTUFBSyxRQUFRO0FBQ2pDLGtC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QU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQSxVQUNSLE9BQU87QUFBQSxVQUNQLGNBQWM7QUFBQSxVQUNkLElBQUk7QUFBQSxVQUNKLFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLFdBQVc7QUFBQSxVQUNYLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULEtBQUs7QUFBQSxVQUNMLGFBQWE7QUFBQSxVQUNiLFNBQVM7QUFBQSxVQUNULFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLEtBQUs7QUFBQSxVQUNMLE9BQU87QUFBQSxVQUNQLFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLFFBQVE7QUFBQSxVQUNSLFNBQVM7QUFBQSxVQUNULFVBQVU7QUFBQSxVQUNWLFFBQVE7QUFBQSxVQUNSLE9BQU87QUFBQSxVQUNQLEtBQUs7QUFBQSxVQUNMLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLE9BQU87QUFBQSxVQUNQLEtBQUs7QUFBQSxVQUNMLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLFVBQVU7QUFBQSxVQUNWLFVBQVU7QUFBQSxVQUNWLFVBQVU7QUFBQSxVQUNWLFFBQVE7QUFBQSxVQUNSLFNBQVM7QUFBQSxVQUNULFdBQVc7QUFBQSxVQUNYLEtBQUs7QUFBQSxVQUNMLFFBQVE7QUFBQSxVQUNSLEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFBQSxVQUNMLE9BQU87QUFBQSxVQUNQLEtBQUs7QUFBQSxVQUNMLFNBQVM7QUFBQSxVQUNULFFBQVE7QUFBQSxVQUNSLFNBQVM7QUFBQSxVQUNULE9BQU87QUFBQSxVQUNQLE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQSxVQUNSLFdBQVc7QUFBQSxVQUNYLFNBQVM7QUFBQSxVQUNULFlBQVk7QUFBQSxVQUNaLEtBQUs7QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLFdBQVc7QUFBQSxVQUNYLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLE9BQU87QUFBQSxVQUNQLE9BQU87QUFBQSxVQUNQLFNBQVM7QUFBQSxVQUNULEtBQUs7QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxVQUNULEtBQUs7QUFBQSxVQUNMLFFBQVE7QUFBQSxVQUNSLE9BQU87QUFBQSxVQUNQLFlBQVk7QUFBQSxVQUNaLEtBQUs7QUFBQSxVQUNMLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUNOLFdBQVc7QUFBQSxVQUNYLEtBQUs7QUFBQSxVQUNMLFVBQVU7QUFBQSxVQUNWLFlBQVk7QUFBQSxVQUNaLFNBQVM7QUFBQSxVQUNULFVBQVU7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULFlBQVk7QUFBQSxVQUNaLE1BQU07QUFBQSxVQUNOLFFBQVE7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxVQUNULE9BQU87QUFBQSxVQUNQLFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLFdBQVc7QUFBQSxVQUNYLFFBQVE7QUFBQSxVQUNSLE9BQU87QUFBQSxVQUNQLFlBQVk7QUFBQSxVQUNaLFdBQVc7QUFBQSxVQUNYLFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLEtBQUs7QUFBQSxVQUNMLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxVQUNULE9BQU87QUFBQSxVQUNQLGFBQWE7QUFBQSxVQUNiLElBQUk7QUFBQSxVQUNKLFVBQVU7QUFBQSxVQUNWLE9BQU87QUFBQSxVQUNQLFdBQVc7QUFBQSxVQUNYLE9B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
